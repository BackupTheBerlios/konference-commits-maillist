<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Konference-commits] r76 - in konference/src: . codecs rtp rtp/jrtplib rtp/jrtplib/.deps sip
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/konference-commits/2005-October/index.html" >
   <LINK REL="made" HREF="mailto:konference-commits%40lists.berlios.de?Subject=Re%3A%20%5BKonference-commits%5D%20r76%20-%20in%20konference/src%3A%20.%20codecs%20rtp%20rtp/jrtplib%20rtp/jrtplib/.deps%20sip&In-Reply-To=%3C200510280933.j9S9XGks001525%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000008.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Konference-commits] r76 - in konference/src: . codecs rtp rtp/jrtplib rtp/jrtplib/.deps sip</H1>
    <B>Malte B&#246;hme at BerliOS</B> 
    <A HREF="mailto:konference-commits%40lists.berlios.de?Subject=Re%3A%20%5BKonference-commits%5D%20r76%20-%20in%20konference/src%3A%20.%20codecs%20rtp%20rtp/jrtplib%20rtp/jrtplib/.deps%20sip&In-Reply-To=%3C200510280933.j9S9XGks001525%40sheep.berlios.de%3E"
       TITLE="[Konference-commits] r76 - in konference/src: . codecs rtp rtp/jrtplib rtp/jrtplib/.deps sip">maldn at berlios.de
       </A><BR>
    <I>Fri Oct 28 11:33:16 CEST 2005</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000008.html">[Konference-commits] r77 - konference/src/rtp/jrtplib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11">[ date ]</a>
              <a href="thread.html#11">[ thread ]</a>
              <a href="subject.html#11">[ subject ]</a>
              <a href="author.html#11">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: maldn
Date: 2005-10-28 11:33:02 +0200 (Fri, 28 Oct 2005)
New Revision: 76

Added:
   konference/src/rtp/jrtplib/
   konference/src/rtp/jrtplib/.deps/
   konference/src/rtp/jrtplib/.deps/rtcpapppacket.Plo
   konference/src/rtp/jrtplib/.deps/rtcpbyepacket.Plo
   konference/src/rtp/jrtplib/.deps/rtcpcompoundpacket.Plo
   konference/src/rtp/jrtplib/.deps/rtcpcompoundpacketbuilder.Plo
   konference/src/rtp/jrtplib/.deps/rtcppacket.Plo
   konference/src/rtp/jrtplib/.deps/rtcppacketbuilder.Plo
   konference/src/rtp/jrtplib/.deps/rtcprrpacket.Plo
   konference/src/rtp/jrtplib/.deps/rtcpscheduler.Plo
   konference/src/rtp/jrtplib/.deps/rtcpsdesinfo.Plo
   konference/src/rtp/jrtplib/.deps/rtcpsdespacket.Plo
   konference/src/rtp/jrtplib/.deps/rtcpsrpacket.Plo
   konference/src/rtp/jrtplib/.deps/rtpcollisionlist.Plo
   konference/src/rtp/jrtplib/.deps/rtpdebug.Plo
   konference/src/rtp/jrtplib/.deps/rtperrors.Plo
   konference/src/rtp/jrtplib/.deps/rtpgsttransmitter.Plo
   konference/src/rtp/jrtplib/.deps/rtpinternalsourcedata.Plo
   konference/src/rtp/jrtplib/.deps/rtpipv4address.Plo
   konference/src/rtp/jrtplib/.deps/rtpipv6address.Plo
   konference/src/rtp/jrtplib/.deps/rtplibraryversion.Plo
   konference/src/rtp/jrtplib/.deps/rtppacket.Plo
   konference/src/rtp/jrtplib/.deps/rtppacketbuilder.Plo
   konference/src/rtp/jrtplib/.deps/rtppollthread.Plo
   konference/src/rtp/jrtplib/.deps/rtprandom.Plo
   konference/src/rtp/jrtplib/.deps/rtpsession.Plo
   konference/src/rtp/jrtplib/.deps/rtpsessionparams.Plo
   konference/src/rtp/jrtplib/.deps/rtpsessionsources.Plo
   konference/src/rtp/jrtplib/.deps/rtpsourcedata.Plo
   konference/src/rtp/jrtplib/.deps/rtpsources.Plo
   konference/src/rtp/jrtplib/.deps/rtptimeutilities.Plo
   konference/src/rtp/jrtplib/.deps/rtpudpv4transmitter.Plo
   konference/src/rtp/jrtplib/.deps/rtpudpv6transmitter.Plo
   konference/src/rtp/jrtplib/Makefile.am
   konference/src/rtp/jrtplib/rtcpapppacket.cpp
   konference/src/rtp/jrtplib/rtcpapppacket.h
   konference/src/rtp/jrtplib/rtcpbyepacket.cpp
   konference/src/rtp/jrtplib/rtcpbyepacket.h
   konference/src/rtp/jrtplib/rtcpcompoundpacket.cpp
   konference/src/rtp/jrtplib/rtcpcompoundpacket.h
   konference/src/rtp/jrtplib/rtcpcompoundpacketbuilder.cpp
   konference/src/rtp/jrtplib/rtcpcompoundpacketbuilder.h
   konference/src/rtp/jrtplib/rtcppacket.cpp
   konference/src/rtp/jrtplib/rtcppacket.h
   konference/src/rtp/jrtplib/rtcppacketbuilder.cpp
   konference/src/rtp/jrtplib/rtcppacketbuilder.h
   konference/src/rtp/jrtplib/rtcprrpacket.cpp
   konference/src/rtp/jrtplib/rtcprrpacket.h
   konference/src/rtp/jrtplib/rtcpscheduler.cpp
   konference/src/rtp/jrtplib/rtcpscheduler.h
   konference/src/rtp/jrtplib/rtcpsdesinfo.cpp
   konference/src/rtp/jrtplib/rtcpsdesinfo.h
   konference/src/rtp/jrtplib/rtcpsdespacket.cpp
   konference/src/rtp/jrtplib/rtcpsdespacket.h
   konference/src/rtp/jrtplib/rtcpsrpacket.cpp
   konference/src/rtp/jrtplib/rtcpsrpacket.h
   konference/src/rtp/jrtplib/rtcpunknownpacket.h
   konference/src/rtp/jrtplib/rtpaddress.h
   konference/src/rtp/jrtplib/rtpcollisionlist.cpp
   konference/src/rtp/jrtplib/rtpcollisionlist.h
   konference/src/rtp/jrtplib/rtpconfig.h
   konference/src/rtp/jrtplib/rtpconfig_unix.h
   konference/src/rtp/jrtplib/rtpconfig_unix.h.in
   konference/src/rtp/jrtplib/rtpconfig_win.h
   konference/src/rtp/jrtplib/rtpdebug.cpp
   konference/src/rtp/jrtplib/rtpdebug.h
   konference/src/rtp/jrtplib/rtpdefines.h
   konference/src/rtp/jrtplib/rtperrors.cpp
   konference/src/rtp/jrtplib/rtperrors.h
   konference/src/rtp/jrtplib/rtpgsttransmitter.cpp
   konference/src/rtp/jrtplib/rtpgsttransmitter.h
   konference/src/rtp/jrtplib/rtphashtable.h
   konference/src/rtp/jrtplib/rtpinternalsourcedata.cpp
   konference/src/rtp/jrtplib/rtpinternalsourcedata.h
   konference/src/rtp/jrtplib/rtpipv4address.cpp
   konference/src/rtp/jrtplib/rtpipv4address.h
   konference/src/rtp/jrtplib/rtpipv4destination.h
   konference/src/rtp/jrtplib/rtpipv6address.cpp
   konference/src/rtp/jrtplib/rtpipv6address.h
   konference/src/rtp/jrtplib/rtpipv6destination.h
   konference/src/rtp/jrtplib/rtpkeyhashtable.h
   konference/src/rtp/jrtplib/rtplibraryversion.cpp
   konference/src/rtp/jrtplib/rtplibraryversion.h
   konference/src/rtp/jrtplib/rtppacket.cpp
   konference/src/rtp/jrtplib/rtppacket.h
   konference/src/rtp/jrtplib/rtppacketbuilder.cpp
   konference/src/rtp/jrtplib/rtppacketbuilder.h
   konference/src/rtp/jrtplib/rtppollthread.cpp
   konference/src/rtp/jrtplib/rtppollthread.h
   konference/src/rtp/jrtplib/rtprandom.cpp
   konference/src/rtp/jrtplib/rtprandom.h
   konference/src/rtp/jrtplib/rtprawpacket.h
   konference/src/rtp/jrtplib/rtpsession.cpp
   konference/src/rtp/jrtplib/rtpsession.h
   konference/src/rtp/jrtplib/rtpsessionparams.cpp
   konference/src/rtp/jrtplib/rtpsessionparams.h
   konference/src/rtp/jrtplib/rtpsessionsources.cpp
   konference/src/rtp/jrtplib/rtpsessionsources.h
   konference/src/rtp/jrtplib/rtpsourcedata.cpp
   konference/src/rtp/jrtplib/rtpsourcedata.h
   konference/src/rtp/jrtplib/rtpsources.cpp
   konference/src/rtp/jrtplib/rtpsources.h
   konference/src/rtp/jrtplib/rtpstructs.h
   konference/src/rtp/jrtplib/rtptimeutilities.cpp
   konference/src/rtp/jrtplib/rtptimeutilities.h
   konference/src/rtp/jrtplib/rtptransmitter.h
   konference/src/rtp/jrtplib/rtptypes.h
   konference/src/rtp/jrtplib/rtptypes_unix.h
   konference/src/rtp/jrtplib/rtptypes_win.h
   konference/src/rtp/jrtplib/rtpudpv4transmitter.cpp
   konference/src/rtp/jrtplib/rtpudpv4transmitter.h
   konference/src/rtp/jrtplib/rtpudpv6transmitter.cpp
   konference/src/rtp/jrtplib/rtpudpv6transmitter.h
Modified:
   konference/src/Makefile.am
   konference/src/codecs/Makefile.am
   konference/src/codecs/codecbase.h
   konference/src/codecs/speexcodec.cpp
   konference/src/codecs/speexcodec.h
   konference/src/konference_part.cpp
   konference/src/konference_part.h
   konference/src/rtp/Makefile.am
   konference/src/rtp/jitter.cpp
   konference/src/rtp/jitter.h
   konference/src/rtp/rtpaudio.cpp
   konference/src/rtp/rtpaudio.h
   konference/src/rtp/rtpbase.h
   konference/src/rtp/rtpvideo.cpp
   konference/src/rtp/rtpvideo.h
   konference/src/sip/sipfsm.cpp
   konference/src/sip/sipmsg.cpp
   konference/src/sip/sipurl.h
Log:
_big_ patch...
biggest changes: replaced rtp-subsystem with jrtplib and added 
speex-codec


Modified: konference/src/Makefile.am
===================================================================
--- konference/src/Makefile.am	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/Makefile.am	2005-10-28 09:33:02 UTC (rev 76)
@@ -1,6 +1,6 @@
 # set the include path for X, qt and KDE
 INCLUDES = -I$(top_srcdir)/src/dialogs -I$(top_srcdir)/src/dialogs/config \
-	-I$(top_srcdir)/src/dialogs/wizard $(all_includes)
+	-I$(top_srcdir)/src/dialogs/wizard -I$(top_srcdir)/src/rtp/jrtplib $(all_includes)
 
 # these are the headers for your project
 noinst_HEADERS = konference.h konference_part.h videowidget.h konferenceui.h \

Modified: konference/src/codecs/Makefile.am
===================================================================
--- konference/src/codecs/Makefile.am	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/codecs/Makefile.am	2005-10-28 09:33:02 UTC (rev 76)
@@ -7,4 +7,4 @@
 	gsmcodec.cpp speexcodec.cpp
 SUBDIRS = gsm
 
-libcodecs_la_LIBADD = $(top_builddir)/src/codecs/gsm/libgsm.la
+libcodecs_la_LIBADD = $(top_builddir)/src/codecs/gsm/libgsm.la -lspeex

Modified: konference/src/codecs/codecbase.h
===================================================================
--- konference/src/codecs/codecbase.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/codecs/codecbase.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -30,12 +30,12 @@
 class codecBase
 {
 public:
-    codecBase();
+	codecBase();
 	virtual ~codecBase();
-    virtual int Decode(uchar *In, short *out, int Len, short &amp;maxPower)=0;
-    virtual int Encode(short *In, uchar *out, int Samples, short &amp;maxPower, int gain)=0;
-    virtual int Silence(uchar *out, int ms)=0;
-    virtual QString getCodecName()=0;
+	virtual int Decode(uchar *In, short *out, int Len, short &amp;maxPower)=0;
+	virtual int Encode(short *In, uchar *out, int Samples, short &amp;maxPower, int gain)=0;
+	virtual int Silence(uchar *out, int ms)=0;
+	virtual QString getCodecName()=0;
 	virtual int getPayload()=0;
 };
 

Modified: konference/src/codecs/speexcodec.cpp
===================================================================
--- konference/src/codecs/speexcodec.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/codecs/speexcodec.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -17,16 +17,88 @@
  *   Free Software Foundation, Inc.,                                       *
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
+
+#include &lt;iostream&gt;
+using namespace std;
+
 #include &quot;speexcodec.h&quot;
 
-speexCodec::speexCodec()
- : codecBase()
+speexCodec::speexCodec(): codecBase()
 {
+	//encoder
+	speex_bits_init(&amp;m_encSpeexBits);
+	m_encState = speex_encoder_init(&amp;speex_nb_mode);
+	speex_encoder_ctl(m_encState,SPEEX_GET_FRAME_SIZE,&amp;m_encFrameSize);
+	int tmp=15;
+	speex_encoder_ctl(m_encState, SPEEX_SET_QUALITY, &amp;tmp);
+	cout &lt;&lt; &quot;FRAMESIZE encoder:&quot; &lt;&lt; m_encFrameSize &lt;&lt; endl;
+
+	//decoder
+	speex_bits_init(&amp;m_decSpeexBits);
+	m_decState = speex_decoder_init(&amp;speex_nb_mode);
+	speex_decoder_ctl(m_decState, SPEEX_GET_FRAME_SIZE, &amp;m_decFrameSize);
+	//There is also a parameter that can be set for the decoder: whether or not to use a perceptual post-filter. This can be set by:
+	//speex_decoder_ctl(dec_state, SPEEX_SET_ENH, &amp;enh);
+	//where enh is an int that with value 0 to have the post-filter disabled and 1 to have it enabled.
+	cout &lt;&lt; &quot;FRAMESIZE decoder:&quot; &lt;&lt; m_decFrameSize &lt;&lt; endl;
 }
 
-
 speexCodec::~speexCodec()
 {
+	speex_bits_destroy(&amp;m_encSpeexBits);
+	speex_encoder_destroy(m_encState);
+
+	speex_bits_destroy(&amp;m_decSpeexBits);
+	speex_decoder_destroy(m_decState);
 }
 
+int speexCodec::Encode(short *In, unsigned char *Out, int Samples, short &amp;maxPower, int gain)
+{
+//memcpy(faketmp,In,160);
 
+	int MAX_NB_BYTES = 2000;//nb = number (of) bytes
+	float in_float[160];//should be 160 framesize
+	int i;
+	for (i=0;i&lt;m_encFrameSize;i++)
+	{
+		in_float[i]=In[i];
+	}
+	char out_bits[MAX_NB_BYTES];
+	int len=0;
+	speex_bits_reset(&amp;m_encSpeexBits);
+	speex_encode(m_encState, in_float, &amp;m_encSpeexBits);
+	len = speex_bits_write(&amp;m_encSpeexBits, out_bits, MAX_NB_BYTES);
+	memcpy(Out,out_bits,len);
+	
+	
+	return len;
+}
+
+int speexCodec::Decode(unsigned char *In, short *Out, int Len, short &amp;maxPower)
+{
+	float out_float[160];//should be 160 framesize
+
+	char in_bits[160];
+	memcpy(in_bits, In,Len);
+	speex_bits_read_from(&amp;m_decSpeexBits, in_bits, Len);
+	speex_decode(m_decState, &amp;m_decSpeexBits, out_float);
+
+	int i;
+	for (i=0;i&lt;m_encFrameSize;i++)
+	{
+		Out[i]=out_float[i];
+	}
+	//memcpy(Out,faketmp,160);
+	return m_decFrameSize*sizeof(short);
+}
+
+int speexCodec::Silence(uchar *out, int ms)
+{
+	if (ms != 20)
+		cout &lt;&lt; &quot;SPEEX: Silence unsupported length &quot; &lt;&lt; ms &lt;&lt; endl;
+
+	//short pcmSilence[160];
+	//memset(pcmSilence, 0, 160*sizeof(short));
+	//gsm_encode(gsmEncData, pcmSilence, out);
+	return 0;//TODO
+}

Modified: konference/src/codecs/speexcodec.h
===================================================================
--- konference/src/codecs/speexcodec.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/codecs/speexcodec.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -20,7 +20,7 @@
 #ifndef SPEEXCODEC_H
 #define SPEEXCODEC_H
 
-//#include &lt;speex.h&gt;
+#include &lt;speex/speex.h&gt;
 
 #include &quot;codecbase.h&quot;
 
@@ -30,10 +30,27 @@
 class speexCodec : public codecBase
 {
 public:
-    speexCodec();
+	speexCodec();
 
-    ~speexCodec();
+	~speexCodec();
+	//reimplemented from base-class
+	QString getCodecName(){return &quot;speex&quot;;};
+	int getPayload(){return 0x61;};
+	int Decode(uchar *In, short *out, int Len, short &amp;maxPower);
+	int Encode(short *In, uchar *out, int Samples, short &amp;maxPower, int gain);
+	int Silence(uchar *out, int ms);
 
+private:
+	//encoder
+	SpeexBits m_encSpeexBits;
+	void *m_encState;
+	int m_encFrameSize;
+
+	//decoder
+	SpeexBits m_decSpeexBits;
+	void *m_decState;
+	int m_decFrameSize;
+	//short faketmp[320];
 };
 
 #endif

Modified: konference/src/konference_part.cpp
===================================================================
--- konference/src/konference_part.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/konference_part.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -47,6 +47,7 @@
 #include &quot;codecs/codecbase.h&quot;
 #include &quot;codecs/gsmcodec.h&quot;
 #include &quot;codecs/g711.h&quot;
+#include &quot;codecs/speexcodec.h&quot;
 #include &quot;codecs/h263.h&quot;
 #include &quot;sip/sipcontainer.h&quot;
 #include &quot;audio/oss.h&quot;
@@ -55,6 +56,11 @@
 #include &quot;konferenceui.h&quot;
 #include &quot;dialogs/wizard/wizard.h&quot;
 
+#define RTP_PAYLOAD_G711U		0x00
+#define RTP_PAYLOAD_G711A		0x08
+#define RTP_PAYLOAD_COMF_NOISE	0x0D
+#define RTP_PAYLOAD_GSM			0x03
+#define RTP_PAYLOAD_SPEEX		0x61
 
 KonferencePart::KonferencePart( QWidget *parentWidget, const char *widgetName,
                                 QObject *parent, const char *name )
@@ -216,6 +222,8 @@
 				}
 			default:
 				kdDebug() &lt;&lt; &quot;		DEFAULT:&quot; &lt;&lt; NotifyParam2 &lt;&lt; endl;
+				kdDebug() &lt;&lt; &quot;		DEFAULT:&quot; &lt;&lt; NotifyParam1 &lt;&lt; endl;
+				kdDebug() &lt;&lt; &quot;		DEFAULT:&quot; &lt;&lt; NotifyUrl &lt;&lt; endl;
 				break;
 			}
 		}
@@ -338,6 +346,11 @@
 		m_audioCodec = new g711ulaw();
 	}
 
+	//speex-testing
+	kdDebug() &lt;&lt; &quot;using speex codec&quot; &lt;&lt; endl;
+	audioPayload = RTP_PAYLOAD_SPEEX;
+	m_audioCodec = new speexCodec();
+
 	if(KonferenceSettings::audioPlugin() == KonferenceSettings::EnumAudioPlugin::OSS)
 	{
 		kdDebug() &lt;&lt; &quot;using OSS driver&quot; &lt;&lt; endl;
@@ -358,10 +371,12 @@
 		m_audioDevice-&gt;openDevice(&quot;plughw:0,0&quot;);
 	}
 
+	//m_rtpAudio = new rtpAudio(KonferenceSettings::localAudioPort(), remoteIP,
+	//                          remoteAudioPort, audioPayload, dtmfPayload,
+	//                          m_audioCodec, m_audioDevice);
 	m_rtpAudio = new rtpAudio(KonferenceSettings::localAudioPort(), remoteIP,
-	                          remoteAudioPort, audioPayload, dtmfPayload,
-	                          m_audioCodec, m_audioDevice);
-
+	                          remoteAudioPort,  m_audioCodec, m_audioDevice);
+	 
 	//kdDebug() &lt;&lt; &quot;dtmfpayload: &quot; &lt;&lt; dtmfPayload &lt;&lt; endl;
 }
 
@@ -408,8 +423,7 @@
 
 	h263-&gt;H263StartEncoder(m_webcam-&gt;width(), m_webcam-&gt;height(), 5);
 	h263-&gt;H263StartDecoder(w, h);
-	m_rtpVideo = new rtpVideo (this, KonferenceSettings::localVideoPort(), remoteIP,
-	                           remoteVideoPort, videoPayload,RTP_TX_VIDEO, RTP_RX_VIDEO);
+	m_rtpVideo = new rtpVideo(this,KonferenceSettings::localVideoPort(), remoteIP,remoteVideoPort, videoPayload,5.0);
 }
 
 void KonferencePart::stopVideoRTP()
@@ -418,32 +432,23 @@
 
 	h263-&gt;H263StopEncoder();
 	h263-&gt;H263StopDecoder();
-	if(m_rtpVideo)
-		delete m_rtpVideo;
-	m_rtpVideo = 0;
+	m_rtpVideo-&gt;stop();
+	delete m_rtpVideo;
 }
 
 void KonferencePart::ProcessRxVideoFrame()
 {
-	VIDEOBUFFER *v;
+	VIDEOBUFFER v;
+	m_rtpVideo-&gt;getReceivedFrame(&amp;v);
 
-	//kdDebug() &lt;&lt; &quot;KonferencePart::ProcessRxVideoFrame()&quot; &lt;&lt; endl;
-
-	//TODO always true, isnt it?
-	if (m_rtpVideo &amp;&amp; (v = m_rtpVideo-&gt;getRxedVideo()))
+	//kdDebug() &lt;&lt; &quot;====&gt; v.h=&quot; &lt;&lt; v.h &lt;&lt; &quot; v.w=&quot; &lt;&lt; v.w &lt;&lt; &quot;v.len=&quot; &lt;&lt; v.len &lt;&lt; endl;
+	uchar *decRgbFrame = h263-&gt;H263DecodeFrame(v.video, v.len, rxRgbBuffer, sizeof(rxRgbBuffer));
+	if (decRgbFrame)
 	{
-		//kdDebug() &lt;&lt; &quot;rtpVideo &amp;&amp; (v = rtpVideo-&gt;getRxedVideo())&quot; &lt;&lt; endl;
-
-		uchar *decRgbFrame = h263-&gt;H263DecodeFrame(v-&gt;video, v-&gt;len, rxRgbBuffer, sizeof(rxRgbBuffer));
-		if (decRgbFrame)
-		{
-			//kdDebug() &lt;&lt; &quot;if (decRgbFrame)&quot; &lt;&lt; endl;
-
-			QImage rxImage(rxRgbBuffer, v-&gt;w, v-&gt;h, 32, (QRgb *)0, 0, QImage::LittleEndian);
-			KonferenceNewImageEvent* ce = new KonferenceNewImageEvent( rxImage, KonferenceNewImageEvent::REMOTE );
-			QApplication::postEvent( m_widget, ce );  // Qt will delete the event when done-
-		}
-		m_rtpVideo-&gt;freeVideoBuffer(v);
+		//kdDebug() &lt;&lt; &quot;if (decRgbFrame)&quot; &lt;&lt; endl;
+		QImage rxImage(rxRgbBuffer, v.w, v.h, 32, (QRgb *)0, 0, QImage::LittleEndian);
+		KonferenceNewImageEvent* ce = new KonferenceNewImageEvent( rxImage, KonferenceNewImageEvent::REMOTE );
+		QApplication::postEvent( m_widget, ce );  // Qt will delete the event when done-
 	}
 }
 
@@ -452,7 +457,7 @@
 	uchar *yuvFrame = m_webcam-&gt;GetVideoFrame(m_txWebcamClient);
 
 	int encLen=0;
-	if (yuvFrame != 0 &amp;&amp; m_rtpVideo)
+	if ((yuvFrame != 0)/* &amp;&amp; m_rtpVideo2*/)
 	{
 		//TODO find better fix for odd quickcam resolutions
 		int txWidth = m_webcam-&gt;width();//176;
@@ -472,27 +477,28 @@
 		else
 		{
 
-			VIDEOBUFFER *vb = m_rtpVideo-&gt;getVideoBuffer(0);
-			if (vb)
+			VIDEOBUFFER *vb = new VIDEOBUFFER;// = m_rtpVideo-&gt;getVideoBuffer(0);
+			//if (vb)
+			//{
+			if (encLen &gt; (int)sizeof(vb-&gt;video))
 			{
-				if (encLen &gt; (int)sizeof(vb-&gt;video))
-				{
-					kdDebug()  &lt;&lt; &quot;SIP: Encoded H.263 frame size is &quot; &lt;&lt; encLen &lt;&lt; &quot;; too big for buffer\n&quot;;
-					m_rtpVideo-&gt;freeVideoBuffer(vb);
-				}
-				else
-				{
-					memcpy(vb-&gt;video, encFrame, encLen); // Optimisation to get rid of this copy may be possible, check H.263 stack
-					vb-&gt;len = encLen;
-					vb-&gt;w = m_webcam-&gt;width();//176;
-					vb-&gt;h = m_webcam-&gt;height();//144;
-					if (!m_rtpVideo-&gt;queueVideo(vb))
-					{
-						kdDebug()  &lt;&lt; &quot;KonferencePart::TransmitLocalWebcamImage(): Could not queue RTP Video frame for transmission\n&quot;;
-						m_rtpVideo-&gt;freeVideoBuffer(vb);
-					}
-				}
+				kdDebug()  &lt;&lt; &quot;Encoded H.263 frame size is &quot; &lt;&lt; encLen &lt;&lt; &quot;; too big for buffer\n&quot;;
+				//m_rtpVideo-&gt;freeVideoBuffer(vb);
 			}
+			else
+			{
+				memcpy(vb-&gt;video, encFrame, encLen); // Optimisation to get rid of this copy may be possible, check H.263 stack
+				vb-&gt;len = encLen;
+				vb-&gt;w = m_webcam-&gt;width();//176;
+				vb-&gt;h = m_webcam-&gt;height();//144;
+				m_rtpVideo-&gt;queueVideoForTransmission(vb);
+				//if (!m_rtpVideo-&gt;queueVideo(vb))
+				//{
+				//	kdDebug()  &lt;&lt; &quot;KonferencePart::TransmitLocalWebcamImage(): Could not queue RTP Video frame for transmission\n&quot;;
+				//m_rtpVideo-&gt;freeVideoBuffer(vb);
+				//}
+			}
+			//}
 		}
 		m_webcam-&gt;FreeVideoBuffer(m_txWebcamClient, yuvFrame);
 	}
@@ -594,8 +600,8 @@
 void KonferencePart::connectClicked()
 {//TODO enabling buttons needs fix
 	//TODO Mode not used?
-	kdDebug() &lt;&lt; &quot;moooh&quot; &lt;&lt; endl;
-	sipStack-&gt;PlaceNewCall(&quot;CIF&quot;, m_location-&gt;currentText(), &quot;&quot;, 1);
+	//kdDebug() &lt;&lt; &quot;moooh&quot; &lt;&lt; endl;
+	sipStack-&gt;PlaceNewCall(&quot;QCIF&quot;, m_location-&gt;currentText(), &quot;mooh&quot;, 1);
 	m_cancelAction-&gt;setEnabled(true);
 	m_connectAction-&gt;setEnabled(false);
 	addToHistory(KURL(m_location-&gt;currentText()));

Modified: konference/src/konference_part.h
===================================================================
--- konference/src/konference_part.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/konference_part.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -43,7 +43,7 @@
 class KonferenceUI;
 class KonferenceWizard;
 #include &quot;dcopiface.h&quot;
-
+#include &quot;rtp/rtpvideo.h&quot;
 /**
  * This is a &quot;Part&quot;.  It that does all the real work in a KPart
  * application.
@@ -78,7 +78,7 @@
 	*/
 	virtual void call(const QString &amp;ip);
 	//dcop stuff ends here
-	
+
 protected:
 	/**
 	 * This must be implemented by each part
@@ -92,7 +92,7 @@
 	void showConfigDialog();
 
 	void showWizard();
-	
+
 	/**
 	 * Reloads the configuration
 	 */
@@ -150,7 +150,7 @@
 	 * Our wizard
 	 */
 	KonferenceWizard *m_wizard;
-	
+
 	/**
 	 * This handles the grabbing from our cam. if there is a new frame our part get an event.
 	 */
@@ -177,7 +177,6 @@
 
 	rtpVideo *m_rtpVideo;
 	rtpAudio *m_rtpAudio;
-
 	wcClient *m_localWebcamClient;
 	wcClient *m_txWebcamClient;
 

Modified: konference/src/rtp/Makefile.am
===================================================================
--- konference/src/rtp/Makefile.am	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/Makefile.am	2005-10-28 09:33:02 UTC (rev 76)
@@ -1,7 +1,12 @@
-INCLUDES = -I$(top_srcdir)/src/dialogs -I$(top_srcdir)/src/dialogs/config \
-	-I$(top_srcdir)/src/dialogs/wizard -I$(top_srcdir)/src/rtp -I$(top_srcdir)/src/codecs $(all_includes)
+INCLUDES = -I$(top_srcdir)/src/codecs -I$(top_srcdir)/src/dialogs \
+	-I$(top_srcdir)/src/dialogs/config -I$(top_srcdir)/src/dialogs/wizard -I$(top_srcdir)/src/rtp \
+	-I$(top_srcdir)/src/rtp/jrtplib $(all_includes)
 METASOURCES = AUTO
 librtp_la_LDFLAGS = $(all_libraries)
 noinst_LTLIBRARIES = librtp.la
-noinst_HEADERS = jitter.h
-librtp_la_SOURCES = jitter.cpp rtpbase.cpp rtpvideo.cpp rtpaudio.cpp
+
+librtp_la_SOURCES = rtpvideo.cpp rtpaudio.cpp
+
+SUBDIRS = jrtplib
+librtp_la_LIBADD = $(top_builddir)/src/rtp/jrtplib/libjrtp.la
+AM_CXXFLAGS = -DRTPDEBUG

Modified: konference/src/rtp/jitter.cpp
===================================================================
--- konference/src/rtp/jitter.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jitter.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -98,15 +98,15 @@
 	}
 }
 
-
+/*
 int Jitter::compareItems(QPtrCollection::Item s1, QPtrCollection::Item s2)
 {
 	RTPPACKET *r1 = (RTPPACKET *)s1;
 	RTPPACKET *r2 = (RTPPACKET *)s2;
 	return (r1-&gt;RtpSequenceNumber - r2-&gt;RtpSequenceNumber);
 }
+*/
 
-
 RTPPACKET *Jitter::DequeueJBuffer(ushort seqNum, int &amp;reason)
 {
 	RTPPACKET *head = first();

Modified: konference/src/rtp/jitter.h
===================================================================
--- konference/src/rtp/jitter.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jitter.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -38,7 +38,6 @@
 #define JB_REASON_DTMF        4   // Buffer which matches seq-number contained DTMF
 #define JB_REASON_DUPLICATE   5   // Got the same sequence number twice
 
-
 typedef struct RTPPACKET
 {
   int     len;                       // Not part of the RTP frame itself
@@ -64,7 +63,7 @@
     void		InsertJBuffer(RTPPACKET *Buffer);
     RTPPACKET *DequeueJBuffer(ushort seqNum, int &amp;reason);  
     int     DumpAllJBuffers(bool StopAtMarkerBit);
-    virtual int compareItems(QPtrCollection::Item s1, QPtrCollection::Item s2);
+   // virtual int compareItems(QPtrCollection::Item s1, QPtrCollection::Item s2);
     int AnyData() { return count(); };
     bool isPacketQueued(ushort Seq);
     int GotAllBufsInFrame(ushort seq, int offset);

Added: konference/src/rtp/jrtplib/.deps/rtcpapppacket.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcpapppacket.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcpapppacket.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtcpbyepacket.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcpbyepacket.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcpbyepacket.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtcpcompoundpacket.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcpcompoundpacket.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcpcompoundpacket.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtcpcompoundpacketbuilder.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcpcompoundpacketbuilder.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcpcompoundpacketbuilder.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtcppacket.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcppacket.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcppacket.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtcppacketbuilder.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcppacketbuilder.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcppacketbuilder.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtcprrpacket.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcprrpacket.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcprrpacket.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtcpscheduler.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcpscheduler.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcpscheduler.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtcpsdesinfo.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcpsdesinfo.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcpsdesinfo.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtcpsdespacket.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcpsdespacket.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcpsdespacket.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtcpsrpacket.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcpsrpacket.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcpsrpacket.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpcollisionlist.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpcollisionlist.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpcollisionlist.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpdebug.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpdebug.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpdebug.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtperrors.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtperrors.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtperrors.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpgsttransmitter.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpgsttransmitter.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpgsttransmitter.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpinternalsourcedata.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpinternalsourcedata.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpinternalsourcedata.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpipv4address.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpipv4address.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpipv4address.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpipv6address.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpipv6address.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpipv6address.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtplibraryversion.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtplibraryversion.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtplibraryversion.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtppacket.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtppacket.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtppacket.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtppacketbuilder.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtppacketbuilder.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtppacketbuilder.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtppollthread.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtppollthread.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtppollthread.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtprandom.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtprandom.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtprandom.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpsession.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpsession.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpsession.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpsessionparams.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpsessionparams.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpsessionparams.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpsessionsources.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpsessionsources.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpsessionsources.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpsourcedata.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpsourcedata.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpsourcedata.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpsources.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpsources.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpsources.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtptimeutilities.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtptimeutilities.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtptimeutilities.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpudpv4transmitter.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpudpv4transmitter.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpudpv4transmitter.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpudpv6transmitter.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpudpv6transmitter.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpudpv6transmitter.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/Makefile.am
===================================================================
--- konference/src/rtp/jrtplib/Makefile.am	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/Makefile.am	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,35 @@
+noinst_LTLIBRARIES = libjrtp.la
+libjrtp_la_SOURCES = rtpdebug.cpp rtpsession.cpp rtpconfig_win.h \
+		     rtperrors.cpp rtpudpv4transmitter.cpp \
+		     rtcpsdesinfo.cpp rtppollthread.cpp rtppacket.cpp \
+		     rtppacketbuilder.cpp rtpsessionparams.cpp \
+		     rtpsources.cpp rtpinternalsourcedata.cpp \
+		     rtpsourcedata.cpp rtpipv4address.cpp \
+		     rtcpcompoundpacket.cpp \
+		     rtcpapppacket.cpp rtcpbyepacket.cpp \
+		     rtcprrpacket.cpp rtcpsdespacket.cpp \
+		     rtcpsrpacket.cpp rtplibraryversion.cpp \
+		     rtcppacket.cpp rtcpcompoundpacketbuilder.cpp \
+		     rtprandom.cpp rtcpscheduler.cpp \
+		     rtcppacketbuilder.cpp rtpsessionsources.cpp \
+		     rtpcollisionlist.cpp rtpipv6address.cpp \
+		     rtpudpv6transmitter.cpp rtptimeutilities.cpp \
+		     rtpgsttransmitter.cpp
+
+noinst_HEADERS = rtcpapppacket.h rtcpbyepacket.h rtcpcompoundpacket.h \
+			 rtcpcompoundpacketbuilder.h rtcppacket.h rtcppacketbuilder.h \
+			 rtcprrpacket.h rtcpscheduler.h rtcpsdesinfo.h rtcpsdespacket.h \
+			 rtcpsrpacket.h rtcpunknownpacket.h rtpaddress.h rtpconfig.h \
+			 rtpconfig_win.h rtpdebug.h rtpdefines.h rtperrors.h rtphashtable.h \
+			 rtpconfig_unix.h rtpinternalsourcedata.h rtpipv4address.h \
+			 rtpipv4destination.h rtpkeyhashtable.h rtplibraryversion.h rtppacket.h \
+			 rtppacketbuilder.h rtppollthread.h rtprandom.h rtprawpacket.h \
+			 rtpsession.h rtpsessionparams.h rtpsourcedata.h rtpsources.h \
+			 rtpstructs.h rtptimeutilities.h rtptransmitter.h \
+			 rtptypes_win.h rtpudpv4transmitter.h rtpsessionsources.h \
+			 rtpcollisionlist.h rtpipv6address.h rtpipv6destination.h \
+			 rtpudpv6transmitter.h rtptypes.h rtptypes_unix.h \
+			 rtpgsttransmitter.h
+EXTRA_DIST = rtpconfig_unix.h.in
+
+AM_CXXFLAGS = -DRTPDEBUG

Added: konference/src/rtp/jrtplib/rtcpapppacket.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcpapppacket.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpapppacket.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,87 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtcpapppacket.h&quot;
+#ifdef RTPDEBUG
+	#include &lt;iostream&gt;
+	#include &lt;string&gt;
+#endif // RTPDEBUG
+
+#include &quot;rtpdebug.h&quot;
+
+RTCPAPPPacket::RTCPAPPPacket(u_int8_t *data,size_t datalength)
+	: RTCPPacket(APP,data,datalength)
+{
+	knownformat = false;
+	
+	RTCPCommonHeader *hdr;
+	size_t len = datalength;
+	
+	hdr = (RTCPCommonHeader *)data;
+	if (hdr-&gt;padding)
+	{
+		u_int8_t padcount = data[datalength-1];
+		if ((padcount &amp; 0x03) != 0) // not a multiple of four! (see rfc 3550 p 37)
+			return;
+		if (((size_t)padcount) &gt;= len)
+			return;
+		len -= (size_t)padcount;
+	}
+	
+	if (len &lt; (sizeof(RTCPCommonHeader)+sizeof(u_int32_t)*2))
+		return;
+	len -= (sizeof(RTCPCommonHeader)+sizeof(u_int32_t)*2);
+	appdatalen = len;
+	knownformat = true;
+}
+
+#ifdef RTPDEBUG
+void RTCPAPPPacket::Dump()
+{
+	RTCPPacket::Dump();
+	if (!IsKnownFormat())
+	{
+		std::cout &lt;&lt; &quot;    Unknown format!&quot; &lt;&lt; std::endl;
+	}
+	else
+	{
+		std::cout &lt;&lt; &quot;    SSRC:   &quot; &lt;&lt; GetSSRC() &lt;&lt; std::endl;
+		
+		char str[5];
+		memcpy(str,GetName(),4);
+		str[4] = 0;
+		std::cout &lt;&lt; &quot;    Name:   &quot; &lt;&lt; std::string(str).c_str() &lt;&lt; std::endl;
+		std::cout &lt;&lt; &quot;    Length: &quot; &lt;&lt; GetAPPDataLength() &lt;&lt; std::endl;
+	}
+}
+#endif // RTPDEBUG
+

Added: konference/src/rtp/jrtplib/rtcpapppacket.h
===================================================================
--- konference/src/rtp/jrtplib/rtcpapppacket.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpapppacket.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,106 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPAPPPACKET_H
+
+#define RTCPAPPPACKET_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtcppacket.h&quot;
+#include &quot;rtpstructs.h&quot;
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include &lt;netinet/in.h&gt;
+#endif // WIN32 
+
+class RTCPCompoundPacket;
+
+class RTCPAPPPacket : public RTCPPacket
+{
+public:
+	RTCPAPPPacket(u_int8_t *data,size_t datalen);
+	~RTCPAPPPacket()							{ }
+
+	u_int8_t GetSubType() const;
+	u_int32_t GetSSRC() const;
+	u_int8_t *GetName(); // Note that the name always consists of 4 octets and is not null-terminated
+	u_int8_t *GetAPPData();
+	size_t GetAPPDataLength() const;
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG	
+private:
+	size_t appdatalen;
+};
+
+inline u_int8_t RTCPAPPPacket::GetSubType() const
+{
+	if (!knownformat)
+		return 0;
+	RTCPCommonHeader *hdr = (RTCPCommonHeader *)data;
+	return hdr-&gt;count;
+}
+
+inline u_int32_t RTCPAPPPacket::GetSSRC() const
+{
+	if (!knownformat)
+		return 0;
+
+	u_int32_t *ssrc = (u_int32_t *)(data+sizeof(RTCPCommonHeader));
+	return ntohl(*ssrc);	
+}
+
+inline u_int8_t *RTCPAPPPacket::GetName()
+{
+	if (!knownformat)
+		return 0;
+
+	return (data+sizeof(RTCPCommonHeader)+sizeof(u_int32_t));	
+}
+
+inline u_int8_t *RTCPAPPPacket::GetAPPData()
+{
+	if (!knownformat)
+		return 0;
+	if (appdatalen == 0)
+		return 0;
+	return (data+sizeof(RTCPCommonHeader)+sizeof(u_int32_t)*2);
+}
+
+inline size_t RTCPAPPPacket::GetAPPDataLength() const
+{
+	if (!knownformat)
+		return 0;
+	return appdatalen;
+}
+
+#endif // RTCPAPPPACKET_H
+

Added: konference/src/rtp/jrtplib/rtcpbyepacket.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcpbyepacket.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpbyepacket.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,98 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtcpbyepacket.h&quot;
+#ifdef RTPDEBUG
+	#include &lt;iostream&gt;
+#endif // RTPDEBUG
+
+#include &quot;rtpdebug.h&quot;
+
+RTCPBYEPacket::RTCPBYEPacket(u_int8_t *data,size_t datalength)
+	: RTCPPacket(BYE,data,datalength)
+{
+	knownformat = false;
+	reasonoffset = 0;	
+	
+	RTCPCommonHeader *hdr;
+	size_t len = datalength;
+	
+	hdr = (RTCPCommonHeader *)data;
+	if (hdr-&gt;padding)
+	{
+		u_int8_t padcount = data[datalength-1];
+		if ((padcount &amp; 0x03) != 0) // not a multiple of four! (see rfc 3550 p 37)
+			return;
+		if (((size_t)padcount) &gt;= len)
+			return;
+		len -= (size_t)padcount;
+	}
+	
+	size_t ssrclen = ((size_t)(hdr-&gt;count))*sizeof(u_int32_t) + sizeof(RTCPCommonHeader);
+	if (ssrclen &gt; len)
+		return;
+	if (ssrclen &lt; len) // there's probably a reason for leaving
+	{
+		u_int8_t *reasonlength = (data+ssrclen);
+		size_t reaslen = (size_t)(*reasonlength);
+		if (reaslen &gt; (len-ssrclen-1))
+			return;
+		reasonoffset = ssrclen;
+	}
+	knownformat = true;
+}
+
+#ifdef RTPDEBUG
+void RTCPBYEPacket::Dump()
+{
+	RTCPPacket::Dump();
+	if (!IsKnownFormat())
+	{
+		std::cout &lt;&lt; &quot;    Unknown format&quot; &lt;&lt; std::endl;
+		return;	
+	}
+
+	int num = GetSSRCCount();
+	int i;
+
+	for (i = 0 ; i &lt; num ; i++)
+		std::cout &lt;&lt; &quot;    SSRC: &quot; &lt;&lt; GetSSRC(i) &lt;&lt; std::endl;
+	if (HasReasonForLeaving())
+	{
+		char str[1024];
+		memcpy(str,GetReasonData(),GetReasonLength());
+		str[GetReasonLength()] = 0;
+		std::cout &lt;&lt; &quot;    Reason: &quot; &lt;&lt; str &lt;&lt; std::endl;
+	}
+}
+#endif // RTPDEBUG
+

Added: konference/src/rtp/jrtplib/rtcpbyepacket.h
===================================================================
--- konference/src/rtp/jrtplib/rtcpbyepacket.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpbyepacket.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,114 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPBYEPACKET_H
+
+#define RTCPBYEPACKET_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtcppacket.h&quot;
+#include &quot;rtpstructs.h&quot;
+#if ! (defined(WIN32) || defined (_WIN32_WCE))
+	#include &lt;netinet/in.h&gt;
+#endif // WIN32
+
+class RTCPCompoundPacket;
+
+class RTCPBYEPacket : public RTCPPacket
+{
+public:
+	RTCPBYEPacket(u_int8_t *data,size_t datalen);
+	~RTCPBYEPacket()							{ }
+	
+	int GetSSRCCount() const;
+	u_int32_t GetSSRC(int index) const; // note: no check is performed to see if index is valid!
+	bool HasReasonForLeaving() const;
+	size_t GetReasonLength() const;
+	u_int8_t *GetReasonData();
+
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+private:
+	size_t reasonoffset;
+};
+		      
+inline int RTCPBYEPacket::GetSSRCCount() const
+{
+	if (!knownformat)
+		return 0;
+
+	RTCPCommonHeader *hdr = (RTCPCommonHeader *)data;
+	return (int)(hdr-&gt;count);
+}
+
+inline u_int32_t RTCPBYEPacket::GetSSRC(int index) const
+{
+	if (!knownformat)
+		return 0;
+	u_int32_t *ssrc = (u_int32_t *)(data+sizeof(RTCPCommonHeader)+sizeof(u_int32_t)*index);
+	return ntohl(*ssrc);
+}
+
+inline bool RTCPBYEPacket::HasReasonForLeaving() const
+{
+	if (!knownformat)
+		return false;
+	if (reasonoffset == 0)
+		return false;
+	return true;
+}
+
+inline size_t RTCPBYEPacket::GetReasonLength() const
+{
+	if (!knownformat)
+		return 0;
+	if (reasonoffset == 0)
+		return 0;
+	u_int8_t *reasonlen = (data+reasonoffset);
+	return (size_t)(*reasonlen);
+}
+
+inline u_int8_t *RTCPBYEPacket::GetReasonData()
+{
+	if (!knownformat)
+		return 0;
+	if (reasonoffset == 0)
+		return 0;
+	u_int8_t *reasonlen = (data+reasonoffset);
+	if ((*reasonlen) == 0)
+		return 0;
+	return (data+reasonoffset+1);	
+}
+
+#endif // RTCPBYEPACKET_H
+

Added: konference/src/rtp/jrtplib/rtcpcompoundpacket.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcpcompoundpacket.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpcompoundpacket.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,208 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtcpcompoundpacket.h&quot;
+#include &quot;rtprawpacket.h&quot;
+#include &quot;rtperrors.h&quot;
+#include &quot;rtpstructs.h&quot;
+#include &quot;rtpdefines.h&quot;
+#include &quot;rtcpsrpacket.h&quot;
+#include &quot;rtcprrpacket.h&quot;
+#include &quot;rtcpsdespacket.h&quot;
+#include &quot;rtcpbyepacket.h&quot;
+#include &quot;rtcpapppacket.h&quot;
+#include &quot;rtcpunknownpacket.h&quot;
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include &lt;netinet/in.h&gt;
+#endif // WIN32
+
+#include &quot;rtpdebug.h&quot;
+
+RTCPCompoundPacket::RTCPCompoundPacket(RTPRawPacket &amp;rawpack)
+{
+	compoundpacket = 0;
+	compoundpacketlength = 0;
+	error = 0;
+	
+	if (rawpack.IsRTP())
+	{
+		error = ERR_RTP_RTCPCOMPOUND_INVALIDPACKET;
+		return;
+	}
+
+	u_int8_t *data = rawpack.GetData();
+	size_t datalen = rawpack.GetDataLength();
+	bool first;
+	
+	if (datalen &lt; sizeof(RTCPCommonHeader))
+	{
+		error = ERR_RTP_RTCPCOMPOUND_INVALIDPACKET;
+		return;
+	}
+
+	first = true;
+	
+	do
+	{
+		RTCPCommonHeader *rtcphdr;
+		size_t length;
+		
+		rtcphdr = (RTCPCommonHeader *)data;
+		if (rtcphdr-&gt;version != RTP_VERSION) // check version
+		{
+			ClearPacketList();
+			error = ERR_RTP_RTCPCOMPOUND_INVALIDPACKET;
+			return;
+		}
+		if (first)
+		{
+			// Check if first packet is SR or RR
+			
+			first = false;
+			if ( ! (rtcphdr-&gt;packettype == RTP_RTCPTYPE_SR || rtcphdr-&gt;packettype == RTP_RTCPTYPE_RR))
+			{
+				ClearPacketList();
+				error = ERR_RTP_RTCPCOMPOUND_INVALIDPACKET;
+				return;
+			}
+		}
+		
+		length = (size_t)ntohs(rtcphdr-&gt;length);
+		length++;
+		length *= sizeof(u_int32_t);
+
+		if (length &gt; datalen) // invalid length field
+		{
+			ClearPacketList();
+			error = ERR_RTP_RTCPCOMPOUND_INVALIDPACKET;
+			return;
+		}
+		
+		if (rtcphdr-&gt;padding)
+		{
+			// check if it's the last packet
+			if (length != datalen)
+			{
+				ClearPacketList();
+				error = ERR_RTP_RTCPCOMPOUND_INVALIDPACKET;
+				return; // not last packet
+			}
+		}
+
+		RTCPPacket *p;
+		
+		switch (rtcphdr-&gt;packettype)
+		{
+		case RTP_RTCPTYPE_SR:
+			p = new RTCPSRPacket(data,length);
+			break;
+		case RTP_RTCPTYPE_RR:
+			p = new RTCPRRPacket(data,length);
+			break;
+		case RTP_RTCPTYPE_SDES:
+			p = new RTCPSDESPacket(data,length);
+			break;
+		case RTP_RTCPTYPE_BYE:
+			p = new RTCPBYEPacket(data,length);
+			break;
+		case RTP_RTCPTYPE_APP:
+			p = new RTCPAPPPacket(data,length);
+			break;
+		default:
+			p = new RTCPUnknownPacket(data,length);
+		}
+
+		if (p == 0)
+		{
+			ClearPacketList();
+			error = ERR_RTP_OUTOFMEM;
+			return;
+		}
+
+		rtcppacklist.push_back(p);
+		
+		datalen -= length;
+		data += length;
+	} while (datalen &gt;= (size_t)sizeof(RTCPCommonHeader));
+
+	if (datalen != 0) // some remaining bytes
+	{
+		ClearPacketList();
+		error = ERR_RTP_RTCPCOMPOUND_INVALIDPACKET;
+		return;
+	}
+
+	compoundpacket = rawpack.GetData();
+	compoundpacketlength = rawpack.GetDataLength();
+
+	rawpack.ZeroData();
+	
+	rtcppackit = rtcppacklist.begin();
+}
+
+RTCPCompoundPacket::RTCPCompoundPacket()
+{
+	compoundpacket = 0;
+	compoundpacketlength = 0;
+	error = 0;
+}
+
+RTCPCompoundPacket::~RTCPCompoundPacket()
+{
+	ClearPacketList();
+	if (compoundpacket)
+		delete [] compoundpacket;
+}
+
+void RTCPCompoundPacket::ClearPacketList()
+{
+	std::list&lt;RTCPPacket *&gt;::const_iterator it;
+
+	for (it = rtcppacklist.begin() ; it != rtcppacklist.end() ; it++)
+		delete *it;
+
+	rtcppacklist.clear();
+	rtcppackit = rtcppacklist.begin();
+}
+
+#ifdef RTPDEBUG
+void RTCPCompoundPacket::Dump()
+{
+	std::list&lt;RTCPPacket *&gt;::const_iterator it;
+	for (it = rtcppacklist.begin() ; it != rtcppacklist.end() ; it++)
+	{
+		RTCPPacket *p = *it;
+
+		p-&gt;Dump();
+	}
+}
+#endif // RTPDEBUG

Added: konference/src/rtp/jrtplib/rtcpcompoundpacket.h
===================================================================
--- konference/src/rtp/jrtplib/rtcpcompoundpacket.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpcompoundpacket.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,79 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+
+#ifndef RTCPCOMPOUNDPACKET_H
+
+#define RTCPCOMPOUNDPACKET_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtptypes.h&quot;
+#include &lt;list&gt;
+
+class RTPRawPacket;
+class RTCPPacket;
+
+class RTCPCompoundPacket
+{
+public:
+	RTCPCompoundPacket(RTPRawPacket &amp;rawpack);
+protected:
+	RTCPCompoundPacket(); // this is for the compoundpacket builder
+public:
+	virtual ~RTCPCompoundPacket();
+	int GetCreationError()								{ return error; }
+
+	u_int8_t *GetCompoundPacketData()						{ return compoundpacket; }
+	size_t GetCompoundPacketLength()						{ return compoundpacketlength; }
+
+	void GotoFirstPacket()								{ rtcppackit = rtcppacklist.begin(); }
+
+	// Note: the individual RTCPPackets may NOT be deleted!
+	RTCPPacket *GetNextPacket()							{ if (rtcppackit == rtcppacklist.end()) return 0; RTCPPacket *p = *rtcppackit; rtcppackit++; return p; }
+
+#ifdef RTPDEBUG
+	void Dump();	
+#endif // RTPDEBUG
+protected:
+	void ClearPacketList();
+	
+	int error;
+
+	u_int8_t *compoundpacket;
+	size_t compoundpacketlength;
+	
+	std::list&lt;RTCPPacket *&gt; rtcppacklist;
+	std::list&lt;RTCPPacket *&gt;::const_iterator rtcppackit;
+};
+
+#endif // RTCPCOMPOUNDPACKET_H
+

Added: konference/src/rtp/jrtplib/rtcpcompoundpacketbuilder.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcpcompoundpacketbuilder.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpcompoundpacketbuilder.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,672 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtcpcompoundpacketbuilder.h&quot;
+#include &quot;rtcpsrpacket.h&quot;
+#include &quot;rtcprrpacket.h&quot;
+#include &quot;rtcpsdespacket.h&quot;
+#include &quot;rtcpbyepacket.h&quot;
+#include &quot;rtcpapppacket.h&quot;
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include &lt;netinet/in.h&gt;
+#endif // WIN32
+
+#include &quot;rtpdebug.h&quot;
+
+RTCPCompoundPacketBuilder::RTCPCompoundPacketBuilder()
+{
+	byesize = 0;
+	appsize = 0;
+	maximumpacketsize = 0;
+	buffer = 0;
+	external = false;
+	arebuilding = false;
+}
+
+RTCPCompoundPacketBuilder::~RTCPCompoundPacketBuilder()
+{
+	if (external)
+		compoundpacket = 0; // make sure RTCPCompoundPacket doesn't delete the external buffer
+	ClearBuildBuffers();
+}
+
+void RTCPCompoundPacketBuilder::ClearBuildBuffers()
+{
+	report.Clear();
+	sdes.Clear();
+
+	std::list&lt;Buffer&gt;::const_iterator it;
+	for (it = byepackets.begin() ; it != byepackets.end() ; it++)
+		if ((*it).packetdata)
+			delete [] (*it).packetdata;
+	
+	for (it = apppackets.begin() ; it != apppackets.end() ; it++)
+		if ((*it).packetdata)
+			delete [] (*it).packetdata;
+
+	byepackets.clear();
+	apppackets.clear();
+	byesize = 0;
+	appsize = 0;
+}
+
+int RTCPCompoundPacketBuilder::InitBuild(size_t maxpacketsize)
+{
+	if (arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYBUILDING;
+	if (compoundpacket)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYBUILT;
+
+	if (maxpacketsize &lt; RTP_MINPACKETSIZE)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_MAXPACKETSIZETOOSMALL;
+	
+	maximumpacketsize = maxpacketsize;
+	buffer = 0;
+	external = false;
+	byesize = 0;
+	appsize = 0;
+	
+	arebuilding = true;
+	return 0;
+}
+
+int RTCPCompoundPacketBuilder::InitBuild(void *externalbuffer,size_t buffersize)
+{
+	if (arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYBUILDING;
+	if (compoundpacket)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYBUILT;
+
+	if (buffersize &lt; RTP_MINPACKETSIZE)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_BUFFERSIZETOOSMALL;
+
+	maximumpacketsize = buffersize;
+	buffer = (u_int8_t *)externalbuffer;
+	external = true;
+	byesize = 0;
+	appsize = 0;
+
+	arebuilding = true;
+	return 0;
+}
+
+int RTCPCompoundPacketBuilder::StartSenderReport(u_int32_t senderssrc,const RTPNTPTime &amp;ntptimestamp,u_int32_t rtptimestamp,
+                                                 u_int32_t packetcount,u_int32_t octetcount)
+{
+	if (!arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING;
+
+	if (report.headerlength != 0)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYGOTREPORT;
+
+	size_t totalsize = byesize+appsize+sdes.NeededBytes();
+	size_t sizeleft = maximumpacketsize-totalsize;
+	size_t neededsize = sizeof(RTCPCommonHeader)+sizeof(u_int32_t)+sizeof(RTCPSenderReport);
+	
+	if (neededsize &gt; sizeleft)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT;
+	
+	// fill in some things
+
+	report.headerlength = sizeof(u_int32_t)+sizeof(RTCPSenderReport);
+	report.isSR = true;	
+	
+	u_int32_t *ssrc = (u_int32_t *)report.headerdata;
+	*ssrc = htonl(senderssrc);
+
+	RTCPSenderReport *sr = (RTCPSenderReport *)(report.headerdata + sizeof(u_int32_t));
+	sr-&gt;ntptime_msw = htonl(ntptimestamp.GetMSW());
+	sr-&gt;ntptime_lsw = htonl(ntptimestamp.GetLSW());
+	sr-&gt;rtptimestamp = htonl(rtptimestamp);
+	sr-&gt;packetcount = htonl(packetcount);
+	sr-&gt;octetcount = htonl(octetcount);
+
+	return 0;
+}
+
+int RTCPCompoundPacketBuilder::StartReceiverReport(u_int32_t senderssrc)
+{
+	if (!arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING;
+	if (report.headerlength != 0)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYGOTREPORT;
+
+	size_t totalsize = byesize+appsize+sdes.NeededBytes();
+	size_t sizeleft = maximumpacketsize-totalsize;
+	size_t neededsize = sizeof(RTCPCommonHeader)+sizeof(u_int32_t);
+	
+	if (neededsize &gt; sizeleft)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT;
+	
+	// fill in some things
+
+	report.headerlength = sizeof(u_int32_t);
+	report.isSR = false;
+	
+	u_int32_t *ssrc = (u_int32_t *)report.headerdata;
+	*ssrc = htonl(senderssrc);
+
+	return 0;
+}
+
+int RTCPCompoundPacketBuilder::AddReportBlock(u_int32_t ssrc,u_int8_t fractionlost,int32_t packetslost,u_int32_t exthighestseq,
+	                                      u_int32_t jitter,u_int32_t lsr,u_int32_t dlsr)
+{
+	if (!arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING;
+	if (report.headerlength == 0)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_REPORTNOTSTARTED;
+
+	size_t totalothersize = byesize+appsize+sdes.NeededBytes();
+	size_t reportsizewithextrablock = report.NeededBytesWithExtraReportBlock();
+	
+	if ((totalothersize+reportsizewithextrablock) &gt; maximumpacketsize)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT;
+
+	u_int8_t *buf = new u_int8_t[sizeof(RTCPReceiverReport)];
+	if (buf == 0)
+		return ERR_RTP_OUTOFMEM;
+	
+	RTCPReceiverReport *rr = (RTCPReceiverReport *)buf;
+	u_int32_t *packlost = (u_int32_t *)&packetslost;
+	u_int32_t packlost2 = (*packlost);
+		
+	rr-&gt;ssrc = htonl(ssrc);
+	rr-&gt;fractionlost = fractionlost;
+	rr-&gt;packetslost[2] = (u_int8_t)(packlost2&amp;0xFF);
+	rr-&gt;packetslost[1] = (u_int8_t)((packlost2&gt;&gt;8)&amp;0xFF);
+	rr-&gt;packetslost[0] = (u_int8_t)((packlost2&gt;&gt;16)&amp;0xFF);
+	rr-&gt;exthighseqnr = htonl(exthighestseq);
+	rr-&gt;jitter = htonl(jitter);
+	rr-&gt;lsr = htonl(lsr);
+	rr-&gt;dlsr = htonl(dlsr);
+
+	report.reportblocks.push_back(Buffer(buf,sizeof(RTCPReceiverReport)));
+	return 0;
+}
+
+int RTCPCompoundPacketBuilder::AddSDESSource(u_int32_t ssrc)
+{
+	if (!arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING;
+
+	size_t totalotherbytes = byesize+appsize+report.NeededBytes();
+	size_t sdessizewithextrasource = sdes.NeededBytesWithExtraSource();
+
+	if ((totalotherbytes + sdessizewithextrasource) &gt; maximumpacketsize)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT;
+
+	int status;
+
+	if ((status = sdes.AddSSRC(ssrc)) &lt; 0)
+		return status;
+	return 0;
+}
+
+int RTCPCompoundPacketBuilder::AddSDESNormalItem(RTCPSDESPacket::ItemType t,const void *itemdata,u_int8_t itemlength)
+{
+	if (!arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING;
+	if (sdes.sdessources.empty())
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOCURRENTSOURCE;
+
+	u_int8_t itemid;
+	
+	switch(t)
+	{
+	case RTCPSDESPacket::CNAME:
+		itemid = RTCP_SDES_ID_CNAME;
+		break;
+	case RTCPSDESPacket::NAME:
+		itemid = RTCP_SDES_ID_NAME;
+		break;
+	case RTCPSDESPacket::EMAIL:
+		itemid = RTCP_SDES_ID_EMAIL;
+		break;
+	case RTCPSDESPacket::PHONE:
+		itemid = RTCP_SDES_ID_PHONE;
+		break;
+	case RTCPSDESPacket::LOC:
+		itemid = RTCP_SDES_ID_LOCATION;
+		break;
+	case RTCPSDESPacket::TOOL:
+		itemid = RTCP_SDES_ID_TOOL;
+		break;
+	case RTCPSDESPacket::NOTE:
+		itemid = RTCP_SDES_ID_NOTE;
+		break;
+	default:
+		return ERR_RTP_RTCPCOMPPACKBUILDER_INVALIDITEMTYPE;
+	}
+
+	size_t totalotherbytes = byesize+appsize+report.NeededBytes();
+	size_t sdessizewithextraitem = sdes.NeededBytesWithExtraItem(itemlength);
+
+	if ((sdessizewithextraitem+totalotherbytes) &gt; maximumpacketsize)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT;
+
+	u_int8_t *buf;
+	size_t len;
+
+	buf = new u_int8_t[sizeof(RTCPSDESHeader)+(size_t)itemlength];
+	if (buf == 0)
+		return ERR_RTP_OUTOFMEM;
+	len = sizeof(RTCPSDESHeader)+(size_t)itemlength;
+
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(buf);
+
+	sdeshdr-&gt;id = itemid;
+	sdeshdr-&gt;length = itemlength;
+	if (itemlength != 0)
+		memcpy((buf + sizeof(RTCPSDESHeader)),itemdata,(size_t)itemlength);
+
+	sdes.AddItem(buf,len);
+	return 0;
+}
+
+#ifdef RTP_SUPPORT_SDESPRIV
+int RTCPCompoundPacketBuilder::AddSDESPrivateItem(const void *prefixdata,u_int8_t prefixlength,const void *valuedata,
+                                                  u_int8_t valuelength)
+{
+	if (!arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING;
+	if (sdes.sdessources.empty())
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOCURRENTSOURCE;
+
+	size_t itemlength = ((size_t)prefixlength)+1+((size_t)valuelength);
+	if (itemlength &gt; 255)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_TOTALITEMLENGTHTOOBIG;
+	
+	size_t totalotherbytes = byesize+appsize+report.NeededBytes();
+	size_t sdessizewithextraitem = sdes.NeededBytesWithExtraItem(itemlength);
+
+	if ((sdessizewithextraitem+totalotherbytes) &gt; maximumpacketsize)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT;
+
+	u_int8_t *buf;
+	size_t len;
+
+	buf = new u_int8_t[sizeof(RTCPSDESHeader)+itemlength];
+	if (buf == 0)
+		return ERR_RTP_OUTOFMEM;
+	len = sizeof(RTCPSDESHeader)+(size_t)itemlength;
+
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(buf);
+
+	sdeshdr-&gt;id = RTCP_SDES_ID_PRIVATE;
+	sdeshdr-&gt;length = itemlength;
+	
+	buf[sizeof(RTCPSDESHeader)] = prefixlength;
+	if (prefixlength != 0)
+		memcpy((buf+sizeof(RTCPSDESHeader)+1),prefixdata,(size_t)prefixlength);
+	if (valuelength != 0)
+		memcpy((buf+sizeof(RTCPSDESHeader)+1+(size_t)prefixlength),valuedata,(size_t)valuelength);
+
+	sdes.AddItem(buf,len);
+	return 0;
+}
+#endif // RTP_SUPPORT_SDESPRIV
+
+int RTCPCompoundPacketBuilder::AddBYEPacket(u_int32_t *ssrcs,u_int8_t numssrcs,const void *reasondata,u_int8_t reasonlength)
+{
+	if (!arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING;
+
+	if (numssrcs &gt; 31)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_TOOMANYSSRCS;
+	
+	size_t packsize = sizeof(RTCPCommonHeader)+sizeof(u_int32_t)*((size_t)numssrcs);
+	size_t zerobytes = 0;
+	
+	if (reasonlength &gt; 0)
+	{
+		packsize += 1; // 1 byte for the length;
+		packsize += (size_t)reasonlength;
+
+		size_t r = (packsize&amp;0x03);
+		if (r != 0)
+		{
+			zerobytes = 4-r;
+			packsize += zerobytes;
+		}
+	}
+
+	size_t totalotherbytes = appsize+byesize+sdes.NeededBytes()+report.NeededBytes();
+
+	if ((totalotherbytes + packsize) &gt; maximumpacketsize)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT;
+
+	u_int8_t *buf;
+	size_t numwords;
+	
+	buf = new u_int8_t[packsize];
+	if (buf == 0)
+		return ERR_RTP_OUTOFMEM;
+
+	RTCPCommonHeader *hdr = (RTCPCommonHeader *)buf;
+
+	hdr-&gt;version = 2;
+	hdr-&gt;padding = 0;
+	hdr-&gt;count = numssrcs;
+	
+	numwords = packsize/sizeof(u_int32_t);
+	hdr-&gt;length = htons((u_int16_t)(numwords-1));
+	hdr-&gt;packettype = RTP_RTCPTYPE_BYE;
+	
+	u_int32_t *sources = (u_int32_t *)(buf+sizeof(RTCPCommonHeader));
+	u_int8_t srcindex;
+	
+	for (srcindex = 0 ; srcindex &lt; numssrcs ; srcindex++)
+		sources[srcindex] = htonl(ssrcs[srcindex]);
+
+	if (reasonlength != 0)
+	{
+		size_t offset = sizeof(RTCPCommonHeader)+((size_t)numssrcs)*sizeof(u_int32_t);
+
+		buf[offset] = reasonlength;
+		memcpy((buf+offset+1),reasondata,(size_t)reasonlength);
+		for (size_t i = 0 ; i &lt; zerobytes ; i++)
+			buf[packsize-1-i] = 0;
+	}
+
+	byepackets.push_back(Buffer(buf,packsize));
+	byesize += packsize;
+	
+	return 0;
+}
+
+int RTCPCompoundPacketBuilder::AddAPPPacket(u_int8_t subtype,u_int32_t ssrc,const u_int8_t name[4],const void *appdata,size_t appdatalen)
+{
+	if (!arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING;
+	if (subtype &gt; 31)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_ILLEGALSUBTYPE;
+	if ((appdatalen%4) != 0)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_ILLEGALAPPDATALENGTH;
+
+	size_t appdatawords = appdatalen/4;
+
+	if ((appdatawords+2) &gt; 65535)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_APPDATALENTOOBIG;
+	
+	size_t packsize = sizeof(RTCPCommonHeader)+sizeof(u_int32_t)*2+appdatalen;
+	size_t totalotherbytes = appsize+byesize+sdes.NeededBytes()+report.NeededBytes();
+
+	if ((totalotherbytes + packsize) &gt; maximumpacketsize)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT;
+
+	u_int8_t *buf;
+	
+	buf = new u_int8_t[packsize];
+	if (buf == 0)
+		return ERR_RTP_OUTOFMEM;
+
+	RTCPCommonHeader *hdr = (RTCPCommonHeader *)buf;
+
+	hdr-&gt;version = 2;
+	hdr-&gt;padding = 0;
+	hdr-&gt;count = subtype;
+	
+	hdr-&gt;length = htons((u_int16_t)(appdatawords+2));
+	hdr-&gt;packettype = RTP_RTCPTYPE_APP;
+	
+	u_int32_t *source = (u_int32_t *)(buf+sizeof(RTCPCommonHeader));
+	*source = htonl(ssrc);
+
+	buf[sizeof(RTCPCommonHeader)+sizeof(u_int32_t)+0] = name[0];
+	buf[sizeof(RTCPCommonHeader)+sizeof(u_int32_t)+1] = name[1];
+	buf[sizeof(RTCPCommonHeader)+sizeof(u_int32_t)+2] = name[2];
+	buf[sizeof(RTCPCommonHeader)+sizeof(u_int32_t)+3] = name[3];
+
+	if (appdatalen &gt; 0)
+		memcpy((buf+sizeof(RTCPCommonHeader)+sizeof(u_int32_t)*2),appdata,appdatalen);
+
+	apppackets.push_back(Buffer(buf,packsize));
+	appsize += packsize;
+	
+	return 0;
+}
+
+int RTCPCompoundPacketBuilder::EndBuild()
+{
+	if (!arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING;
+	if (report.headerlength == 0)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOREPORTPRESENT;
+	
+	u_int8_t *buf;
+	size_t len;
+	
+	len = appsize+byesize+report.NeededBytes()+sdes.NeededBytes();
+	
+	if (!external)
+	{
+		buf = new u_int8_t[len];
+		if (buf == 0)
+			return ERR_RTP_OUTOFMEM;
+	}
+	else
+		buf = buffer;
+	
+	u_int8_t *curbuf = buf;
+	RTCPPacket *p;
+
+	// first, we'll add all report info
+	
+	{
+		bool firstpacket = true;
+		bool done = false;
+		std::list&lt;Buffer&gt;::const_iterator it = report.reportblocks.begin();
+		do
+		{
+			RTCPCommonHeader *hdr = (RTCPCommonHeader *)curbuf;
+			size_t offset;
+			
+			hdr-&gt;version = 2;
+			hdr-&gt;padding = 0;
+
+			if (firstpacket &amp;&amp; report.isSR)
+			{
+				hdr-&gt;packettype = RTP_RTCPTYPE_SR;
+				memcpy((curbuf+sizeof(RTCPCommonHeader)),report.headerdata,report.headerlength);
+				offset = sizeof(RTCPCommonHeader)+report.headerlength;
+			}
+			else
+			{
+				hdr-&gt;packettype = RTP_RTCPTYPE_RR;
+				memcpy((curbuf+sizeof(RTCPCommonHeader)),report.headerdata,sizeof(u_int32_t));
+				offset = sizeof(RTCPCommonHeader)+sizeof(u_int32_t);
+			}
+			firstpacket = false;
+			
+			u_int8_t count = 0;
+
+			while (it != report.reportblocks.end() &amp;&amp; count &lt; 31)
+			{
+				memcpy(curbuf+offset,(*it).packetdata,(*it).packetlength);
+				offset += (*it).packetlength;
+				count++;
+				it++;
+			}
+
+			size_t numwords = offset/sizeof(u_int32_t);
+
+			hdr-&gt;length = htons((u_int16_t)(numwords-1));
+			hdr-&gt;count = count;
+
+			// add entry in parent's list
+			if (hdr-&gt;packettype == RTP_RTCPTYPE_SR)
+				p = new RTCPSRPacket(curbuf,offset);
+			else
+				p = new RTCPRRPacket(curbuf,offset);
+			if (p == 0)
+			{
+				if (!external)
+					delete [] buf;
+				ClearPacketList();
+				return ERR_RTP_OUTOFMEM;
+			}
+			rtcppacklist.push_back(p);
+
+			curbuf += offset;
+			if (it == report.reportblocks.end())
+				done = true;
+		} while (!done);
+	}
+		
+	// then, we'll add the sdes info
+
+	if (!sdes.sdessources.empty())
+	{
+		bool done = false;
+		std::list&lt;SDESSource *&gt;::const_iterator sourceit = sdes.sdessources.begin();
+		
+		do
+		{
+			RTCPCommonHeader *hdr = (RTCPCommonHeader *)curbuf;
+			size_t offset = sizeof(RTCPCommonHeader);
+			
+			hdr-&gt;version = 2;
+			hdr-&gt;padding = 0;
+			hdr-&gt;packettype = RTP_RTCPTYPE_SDES;
+
+			u_int8_t sourcecount = 0;
+			
+			while (sourceit != sdes.sdessources.end() &amp;&amp; sourcecount &lt; 31)
+			{
+				u_int32_t *ssrc = (u_int32_t *)(curbuf+offset);
+				*ssrc = htonl((*sourceit)-&gt;ssrc);
+				offset += sizeof(u_int32_t);
+				
+				std::list&lt;Buffer&gt;::const_iterator itemit,itemend;
+
+				itemit = (*sourceit)-&gt;items.begin();
+				itemend = (*sourceit)-&gt;items.end();
+				while (itemit != itemend)
+				{
+					memcpy(curbuf+offset,(*itemit).packetdata,(*itemit).packetlength);
+					offset += (*itemit).packetlength;
+					itemit++;
+				}
+
+				curbuf[offset] = 0; // end of item list;
+				offset++;
+
+				size_t r = offset&amp;0x03;
+				if (r != 0) // align to 32 bit boundary
+				{
+					size_t num = 4-r;
+					size_t i;
+
+					for (i = 0 ; i &lt; num ; i++)
+						curbuf[offset+i] = 0;
+					offset += num;
+				}
+				
+				sourceit++;
+				sourcecount++;
+			}
+
+			size_t numwords = offset/4;
+			
+			hdr-&gt;count = sourcecount;
+			hdr-&gt;length = htons((u_int16_t)(numwords-1));
+
+			p = new RTCPSDESPacket(curbuf,offset);
+			if (p == 0)
+			{
+				if (!external)
+					delete [] buf;
+				ClearPacketList();
+				return ERR_RTP_OUTOFMEM;
+			}
+			rtcppacklist.push_back(p);
+			
+			curbuf += offset;
+			if (sourceit == sdes.sdessources.end())
+				done = true;
+		} while (!done);
+	}
+	
+	// adding the app data
+	
+	{
+		std::list&lt;Buffer&gt;::const_iterator it;
+
+		for (it = apppackets.begin() ; it != apppackets.end() ; it++)
+		{
+			memcpy(curbuf,(*it).packetdata,(*it).packetlength);
+			
+			p = new RTCPAPPPacket(curbuf,(*it).packetlength);
+			if (p == 0)
+			{
+				if (!external)
+					delete [] buf;
+				ClearPacketList();
+				return ERR_RTP_OUTOFMEM;
+			}
+			rtcppacklist.push_back(p);
+	
+			curbuf += (*it).packetlength;
+		}
+	}
+	
+	// adding bye packets
+	
+	{
+		std::list&lt;Buffer&gt;::const_iterator it;
+
+		for (it = byepackets.begin() ; it != byepackets.end() ; it++)
+		{
+			memcpy(curbuf,(*it).packetdata,(*it).packetlength);
+			
+			p = new RTCPBYEPacket(curbuf,(*it).packetlength);
+			if (p == 0)
+			{
+				if (!external)
+					delete [] buf;
+				ClearPacketList();
+				return ERR_RTP_OUTOFMEM;
+			}
+			rtcppacklist.push_back(p);
+	
+			curbuf += (*it).packetlength;
+		}
+	}
+	
+	compoundpacket = buf;
+	compoundpacketlength = len;
+	arebuilding = false;
+	ClearBuildBuffers();
+	return 0;
+}
+

Added: konference/src/rtp/jrtplib/rtcpcompoundpacketbuilder.h
===================================================================
--- konference/src/rtp/jrtplib/rtcpcompoundpacketbuilder.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpcompoundpacketbuilder.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,317 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPCOMPOUNDPACKETBUILDER_H
+
+#define RTCPCOMPOUNDPACKETBUILDER_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtcpcompoundpacket.h&quot;
+#include &quot;rtptimeutilities.h&quot;
+#include &quot;rtcpsdespacket.h&quot;
+#include &quot;rtperrors.h&quot;
+#include &lt;list&gt;
+
+class RTCPCompoundPacketBuilder : public RTCPCompoundPacket
+{
+public:
+	RTCPCompoundPacketBuilder();
+	~RTCPCompoundPacketBuilder();
+
+	int InitBuild(size_t maxpacketsize);
+	int InitBuild(void *externalbuffer,size_t buffersize);
+	
+	int StartSenderReport(u_int32_t senderssrc,const RTPNTPTime &amp;ntptimestamp,u_int32_t rtptimestamp,
+	                    u_int32_t packetcount,u_int32_t octetcount);
+	int StartReceiverReport(u_int32_t senderssrc);
+	int AddReportBlock(u_int32_t ssrc,u_int8_t fractionlost,int32_t packetslost,u_int32_t exthighestseq,
+	                   u_int32_t jitter,u_int32_t lsr,u_int32_t dlsr);
+	
+	int AddSDESSource(u_int32_t ssrc);
+	int AddSDESNormalItem(RTCPSDESPacket::ItemType t,const void *itemdata,u_int8_t itemlength);
+#ifdef RTP_SUPPORT_SDESPRIV
+	int AddSDESPrivateItem(const void *prefixdata,u_int8_t prefixlength,const void *valuedata,
+	                       u_int8_t valuelength);
+#endif // RTP_SUPPORT_SDESPRIV
+
+	int AddBYEPacket(u_int32_t *ssrcs,u_int8_t numssrcs,const void *reasondata,u_int8_t reasonlength);
+
+	// note: appdatalen must be a multiple of 4 (32 bits) !
+	int AddAPPPacket(u_int8_t subtype,u_int32_t ssrc,const u_int8_t name[4],const void *appdata,size_t appdatalen);
+
+	int EndBuild();
+private:
+	class Buffer
+	{
+	public:
+		Buffer():packetdata(0),packetlength(0) { }
+		Buffer(u_int8_t *data,size_t len):packetdata(data),packetlength(len) { }			
+		
+		u_int8_t *packetdata;
+		size_t packetlength;
+	};
+
+	class Report
+	{
+	public:
+		Report() { headerdata = (u_int8_t *)headerdata32; isSR = false; headerlength = 0; }
+		~Report() { Clear(); }
+
+		void Clear()
+		{
+			std::list&lt;Buffer&gt;::const_iterator it; 
+			for (it = reportblocks.begin() ; it != reportblocks.end() ; it++) 
+				if ((*it).packetdata) 
+					delete [] (*it).packetdata; 
+			reportblocks.clear();
+			isSR = false;
+			headerlength = 0;
+		}
+
+		size_t NeededBytes() 
+		{ 
+			size_t x,n,d,r; 
+			n = reportblocks.size(); 
+			if (n == 0)
+			{
+				if (headerlength == 0)
+					return 0;
+				x = sizeof(RTCPCommonHeader)+headerlength;
+			}
+			else
+			{
+				x = n*sizeof(RTCPReceiverReport);
+				d = n/31; // max 31 reportblocks per report
+				r = n%31;
+				if (r != 0)
+					d++;
+				x += d*(sizeof(RTCPCommonHeader)+sizeof(u_int32_t)); /* header and SSRC */
+				if (isSR)
+					x += sizeof(RTCPSenderReport);
+			}
+			return x;
+		}			
+
+		size_t NeededBytesWithExtraReportBlock()
+		{
+			size_t x,n,d,r; 
+			n = reportblocks.size() + 1; // +1 for the extra block
+			x = n*sizeof(RTCPReceiverReport);
+			d = n/31; // max 31 reportblocks per report
+			r = n%31;
+			if (r != 0)
+				d++;
+			x += d*(sizeof(RTCPCommonHeader)+sizeof(u_int32_t)); /* header and SSRC */
+			if (isSR)
+				x += sizeof(RTCPSenderReport);
+			return x;
+		}
+		
+		bool isSR;
+
+		u_int8_t *headerdata;
+		u_int32_t headerdata32[(sizeof(u_int32_t)+sizeof(RTCPSenderReport))/sizeof(u_int32_t)]; // either for ssrc and sender info or just ssrc
+		size_t headerlength;
+		std::list&lt;Buffer&gt; reportblocks;
+	};
+
+	class SDESSource
+	{
+	public:
+		SDESSource(u_int32_t s) : ssrc(s),totalitemsize(0) { }
+		~SDESSource()
+		{
+			std::list&lt;Buffer&gt;::const_iterator it;
+			for (it = items.begin() ; it != items.end() ; it++)
+				if ((*it).packetdata)
+					delete [] (*it).packetdata;
+			items.clear();
+		}
+
+		size_t NeededBytes()
+		{
+			size_t x,r;
+			x = totalitemsize + 1; // +1 for the 0 byte which terminates the item list
+			r = x%sizeof(u_int32_t);
+			if (r != 0)
+				x += (sizeof(u_int32_t)-r); // make sure it ends on a 32 bit boundary
+			x += sizeof(u_int32_t); // for ssrc
+			return x;
+		}
+
+		size_t NeededBytesWithExtraItem(u_int8_t itemdatalength)
+		{
+			size_t x,r;
+			x = totalitemsize + sizeof(RTCPSDESHeader) + (size_t)itemdatalength + 1;
+			r = x%sizeof(u_int32_t);
+			if (r != 0)
+				x += (sizeof(u_int32_t)-r); // make sure it ends on a 32 bit boundary
+			x += sizeof(u_int32_t); // for ssrc
+			return x;
+		}
+		
+		void AddItem(u_int8_t *buf,size_t len)
+		{
+			Buffer b(buf,len);
+			totalitemsize += len;
+			items.push_back(b);	
+		}
+		
+		u_int32_t ssrc;
+		std::list&lt;Buffer&gt; items;
+	private:
+		size_t totalitemsize;
+	};
+	
+	class SDES
+	{
+	public:
+		SDES() { sdesit = sdessources.end(); }
+		~SDES() { Clear(); }
+
+		void Clear()
+		{
+			std::list&lt;SDESSource *&gt;::const_iterator it;
+
+			for (it = sdessources.begin() ; it != sdessources.end() ; it++)
+				delete (*it);
+			sdessources.clear();
+		}
+
+		int AddSSRC(u_int32_t ssrc)
+		{
+			SDESSource *s = new SDESSource(ssrc);
+			if (s == 0)
+				return ERR_RTP_OUTOFMEM;
+			sdessources.push_back(s);
+			sdesit = sdessources.end();
+			sdesit--;
+			return 0;
+		}
+
+		int AddItem(u_int8_t *buf,size_t len)
+		{
+			if (sdessources.empty())
+				return ERR_RTP_RTCPCOMPPACKBUILDER_NOCURRENTSOURCE;
+			(*sdesit)-&gt;AddItem(buf,len);
+			return 0;
+		}
+
+		size_t NeededBytes()
+		{
+			std::list&lt;SDESSource *&gt;::const_iterator it;
+			size_t x = 0;
+			size_t n,d,r;
+			
+			if (sdessources.empty())
+				return 0;
+			
+			for (it = sdessources.begin() ; it != sdessources.end() ; it++)
+				x += (*it)-&gt;NeededBytes();
+			n = sdessources.size();
+			d = n/31;
+			r = n%31;
+			if (r != 0)
+				d++;
+			x += d*sizeof(RTCPCommonHeader);
+			return x;
+		}
+		
+		size_t NeededBytesWithExtraItem(u_int8_t itemdatalength)
+		{
+			std::list&lt;SDESSource *&gt;::const_iterator it;
+			size_t x = 0;
+			size_t n,d,r;
+			
+			if (sdessources.empty())
+				return 0;
+			
+			for (it = sdessources.begin() ; it != sdesit ; it++)
+				x += (*it)-&gt;NeededBytes();
+			x += (*sdesit)-&gt;NeededBytesWithExtraItem(itemdatalength);
+			n = sdessources.size();
+			d = n/31;
+			r = n%31;
+			if (r != 0)
+				d++;
+			x += d*sizeof(RTCPCommonHeader);
+			return x;
+		}
+
+		size_t NeededBytesWithExtraSource()
+		{
+			std::list&lt;SDESSource *&gt;::const_iterator it;
+			size_t x = 0;
+			size_t n,d,r;
+			
+			if (sdessources.empty())
+				return 0;
+			
+			for (it = sdessources.begin() ; it != sdessources.end() ; it++)
+				x += (*it)-&gt;NeededBytes();
+			
+			// for the extra source we'll need at least 8 bytes (ssrc and four 0 bytes)
+			x += sizeof(u_int32_t)*2;
+			
+			n = sdessources.size() + 1; // also, the number of sources will increase
+			d = n/31;
+			r = n%31;
+			if (r != 0)
+				d++;
+			x += d*sizeof(RTCPCommonHeader);
+			return x;
+		}
+		
+		std::list&lt;SDESSource *&gt; sdessources;
+	private:
+		std::list&lt;SDESSource *&gt;::const_iterator sdesit;
+	};
+
+	size_t maximumpacketsize;
+	u_int8_t *buffer;
+	bool external;
+	bool arebuilding;
+	
+	Report report;
+	SDES sdes;
+
+	std::list&lt;Buffer&gt; byepackets;
+	size_t byesize;
+	
+	std::list&lt;Buffer&gt; apppackets;
+	size_t appsize;
+	
+	void ClearBuildBuffers();
+};
+
+#endif // RTCPCOMPOUNDPACKETBUILDER_H
+

Added: konference/src/rtp/jrtplib/rtcppacket.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcppacket.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcppacket.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,71 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtcppacket.h&quot;
+#ifdef RTPDEBUG
+	#include &lt;iostream&gt;
+#endif // RTPDEBUG
+
+#include &quot;rtpdebug.h&quot;
+
+#ifdef RTPDEBUG
+
+void RTCPPacket::Dump()
+{
+	switch(packettype)
+	{
+	case SR:
+		std::cout &lt;&lt; &quot;RTCP Sender Report      &quot;;
+		break;
+	case RR:
+		std::cout &lt;&lt; &quot;RTCP Receiver Report    &quot;;
+		break;
+	case SDES:
+		std::cout &lt;&lt; &quot;RTCP Source Description &quot;;
+		break;
+	case APP:
+		std::cout &lt;&lt; &quot;RTCP APP Packet         &quot;;
+		break;
+	case BYE:
+		std::cout &lt;&lt; &quot;RTCP Bye Packet         &quot;;
+		break;
+	case Unknown:
+		std::cout &lt;&lt; &quot;Unknown RTCP Packet     &quot;;
+		break;
+	default:
+		std::cout &lt;&lt; &quot;ERROR: Invalid packet type!&quot; &lt;&lt; std::endl;		
+	}
+	std::cout &lt;&lt; &quot;Length: &quot; &lt;&lt; datalen;
+	std::cout &lt;&lt; std::endl;
+}
+
+#endif // RTPDEBUG

Added: konference/src/rtp/jrtplib/rtcppacket.h
===================================================================
--- konference/src/rtp/jrtplib/rtcppacket.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcppacket.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,69 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPPACKET_H
+
+#define RTCPPACKET_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtptypes.h&quot;
+
+class RTCPCompoundPacket;
+
+class RTCPPacket 
+{
+public:
+	enum PacketType { SR,RR,SDES,BYE,APP,Unknown };
+protected:
+	RTCPPacket(PacketType t,u_int8_t *d,size_t dlen) : data(d),datalen(dlen),packettype(t) { knownformat = false; }
+public:
+	virtual ~RTCPPacket()								{ }	
+
+	bool IsKnownFormat() const							{ return knownformat; }
+	
+	PacketType GetPacketType() const						{ return packettype; }
+	u_int8_t *GetPacketData()							{ return data; }
+	size_t GetPacketLength() const							{ return datalen; }
+
+#ifdef RTPDEBUG
+	virtual void Dump();
+#endif // RTPDEBUG
+protected:
+	u_int8_t *data;
+	size_t datalen;
+	bool knownformat;
+private:
+	const PacketType packettype;
+};
+
+#endif // RTCPPACKET_H
+

Added: konference/src/rtp/jrtplib/rtcppacketbuilder.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcppacketbuilder.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcppacketbuilder.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,733 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtcppacketbuilder.h&quot;
+#include &quot;rtpsources.h&quot;
+#include &quot;rtppacketbuilder.h&quot;
+#include &quot;rtcpscheduler.h&quot;
+#include &quot;rtpsourcedata.h&quot;
+#include &quot;rtcpcompoundpacketbuilder.h&quot;
+
+#include &quot;rtpdebug.h&quot;
+
+RTCPPacketBuilder::RTCPPacketBuilder(RTPSources &amp;s,RTPPacketBuilder &amp;pb)
+	: sources(s),rtppacketbuilder(pb),prevbuildtime(0,0)
+{
+	init = false;
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	timeinit.Dummy();
+#endif // WIN32 || _WIN32_WCE
+}
+
+RTCPPacketBuilder::~RTCPPacketBuilder()
+{
+	Destroy();
+}
+
+int RTCPPacketBuilder::Init(size_t maxpacksize,double tsunit,const void *cname,size_t cnamelen)
+{
+	if (init)
+		return ERR_RTP_RTCPPACKETBUILDER_ALREADYINIT;
+	if (maxpacksize &lt; RTP_MINPACKETSIZE)
+		return ERR_RTP_RTCPPACKETBUILDER_ILLEGALMAXPACKSIZE;
+	if (tsunit &lt; 0.0)
+		return ERR_RTP_RTCPPACKETBUILDER_ILLEGALTIMESTAMPUNIT;
+
+	if (cnamelen&gt;255)
+		cnamelen = 255;
+	
+	maxpacketsize = maxpacksize;
+	timestampunit = tsunit;
+	
+	int status;
+	
+	if ((status = ownsdesinfo.SetCNAME((const u_int8_t *)cname,cnamelen)) &lt; 0)
+		return status;
+	
+	ClearAllSourceFlags();
+	
+	interval_name = -1;
+	interval_email = -1;
+	interval_location = -1;
+	interval_phone = -1;
+	interval_tool = -1;
+	interval_note = -1;
+
+	sdesbuildcount = 0;
+
+	firstpacket = true;
+	processingsdes = false;
+	init = true;
+	return 0;
+}
+
+void RTCPPacketBuilder::Destroy()
+{
+	if (!init)
+		return;
+	ownsdesinfo.Clear();
+	init = false;
+}
+
+int RTCPPacketBuilder::BuildNextPacket(RTCPCompoundPacket **pack)
+{
+	if (!init)
+		return ERR_RTP_RTCPPACKETBUILDER_NOTINIT;
+
+	RTCPCompoundPacketBuilder *rtcpcomppack;
+	int status;
+	bool sender = false;
+	RTPSourceData *srcdat;
+	
+	*pack = 0;
+	
+	rtcpcomppack = new RTCPCompoundPacketBuilder();
+	if (rtcpcomppack == 0)
+		return ERR_RTP_OUTOFMEM;
+	
+	if ((status = rtcpcomppack-&gt;InitBuild(maxpacketsize)) &lt; 0)
+	{
+		delete rtcpcomppack;
+		return status;
+	}
+	
+	if ((srcdat = sources.GetOwnSourceInfo()) != 0)
+	{
+		if (srcdat-&gt;IsSender())
+			sender = true;
+	}
+	
+	u_int32_t ssrc = rtppacketbuilder.GetSSRC();
+	RTPTime curtime = RTPTime::CurrentTime();
+
+	if (sender)
+	{
+		RTPTime rtppacktime = rtppacketbuilder.GetPacketTime();
+		u_int32_t rtppacktimestamp = rtppacketbuilder.GetPacketTimestamp();
+		u_int32_t packcount = rtppacketbuilder.GetPacketCount();
+		u_int32_t octetcount = rtppacketbuilder.GetPayloadOctetCount();
+		RTPTime diff = curtime;
+		diff -= rtppacktime;
+		
+		u_int32_t tsdiff = (u_int32_t)((diff.GetDouble()/timestampunit)+0.5);
+		u_int32_t rtptimestamp = rtppacktimestamp+tsdiff;
+		RTPNTPTime ntptimestamp = curtime.GetNTPTime();
+
+		if ((status = rtcpcomppack-&gt;StartSenderReport(ssrc,ntptimestamp,rtptimestamp,packcount,octetcount)) &lt; 0)
+		{
+			delete rtcpcomppack;
+			if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+				return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+			return status;
+		}
+	}
+	else
+	{
+		if ((status = rtcpcomppack-&gt;StartReceiverReport(ssrc)) &lt; 0)
+		{
+			delete rtcpcomppack;
+			if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+				return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+			return status;
+		}
+	}
+
+	u_int8_t *owncname;
+	size_t owncnamelen;
+
+	owncname = ownsdesinfo.GetCNAME(&amp;owncnamelen);
+
+	if ((status = rtcpcomppack-&gt;AddSDESSource(ssrc)) &lt; 0)
+	{
+		delete rtcpcomppack;
+		if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+			return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+		return status;
+	}
+	if ((status = rtcpcomppack-&gt;AddSDESNormalItem(RTCPSDESPacket::CNAME,owncname,owncnamelen)) &lt; 0)
+	{
+		delete rtcpcomppack;
+		if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+			return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+		return status;
+	}
+
+	if (!processingsdes)
+	{
+		int added,skipped;
+		bool full,atendoflist;
+
+		if ((status = FillInReportBlocks(rtcpcomppack,curtime,sources.GetTotalCount(),&amp;full,&amp;added,&amp;skipped,&amp;atendoflist)) &lt; 0)
+		{
+			delete rtcpcomppack;
+			return status;
+		}
+		
+		if (full &amp;&amp; added == 0)
+		{
+			delete rtcpcomppack;
+			return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+		}
+	
+		if (!full)
+		{
+			processingsdes = true;
+			sdesbuildcount++;
+			
+			ClearAllSourceFlags();
+	
+			doname = false;
+			doemail = false;
+			doloc = false;
+			dophone = false;
+			dotool = false;
+			donote = false;
+			if (interval_name &gt; 0 &amp;&amp; ((sdesbuildcount%interval_name) == 0)) doname = true;
+			if (interval_email &gt; 0 &amp;&amp; ((sdesbuildcount%interval_email) == 0)) doemail = true;
+			if (interval_location &gt; 0 &amp;&amp; ((sdesbuildcount%interval_location) == 0)) doloc = true;
+			if (interval_phone &gt; 0 &amp;&amp; ((sdesbuildcount%interval_phone) == 0)) dophone = true;
+			if (interval_tool &gt; 0 &amp;&amp; ((sdesbuildcount%interval_tool) == 0)) dotool = true;
+			if (interval_note &gt; 0 &amp;&amp; ((sdesbuildcount%interval_note) == 0)) donote = true;
+			
+			bool processedall;
+			int itemcount;
+			
+			if ((status = FillInSDES(rtcpcomppack,&amp;full,&amp;processedall,&amp;itemcount)) &lt; 0)
+			{
+				delete rtcpcomppack;
+				return status;
+			}
+
+			if (processedall)
+			{
+				processingsdes = false;
+				ClearAllSDESFlags();
+				if (!full &amp;&amp; skipped &gt; 0) 
+				{
+					// if the packet isn't full and we skipped some
+				        // sources that we already got in a previous packet,
+					// we can add some of them now
+					
+					bool atendoflist;
+					 
+					if ((status = FillInReportBlocks(rtcpcomppack,curtime,skipped,&amp;full,&amp;added,&amp;skipped,&amp;atendoflist)) &lt; 0)
+					{
+						delete rtcpcomppack;
+						return status;
+					}
+				}
+			}
+		}
+	}
+	else // previous sdes processing wasn't finished
+	{
+		bool processedall;
+		int itemcount;
+		bool full;
+			
+		if ((status = FillInSDES(rtcpcomppack,&amp;full,&amp;processedall,&amp;itemcount)) &lt; 0)
+		{
+			delete rtcpcomppack;
+			return status;
+		}
+
+		if (itemcount == 0) // Big problem: packet size is too small to let any progress happen
+		{
+			delete rtcpcomppack;
+			return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+		}
+
+		if (processedall)
+		{
+			processingsdes = false;
+			ClearAllSDESFlags();
+			if (!full) 
+			{
+				// if the packet isn't full and we skipped some
+				// we can add some report blocks
+				
+				int added,skipped;
+				bool atendoflist;
+
+				if ((status = FillInReportBlocks(rtcpcomppack,curtime,sources.GetTotalCount(),&amp;full,&amp;added,&amp;skipped,&amp;atendoflist)) &lt; 0)
+				{
+					delete rtcpcomppack;
+					return status;
+				}
+				if (atendoflist) // filled in all possible sources
+					ClearAllSourceFlags();
+			}
+		}
+	}
+		
+	if ((status = rtcpcomppack-&gt;EndBuild()) &lt; 0)
+	{
+		delete rtcpcomppack;
+		return status;
+	}
+
+	*pack = rtcpcomppack;
+	firstpacket = false;
+	prevbuildtime = curtime;
+	return 0;
+}
+
+void RTCPPacketBuilder::ClearAllSourceFlags()
+{
+	if (sources.GotoFirstSource())
+	{
+		do
+		{
+			RTPSourceData *srcdat = sources.GetCurrentSourceInfo();
+			srcdat-&gt;SetProcessedInRTCP(false);
+		} while (sources.GotoNextSource());
+	}
+}
+
+int RTCPPacketBuilder::FillInReportBlocks(RTCPCompoundPacketBuilder *rtcpcomppack,const RTPTime &amp;curtime,int maxcount,bool *full,int *added,int *skipped,bool *atendoflist)
+{
+	RTPSourceData *srcdat;
+	int addedcount = 0;
+	int skippedcount = 0;
+	bool done = false;
+	bool filled = false;
+	bool atend = false;
+	int status;
+
+	if (sources.GotoFirstSource())
+	{
+		do
+		{
+			bool shouldprocess = false;
+			
+			srcdat = sources.GetCurrentSourceInfo();
+			if (!srcdat-&gt;IsOwnSSRC()) // don't send to ourselves
+			{
+				if (!srcdat-&gt;IsCSRC()) // p 35: no reports should go to CSRCs
+				{
+					if (srcdat-&gt;INF_HasSentData()) // if this isn't true, INF_GetLastRTPPacketTime() won't make any sense
+					{
+						if (firstpacket)
+							shouldprocess = true;
+						else
+						{
+							// p 35: only if rtp packets were received since the last RTP packet, a report block
+							// should be added
+							
+							RTPTime lastrtptime = srcdat-&gt;INF_GetLastRTPPacketTime();
+							
+							if (lastrtptime &gt; prevbuildtime)
+								shouldprocess = true;
+						}
+					}
+				}
+			}
+
+			if (shouldprocess)
+			{
+				if (srcdat-&gt;IsProcessedInRTCP()) // already covered this one
+				{
+					skippedcount++;
+				}
+				else
+				{
+					u_int32_t rr_ssrc = srcdat-&gt;GetSSRC();
+					u_int32_t num = srcdat-&gt;INF_GetNumPacketsReceivedInInterval();
+					u_int32_t prevseq = srcdat-&gt;INF_GetSavedExtendedSequenceNumber();
+					u_int32_t curseq = srcdat-&gt;INF_GetExtendedHighestSequenceNumber();
+					u_int32_t expected = curseq-prevseq;
+					u_int8_t fraclost;
+					
+					if (expected &lt; num) // got duplicates
+						fraclost = 0;
+					else
+					{
+						double lost = (double)(expected-num);
+						double frac = lost/((double)expected);
+						fraclost = (u_int8_t)(frac*256.0);
+					}
+
+					expected = curseq-srcdat-&gt;INF_GetBaseSequenceNumber();
+					num = srcdat-&gt;INF_GetNumPacketsReceived();
+
+					u_int32_t diff = expected-num;
+					int32_t *packlost = (int32_t *)&diff;
+					
+					u_int32_t jitter = srcdat-&gt;INF_GetJitter();
+					u_int32_t lsr;
+					u_int32_t dlsr; 	
+
+					if (!srcdat-&gt;SR_HasInfo())
+					{
+						lsr = 0;
+						dlsr = 0;
+					}
+					else
+					{
+						RTPNTPTime srtime = srcdat-&gt;SR_GetNTPTimestamp();
+						u_int32_t m = (srtime.GetMSW()&amp;0xFFFF);
+						u_int32_t l = ((srtime.GetLSW()&gt;&gt;16)&amp;0xFFFF);
+						lsr = ((m&lt;&lt;16)|l);
+
+						RTPTime diff = curtime;
+						diff -= srcdat-&gt;SR_GetReceiveTime();
+						double diff2 = diff.GetDouble();
+						diff2 *= 65536.0;
+						dlsr = (u_int32_t)diff2;
+					}
+
+					status = rtcpcomppack-&gt;AddReportBlock(rr_ssrc,fraclost,*packlost,curseq,jitter,lsr,dlsr);
+					if (status &lt; 0)
+					{
+						if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+						{
+							done = true;
+							filled = true;
+						}
+						else
+							return status;
+					}
+					else
+					{
+						addedcount++;
+						if (addedcount &gt;= maxcount)
+						{
+							done = true;
+							if (!sources.GotoNextSource())
+								atend = true;
+						}
+						srcdat-&gt;INF_StartNewInterval();
+						srcdat-&gt;SetProcessedInRTCP(true);
+					}
+				}
+			}
+
+			if (!done)
+			{
+				if (!sources.GotoNextSource())
+				{
+					atend = true;
+					done = true;
+				}
+			}
+
+		} while (!done);
+	}
+	
+	*added = addedcount;
+	*skipped = skippedcount;
+	*full = filled;
+	
+	if (!atend) // search for available sources
+	{
+		bool shouldprocess = false;
+		
+		do
+		{	
+			srcdat = sources.GetCurrentSourceInfo();
+			if (!srcdat-&gt;IsOwnSSRC()) // don't send to ourselves
+			{
+				if (!srcdat-&gt;IsCSRC()) // p 35: no reports should go to CSRCs
+				{
+					if (srcdat-&gt;INF_HasSentData()) // if this isn't true, INF_GetLastRTPPacketTime() won't make any sense
+					{
+						if (firstpacket)
+							shouldprocess = true;
+						else
+						{
+							// p 35: only if rtp packets were received since the last RTP packet, a report block
+							// should be added
+							
+							RTPTime lastrtptime = srcdat-&gt;INF_GetLastRTPPacketTime();
+							
+							if (lastrtptime &gt; prevbuildtime)
+								shouldprocess = true;
+						}
+					}
+				}
+			}
+			
+			if (shouldprocess)
+			{
+				if (srcdat-&gt;IsProcessedInRTCP())
+					shouldprocess = false;
+			}
+
+			if (!shouldprocess)
+			{
+				if (!sources.GotoNextSource())
+					atend = true;
+			}
+	
+		} while (!atend &amp;&amp; !shouldprocess);
+	}	
+
+	*atendoflist = atend;
+	return 0;	
+}
+
+int RTCPPacketBuilder::FillInSDES(RTCPCompoundPacketBuilder *rtcpcomppack,bool *full,bool *processedall,int *added)
+{
+	int status;
+	u_int8_t *data;
+	size_t datalen;
+	
+	*full = false;
+	*processedall = false;
+	*added = 0;
+
+	// We don't need to add a SSRC for our own data, this is still set
+	// from adding the CNAME
+	if (doname)
+	{
+		if (!ownsdesinfo.ProcessedName())
+		{
+			data = ownsdesinfo.GetName(&amp;datalen);
+			if ((status = rtcpcomppack-&gt;AddSDESNormalItem(RTCPSDESPacket::NAME,data,datalen)) &lt; 0)
+			{
+				if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+				{
+					*full = true;
+					return 0;
+				}
+			}
+			(*added)++;
+			ownsdesinfo.SetProcessedName(true);
+		}
+	}
+	if (doemail)
+	{
+		if (!ownsdesinfo.ProcessedEMail())
+		{
+			data = ownsdesinfo.GetEMail(&amp;datalen);
+			if ((status = rtcpcomppack-&gt;AddSDESNormalItem(RTCPSDESPacket::EMAIL,data,datalen)) &lt; 0)
+			{
+				if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+				{
+					*full = true;
+					return 0;
+				}
+			}
+			(*added)++;
+			ownsdesinfo.SetProcessedEMail(true);
+		}
+	}
+	if (doloc)
+	{
+		if (!ownsdesinfo.ProcessedLocation())
+		{
+			data = ownsdesinfo.GetLocation(&amp;datalen);
+			if ((status = rtcpcomppack-&gt;AddSDESNormalItem(RTCPSDESPacket::LOC,data,datalen)) &lt; 0)
+			{
+				if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+				{
+					*full = true;
+					return 0;
+				}
+			}
+			(*added)++;
+			ownsdesinfo.SetProcessedLocation(true);
+		}
+	}
+	if (dophone)
+	{
+		if (!ownsdesinfo.ProcessedPhone())
+		{
+			data = ownsdesinfo.GetPhone(&amp;datalen);
+			if ((status = rtcpcomppack-&gt;AddSDESNormalItem(RTCPSDESPacket::PHONE,data,datalen)) &lt; 0)
+			{
+				if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+				{
+					*full = true;
+					return 0;
+				}
+			}
+			(*added)++;
+			ownsdesinfo.SetProcessedPhone(true);
+		}
+	}
+	if (dotool)
+	{
+		if (!ownsdesinfo.ProcessedTool())
+		{
+			data = ownsdesinfo.GetTool(&amp;datalen);
+			if ((status = rtcpcomppack-&gt;AddSDESNormalItem(RTCPSDESPacket::TOOL,data,datalen)) &lt; 0)
+			{
+				if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+				{
+					*full = true;
+					return 0;
+				}
+			}
+			(*added)++;
+			ownsdesinfo.SetProcessedTool(true);
+		}
+	}
+	if (donote)
+	{
+		if (!ownsdesinfo.ProcessedNote())
+		{
+			data = ownsdesinfo.GetNote(&amp;datalen);
+			if ((status = rtcpcomppack-&gt;AddSDESNormalItem(RTCPSDESPacket::NOTE,data,datalen)) &lt; 0)
+			{
+				if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+				{
+					*full = true;
+					return 0;
+				}
+			}
+			(*added)++;
+			ownsdesinfo.SetProcessedNote(true);
+		}
+	}
+
+	*processedall = true;
+	return 0;
+}
+
+void RTCPPacketBuilder::ClearAllSDESFlags()
+{
+	ownsdesinfo.ClearFlags();
+}
+	
+int RTCPPacketBuilder::BuildBYEPacket(RTCPCompoundPacket **pack,const void *reason,size_t reasonlength,bool useSRifpossible)
+{
+	if (!init)
+		return ERR_RTP_RTCPPACKETBUILDER_NOTINIT;
+
+	RTCPCompoundPacketBuilder *rtcpcomppack;
+	int status;
+	
+	if (reasonlength &gt; 255)
+		reasonlength = 255;
+	
+	*pack = 0;
+	
+	rtcpcomppack = new RTCPCompoundPacketBuilder();
+	if (rtcpcomppack == 0)
+		return ERR_RTP_OUTOFMEM;
+	
+	if ((status = rtcpcomppack-&gt;InitBuild(maxpacketsize)) &lt; 0)
+	{
+		delete rtcpcomppack;
+		return status;
+	}
+	
+	u_int32_t ssrc = rtppacketbuilder.GetSSRC();
+	bool useSR = false;
+	
+	if (useSRifpossible)
+	{
+		RTPSourceData *srcdat;
+		
+		if ((srcdat = sources.GetOwnSourceInfo()) != 0)
+		{
+			if (srcdat-&gt;IsSender())
+				useSR = true;
+		}
+	}
+			
+	if (useSR)
+	{
+		RTPTime curtime = RTPTime::CurrentTime();
+		RTPTime rtppacktime = rtppacketbuilder.GetPacketTime();
+		u_int32_t rtppacktimestamp = rtppacketbuilder.GetPacketTimestamp();
+		u_int32_t packcount = rtppacketbuilder.GetPacketCount();
+		u_int32_t octetcount = rtppacketbuilder.GetPayloadOctetCount();
+		RTPTime diff = curtime;
+		diff -= rtppacktime;
+		
+		u_int32_t tsdiff = (u_int32_t)((diff.GetDouble()/timestampunit)+0.5);
+		u_int32_t rtptimestamp = rtppacktimestamp+tsdiff;
+		RTPNTPTime ntptimestamp = curtime.GetNTPTime();
+
+		if ((status = rtcpcomppack-&gt;StartSenderReport(ssrc,ntptimestamp,rtptimestamp,packcount,octetcount)) &lt; 0)
+		{
+			delete rtcpcomppack;
+			if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+				return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+			return status;
+		}
+	}
+	else
+	{
+		if ((status = rtcpcomppack-&gt;StartReceiverReport(ssrc)) &lt; 0)
+		{
+			delete rtcpcomppack;
+			if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+				return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+			return status;
+		}
+	}
+
+	u_int8_t *owncname;
+	size_t owncnamelen;
+
+	owncname = ownsdesinfo.GetCNAME(&amp;owncnamelen);
+
+	if ((status = rtcpcomppack-&gt;AddSDESSource(ssrc)) &lt; 0)
+	{
+		delete rtcpcomppack;
+		if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+			return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+		return status;
+	}
+	if ((status = rtcpcomppack-&gt;AddSDESNormalItem(RTCPSDESPacket::CNAME,owncname,owncnamelen)) &lt; 0)
+	{
+		delete rtcpcomppack;
+		if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+			return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+		return status;
+	}
+
+	u_int32_t ssrcs[1];
+
+	ssrcs[0] = ssrc;
+	
+	if ((status = rtcpcomppack-&gt;AddBYEPacket(ssrcs,1,(const u_int8_t *)reason,reasonlength)) &lt; 0)
+	{
+		delete rtcpcomppack;
+		if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+			return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+		return status;
+	}
+	
+	if ((status = rtcpcomppack-&gt;EndBuild()) &lt; 0)
+	{
+		delete rtcpcomppack;
+		return status;
+	}
+
+	*pack = rtcpcomppack;
+	return 0;
+}
+

Added: konference/src/rtp/jrtplib/rtcppacketbuilder.h
===================================================================
--- konference/src/rtp/jrtplib/rtcppacketbuilder.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcppacketbuilder.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,122 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPPACKETBUILDER_H
+
+#define RTCPPACKETBUILDER_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtptypes.h&quot;
+#include &quot;rtperrors.h&quot;
+#include &quot;rtcpsdesinfo.h&quot;
+#include &quot;rtptimeutilities.h&quot;
+
+class RTPSources;
+class RTPPacketBuilder;
+class RTCPScheduler;
+class RTCPCompoundPacket;
+class RTCPCompoundPacketBuilder;
+
+class RTCPPacketBuilder
+{
+public:
+	RTCPPacketBuilder(RTPSources &amp;sources,RTPPacketBuilder &amp;rtppackbuilder);
+	~RTCPPacketBuilder();
+
+	int Init(size_t maxpacksize,double timestampunit,const void *cname,size_t cnamelen);
+	void Destroy();
+
+	int SetTimestampUnit(double tsunit)						{ if (!init) return ERR_RTP_RTCPPACKETBUILDER_NOTINIT; if (tsunit &lt; 0) return ERR_RTP_RTCPPACKETBUILDER_ILLEGALTIMESTAMPUNIT; timestampunit = tsunit; return 0; }
+	int SetMaximumPacketSize(size_t maxpacksize)					{ if (!init) return ERR_RTP_RTCPPACKETBUILDER_NOTINIT; if (maxpacksize &lt; RTP_MINPACKETSIZE) return ERR_RTP_RTCPPACKETBUILDER_ILLEGALMAXPACKSIZE; maxpacketsize = maxpacksize; return 0; }
+	
+	int BuildNextPacket(RTCPCompoundPacket **pack);
+	int BuildBYEPacket(RTCPCompoundPacket **pack,const void *reason,size_t reasonlength,bool useSRifpossible = true);
+
+	void SetNameInterval(int count)							{ if (!init) return; interval_name = count; }
+	void SetEMailInterval(int count)						{ if (!init) return; interval_email = count; }
+	void SetLocationInterval(int count)						{ if (!init) return; interval_location = count; }
+	void SetPhoneInterval(int count)						{ if (!init) return; interval_phone = count; }
+	void SetToolInterval(int count)							{ if (!init) return; interval_tool = count; }
+	void SetNoteInterval(int count)							{ if (!init) return; interval_note = count; }
+	int SetLocalName(const void *s,size_t len)					{ if (!init) return ERR_RTP_RTCPPACKETBUILDER_NOTINIT; return ownsdesinfo.SetName((const u_int8_t *)s,len); }
+	int SetLocalEMail(const void *s,size_t len)					{ if (!init) return ERR_RTP_RTCPPACKETBUILDER_NOTINIT; return ownsdesinfo.SetEMail((const u_int8_t *)s,len); }
+	int SetLocalLocation(const void *s,size_t len)					{ if (!init) return ERR_RTP_RTCPPACKETBUILDER_NOTINIT; return ownsdesinfo.SetLocation((const u_int8_t *)s,len); }
+	int SetLocalPhone(const void *s,size_t len)					{ if (!init) return ERR_RTP_RTCPPACKETBUILDER_NOTINIT; return ownsdesinfo.SetPhone((const u_int8_t *)s,len); }
+	int SetLocalTool(const void *s,size_t len)					{ if (!init) return ERR_RTP_RTCPPACKETBUILDER_NOTINIT; return ownsdesinfo.SetTool((const u_int8_t *)s,len); }
+	int SetLocalNote(const void *s,size_t len)					{ if (!init) return ERR_RTP_RTCPPACKETBUILDER_NOTINIT; return ownsdesinfo.SetNote((const u_int8_t *)s,len); }
+private:
+	void ClearAllSourceFlags();
+	int FillInReportBlocks(RTCPCompoundPacketBuilder *pack,const RTPTime &amp;curtime,int maxcount,bool *full,int *added,int *skipped,bool *atendoflist);
+	int FillInSDES(RTCPCompoundPacketBuilder *pack,bool *full,bool *processedall,int *added);
+	void ClearAllSDESFlags();
+	
+	RTPSources &sources;
+	RTPPacketBuilder &rtppacketbuilder;
+	
+	bool init;
+	size_t maxpacketsize;
+	double timestampunit;
+	bool firstpacket;
+	RTPTime prevbuildtime;
+
+	class RTCPSDESInfoInternal : public RTCPSDESInfo
+	{
+	public:
+		RTCPSDESInfoInternal() 			{ ClearFlags(); }
+		void ClearFlags()			{ pname = false; pemail = false; plocation = false; pphone = false; ptool = false; pnote = false; }
+		bool ProcessedName() const 		{ return pname; }
+		bool ProcessedEMail() const		{ return pemail; }
+		bool ProcessedLocation() const		{ return plocation; }
+		bool ProcessedPhone() const		{ return pphone; }
+		bool ProcessedTool() const		{ return ptool; }
+		bool ProcessedNote() const		{ return pnote; }
+		void SetProcessedName(bool v)		{ pname = v; }
+		void SetProcessedEMail(bool v)		{ pemail = v; }
+		void SetProcessedLocation(bool v)	{ plocation  = v; }
+		void SetProcessedPhone(bool v)		{ pphone = v; }
+		void SetProcessedTool(bool v)		{ ptool = v; }
+		void SetProcessedNote(bool v)		{ pnote = v; }
+	private:
+		bool pname,pemail,plocation,pphone,ptool,pnote;
+	};
+	
+	RTCPSDESInfoInternal ownsdesinfo;
+	int interval_name,interval_email,interval_location;
+	int interval_phone,interval_tool,interval_note;
+	bool doname,doemail,doloc,dophone,dotool,donote;
+	bool processingsdes;
+
+	int sdesbuildcount;
+};
+
+#endif // RTCPPACKETBUILDER_H
+

Added: konference/src/rtp/jrtplib/rtcprrpacket.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcprrpacket.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcprrpacket.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,94 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtcprrpacket.h&quot;
+#ifdef RTPDEBUG
+	#include &lt;iostream&gt;
+#endif // RTPDEBUG
+
+#include &quot;rtpdebug.h&quot;
+
+RTCPRRPacket::RTCPRRPacket(u_int8_t *data,size_t datalength)
+	: RTCPPacket(RR,data,datalength)
+{
+	knownformat = false;
+	
+	RTCPCommonHeader *hdr;
+	size_t len = datalength;
+	size_t expectedlength;
+	
+	hdr = (RTCPCommonHeader *)data;
+	if (hdr-&gt;padding)
+	{
+		u_int8_t padcount = data[datalength-1];
+		if ((padcount &amp; 0x03) != 0) // not a multiple of four! (see rfc 3550 p 37)
+			return;
+		if (((size_t)padcount) &gt;= len)
+			return;
+		len -= (size_t)padcount;
+	}
+
+	expectedlength = sizeof(RTCPCommonHeader)+sizeof(u_int32_t);
+	expectedlength += sizeof(RTCPReceiverReport)*((int)hdr-&gt;count);
+
+	if (expectedlength != len)
+		return;
+	
+	knownformat = true;
+}
+
+#ifdef RTPDEBUG
+void RTCPRRPacket::Dump()
+{
+	RTCPPacket::Dump();
+	if (!IsKnownFormat())
+		std::cout &lt;&lt; &quot;    Unknown format&quot; &lt;&lt; std::endl;
+	else
+	{
+		int num = GetReceptionReportCount();
+		int i;
+
+		std::cout &lt;&lt; &quot;    SSRC of sender:     &quot; &lt;&lt; GetSenderSSRC() &lt;&lt; std::endl;
+		for (i = 0 ; i &lt; num ; i++)
+		{
+			std::cout &lt;&lt; &quot;    Report block &quot; &lt;&lt; i &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        SSRC:           &quot; &lt;&lt; GetSSRC(i) &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Fraction lost:  &quot; &lt;&lt; (u_int32_t)GetFractionLost(i) &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Packets lost:   &quot; &lt;&lt; GetLostPacketCount(i) &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Seq. nr.:       &quot; &lt;&lt; GetExtendedHighestSequenceNumber(i) &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Jitter:         &quot; &lt;&lt; GetJitter(i) &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        LSR:            &quot; &lt;&lt; GetLSR(i) &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        DLSR:           &quot; &lt;&lt; GetDLSR(i) &lt;&lt; std::endl;
+		}
+	}	
+}
+#endif // RTPDEBUG

Added: konference/src/rtp/jrtplib/rtcprrpacket.h
===================================================================
--- konference/src/rtp/jrtplib/rtcprrpacket.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcprrpacket.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,158 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPRRPACKET_H
+
+#define RTCPRRPACKET_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtcppacket.h&quot;
+#include &quot;rtpstructs.h&quot;
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include &lt;netinet/in.h&gt;
+#endif // WIN32
+
+class RTCPCompoundPacket;
+
+class RTCPRRPacket : public RTCPPacket
+{
+public:
+	RTCPRRPacket(u_int8_t *data,size_t datalen);
+	~RTCPRRPacket()								{ }
+	
+	// Sender info
+	
+	u_int32_t GetSenderSSRC() const;
+	
+	// Reportblocks
+
+	int GetReceptionReportCount() const;
+	// Note: the validity of index is NOT checked!
+	u_int32_t GetSSRC(int index) const;
+	u_int8_t GetFractionLost(int index) const;
+	int32_t GetLostPacketCount(int index) const;
+	u_int32_t GetExtendedHighestSequenceNumber(int index) const;
+	u_int32_t GetJitter(int index) const;
+	u_int32_t GetLSR(int index) const;
+	u_int32_t GetDLSR(int index) const;
+
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+private:
+	RTCPReceiverReport *GotoReport(int index) const;
+};
+
+inline u_int32_t RTCPRRPacket::GetSenderSSRC() const
+{
+	if (!knownformat)
+		return 0;
+	
+	u_int32_t *ssrcptr = (u_int32_t *)(data+sizeof(RTCPCommonHeader));
+	return ntohl(*ssrcptr);
+}
+inline int RTCPRRPacket::GetReceptionReportCount() const
+{
+	if (!knownformat)
+		return 0;
+	RTCPCommonHeader *hdr = (RTCPCommonHeader *)data;
+	return ((int)hdr-&gt;count);
+}
+
+inline RTCPReceiverReport *RTCPRRPacket::GotoReport(int index) const
+{
+	RTCPReceiverReport *r = (RTCPReceiverReport *)(data+sizeof(RTCPCommonHeader)+sizeof(u_int32_t)+index*sizeof(RTCPReceiverReport));
+	return r;
+}
+
+inline u_int32_t RTCPRRPacket::GetSSRC(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return ntohl(r-&gt;ssrc);
+}
+
+inline u_int8_t RTCPRRPacket::GetFractionLost(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return r-&gt;fractionlost;
+}
+
+inline int32_t RTCPRRPacket::GetLostPacketCount(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	u_int32_t count = ((u_int32_t)r-&gt;packetslost[2])|(((u_int32_t)r-&gt;packetslost[1])&lt;&lt;8)|(((u_int32_t)r-&gt;packetslost[0])&lt;&lt;16);
+	if ((count&amp;0x00800000) != 0) // test for negative number
+		count |= 0xFF000000;
+	int32_t *count2 = (int32_t *)(&amp;count);
+	return (*count2);
+}
+
+inline u_int32_t RTCPRRPacket::GetExtendedHighestSequenceNumber(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return ntohl(r-&gt;exthighseqnr);
+}
+
+inline u_int32_t RTCPRRPacket::GetJitter(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return ntohl(r-&gt;jitter);
+}
+
+inline u_int32_t RTCPRRPacket::GetLSR(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return ntohl(r-&gt;lsr);
+}
+
+inline u_int32_t RTCPRRPacket::GetDLSR(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return ntohl(r-&gt;dlsr);
+}
+
+#endif // RTCPRRPACKET_H
+

Added: konference/src/rtp/jrtplib/rtcpscheduler.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcpscheduler.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpscheduler.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,381 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtcpscheduler.h&quot;
+#include &quot;rtpsources.h&quot;
+#include &quot;rtpdefines.h&quot;
+#include &quot;rtcppacket.h&quot;
+#include &quot;rtppacket.h&quot;
+#include &quot;rtcpcompoundpacket.h&quot;
+#include &quot;rtpsourcedata.h&quot;
+
+#include &quot;rtpdebug.h&quot;
+
+#define RTCPSCHED_MININTERVAL						1.0
+
+RTCPSchedulerParams::RTCPSchedulerParams() : mininterval(RTCP_DEFAULTMININTERVAL)
+{
+	bandwidth = 1000; // TODO What is a good value here? 
+	senderfraction = RTCP_DEFAULTSENDERFRACTION;
+	usehalfatstartup = RTCP_DEFAULTHALFATSTARTUP;
+	immediatebye = RTCP_DEFAULTIMMEDIATEBYE;
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	timeinit.Dummy();
+#endif // WIN32 || _WIN32_WCE
+}
+
+RTCPSchedulerParams::~RTCPSchedulerParams()
+{
+}
+
+int RTCPSchedulerParams::SetRTCPBandwidth(double bw)
+{
+	if (bw &lt; 0.0)
+		return ERR_RTP_SCHEDPARAMS_INVALIDBANDWIDTH;
+	bandwidth = bw;
+	return 0;
+}
+
+int RTCPSchedulerParams::SetSenderBandwidthFraction(double fraction)
+{
+	if (fraction &lt; 0.0 || fraction &gt; 1.0)
+		return ERR_RTP_SCHEDPARAMS_BADFRACTION;
+	senderfraction = fraction;
+	return 0;
+}
+
+int RTCPSchedulerParams::SetMinimumTransmissionInterval(const RTPTime &amp;t)
+{
+	double t2 = t.GetDouble();
+
+	if (t2 &lt; RTCPSCHED_MININTERVAL)
+		return ERR_RTP_SCHEDPARAMS_BADMINIMUMINTERVAL;
+
+	mininterval = t;
+	return 0;
+}
+
+RTCPScheduler::RTCPScheduler(RTPSources &amp;s) : sources(s),nextrtcptime(0,0),prevrtcptime(0,0)
+{
+	Reset();
+}
+
+RTCPScheduler::~RTCPScheduler()
+{
+}
+
+void RTCPScheduler::Reset()
+{
+	headeroverhead = 0; // user has to set this to an appropriate value
+	hassentrtcp = false;
+	firstcall = true;
+	avgrtcppacksize = 1000; // TODO: what is a good value for this?
+	byescheduled = false;
+	sendbyenow = false;
+}
+
+void RTCPScheduler::AnalyseIncoming(RTCPCompoundPacket &amp;rtcpcomppack)
+{
+	bool isbye = false;
+	RTCPPacket *p;
+	
+	rtcpcomppack.GotoFirstPacket();
+	while (!isbye &amp;&amp; ((p = rtcpcomppack.GetNextPacket()) != 0))
+	{
+		if (p-&gt;GetPacketType() == RTCPPacket::BYE)
+			isbye = true;
+	}
+	
+	if (!isbye)
+	{
+		size_t packsize = headeroverhead+rtcpcomppack.GetCompoundPacketLength();
+		avgrtcppacksize = (size_t)((1.0/16.0)*((double)packsize)+(15.0/16.0)*((double)avgrtcppacksize));
+	}
+	else
+	{
+		if (byescheduled)
+		{
+			size_t packsize = headeroverhead+rtcpcomppack.GetCompoundPacketLength();
+			avgbyepacketsize = (size_t)((1.0/16.0)*((double)packsize)+(15.0/16.0)*((double)avgbyepacketsize));
+			byemembers++;
+		}
+	}
+}
+
+void RTCPScheduler::AnalyseOutgoing(RTCPCompoundPacket &amp;rtcpcomppack)
+{
+	bool isbye = false;
+	RTCPPacket *p;
+	
+	rtcpcomppack.GotoFirstPacket();
+	while (!isbye &amp;&amp; ((p = rtcpcomppack.GetNextPacket()) != 0))
+	{
+		if (p-&gt;GetPacketType() == RTCPPacket::BYE)
+			isbye = true;
+	}
+	
+	if (!isbye)
+	{
+		size_t packsize = headeroverhead+rtcpcomppack.GetCompoundPacketLength();
+		avgrtcppacksize = (size_t)((1.0/16.0)*((double)packsize)+(15.0/16.0)*((double)avgrtcppacksize));
+	}
+
+	hassentrtcp = true;
+}
+
+RTPTime RTCPScheduler::GetTransmissionDelay()
+{
+	if (firstcall)
+	{
+		firstcall = false;
+		prevrtcptime = RTPTime::CurrentTime();
+		pmembers = sources.GetActiveMemberCount();
+		CalculateNextRTCPTime();
+	}
+	
+	RTPTime curtime = RTPTime::CurrentTime();
+
+	if (curtime &gt; nextrtcptime) // packet should be sent
+		return RTPTime(0,0);
+
+	RTPTime diff = nextrtcptime;
+	diff -= curtime;
+	
+	return diff;
+}
+
+bool RTCPScheduler::IsTime()
+{
+	if (firstcall)
+	{
+		firstcall = false;
+		prevrtcptime = RTPTime::CurrentTime();
+		pmembers = sources.GetActiveMemberCount();
+		CalculateNextRTCPTime();
+		return false;
+	}
+
+	RTPTime currenttime = RTPTime::CurrentTime();
+
+	if (currenttime &lt; nextrtcptime) // timer has not yet expired
+		return false;
+
+	RTPTime checktime(0,0);
+	
+	if (!byescheduled)
+	{
+		bool aresender = false;
+		RTPSourceData *srcdat;
+		
+		if ((srcdat = sources.GetOwnSourceInfo()) != 0)
+			aresender = srcdat-&gt;IsSender();
+		
+		checktime = CalculateTransmissionInterval(aresender);
+	}
+	else
+		checktime = CalculateBYETransmissionInterval();
+	
+	checktime += prevrtcptime;
+	
+	if (checktime &lt;= currenttime) // Okay
+	{
+		byescheduled = false;
+		prevrtcptime = currenttime;
+		pmembers = sources.GetActiveMemberCount();
+		CalculateNextRTCPTime();
+		return true;
+	}
+	
+	nextrtcptime = checktime;
+	pmembers = sources.GetActiveMemberCount();
+	
+	return false;
+}
+
+void RTCPScheduler::CalculateNextRTCPTime()
+{
+	bool aresender = false;
+	RTPSourceData *srcdat;
+	
+	if ((srcdat = sources.GetOwnSourceInfo()) != 0)
+		aresender = srcdat-&gt;IsSender();
+	
+	nextrtcptime = RTPTime::CurrentTime();	
+	nextrtcptime += CalculateTransmissionInterval(aresender);
+}
+
+RTPTime RTCPScheduler::CalculateDeterministicInterval(bool sender /* = false */)
+{
+	int numsenders = sources.GetSenderCount();
+	int numtotal = sources.GetActiveMemberCount();
+
+	// Try to avoid division by zero:
+	if (numtotal == 0)
+		numtotal++;
+
+	double sfraction = ((double)numsenders)/((double)numtotal);
+	double C,n;
+
+	if (sfraction &lt;= schedparams.GetSenderBandwidthFraction())
+	{
+		if (sender)
+		{
+			C = ((double)avgrtcppacksize)/(schedparams.GetSenderBandwidthFraction()*schedparams.GetRTCPBandwidth());
+			n = (double)numsenders;
+		}
+		else
+		{
+			C = ((double)avgrtcppacksize)/((1.0-schedparams.GetSenderBandwidthFraction())*schedparams.GetRTCPBandwidth());
+			n = (double)(numtotal-numsenders);
+		}
+	}
+	else
+	{
+		C = ((double)avgrtcppacksize)/schedparams.GetRTCPBandwidth();
+		n = (double)numtotal;
+	}
+	
+	RTPTime Tmin = schedparams.GetMinimumTransmissionInterval();
+	double tmin = Tmin.GetDouble();
+	
+	if (!hassentrtcp &amp;&amp; schedparams.GetUseHalfAtStartup())
+		tmin /= 2.0;
+
+	double ntimesC = n*C;
+	double Td = (tmin&gt;ntimesC)?tmin:ntimesC;
+
+	return RTPTime(Td);
+}
+
+RTPTime RTCPScheduler::CalculateTransmissionInterval(bool sender)
+{
+	RTPTime Td = CalculateDeterministicInterval(sender);
+	double td,mul,T;
+
+	td = Td.GetDouble();
+	mul = rtprand.GetRandomDouble()+0.5; // gives random value between 0.5 and 1.5
+	T = (td*mul)/1.21828; // see RFC 3550 p 30
+
+	return RTPTime(T);
+}
+
+void RTCPScheduler::PerformReverseReconsideration()
+{
+	if (firstcall)
+		return;
+	
+	double diff1,diff2;
+	int members = sources.GetActiveMemberCount();
+	
+	RTPTime tc = RTPTime::CurrentTime();
+	RTPTime tn_min_tc = nextrtcptime;
+	tn_min_tc -= tc;
+	RTPTime tc_min_tp = tc;
+	tc_min_tp -= prevrtcptime;
+	
+	if (pmembers == 0) // avoid division by zero
+		pmembers++;
+	
+	diff1 = (((double)members)/((double)pmembers))*tn_min_tc.GetDouble();
+	diff2 = (((double)members)/((double)pmembers))*tc_min_tp.GetDouble();
+
+	nextrtcptime = tc;
+	prevrtcptime = tc;
+	nextrtcptime += RTPTime(diff1);
+	prevrtcptime -= RTPTime(diff2);
+	
+	pmembers = members;
+}
+
+void RTCPScheduler::ScheduleBYEPacket(size_t packetsize)
+{
+	if (byescheduled)
+		return;
+	
+	if (firstcall)
+	{
+		firstcall = false;
+		pmembers = sources.GetActiveMemberCount();
+	}
+
+	byescheduled = true;
+	avgbyepacketsize = packetsize+headeroverhead;
+
+	// For now, we will always use the BYE backoff algorithm as described in rfc 3550 p 33
+	
+	byemembers = 1;
+	pbyemembers = 1;
+
+	if (schedparams.GetRequestImmediateBYE() &amp;&amp; sources.GetActiveMemberCount() &lt; 50) // p 34 (top)
+		sendbyenow = true;
+	else
+		sendbyenow = false;
+	
+	prevrtcptime = RTPTime::CurrentTime();
+	nextrtcptime = prevrtcptime;
+	nextrtcptime += CalculateBYETransmissionInterval();
+}
+
+void RTCPScheduler::ActiveMemberDecrease()
+{
+	if (sources.GetActiveMemberCount() &lt; pmembers)
+		PerformReverseReconsideration();
+}
+
+RTPTime RTCPScheduler::CalculateBYETransmissionInterval()
+{
+	if (!byescheduled)
+		return RTPTime(0,0);
+	
+	if (sendbyenow)
+		return RTPTime(0,0);
+	
+	double C,n;
+
+	C = ((double)avgbyepacketsize)/((1.0-schedparams.GetSenderBandwidthFraction())*schedparams.GetRTCPBandwidth());
+	n = (double)byemembers;
+	
+	RTPTime Tmin = schedparams.GetMinimumTransmissionInterval();
+	double tmin = Tmin.GetDouble();
+	
+	if (schedparams.GetUseHalfAtStartup())
+		tmin /= 2.0;
+
+	double ntimesC = n*C;
+	double Td = (tmin&gt;ntimesC)?tmin:ntimesC;
+
+	double mul = rtprand.GetRandomDouble()+0.5; // gives random value between 0.5 and 1.5
+	double T = (Td*mul)/1.21828; // see RFC 3550 p 30
+	
+	return RTPTime(T);
+}
+

Added: konference/src/rtp/jrtplib/rtcpscheduler.h
===================================================================
--- konference/src/rtp/jrtplib/rtcpscheduler.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpscheduler.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,122 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPSCHEDULER_H
+
+#define RTCPSCHEDULER_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtptimeutilities.h&quot;
+#include &quot;rtprandom.h&quot;
+
+class RTCPCompoundPacket;
+class RTPPacket;
+class RTPSources;
+
+class RTCPSchedulerParams
+{
+public:
+	RTCPSchedulerParams();
+	~RTCPSchedulerParams();
+	int SetRTCPBandwidth(double bw); // bandwidth is in bytes per second
+	double GetRTCPBandwidth() const							{ return bandwidth; }
+	int SetSenderBandwidthFraction(double fraction);
+	double GetSenderBandwidthFraction() const					{ return senderfraction; }
+	int SetMinimumTransmissionInterval(const RTPTime &amp;t);
+	RTPTime GetMinimumTransmissionInterval() const					{ return mininterval; }
+	void SetUseHalfAtStartup(bool usehalf)						{ usehalfatstartup = usehalf; }
+	bool GetUseHalfAtStartup() const						{ return usehalfatstartup; }
+	void SetRequestImmediateBYE(bool v)						{ immediatebye = v; }
+	bool GetRequestImmediateBYE() const						{ return immediatebye; }	
+private:
+	double bandwidth;
+	double senderfraction;
+	RTPTime mininterval;
+	bool usehalfatstartup;
+	bool immediatebye;
+};
+
+class RTCPScheduler
+{
+public:
+	RTCPScheduler(RTPSources &amp;sources);
+	~RTCPScheduler();
+	void Reset();
+
+	void SetParameters(const RTCPSchedulerParams &amp;params)						{ schedparams = params; }
+	RTCPSchedulerParams GetParameters() const							{ return schedparams; }
+
+	void SetHeaderOverhead(size_t numbytes)								{ headeroverhead = numbytes; }
+	size_t GetHeaderOverhead() const								{ return headeroverhead; }
+
+	void AnalyseIncoming(RTCPCompoundPacket &amp;rtcpcomppack);
+	void AnalyseOutgoing(RTCPCompoundPacket &amp;rtcpcomppack);
+
+	// is to be called when a source times out or when a bye packet was received
+	void ActiveMemberDecrease();
+	void ScheduleBYEPacket(size_t packetsize);
+
+	RTPTime GetTransmissionDelay();
+	
+	// Returns true is it is time to send a packet and then recalculates the next rtcp time
+	// So, if the function would be called immediately after it returned true, it would then
+	// return false
+	bool IsTime();
+
+	RTPTime CalculateDeterministicInterval(bool sender = false);
+private:
+	void CalculateNextRTCPTime();
+	void PerformReverseReconsideration();
+	RTPTime CalculateBYETransmissionInterval();
+	RTPTime CalculateTransmissionInterval(bool sender);
+	
+	RTPSources &sources;
+	RTCPSchedulerParams schedparams;
+	size_t headeroverhead;
+	size_t avgrtcppacksize;
+	bool hassentrtcp;
+	bool firstcall;
+	RTPTime nextrtcptime;
+	RTPTime prevrtcptime;
+	int pmembers;
+
+	// for BYE packet scheduling
+	bool byescheduled;
+	int byemembers,pbyemembers;
+	size_t avgbyepacketsize;
+	bool sendbyenow;
+
+	RTPRandom rtprand;
+};
+
+#endif // RTCPSCHEDULER_H
+

Added: konference/src/rtp/jrtplib/rtcpsdesinfo.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcpsdesinfo.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpsdesinfo.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,177 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtcpsdesinfo.h&quot;
+
+#include &quot;rtpdebug.h&quot;
+
+void RTCPSDESInfo::Clear()
+{
+#ifdef RTP_SUPPORT_SDESPRIV
+	std::list&lt;SDESPrivateItem *&gt;::const_iterator it;
+
+	for (it = privitems.begin() ; it != privitems.end() ; ++it)
+		delete *it;
+	privitems.clear();
+#endif // RTP_SUPPORT_SDESPRIV
+}
+
+#ifdef RTP_SUPPORT_SDESPRIV
+int RTCPSDESInfo::SetPrivateValue(const u_int8_t *prefix,size_t prefixlen,const u_int8_t *value,size_t valuelen)
+{
+	std::list&lt;SDESPrivateItem *&gt;::const_iterator it;
+	bool found;
+	
+	found = false;
+	it = privitems.begin();
+	while (!found &amp;&amp; it != privitems.end())
+	{
+		u_int8_t *p;
+		size_t l;
+		
+		p = (*it)-&gt;GetPrefix(&amp;l);
+		if (l == prefixlen)
+		{
+			if (l &lt;= 0)
+				found = true;
+			else if (memcmp(prefix,p,l) == 0)
+				found = true;
+			else
+				++it;
+		}
+		else
+			++it;
+	}
+	
+	SDESPrivateItem *item;
+	
+	if (found) // replace the value for this entry
+		item = *it;
+	else // no entry for this prefix found... add it
+	{
+		if (privitems.size() &gt;= RTP_MAXPRIVITEMS) // too many items present, just ignore it
+			return ERR_RTP_SDES_MAXPRIVITEMS;
+		
+		int status;
+		
+		item = new SDESPrivateItem();
+		if (item == 0)
+			return ERR_RTP_OUTOFMEM;
+		if ((status = item-&gt;SetPrefix(prefix,prefixlen)) &lt; 0)
+		{
+			delete item;
+			return status;
+		}
+		privitems.push_front(item);
+	}
+	return item-&gt;SetInfo(value,valuelen);
+}
+
+int RTCPSDESInfo::DeletePrivatePrefix(const u_int8_t *prefix,size_t prefixlen)
+{
+	std::list&lt;SDESPrivateItem *&gt;::iterator it;
+	bool found;
+	
+	found = false;
+	it = privitems.begin();
+	while (!found &amp;&amp; it != privitems.end())
+	{
+		u_int8_t *p;
+		size_t l;
+		
+		p = (*it)-&gt;GetPrefix(&amp;l);
+		if (l == prefixlen)
+		{
+			if (l &lt;= 0)
+				found = true;
+			else if (memcmp(prefix,p,l) == 0)
+				found = true;
+			else
+				++it;
+		}
+		else
+			++it;
+	}
+	if (!found)
+		return ERR_RTP_SDES_PREFIXNOTFOUND;
+	
+	delete (*it);
+	privitems.erase(it);
+	return 0;
+}
+
+void RTCPSDESInfo::GotoFirstPrivateValue()
+{
+	curitem = privitems.begin();
+}
+
+bool RTCPSDESInfo::GetNextPrivateValue(u_int8_t **prefix,size_t *prefixlen,u_int8_t **value,size_t *valuelen)
+{
+	if (curitem == privitems.end())
+		return false;
+	*prefix = (*curitem)-&gt;GetPrefix(prefixlen);
+	*value = (*curitem)-&gt;GetInfo(valuelen);
+	++curitem;
+	return true;
+}
+
+bool RTCPSDESInfo::GetPrivateValue(const u_int8_t *prefix,size_t prefixlen,u_int8_t **value,size_t *valuelen) const
+{
+	std::list&lt;SDESPrivateItem *&gt;::const_iterator it;
+	bool found;
+	
+	found = false;
+	it = privitems.begin();
+	while (!found &amp;&amp; it != privitems.end())
+	{
+		u_int8_t *p;
+		size_t l;
+		
+		p = (*it)-&gt;GetPrefix(&amp;l);
+		if (l == prefixlen)
+		{
+			if (l &lt;= 0)
+				found = true;
+			else if (memcmp(prefix,p,l) == 0)
+				found = true;
+			else
+				++it;
+		}
+		else
+			++it;
+	}
+	if (found)
+		*value = (*it)-&gt;GetInfo(valuelen);
+	return found;
+}
+#endif // RTP_SUPPORT_SDESPRIV
+

Added: konference/src/rtp/jrtplib/rtcpsdesinfo.h
===================================================================
--- konference/src/rtp/jrtplib/rtcpsdesinfo.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpsdesinfo.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,138 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPSDESINFO_H
+
+#define RTCPSDESINFO_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtperrors.h&quot;
+#include &quot;rtpdefines.h&quot;
+#include &quot;rtptypes.h&quot;
+#include &lt;string.h&gt;
+#include &lt;list&gt;
+
+class RTCPSDESInfo
+{
+public:
+	RTCPSDESInfo()								{ }
+	virtual ~RTCPSDESInfo()							{ Clear(); }
+	void Clear();
+
+	int SetCNAME(const u_int8_t *s,size_t l)				{ return SetNonPrivateItem(RTCP_SDES_ID_CNAME-1,s,l); }
+	int SetName(const u_int8_t *s,size_t l)					{ return SetNonPrivateItem(RTCP_SDES_ID_NAME-1,s,l); }
+	int SetEMail(const u_int8_t *s,size_t l)				{ return SetNonPrivateItem(RTCP_SDES_ID_EMAIL-1,s,l); }
+	int SetPhone(const u_int8_t *s,size_t l)				{ return SetNonPrivateItem(RTCP_SDES_ID_PHONE-1,s,l); }
+	int SetLocation(const u_int8_t *s,size_t l)				{ return SetNonPrivateItem(RTCP_SDES_ID_LOCATION-1,s,l); }
+	int SetTool(const u_int8_t *s,size_t l)					{ return SetNonPrivateItem(RTCP_SDES_ID_TOOL-1,s,l); }
+	int SetNote(const u_int8_t *s,size_t l)					{ return SetNonPrivateItem(RTCP_SDES_ID_NOTE-1,s,l); }
+
+#ifdef RTP_SUPPORT_SDESPRIV
+	int SetPrivateValue(const u_int8_t *prefix,size_t prefixlen,const u_int8_t *value,size_t valuelen);
+	int DeletePrivatePrefix(const u_int8_t *s,size_t len);
+#endif // RTP_SUPPORT_SDESPRIV
+	
+	u_int8_t *GetCNAME(size_t *len) const					{ return GetNonPrivateItem(RTCP_SDES_ID_CNAME-1,len); }
+	u_int8_t *GetName(size_t *len) const					{ return GetNonPrivateItem(RTCP_SDES_ID_NAME-1,len); }
+	u_int8_t *GetEMail(size_t *len) const					{ return GetNonPrivateItem(RTCP_SDES_ID_EMAIL-1,len); }
+	u_int8_t *GetPhone(size_t *len) const					{ return GetNonPrivateItem(RTCP_SDES_ID_PHONE-1,len); }
+	u_int8_t *GetLocation(size_t *len) const				{ return GetNonPrivateItem(RTCP_SDES_ID_LOCATION-1,len); }
+	u_int8_t *GetTool(size_t *len) const					{ return GetNonPrivateItem(RTCP_SDES_ID_TOOL-1,len); }
+	u_int8_t *GetNote(size_t *len) const 					{ return GetNonPrivateItem(RTCP_SDES_ID_NOTE-1,len); }
+
+#ifdef RTP_SUPPORT_SDESPRIV
+	void GotoFirstPrivateValue();
+	bool GetNextPrivateValue(u_int8_t **prefix,size_t *prefixlen,u_int8_t **value,size_t *valuelen);
+	bool GetPrivateValue(const u_int8_t *prefix,size_t prefixlen,u_int8_t **value,size_t *valuelen) const;
+#endif // RTP_SUPPORT_SDESPRIV
+private:
+	int SetNonPrivateItem(int itemno,const u_int8_t *s,size_t l)		{ if (l &gt; RTCP_SDES_MAXITEMLENGTH) return ERR_RTP_SDES_LENGTHTOOBIG; return nonprivateitems[itemno].SetInfo(s,l); }
+	u_int8_t *GetNonPrivateItem(int itemno,size_t *len) const		{ return nonprivateitems[itemno].GetInfo(len); }
+
+	class SDESItem
+	{
+	public:
+		SDESItem() 							{ str = 0; length = 0; }
+		~SDESItem() 							{ if (str) delete [] str; }
+		u_int8_t *GetInfo(size_t *len) const				{ *len = length; return str; }
+		int SetInfo(const u_int8_t *s,size_t len)			{ return SetString(&amp;str,&amp;length,s,len); }
+	protected:
+		static int SetString(u_int8_t **dest,size_t *destlen,const u_int8_t *s,size_t len)
+		{
+			if (len &lt;= 0)
+			{
+				if (*dest)
+					delete [] (*dest);
+				*dest = 0;
+				*destlen = 0;
+			}
+			else
+			{
+				len = (len&gt;RTCP_SDES_MAXITEMLENGTH)?RTCP_SDES_MAXITEMLENGTH:len;
+				u_int8_t *str2 = new u_int8_t[len];
+				if (str2 == 0)
+					return ERR_RTP_OUTOFMEM;
+				memcpy(str2,s,len);
+				*destlen = len;
+				if (*dest)
+					delete [] (*dest);
+				*dest = str2;
+			}
+			return 0;
+		}
+	private:
+		u_int8_t *str;
+		size_t length;
+	};
+
+	SDESItem nonprivateitems[RTCP_SDES_NUMITEMS_NONPRIVATE];
+
+#ifdef RTP_SUPPORT_SDESPRIV
+	class SDESPrivateItem : public SDESItem
+	{
+	public:
+		SDESPrivateItem()						{ prefixlen = 0; prefix = 0; }
+		~SDESPrivateItem()						{ if (prefix) delete [] prefix; }
+		u_int8_t *GetPrefix(size_t *len) const				{ *len = prefixlen; return prefix; }
+		int SetPrefix(const u_int8_t *s,size_t len)			{ return SetString(&amp;prefix,&amp;prefixlen,s,len); }
+	private:
+		u_int8_t *prefix;
+		size_t prefixlen;
+	};
+
+	std::list&lt;SDESPrivateItem *&gt; privitems;
+	std::list&lt;SDESPrivateItem *&gt;::const_iterator curitem;
+#endif // RTP_SUPPORT_SDESPRIV
+};
+
+#endif // RTCPSDESINFO_H
+

Added: konference/src/rtp/jrtplib/rtcpsdespacket.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcpsdespacket.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpsdespacket.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,230 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtcpsdespacket.h&quot;
+#ifdef RTPDEBUG
+	#include &lt;iostream&gt;
+#endif // RTPDEBUG
+
+#include &quot;rtpdebug.h&quot;
+
+RTCPSDESPacket::RTCPSDESPacket(u_int8_t *data,size_t datalength)
+	: RTCPPacket(SDES,data,datalength)
+{
+	knownformat = false;
+	currentchunk = 0;
+	itemoffset = 0;
+	curchunknum = 0;
+		
+	RTCPCommonHeader *hdr = (RTCPCommonHeader *)data;
+	size_t len = datalength;
+	
+	if (hdr-&gt;padding)
+	{
+		u_int8_t padcount = data[datalength-1];
+		if ((padcount &amp; 0x03) != 0) // not a multiple of four! (see rfc 3550 p 37)
+			return;
+		if (((size_t)padcount) &gt;= len)
+			return;
+		len -= (size_t)padcount;
+	}
+	
+	if (hdr-&gt;count == 0)
+	{
+		if (len != sizeof(RTCPCommonHeader))
+			return;
+	}
+	else
+	{
+		int ssrccount = (int)(hdr-&gt;count);
+		u_int8_t *chunk;
+		int chunkoffset;
+		
+		if (len &lt; sizeof(RTCPCommonHeader))
+			return;
+		
+		len -= sizeof(RTCPCommonHeader);
+		chunk = data+sizeof(RTCPCommonHeader);
+		
+		while ((ssrccount &gt; 0) &amp;&amp; (len &gt; 0))
+		{
+			chunkoffset = 0;
+			
+			if (len &lt; (sizeof(u_int32_t)*2)) // chunk must contain at least a SSRC identifier
+				return;                  // and a (possibly empty) item
+			
+			len -= sizeof(u_int32_t);
+			chunkoffset = sizeof(u_int32_t);
+
+			bool done = false;
+			while (!done)
+			{
+				if (len &lt; 1) // at least a zero byte (end of item list) should be there
+					return;
+				
+				RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(chunk+chunkoffset);
+				if (sdeshdr-&gt;id == 0) // end of item list
+				{
+					len--;
+					chunkoffset++;
+
+					size_t r = (chunkoffset&amp;0x03);
+					if (r != 0)
+					{
+						size_t addoffset = 4-r;
+					
+						if (addoffset &gt; len)
+							return;
+						len -= addoffset;
+						chunkoffset += addoffset;
+					}
+					done = true;
+				}
+				else
+				{
+					if (len &lt; sizeof(RTCPSDESHeader))
+						return;
+					
+					len -= sizeof(RTCPSDESHeader);
+					chunkoffset += sizeof(RTCPSDESHeader);
+					
+					size_t itemlen = (size_t)(sdeshdr-&gt;length);
+					if (itemlen &gt; len)
+						return;
+					
+					len -= itemlen;
+					chunkoffset += itemlen;
+				}		
+			}
+			
+			ssrccount--;
+			chunk += chunkoffset;
+		}
+
+		// check for remaining bytes
+		if (len &gt; 0)
+			return;
+		if (ssrccount &gt; 0)
+			return;
+	}
+
+	knownformat = true;
+}
+
+#ifdef RTPDEBUG
+void RTCPSDESPacket::Dump()
+{
+	RTCPPacket::Dump();
+	if (!IsKnownFormat())
+	{
+		std::cout &lt;&lt; &quot;    Unknown format&quot; &lt;&lt; std::endl;
+		return;
+	}
+	if (!GotoFirstChunk())
+	{
+		std::cout &lt;&lt; &quot;    No chunks present&quot; &lt;&lt; std::endl;
+		return;
+	}
+	
+	do
+	{
+		std::cout &lt;&lt; &quot;    SDES Chunk for SSRC:    &quot; &lt;&lt; GetChunkSSRC() &lt;&lt; std::endl;
+		if (!GotoFirstItem())
+			std::cout &lt;&lt; &quot;        No items found&quot; &lt;&lt; std::endl; 
+		else
+		{
+			do
+			{
+				std::cout &lt;&lt; &quot;        &quot;;
+				switch (GetItemType())
+				{
+				case None:
+					std::cout &lt;&lt; &quot;None    &quot;;
+					break;
+				case CNAME:
+					std::cout &lt;&lt; &quot;CNAME   &quot;;
+					break;
+				case NAME:
+					std::cout &lt;&lt; &quot;NAME    &quot;;
+					break;
+				case EMAIL:
+					std::cout &lt;&lt; &quot;EMAIL   &quot;;
+					break;
+				case PHONE:
+					std::cout &lt;&lt; &quot;PHONE   &quot;;
+					break;
+				case LOC:
+					std::cout &lt;&lt; &quot;LOC     &quot;;
+					break;
+				case TOOL:
+					std::cout &lt;&lt; &quot;TOOL    &quot;;
+					break;
+				case NOTE:
+					std::cout &lt;&lt; &quot;NOTE    &quot;;
+					break;
+				case PRIV:
+					std::cout &lt;&lt; &quot;PRIV    &quot;;
+					break;
+				case Unknown:
+				default:
+					std::cout &lt;&lt; &quot;Unknown &quot;;
+				}
+				
+				std::cout &lt;&lt; &quot;Length: &quot; &lt;&lt; GetItemLength() &lt;&lt; std::endl;
+
+				if (GetItemType() != PRIV)
+				{
+					char str[1024];
+					memcpy(str,GetItemData(),GetItemLength());
+					str[GetItemLength()] = 0;
+					std::cout &lt;&lt; &quot;                Value:  &quot; &lt;&lt; str &lt;&lt; std::endl;
+				}
+#ifdef RTP_SUPPORT_SDESPRIV
+				else // PRIV item
+				{
+					char str[1024];
+					memcpy(str,GetPRIVPrefixData(),GetPRIVPrefixLength());
+					str[GetPRIVPrefixLength()] = 0;
+					std::cout &lt;&lt; &quot;                Prefix: &quot; &lt;&lt; str &lt;&lt; std::endl;
+					std::cout &lt;&lt; &quot;                Length: &quot; &lt;&lt; GetPRIVPrefixLength() &lt;&lt; std::endl;
+					memcpy(str,GetPRIVValueData(),GetPRIVValueLength());
+					str[GetPRIVValueLength()] = 0;
+					std::cout &lt;&lt; &quot;                Value:  &quot; &lt;&lt; str &lt;&lt; std::endl;
+					std::cout &lt;&lt; &quot;                Length: &quot; &lt;&lt; GetPRIVValueLength() &lt;&lt; std::endl;
+				}
+#endif // RTP_SUPPORT_SDESPRIV
+			} while (GotoNextItem());
+		}
+	} while (GotoNextChunk());
+}
+#endif // RTPDEBUG
+

Added: konference/src/rtp/jrtplib/rtcpsdespacket.h
===================================================================
--- konference/src/rtp/jrtplib/rtcpsdespacket.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpsdespacket.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,314 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPSDESPACKET_H
+
+#define RTCPSDESPACKET_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtcppacket.h&quot;
+#include &quot;rtpstructs.h&quot;
+#include &quot;rtpdefines.h&quot;
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include &lt;netinet/in.h&gt;
+#endif // WIN32
+
+class RTCPCompoundPacket;
+
+class RTCPSDESPacket : public RTCPPacket
+{
+public:
+	enum ItemType { None,CNAME,NAME,EMAIL,PHONE,LOC,TOOL,NOTE,PRIV,Unknown };
+	
+	RTCPSDESPacket(u_int8_t *data,size_t datalen);
+	~RTCPSDESPacket()							{ }
+
+	int GetChunkCount() const;
+	
+	bool GotoFirstChunk();
+	bool GotoNextChunk();
+
+	u_int32_t GetChunkSSRC() const;
+	bool GotoFirstItem();
+	bool GotoNextItem();
+
+	ItemType GetItemType() const;
+	size_t GetItemLength() const;
+	u_int8_t *GetItemData();
+
+#ifdef RTP_SUPPORT_SDESPRIV
+	size_t GetPRIVPrefixLength() const;
+	u_int8_t *GetPRIVPrefixData();
+	size_t GetPRIVValueLength() const;
+	u_int8_t *GetPRIVValueData();
+#endif // RTP_SUPPORT_SDESPRIV
+
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+private:
+	u_int8_t *currentchunk;
+	int curchunknum;
+	size_t itemoffset;
+};
+
+inline int RTCPSDESPacket::GetChunkCount() const
+{
+	if (!knownformat)
+		return 0;
+	RTCPCommonHeader *hdr = (RTCPCommonHeader *)data;
+	return ((int)hdr-&gt;count);
+}
+
+inline bool RTCPSDESPacket::GotoFirstChunk()
+{
+	if (GetChunkCount() == 0)
+	{
+		currentchunk = 0;
+		return false;
+	}
+	currentchunk = data+sizeof(RTCPCommonHeader);
+	curchunknum = 1;
+	itemoffset = sizeof(u_int32_t);
+	return true;
+}
+
+inline bool RTCPSDESPacket::GotoNextChunk()
+{
+	if (!knownformat)
+		return false;
+	if (currentchunk == 0)
+		return false;
+	if (curchunknum == GetChunkCount())
+		return false;
+	
+	size_t offset = sizeof(u_int32_t);
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(currentchunk+sizeof(u_int32_t));
+	
+	while (sdeshdr-&gt;id != 0)
+	{
+		offset += sizeof(RTCPSDESHeader);
+		offset += (size_t)(sdeshdr-&gt;length);
+		sdeshdr = (RTCPSDESHeader *)(currentchunk+offset);
+	}
+	offset++; // for the zero byte
+	if ((offset&amp;0x03) != 0)
+		offset += (4-(offset&amp;0x03));
+	currentchunk += offset;
+	curchunknum++;
+	itemoffset = sizeof(u_int32_t);
+	return true;
+}
+
+inline u_int32_t RTCPSDESPacket::GetChunkSSRC() const
+{
+	if (!knownformat)
+		return 0;
+	if (currentchunk == 0)
+		return 0;
+	u_int32_t *ssrc = (u_int32_t *)currentchunk;
+	return ntohl(*ssrc);
+}
+
+inline bool RTCPSDESPacket::GotoFirstItem()
+{
+	if (!knownformat)
+		return false;
+	if (currentchunk == 0)
+		return false;
+	itemoffset = sizeof(u_int32_t);
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(currentchunk+itemoffset);
+	if (sdeshdr-&gt;id == 0)
+		return false;
+	return true;
+}
+
+inline bool RTCPSDESPacket::GotoNextItem()
+{
+	if (!knownformat)
+		return false;
+	if (currentchunk == 0)
+		return false;
+	
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(currentchunk+itemoffset);
+	if (sdeshdr-&gt;id == 0)
+		return false;
+	
+	size_t offset = itemoffset;
+	offset += sizeof(RTCPSDESHeader);
+	offset += (size_t)(sdeshdr-&gt;length);
+	sdeshdr = (RTCPSDESHeader *)(currentchunk+offset);
+	if (sdeshdr-&gt;id == 0)
+		return false;
+	itemoffset = offset;
+	return true;
+}
+
+inline RTCPSDESPacket::ItemType RTCPSDESPacket::GetItemType() const
+{
+	if (!knownformat)
+		return None;
+	if (currentchunk == 0)
+		return None;
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(currentchunk+itemoffset);
+	switch (sdeshdr-&gt;id)
+	{
+	case 0:
+		return None;
+	case RTCP_SDES_ID_CNAME:
+		return CNAME;
+	case RTCP_SDES_ID_NAME:
+		return NAME;
+	case RTCP_SDES_ID_EMAIL:
+		return EMAIL;
+	case RTCP_SDES_ID_PHONE:
+		return PHONE;
+	case RTCP_SDES_ID_LOCATION:
+		return LOC;
+	case RTCP_SDES_ID_TOOL:
+		return TOOL;
+	case RTCP_SDES_ID_NOTE:
+		return NOTE;
+	case RTCP_SDES_ID_PRIVATE:
+		return PRIV;
+	default:
+		return Unknown;
+	}
+	return Unknown;
+}
+
+inline size_t RTCPSDESPacket::GetItemLength() const
+{
+	if (!knownformat)
+		return None;
+	if (currentchunk == 0)
+		return None;
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(currentchunk+itemoffset);
+	if (sdeshdr-&gt;id == 0)
+		return 0;
+	return (size_t)(sdeshdr-&gt;length);
+}
+
+inline u_int8_t *RTCPSDESPacket::GetItemData()
+{
+	if (!knownformat)
+		return 0;
+	if (currentchunk == 0)
+		return 0;
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(currentchunk+itemoffset);
+	if (sdeshdr-&gt;id == 0)
+		return 0;
+	return (currentchunk+itemoffset+sizeof(RTCPSDESHeader));
+}
+
+#ifdef RTP_SUPPORT_SDESPRIV
+inline size_t RTCPSDESPacket::GetPRIVPrefixLength() const
+{
+	if (!knownformat)
+		return 0;
+	if (currentchunk == 0)
+		return 0;
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(currentchunk+itemoffset);
+	if (sdeshdr-&gt;id != RTCP_SDES_ID_PRIVATE)
+		return 0;
+	if (sdeshdr-&gt;length == 0)
+		return 0;
+	u_int8_t *preflen = currentchunk+itemoffset+sizeof(RTCPSDESHeader);
+	size_t prefixlength = (size_t)(*preflen);
+	if (prefixlength &gt; (size_t)((sdeshdr-&gt;length)-1))
+		return 0;
+	return prefixlength;
+}
+
+inline u_int8_t *RTCPSDESPacket::GetPRIVPrefixData()
+{
+	if (!knownformat)
+		return 0;
+	if (currentchunk == 0)
+		return 0;
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(currentchunk+itemoffset);
+	if (sdeshdr-&gt;id != RTCP_SDES_ID_PRIVATE)
+		return 0;
+	if (sdeshdr-&gt;length == 0)
+		return 0;
+	u_int8_t *preflen = currentchunk+itemoffset+sizeof(RTCPSDESHeader);
+	size_t prefixlength = (size_t)(*preflen);
+	if (prefixlength &gt; (size_t)((sdeshdr-&gt;length)-1))
+		return 0;
+	if (prefixlength == 0)
+		return 0;
+	return (currentchunk+itemoffset+sizeof(RTCPSDESHeader)+1);
+}
+
+inline size_t RTCPSDESPacket::GetPRIVValueLength() const
+{
+	if (!knownformat)
+		return 0;
+	if (currentchunk == 0)
+		return 0;
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(currentchunk+itemoffset);
+	if (sdeshdr-&gt;id != RTCP_SDES_ID_PRIVATE)
+		return 0;
+	if (sdeshdr-&gt;length == 0)
+		return 0;
+	u_int8_t *preflen = currentchunk+itemoffset+sizeof(RTCPSDESHeader);
+	size_t prefixlength = (size_t)(*preflen);
+	if (prefixlength &gt; (size_t)((sdeshdr-&gt;length)-1))
+		return 0;
+	return ((size_t)(sdeshdr-&gt;length))-prefixlength-1;
+}
+
+inline u_int8_t *RTCPSDESPacket::GetPRIVValueData()
+{
+	if (!knownformat)
+		return 0;
+	if (currentchunk == 0)
+		return 0;
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(currentchunk+itemoffset);
+	if (sdeshdr-&gt;id != RTCP_SDES_ID_PRIVATE)
+		return 0;
+	if (sdeshdr-&gt;length == 0)
+		return 0;
+	u_int8_t *preflen = currentchunk+itemoffset+sizeof(RTCPSDESHeader);
+	size_t prefixlength = (size_t)(*preflen);
+	if (prefixlength &gt; (size_t)((sdeshdr-&gt;length)-1))
+		return 0;
+	size_t valuelen = ((size_t)(sdeshdr-&gt;length))-prefixlength-1;
+	if (valuelen == 0)
+		return 0;
+	return (currentchunk+itemoffset+sizeof(RTCPSDESHeader)+1+prefixlength);
+}
+
+#endif // RTP_SUPPORT_SDESPRIV
+
+#endif // RTCPSDESPACKET_H
+

Added: konference/src/rtp/jrtplib/rtcpsrpacket.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcpsrpacket.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpsrpacket.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,101 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtcpsrpacket.h&quot;
+#ifdef RTPDEBUG
+	#include &lt;iostream&gt;
+#endif // RTPDEBUG
+
+#include &quot;rtpdebug.h&quot;
+
+RTCPSRPacket::RTCPSRPacket(u_int8_t *data,size_t datalength)
+	: RTCPPacket(SR,data,datalength)
+{
+	knownformat = false;
+	
+	RTCPCommonHeader *hdr;
+	size_t len = datalength;
+	size_t expectedlength;
+	
+	hdr = (RTCPCommonHeader *)data;
+	if (hdr-&gt;padding)
+	{
+		u_int8_t padcount = data[datalength-1];
+		if ((padcount &amp; 0x03) != 0) // not a multiple of four! (see rfc 3550 p 37)
+			return;
+		if (((size_t)padcount) &gt;= len)
+			return;
+		len -= (size_t)padcount;
+	}
+
+	expectedlength = sizeof(RTCPCommonHeader)+sizeof(u_int32_t)+sizeof(RTCPSenderReport);
+	expectedlength += sizeof(RTCPReceiverReport)*((int)hdr-&gt;count);
+
+	if (expectedlength != len)
+		return;
+	
+	knownformat = true;
+}
+
+#ifdef RTPDEBUG
+void RTCPSRPacket::Dump()
+{
+	RTCPPacket::Dump();
+	if (!IsKnownFormat())
+		std::cout &lt;&lt; &quot;    Unknown format&quot; &lt;&lt; std::endl;
+	else
+	{
+		int num = GetReceptionReportCount();
+		int i;
+		RTPNTPTime t = GetNTPTimestamp();
+
+		std::cout &lt;&lt; &quot;    SSRC of sender:     &quot; &lt;&lt; GetSenderSSRC() &lt;&lt; std::endl;
+		std::cout &lt;&lt; &quot;    Sender info:&quot; &lt;&lt; std::endl;
+		std::cout &lt;&lt; &quot;        NTP timestamp:  &quot; &lt;&lt; t.GetMSW() &lt;&lt; &quot;:&quot; &lt;&lt; t.GetLSW() &lt;&lt; std::endl;
+		std::cout &lt;&lt; &quot;        RTP timestamp:  &quot; &lt;&lt; GetRTPTimestamp() &lt;&lt; std::endl;
+		std::cout &lt;&lt; &quot;        Packet count:   &quot; &lt;&lt; GetSenderPacketCount() &lt;&lt; std::endl;
+		std::cout &lt;&lt; &quot;        Octet count:    &quot; &lt;&lt; GetSenderOctetCount() &lt;&lt; std::endl;
+		for (i = 0 ; i &lt; num ; i++)
+		{
+			std::cout &lt;&lt; &quot;    Report block &quot; &lt;&lt; i &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        SSRC:           &quot; &lt;&lt; GetSSRC(i) &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Fraction lost:  &quot; &lt;&lt; (u_int32_t)GetFractionLost(i) &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Packets lost:   &quot; &lt;&lt; GetLostPacketCount(i) &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Seq. nr.:       &quot; &lt;&lt; GetExtendedHighestSequenceNumber(i) &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Jitter:         &quot; &lt;&lt; GetJitter(i) &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        LSR:            &quot; &lt;&lt; GetLSR(i) &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        DLSR:           &quot; &lt;&lt; GetDLSR(i) &lt;&lt; std::endl;
+		}
+	}	
+}
+#endif // RTPDEBUG
+

Added: konference/src/rtp/jrtplib/rtcpsrpacket.h
===================================================================
--- konference/src/rtp/jrtplib/rtcpsrpacket.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpsrpacket.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,197 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPSRPACKET_H
+
+#define RTCPSRPACKET_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtcppacket.h&quot;
+#include &quot;rtptimeutilities.h&quot;
+#include &quot;rtpstructs.h&quot;
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include &lt;netinet/in.h&gt;
+#endif // WIN32
+
+class RTCPCompoundPacket;
+
+class RTCPSRPacket : public RTCPPacket
+{
+public:
+	RTCPSRPacket(u_int8_t *data,size_t datalength);
+	~RTCPSRPacket()								{ }
+
+	// Sender info
+	
+	u_int32_t GetSenderSSRC() const;
+	RTPNTPTime GetNTPTimestamp() const;
+	u_int32_t GetRTPTimestamp() const;
+	u_int32_t GetSenderPacketCount() const;
+	u_int32_t GetSenderOctetCount() const;
+
+	// Reportblocks
+	
+	int GetReceptionReportCount() const;
+	// Note: the validity of index is NOT checked!
+	u_int32_t GetSSRC(int index) const;
+	u_int8_t GetFractionLost(int index) const;
+	int32_t GetLostPacketCount(int index) const;
+	u_int32_t GetExtendedHighestSequenceNumber(int index) const;
+	u_int32_t GetJitter(int index) const;
+	u_int32_t GetLSR(int index) const;
+	u_int32_t GetDLSR(int index) const;
+
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+private:
+	RTCPReceiverReport *GotoReport(int index) const;
+};
+
+inline u_int32_t RTCPSRPacket::GetSenderSSRC() const
+{
+	if (!knownformat)
+		return 0;
+	
+	u_int32_t *ssrcptr = (u_int32_t *)(data+sizeof(RTCPCommonHeader));
+	return ntohl(*ssrcptr);
+}
+
+inline RTPNTPTime RTCPSRPacket::GetNTPTimestamp() const
+{
+	if (!knownformat)
+		return RTPNTPTime(0,0);
+
+	RTCPSenderReport *sr = (RTCPSenderReport *)(data+sizeof(RTCPCommonHeader)+sizeof(u_int32_t));
+	return RTPNTPTime(ntohl(sr-&gt;ntptime_msw),ntohl(sr-&gt;ntptime_lsw));
+}
+
+inline u_int32_t RTCPSRPacket::GetRTPTimestamp() const
+{
+	if (!knownformat)
+		return 0;
+	RTCPSenderReport *sr = (RTCPSenderReport *)(data+sizeof(RTCPCommonHeader)+sizeof(u_int32_t));
+	return ntohl(sr-&gt;rtptimestamp);
+}
+
+inline u_int32_t RTCPSRPacket::GetSenderPacketCount() const
+{
+	if (!knownformat)
+		return 0;
+	RTCPSenderReport *sr = (RTCPSenderReport *)(data+sizeof(RTCPCommonHeader)+sizeof(u_int32_t));
+	return ntohl(sr-&gt;packetcount);
+}
+	
+inline u_int32_t RTCPSRPacket::GetSenderOctetCount() const
+{
+	if (!knownformat)
+		return 0;
+	RTCPSenderReport *sr = (RTCPSenderReport *)(data+sizeof(RTCPCommonHeader)+sizeof(u_int32_t));
+	return ntohl(sr-&gt;octetcount);
+}
+
+inline int RTCPSRPacket::GetReceptionReportCount() const
+{
+	if (!knownformat)
+		return 0;
+	RTCPCommonHeader *hdr = (RTCPCommonHeader *)data;
+	return ((int)hdr-&gt;count);
+}
+
+inline RTCPReceiverReport *RTCPSRPacket::GotoReport(int index) const
+{
+	RTCPReceiverReport *r = (RTCPReceiverReport *)(data+sizeof(RTCPCommonHeader)+sizeof(u_int32_t)+sizeof(RTCPSenderReport)+index*sizeof(RTCPReceiverReport));
+	return r;
+}
+
+inline u_int32_t RTCPSRPacket::GetSSRC(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return ntohl(r-&gt;ssrc);
+}
+
+inline u_int8_t RTCPSRPacket::GetFractionLost(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return r-&gt;fractionlost;
+}
+
+inline int32_t RTCPSRPacket::GetLostPacketCount(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	u_int32_t count = ((u_int32_t)r-&gt;packetslost[2])|(((u_int32_t)r-&gt;packetslost[1])&lt;&lt;8)|(((u_int32_t)r-&gt;packetslost[0])&lt;&lt;16);
+	if ((count&amp;0x00800000) != 0) // test for negative number
+		count |= 0xFF000000;
+	int32_t *count2 = (int32_t *)(&amp;count);
+	return (*count2);
+}
+
+inline u_int32_t RTCPSRPacket::GetExtendedHighestSequenceNumber(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return ntohl(r-&gt;exthighseqnr);
+}
+
+inline u_int32_t RTCPSRPacket::GetJitter(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return ntohl(r-&gt;jitter);
+}
+
+inline u_int32_t RTCPSRPacket::GetLSR(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return ntohl(r-&gt;lsr);
+}
+
+inline u_int32_t RTCPSRPacket::GetDLSR(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return ntohl(r-&gt;dlsr);
+}
+
+#endif // RTCPSRPACKET_H
+

Added: konference/src/rtp/jrtplib/rtcpunknownpacket.h
===================================================================
--- konference/src/rtp/jrtplib/rtcpunknownpacket.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpunknownpacket.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,55 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPUNKNOWNPACKET_H
+
+#define RTCPUNKNOWNPACKET_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtcppacket.h&quot;
+
+class RTCPCompoundPacket;
+
+class RTCPUnknownPacket : public RTCPPacket
+{
+public:
+	RTCPUnknownPacket(u_int8_t *data,size_t datalen) :
+		RTCPPacket(Unknown,data,datalen)                                         
+	{
+	       // Since we don't expect a format, we'll trivially put knownformat = true
+	       knownformat = true;	
+	}
+        ~RTCPUnknownPacket()                                                                    { }
+};
+
+#endif // RTCPUNKNOWNPACKET_H
+

Added: konference/src/rtp/jrtplib/rtpaddress.h
===================================================================
--- konference/src/rtp/jrtplib/rtpaddress.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpaddress.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,64 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPADDRESS_H
+
+#define RTPADDRESS_H
+
+#include &quot;rtpconfig.h&quot;
+#include &lt;string&gt;
+
+class RTPAddress
+{
+public:
+	enum AddressType { IPv4Address, IPv6Address, UserDefinedAddress }; 
+	AddressType GetAddressType() const				{ return addresstype; }
+
+	virtual RTPAddress *CreateCopy() const = 0;
+
+	// note: these functions should be able to handle a NULL argument
+	virtual bool IsSameAddress(const RTPAddress *addr) const = 0;
+	virtual bool IsFromSameHost(const RTPAddress *addr) const  = 0;
+
+#ifdef RTPDEBUG
+	virtual std::string GetAddressString() const = 0;
+#endif // RTPDEBUG
+	
+	virtual ~RTPAddress()						{ }
+protected:
+	RTPAddress(const AddressType t) : addresstype(t) { } // only allow subclasses to be created
+private:
+	const AddressType addresstype;
+};
+
+#endif // RTPADDRESS_H
+

Added: konference/src/rtp/jrtplib/rtpcollisionlist.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpcollisionlist.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpcollisionlist.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,124 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtpcollisionlist.h&quot;
+#include &quot;rtperrors.h&quot;
+#ifdef RTPDEBUG
+	#include &lt;iostream&gt;
+#endif // RTPDEBUG
+
+#include &quot;rtpdebug.h&quot;
+
+RTPCollisionList::RTPCollisionList()
+{
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	timeinit.Dummy();
+#endif // WIN32 || _WIN32_WCE
+}
+
+void RTPCollisionList::Clear()
+{
+	std::list&lt;AddressAndTime&gt;::iterator it;
+	
+	for (it = addresslist.begin() ; it != addresslist.end() ; it++)
+		delete (*it).addr;
+	addresslist.clear();
+}
+
+int RTPCollisionList::UpdateAddress(const RTPAddress *addr,const RTPTime &amp;receivetime,bool *created)
+{
+	if (addr == 0)
+		return ERR_RTP_COLLISIONLIST_BADADDRESS;
+	
+	std::list&lt;AddressAndTime&gt;::iterator it;
+	
+	for (it = addresslist.begin() ; it != addresslist.end() ; it++)
+	{
+		if (((*it).addr)-&gt;IsSameAddress(addr))
+		{
+			(*it).recvtime = receivetime;
+			*created = false;
+			return 0;
+		}
+	}
+
+	RTPAddress *newaddr = addr-&gt;CreateCopy();
+	if (newaddr == 0)
+		return ERR_RTP_OUTOFMEM;
+	
+	addresslist.push_back(AddressAndTime(newaddr,receivetime));
+	*created = true;
+	return 0;
+}
+
+bool RTPCollisionList::HasAddress(const RTPAddress *addr) const
+{
+	std::list&lt;AddressAndTime&gt;::const_iterator it;
+	
+	for (it = addresslist.begin() ; it != addresslist.end() ; it++)
+	{
+		if (((*it).addr)-&gt;IsSameAddress(addr))
+			return true;
+	}
+
+	return false;	
+}
+
+void RTPCollisionList::Timeout(const RTPTime &amp;currenttime,const RTPTime &amp;timeoutdelay)
+{
+	std::list&lt;AddressAndTime&gt;::iterator it;
+	RTPTime checktime = currenttime;
+	checktime -= timeoutdelay;
+	
+	it = addresslist.begin();
+	while(it != addresslist.end())
+	{
+		if ((*it).recvtime &lt; checktime) // timeout
+		{
+			delete (*it).addr;
+			it = addresslist.erase(it);	
+		}
+		else
+			it++;
+	}
+}
+
+#ifdef RTPDEBUG
+void RTPCollisionList::Dump()
+{
+	std::list&lt;AddressAndTime&gt;::const_iterator it;
+	
+	for (it = addresslist.begin() ; it != addresslist.end() ; it++)
+		std::cout &lt;&lt; &quot;Address: &quot; &lt;&lt; ((*it).addr)-&gt;GetAddressString() &lt;&lt; &quot;\tTime: &quot; &lt;&lt; (*it).recvtime.GetSeconds() &lt;&lt; std::endl;
+}
+#endif // RTPDEBUG
+

Added: konference/src/rtp/jrtplib/rtpcollisionlist.h
===================================================================
--- konference/src/rtp/jrtplib/rtpcollisionlist.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpcollisionlist.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,70 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPCOLLISIONLIST_H
+
+#define RTPCOLLISIONLIST_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtpaddress.h&quot;
+#include &quot;rtptimeutilities.h&quot;
+#include &lt;list&gt;
+
+class RTPAddress;
+
+class RTPCollisionList
+{
+public:
+	RTPCollisionList();
+	~RTPCollisionList()								{ Clear(); }
+	void Clear();
+	int UpdateAddress(const RTPAddress *addr,const RTPTime &amp;receivetime,bool *created);
+	bool HasAddress(const RTPAddress *addr) const;
+	void Timeout(const RTPTime &amp;currenttime,const RTPTime &amp;timeoutdelay);
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+private:
+	class AddressAndTime
+	{
+	public:
+		AddressAndTime(RTPAddress *a,const RTPTime &amp;t) : addr(a),recvtime(t) { }
+
+		RTPAddress *addr;
+		RTPTime recvtime;
+	};
+
+	std::list&lt;AddressAndTime&gt; addresslist;
+};
+
+#endif // RTPCOLLISIONLIST_H
+

Added: konference/src/rtp/jrtplib/rtpconfig.h
===================================================================
--- konference/src/rtp/jrtplib/rtpconfig.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpconfig.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,45 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPCONFIG_H
+
+#define RTPCONFIG_H
+
+#if (defined(WIN32) || defined(_WIN32_WCE))
+#include &quot;rtpconfig_win.h&quot;
+#else
+#include &quot;rtpconfig_unix.h&quot;
+#endif // WIN32
+
+// #define RTPDEBUG
+
+#endif // RTPCONFIG_H

Added: konference/src/rtp/jrtplib/rtpconfig_unix.h
===================================================================
--- konference/src/rtp/jrtplib/rtpconfig_unix.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpconfig_unix.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,72 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPCONFIG_UNIX_H
+
+#define RTPCONFIG_UNIX_H
+
+// Don't have &lt;sys/filio.h&gt;
+
+// Don't have &lt;sys/sockio.h&gt;
+
+// Little endian system
+
+#define RTP_SOCKLENTYPE_UINT
+
+// No sa_len member in struct sockaddr
+
+#define RTP_SUPPORT_IPV4MULTICAST
+
+// No support for jthread
+
+#define RTP_SUPPORT_SDESPRIV
+
+#define RTP_SUPPORT_INLINETEMPLATEPARAM
+
+#define RTP_SUPPORT_PROBATION
+
+#define RTP_SUPPORT_GNUDRAND
+
+// Not using rand_r
+
+#define RTP_SUPPORT_GETLOGINR
+
+// No IPv6 support
+
+// No IPv6 multicasting support
+
+#define RTP_SUPPORT_IFADDRS
+
+// No GStreamer support
+
+#endif // RTPCONFIG_UNIX_H
+

Added: konference/src/rtp/jrtplib/rtpconfig_unix.h.in
===================================================================
--- konference/src/rtp/jrtplib/rtpconfig_unix.h.in	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpconfig_unix.h.in	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,72 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPCONFIG_UNIX_H
+
+#define RTPCONFIG_UNIX_H
+
<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">+ at RTP_FILIO</A>@
+
<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">+ at RTP_SOCKIO</A>@
+
<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">+ at RTP_ENDIAN</A>@
+
<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">+ at RTP_SOCKLENTYPE_UINT</A>@
+
<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">+ at RTP_HAVE_SOCKADDR_LEN</A>@
+
<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">+ at RTP_SUPPORT_IPV4MULTICAST</A>@
+
<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">+ at RTP_SUPPORT_THREAD</A>@
+
<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">+ at RTP_SUPPORT_SDESPRIV</A>@
+
<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">+ at RTP_SUPPORT_INLINETEMPLATEPARAM</A>@
+
<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">+ at RTP_SUPPORT_PROBATION</A>@
+
<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">+ at RTP_SUPPORT_GNUDRAND</A>@
+
<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">+ at RTP_SUPPORT_RANDR</A>@
+
<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">+ at RTP_SUPPORT_GETLOGINR</A>@
+
<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">+ at RTP_SUPPORT_IPV6</A>@
+
<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">+ at RTP_SUPPORT_IPV6MULTICAST</A>@
+
<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">+ at RTP_SUPPORT_IFADDRS</A>@
+
<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">+ at RTP_SUPPORT_GST</A>@
+
+#endif // RTPCONFIG_UNIX_H
+

Added: konference/src/rtp/jrtplib/rtpconfig_win.h
===================================================================
--- konference/src/rtp/jrtplib/rtpconfig_win.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpconfig_win.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,50 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPCONFIG_WIN_H
+
+#define RTPCONFIG_WIN_H
+
+#define RTP_SUPPORT_IPV4MULTICAST
+
+#define RTP_SUPPORT_THREAD
+
+#define RTP_SUPPORT_PROBATION
+
+#define RTP_SUPPORT_SDESPRIV
+
+//#define RTP_SUPPORT_IPV6
+
+//#define RTP_SUPPORT_IPV6MULTICAST
+
+#endif // RTPCONFIG_WIN_H
+

Added: konference/src/rtp/jrtplib/rtpdebug.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpdebug.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpdebug.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,177 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtpconfig.h&quot;
+
+#ifdef RTPDEBUG
+
+#include &quot;rtptypes.h&quot;
+#include &lt;stdlib.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+
+struct MemoryInfo
+{
+	void *ptr;
+	size_t size;
+	int lineno;
+	char *filename;
+	
+	MemoryInfo *next;
+};
+
+class MemoryTracker
+{
+public:
+	MemoryTracker() { firstblock = NULL; }
+	~MemoryTracker()
+	{
+		MemoryInfo *tmp;
+		int count = 0;
+		
+		printf(&quot;Checking for memory leaks...\n&quot;);fflush(stdout);
+		while(firstblock)
+		{
+			count++;
+			printf(&quot;Unfreed block %p of %d bytes (file '%s', line %d)\n&quot;,firstblock-&gt;ptr,(int)firstblock-&gt;size,firstblock-&gt;filename,firstblock-&gt;lineno);;
+			
+			tmp = firstblock-&gt;next;
+			
+			free(firstblock-&gt;ptr);
+			if (firstblock-&gt;filename)
+				free(firstblock-&gt;filename);
+			free(firstblock);
+			firstblock = tmp;
+		}
+		if (count == 0)
+			printf(&quot;No memory leaks found\n&quot;);
+		else
+			printf(&quot;%d leaks found\n&quot;,count);
+	}
+	
+	MemoryInfo *firstblock;	
+};
+
+static MemoryTracker memtrack;
+
+void *donew(size_t s,char filename[],int line)
+{	
+	void *p;
+	MemoryInfo *meminf;
+	
+	p = malloc(s);
+	meminf = (MemoryInfo *)malloc(sizeof(MemoryInfo));
+	
+	meminf-&gt;ptr = p;
+	meminf-&gt;size = s;
+	meminf-&gt;lineno = line;
+	meminf-&gt;filename = (char *)malloc(strlen(filename)+1);
+	strcpy(meminf-&gt;filename,filename);
+	meminf-&gt;next = memtrack.firstblock;
+	
+	memtrack.firstblock = meminf;
+	
+	return p;
+}
+
+void dodelete(void *p)
+{
+	MemoryInfo *tmp,*tmpprev;
+	bool found;
+	
+	tmpprev = NULL;
+	tmp = memtrack.firstblock;
+	found = false;
+	while (tmp != NULL &amp;&amp; !found)
+	{
+		if (tmp-&gt;ptr == p)
+			found = true;
+		else
+		{
+			tmpprev = tmp;
+			tmp = tmp-&gt;next;
+		}
+	}
+	if (!found)
+	{
+		printf(&quot;Couldn't free block %p!\n&quot;,p);
+		fflush(stdout);
+	}
+	else
+	{
+		MemoryInfo *n;
+		
+		fflush(stdout);
+		n = tmp-&gt;next;
+		free(tmp-&gt;ptr);
+		if (tmp-&gt;filename)
+			free(tmp-&gt;filename);
+		free(tmp);
+		
+		if (tmpprev)
+			tmpprev-&gt;next = n;
+		else
+			memtrack.firstblock = n;
+	}
+}
+
+void *operator new(size_t s)
+{
+	return donew(s,&quot;UNKNOWN FILE&quot;,0);
+}
+
+void *operator new[](size_t s)
+{
+	return donew(s,&quot;UNKNOWN FILE&quot;,0);
+}
+
+void *operator new(size_t s,char filename[],int line)
+{
+	return donew(s,filename,line);
+}
+
+void *operator new[](size_t s,char filename[],int line)
+{
+	return donew(s,filename,line);
+}
+
+void operator delete(void *p)
+{
+	dodelete(p);
+}
+
+void operator delete[](void *p)
+{
+	dodelete(p);
+}
+
+#endif // RTPDEBUG

Added: konference/src/rtp/jrtplib/rtpdebug.h
===================================================================
--- konference/src/rtp/jrtplib/rtpdebug.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpdebug.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,52 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPDEBUG_H
+
+#define RTPDEBUG_H
+
+#include &quot;rtpconfig.h&quot;
+
+#ifdef RTPDEBUG
+	#include &quot;rtptypes.h&quot;
+
+	void *operator new(size_t s,char filename[],int line);
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	void *operator new[](size_t s,char filename[],int line);
+	#define new new (__FILE__,__LINE__)
+#else
+	#define new new (__FILE__,__LINE__)
+#endif // WIN32
+#endif // RTPDEBUG
+
+#endif // RTPDEBUG_H
+

Added: konference/src/rtp/jrtplib/rtpdefines.h
===================================================================
--- konference/src/rtp/jrtplib/rtpdefines.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpdefines.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,75 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPDEFINES_H
+
+#define RTPDEFINES_H
+
+#define RTP_VERSION							2
+#define RTP_MAXCSRCS							15
+#define RTP_MINPACKETSIZE						600
+#define RTP_DEFAULTPACKETSIZE						1400
+#define RTP_PROBATIONCOUNT						2
+#define RTP_MAXPRIVITEMS						256
+#define RTP_SENDERTIMEOUTMULTIPLIER					2
+#define RTP_BYETIMEOUTMULTIPLIER					1
+#define RTP_MEMBERTIMEOUTMULTIPLIER					5
+#define RTP_COLLISIONTIMEOUTMULTIPLIER					10
+#define RTP_NOTETTIMEOUTMULTIPLIER					25
+#define RTP_DEFAULTSESSIONBANDWIDTH					10000.0
+
+#define RTP_RTCPTYPE_SR							200
+#define RTP_RTCPTYPE_RR							201
+#define RTP_RTCPTYPE_SDES						202
+#define RTP_RTCPTYPE_BYE						203
+#define RTP_RTCPTYPE_APP						204
+
+#define RTCP_SDES_ID_CNAME						1
+#define RTCP_SDES_ID_NAME						2
+#define RTCP_SDES_ID_EMAIL						3
+#define RTCP_SDES_ID_PHONE						4
+#define RTCP_SDES_ID_LOCATION						5
+#define RTCP_SDES_ID_TOOL						6
+#define RTCP_SDES_ID_NOTE						7
+#define RTCP_SDES_ID_PRIVATE						8
+#define RTCP_SDES_NUMITEMS_NONPRIVATE					7
+#define RTCP_SDES_MAXITEMLENGTH						255
+
+#define RTCP_BYE_MAXREASONLENGTH					255
+#define RTCP_DEFAULTMININTERVAL						5.0	
+#define RTCP_DEFAULTBANDWIDTHFRACTION					0.05
+#define RTCP_DEFAULTSENDERFRACTION					0.25
+#define RTCP_DEFAULTHALFATSTARTUP					true
+#define RTCP_DEFAULTIMMEDIATEBYE					true
+#define RTCP_DEFAULTSRBYE						true
+
+#endif // RTPDEFINES_H

Added: konference/src/rtp/jrtplib/rtperrors.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtperrors.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtperrors.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,223 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtperrors.h&quot;
+
+#include &quot;rtpdebug.h&quot;
+
+struct RTPErrorInfo
+{
+	int code;
+	char *description;
+};
+
+static RTPErrorInfo ErrorDescriptions[]=
+{
+	{ ERR_RTP_OUTOFMEM,&quot;Out of memory&quot; },
+	{ ERR_RTP_NOTHREADSUPPORT, &quot;No JThread support was compiled in&quot;},
+	{ ERR_RTP_COLLISIONLIST_BADADDRESS, &quot;Passed invalid address (null) to collision list&quot;},
+	{ ERR_RTP_HASHTABLE_ELEMENTALREADYEXISTS, &quot;Element already exists in hash table&quot;},
+	{ ERR_RTP_HASHTABLE_ELEMENTNOTFOUND, &quot;Element not found in hash table&quot;},
+	{ ERR_RTP_HASHTABLE_FUNCTIONRETURNEDINVALIDHASHINDEX, &quot;Function returned an illegal hash index&quot;},
+	{ ERR_RTP_HASHTABLE_NOCURRENTELEMENT, &quot;No current element selected in hash table&quot;},
+	{ ERR_RTP_KEYHASHTABLE_FUNCTIONRETURNEDINVALIDHASHINDEX, &quot;Function returned an illegal hash index&quot;},
+	{ ERR_RTP_KEYHASHTABLE_KEYALREADYEXISTS, &quot;Key value already exists in key hash table&quot;},
+	{ ERR_RTP_KEYHASHTABLE_KEYNOTFOUND, &quot;Key value not found in key hash table&quot;},
+	{ ERR_RTP_KEYHASHTABLE_NOCURRENTELEMENT, &quot;No current element selected in key hash table&quot;},
+	{ ERR_RTP_PACKBUILD_ALREADYINIT, &quot;RTP packet builder is already initialized&quot;},
+	{ ERR_RTP_PACKBUILD_CSRCALREADYINLIST, &quot;The specified CSRC is already in the RTP packet builder's CSRC list&quot;},
+	{ ERR_RTP_PACKBUILD_CSRCLISTFULL, &quot;The RTP packet builder's CSRC list already contains 15 entries&quot;},
+	{ ERR_RTP_PACKBUILD_CSRCNOTINLIST, &quot;The specified CSRC was not found in the RTP packet builder's CSRC list&quot;},
+	{ ERR_RTP_PACKBUILD_DEFAULTMARKNOTSET, &quot;The RTP packet builder's default mark flag is not set&quot;},
+	{ ERR_RTP_PACKBUILD_DEFAULTPAYLOADTYPENOTSET, &quot;The RTP packet builder's default payload type is not set&quot;},
+	{ ERR_RTP_PACKBUILD_DEFAULTTSINCNOTSET, &quot;The RTP packet builder's default timestamp increment is not set&quot;},
+	{ ERR_RTP_PACKBUILD_INVALIDMAXPACKETSIZE, &quot;The specified maximum packet size for the RTP packet builder is invalid&quot;},
+	{ ERR_RTP_PACKBUILD_NOTINIT, &quot;The RTP packet builder is not initialized&quot;},
+	{ ERR_RTP_PACKET_BADPAYLOADTYPE, &quot;Invalid payload type&quot;},
+	{ ERR_RTP_PACKET_DATAEXCEEDSMAXSIZE, &quot;Tried to create an RTP packet which whould exceed the specified maximum packet size&quot;},
+	{ ERR_RTP_PACKET_EXTERNALBUFFERNULL, &quot;Illegal value (null) passed as external buffer for the RTP packet&quot;},
+	{ ERR_RTP_PACKET_ILLEGALBUFFERSIZE, &quot;Illegal buffer size specified for the RTP packet&quot;},
+	{ ERR_RTP_PACKET_INVALIDPACKET, &quot;Invalid RTP packet format&quot;},
+	{ ERR_RTP_PACKET_TOOMANYCSRCS, &quot;More than 15 CSRCs specified for the RTP packet&quot;},
+	{ ERR_RTP_POLLTHREAD_ALREADYRUNNING, &quot;Poll thread is already running&quot;},
+	{ ERR_RTP_POLLTHREAD_CANTINITMUTEX, &quot;Can't initialize a mutex for the poll thread&quot;},
+	{ ERR_RTP_POLLTHREAD_CANTSTARTTHREAD, &quot;Can't start the poll thread&quot;},
+	{ ERR_RTP_RTCPCOMPOUND_INVALIDPACKET, &quot;Invalid RTCP compound packet format&quot;},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYBUILDING, &quot;Already building this RTCP compound packet&quot;},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYBUILT, &quot;This RTCP compound packet is already built&quot;},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYGOTREPORT, &quot;There's already a SR or RR in this RTCP compound packet&quot;},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_APPDATALENTOOBIG, &quot;The specified APP data length for the RTCP compound packet is too big&quot;},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_BUFFERSIZETOOSMALL, &quot;The specified buffer size for the RTCP comound packet is too small&quot;},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_ILLEGALAPPDATALENGTH, &quot;The APP data length must be a multiple of four&quot;},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_ILLEGALSUBTYPE, &quot;The APP packet subtype must be smaller than 32&quot;},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_INVALIDITEMTYPE, &quot;Invalid SDES item type specified for the RTCP compound packet&quot;},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_MAXPACKETSIZETOOSMALL, &quot;The specified maximum packet size for the RTCP compound packet is too small&quot;},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_NOCURRENTSOURCE, &quot;Tried to add an SDES item to the RTCP compound packet when no SSRC was present&quot;},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_NOREPORTPRESENT, &quot;An RTCP compound packet must contain a SR or RR&quot;},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING, &quot;The RTCP compound packet builder is not initialized&quot;},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT, &quot;Adding this data would exceed the specified maximum RTCP compound packet size&quot;},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_REPORTNOTSTARTED, &quot;Tried to add a report block to the RTCP compound packet when no SR or RR was started&quot;},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_TOOMANYSSRCS, &quot;Only 31 SSRCs will fit into a BYE packet for the RTCP compound packet&quot;},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_TOTALITEMLENGTHTOOBIG, &quot;The total data for the SDES PRIV item exceeds the maximum size (255 bytes) of an SDES item&quot;},
+	{ ERR_RTP_RTCPPACKETBUILDER_ALREADYINIT, &quot;The RTCP packet builder is already initialized&quot;},
+	{ ERR_RTP_RTCPPACKETBUILDER_ILLEGALMAXPACKSIZE, &quot;The specified maximum packet size for the RTCP packet builder is too small&quot;},
+	{ ERR_RTP_RTCPPACKETBUILDER_ILLEGALTIMESTAMPUNIT, &quot;Speficied an illegal timestamp unit for the the RTCP packet builder&quot;},
+	{ ERR_RTP_RTCPPACKETBUILDER_NOTINIT, &quot;The RTCP packet builder was not initialized&quot;},
+	{ ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON, &quot;The RTCP compound packet filled sooner than expected&quot;},
+	{ ERR_RTP_SCHEDPARAMS_BADFRACTION, &quot;Illegal sender bandwidth fraction specified&quot;},
+	{ ERR_RTP_SCHEDPARAMS_BADMINIMUMINTERVAL, &quot;The minimum RTCP interval specified for the scheduler is too small&quot;},
+	{ ERR_RTP_SCHEDPARAMS_INVALIDBANDWIDTH, &quot;Invalid RTCP bandwidth specified for the RTCP scheduler&quot;},
+	{ ERR_RTP_SDES_LENGTHTOOBIG, &quot;Specified size for the SDES item exceeds 255 bytes&quot;},
+	{ ERR_RTP_SDES_PREFIXNOTFOUND, &quot;The specified SDES PRIV prefix was not found&quot;},
+	{ ERR_RTP_SESSION_ALREADYCREATED, &quot;The session is already created&quot;},
+	{ ERR_RTP_SESSION_CANTGETLOGINNAME, &quot;Can't retrieve login name&quot;},
+	{ ERR_RTP_SESSION_CANTINITMUTEX, &quot;A mutex for the RTP session couldn't be initialized&quot;},
+	{ ERR_RTP_SESSION_MAXPACKETSIZETOOSMALL, &quot;The maximum packet size specified for the RTP session is too small&quot;},
+	{ ERR_RTP_SESSION_NOTCREATED, &quot;The RTP session was not created&quot;},
+	{ ERR_RTP_SESSION_UNSUPPORTEDTRANSMISSIONPROTOCOL, &quot;The requested transmission protocol for the RTP session is not supported&quot;},
+	{ ERR_RTP_SESSION_USINGPOLLTHREAD, &quot;This function is not available when using the RTP poll thread feature&quot;},
+	{ ERR_RTP_SESSION_USERDEFINEDTRANSMITTERNULL, &quot;A user-defined transmitter was requested but the supplied transmitter component is NULL&quot;},
+	{ ERR_RTP_SOURCES_ALREADYHAVEOWNSSRC, &quot;Only one source can be marked as own SSRC in the source table&quot;},
+	{ ERR_RTP_SOURCES_DONTHAVEOWNSSRC, &quot;No source was marked as own SSRC in the source table&quot;},
+	{ ERR_RTP_SOURCES_ILLEGALSDESTYPE, &quot;Illegal SDES type specified for processing into the source table&quot;},
+	{ ERR_RTP_SOURCES_SSRCEXISTS, &quot;Can't create own SSRC because this SSRC identifier is already in the source table&quot;},
+	{ ERR_RTP_UDPV4TRANS_ALREADYCREATED, &quot;The transmitter was already created&quot;},
+	{ ERR_RTP_UDPV4TRANS_ALREADYINIT, &quot;The transmitter was already initialize&quot;},
+	{ ERR_RTP_UDPV4TRANS_ALREADYWAITING, &quot;The transmitter is already waiting for incoming data&quot;},
+	{ ERR_RTP_UDPV4TRANS_CANTBINDRTCPSOCKET, &quot;The 'bind' call for the RTCP socket failed&quot;},
+	{ ERR_RTP_UDPV4TRANS_CANTBINDRTPSOCKET, &quot;The 'bind' call for the RTP socket failed&quot;},
+	{ ERR_RTP_UDPV4TRANS_CANTCALCULATELOCALIP, &quot;The local IP addresses could not be determined&quot;},
+	{ ERR_RTP_UDPV4TRANS_CANTCREATEABORTDESCRIPTORS, &quot;Couldn't create the sockets used to abort waiting for incoming data&quot;},
+	{ ERR_RTP_UDPV4TRANS_CANTCREATEPIPE, &quot;Couldn't create the pipe used to abort waiting for incoming data&quot;},
+	{ ERR_RTP_UDPV4TRANS_CANTCREATESOCKET, &quot;Couldn't create the RTP or RTCP socket&quot;},
+	{ ERR_RTP_UDPV4TRANS_CANTINITMUTEX, &quot;Failed to initialize a mutex used by the transmitter&quot;},
+	{ ERR_RTP_UDPV4TRANS_CANTSETRTCPRECEIVEBUF, &quot;Couldn't set the receive buffer size for the RTCP socket&quot;},
+	{ ERR_RTP_UDPV4TRANS_CANTSETRTCPTRANSMITBUF, &quot;Couldn't set the transmission buffer size for the RTCP socket&quot;},
+	{ ERR_RTP_UDPV4TRANS_CANTSETRTPRECEIVEBUF, &quot;Couldn't set the receive buffer size for the RTP socket&quot;},
+	{ ERR_RTP_UDPV4TRANS_CANTSETRTPTRANSMITBUF, &quot;Couldn't set the transmission buffer size for the RTP socket&quot;},
+	{ ERR_RTP_UDPV4TRANS_COULDNTJOINMULTICASTGROUP, &quot;Unable to join the specified multicast group&quot;},
+	{ ERR_RTP_UDPV4TRANS_DIFFERENTRECEIVEMODE, &quot;The function called doens't match the current receive mode&quot;},
+	{ ERR_RTP_UDPV4TRANS_ERRORINSELECT, &quot;Error in the transmitter's 'select' call&quot;},
+	{ ERR_RTP_UDPV4TRANS_ILLEGALPARAMETERS, &quot;Illegal parameters type passed to the transmitter&quot;},
+	{ ERR_RTP_UDPV4TRANS_INVALIDADDRESSTYPE, &quot;Specified address type isn't compatible with this transmitter&quot;},
+	{ ERR_RTP_UDPV4TRANS_NOLOCALIPS, &quot;Couldn't determine the local host name since the local IP list is empty&quot;},
+	{ ERR_RTP_UDPV4TRANS_NOMULTICASTSUPPORT, &quot;Multicast support is not available&quot;},
+	{ ERR_RTP_UDPV4TRANS_NOSUCHENTRY, &quot;Specified entry could not be found&quot;},
+	{ ERR_RTP_UDPV4TRANS_NOTAMULTICASTADDRESS, &quot;The specified address is not a multicast address&quot;},
+	{ ERR_RTP_UDPV4TRANS_NOTCREATED, &quot;The 'Create' call for this transmitter has not been called&quot;},
+	{ ERR_RTP_UDPV4TRANS_NOTINIT, &quot;The 'Init' call for this transmitter has not been called&quot;},
+	{ ERR_RTP_UDPV4TRANS_NOTWAITING, &quot;The transmitter is not waiting for incoming data&quot;},
+	{ ERR_RTP_UDPV4TRANS_PORTBASENOTEVEN, &quot;The specified port base is not an even number&quot;},
+	{ ERR_RTP_UDPV4TRANS_SPECIFIEDSIZETOOBIG, &quot;The maximum packet size is too big for this transmitter&quot;},
+	{ ERR_RTP_UDPV6TRANS_ALREADYCREATED, &quot;The transmitter was already created&quot;},
+	{ ERR_RTP_UDPV6TRANS_ALREADYINIT, &quot;The transmitter was already initialize&quot;},
+	{ ERR_RTP_UDPV6TRANS_ALREADYWAITING, &quot;The transmitter is already waiting for incoming data&quot;},
+	{ ERR_RTP_UDPV6TRANS_CANTBINDRTCPSOCKET, &quot;The 'bind' call for the RTCP socket failed&quot;},
+	{ ERR_RTP_UDPV6TRANS_CANTBINDRTPSOCKET, &quot;The 'bind' call for the RTP socket failed&quot;},
+	{ ERR_RTP_UDPV6TRANS_CANTCALCULATELOCALIP, &quot;The local IP addresses could not be determined&quot;},
+	{ ERR_RTP_UDPV6TRANS_CANTCREATEABORTDESCRIPTORS, &quot;Couldn't create the sockets used to abort waiting for incoming data&quot;},
+	{ ERR_RTP_UDPV6TRANS_CANTCREATEPIPE, &quot;Couldn't create the pipe used to abort waiting for incoming data&quot;},
+	{ ERR_RTP_UDPV6TRANS_CANTCREATESOCKET, &quot;Couldn't create the RTP or RTCP socket&quot;},
+	{ ERR_RTP_UDPV6TRANS_CANTINITMUTEX, &quot;Failed to initialize a mutex used by the transmitter&quot;},
+	{ ERR_RTP_UDPV6TRANS_CANTSETRTCPRECEIVEBUF, &quot;Couldn't set the receive buffer size for the RTCP socket&quot;},
+	{ ERR_RTP_UDPV6TRANS_CANTSETRTCPTRANSMITBUF, &quot;Couldn't set the transmission buffer size for the RTCP socket&quot;},
+	{ ERR_RTP_UDPV6TRANS_CANTSETRTPRECEIVEBUF, &quot;Couldn't set the receive buffer size for the RTP socket&quot;},
+	{ ERR_RTP_UDPV6TRANS_CANTSETRTPTRANSMITBUF, &quot;Couldn't set the transmission buffer size for the RTP socket&quot;},
+	{ ERR_RTP_UDPV6TRANS_COULDNTJOINMULTICASTGROUP, &quot;Unable to join the specified multicast group&quot;},
+	{ ERR_RTP_UDPV6TRANS_DIFFERENTRECEIVEMODE, &quot;The function called doens't match the current receive mode&quot;},
+	{ ERR_RTP_UDPV6TRANS_ERRORINSELECT, &quot;Error in the transmitter's 'select' call&quot;},
+	{ ERR_RTP_UDPV6TRANS_ILLEGALPARAMETERS, &quot;Illegal parameters type passed to the transmitter&quot;},
+	{ ERR_RTP_UDPV6TRANS_INVALIDADDRESSTYPE, &quot;Specified address type isn't compatible with this transmitter&quot;},
+	{ ERR_RTP_UDPV6TRANS_NOLOCALIPS, &quot;Couldn't determine the local host name since the local IP list is empty&quot;},
+	{ ERR_RTP_UDPV6TRANS_NOMULTICASTSUPPORT, &quot;Multicast support is not available&quot;},
+	{ ERR_RTP_UDPV6TRANS_NOSUCHENTRY, &quot;Specified entry could not be found&quot;},
+	{ ERR_RTP_UDPV6TRANS_NOTAMULTICASTADDRESS, &quot;The specified address is not a multicast address&quot;},
+	{ ERR_RTP_UDPV6TRANS_NOTCREATED, &quot;The 'Create' call for this transmitter has not been called&quot;},
+	{ ERR_RTP_UDPV6TRANS_NOTINIT, &quot;The 'Init' call for this transmitter has not been called&quot;},
+	{ ERR_RTP_UDPV6TRANS_NOTWAITING, &quot;The transmitter is not waiting for incoming data&quot;},
+	{ ERR_RTP_UDPV6TRANS_PORTBASENOTEVEN, &quot;The specified port base is not an even number&quot;},
+	{ ERR_RTP_UDPV6TRANS_SPECIFIEDSIZETOOBIG, &quot;The maximum packet size is too big for this transmitter&quot;},
+	{ ERR_RTP_TRANS_BUFFERLENGTHTOOSMALL,&quot;The hostname is larger than the specified buffer size&quot;},
+	{ ERR_RTP_SDES_MAXPRIVITEMS,&quot;The maximum number of SDES private item prefixes was reached&quot;},
+	{ ERR_RTP_INTERNALSOURCEDATA_INVALIDPROBATIONTYPE,&quot;An invalid probation type was specified&quot;},
+	{ ERR_RTP_GSTV4TRANS_ALREADYCREATED, &quot;The transmitter was already created&quot;},
+	{ ERR_RTP_GSTV4TRANS_ALREADYINIT, &quot;The transmitter was already initialize&quot;},
+	{ ERR_RTP_GSTV4TRANS_ALREADYWAITING, &quot;The transmitter is already waiting for incoming data&quot;},
+	{ ERR_RTP_GSTV4TRANS_CANTBINDRTCPSOCKET, &quot;The 'bind' call for the RTCP socket failed&quot;},
+	{ ERR_RTP_GSTV4TRANS_CANTBINDRTPSOCKET, &quot;The 'bind' call for the RTP socket failed&quot;},
+	{ ERR_RTP_GSTV4TRANS_CANTCALCULATELOCALIP, &quot;The local IP addresses could not be determined&quot;},
+	{ ERR_RTP_GSTV4TRANS_CANTCREATEABORTDESCRIPTORS, &quot;Couldn't create the sockets used to abort waiting for incoming data&quot;},
+	{ ERR_RTP_GSTV4TRANS_CANTCREATEPIPE, &quot;Couldn't create the pipe used to abort waiting for incoming data&quot;},
+	{ ERR_RTP_GSTV4TRANS_CANTCREATESOCKET, &quot;Couldn't create the RTP or RTCP socket&quot;},
+	{ ERR_RTP_GSTV4TRANS_CANTINITMUTEX, &quot;Failed to initialize a mutex used by the transmitter&quot;},
+	{ ERR_RTP_GSTV4TRANS_CANTSETRTCPRECEIVEBUF, &quot;Couldn't set the receive buffer size for the RTCP socket&quot;},
+	{ ERR_RTP_GSTV4TRANS_CANTSETRTCPTRANSMITBUF, &quot;Couldn't set the transmission buffer size for the RTCP socket&quot;},
+	{ ERR_RTP_GSTV4TRANS_CANTSETRTPRECEIVEBUF, &quot;Couldn't set the receive buffer size for the RTP socket&quot;},
+	{ ERR_RTP_GSTV4TRANS_CANTSETRTPTRANSMITBUF, &quot;Couldn't set the transmission buffer size for the RTP socket&quot;},
+	{ ERR_RTP_GSTV4TRANS_COULDNTJOINMULTICASTGROUP, &quot;Unable to join the specified multicast group&quot;},
+	{ ERR_RTP_GSTV4TRANS_DIFFERENTRECEIVEMODE, &quot;The function called doens't match the current receive mode&quot;},
+	{ ERR_RTP_GSTV4TRANS_ERRORINSELECT, &quot;Error in the transmitter's 'select' call&quot;},
+	{ ERR_RTP_GSTV4TRANS_ILLEGALPARAMETERS, &quot;Illegal parameters type passed to the transmitter&quot;},
+	{ ERR_RTP_GSTV4TRANS_INVALIDADDRESSTYPE, &quot;Specified address type isn't compatible with this transmitter&quot;},
+	{ ERR_RTP_GSTV4TRANS_NOLOCALIPS, &quot;Couldn't determine the local host name since the local IP list is empty&quot;},
+	{ ERR_RTP_GSTV4TRANS_NOMULTICASTSUPPORT, &quot;Multicast support is not available&quot;},
+	{ ERR_RTP_GSTV4TRANS_NOSUCHENTRY, &quot;Specified entry could not be found&quot;},
+	{ ERR_RTP_GSTV4TRANS_NOTAMULTICASTADDRESS, &quot;The specified address is not a multicast address&quot;},
+	{ ERR_RTP_GSTV4TRANS_NOTCREATED, &quot;The 'Create' call for this transmitter has not been called&quot;},
+	{ ERR_RTP_GSTV4TRANS_NOTINIT, &quot;The 'Init' call for this transmitter has not been called&quot;},
+	{ ERR_RTP_GSTV4TRANS_NOTWAITING, &quot;The transmitter is not waiting for incoming data&quot;},
+	{ ERR_RTP_GSTV4TRANS_PORTBASENOTEVEN, &quot;The specified port base is not an even number&quot;},
+	{ ERR_RTP_GSTV4TRANS_SPECIFIEDSIZETOOBIG, &quot;The maximum packet size is too big for this transmitter&quot;},
+	{ ERR_RTP_GSTV4TRANS_INVALIDEVENT, &quot;Expecting UNKNOWN_EVENT to set source address but got another type of event&quot;},
+	{ ERR_RTP_GSTV4TRANS_SRCADDRNOTSET, &quot;Got packet but src address information was not set, returning&quot;},
+	{ ERR_RTP_GSTV4TRANS_NOTNETBUFFER, &quot;Received buffer is not a GstNetBuffer&quot;},
+	{ ERR_RTP_GSTV4TRANS_WAITNOTIMPLEMENTED, &quot;The WaitForIncomingData is not implemented in the Gst transmitter&quot;},
+	{ 0,0 }
+};
+
+std::string RTPGetErrorString(int errcode)
+{
+	int i;
+	
+	if (errcode &gt;= 0)
+		return std::string(&quot;No error&quot;);
+	
+	i = 0;
+	while (ErrorDescriptions[i].code != 0)
+	{
+		if (ErrorDescriptions[i].code == errcode)
+			return std::string(ErrorDescriptions[i].description);
+		i++;
+	}
+	return std::string(&quot;Unknown error code&quot;);
+}
+

Added: konference/src/rtp/jrtplib/rtperrors.h
===================================================================
--- konference/src/rtp/jrtplib/rtperrors.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtperrors.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,202 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPERRORS_H
+
+#define RTPERRORS_H
+
+#include &lt;string&gt;
+
+std::string RTPGetErrorString(int errcode);
+
+#define ERR_RTP_OUTOFMEM					-1
+#define ERR_RTP_NOTHREADSUPPORT					-2
+#define ERR_RTP_COLLISIONLIST_BADADDRESS			-3
+#define ERR_RTP_HASHTABLE_ELEMENTALREADYEXISTS			-4
+#define ERR_RTP_HASHTABLE_ELEMENTNOTFOUND			-5
+#define ERR_RTP_HASHTABLE_FUNCTIONRETURNEDINVALIDHASHINDEX	-6
+#define ERR_RTP_HASHTABLE_NOCURRENTELEMENT			-7
+#define ERR_RTP_KEYHASHTABLE_FUNCTIONRETURNEDINVALIDHASHINDEX	-8
+#define ERR_RTP_KEYHASHTABLE_KEYALREADYEXISTS			-9
+#define ERR_RTP_KEYHASHTABLE_KEYNOTFOUND			-10
+#define ERR_RTP_KEYHASHTABLE_NOCURRENTELEMENT			-11
+#define ERR_RTP_PACKBUILD_ALREADYINIT				-12
+#define ERR_RTP_PACKBUILD_CSRCALREADYINLIST			-13
+#define ERR_RTP_PACKBUILD_CSRCLISTFULL				-14
+#define ERR_RTP_PACKBUILD_CSRCNOTINLIST				-15
+#define ERR_RTP_PACKBUILD_DEFAULTMARKNOTSET			-16
+#define ERR_RTP_PACKBUILD_DEFAULTPAYLOADTYPENOTSET		-17
+#define ERR_RTP_PACKBUILD_DEFAULTTSINCNOTSET			-18
+#define ERR_RTP_PACKBUILD_INVALIDMAXPACKETSIZE			-19
+#define ERR_RTP_PACKBUILD_NOTINIT				-20
+#define ERR_RTP_PACKET_BADPAYLOADTYPE				-21
+#define ERR_RTP_PACKET_DATAEXCEEDSMAXSIZE			-22
+#define ERR_RTP_PACKET_EXTERNALBUFFERNULL			-23
+#define ERR_RTP_PACKET_ILLEGALBUFFERSIZE			-24
+#define ERR_RTP_PACKET_INVALIDPACKET				-25
+#define ERR_RTP_PACKET_TOOMANYCSRCS				-26
+#define ERR_RTP_POLLTHREAD_ALREADYRUNNING			-27
+#define ERR_RTP_POLLTHREAD_CANTINITMUTEX			-28
+#define ERR_RTP_POLLTHREAD_CANTSTARTTHREAD			-29
+#define ERR_RTP_RTCPCOMPOUND_INVALIDPACKET			-30
+#define ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYBUILDING		-31
+#define ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYBUILT		-32
+#define ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYGOTREPORT		-33
+#define ERR_RTP_RTCPCOMPPACKBUILDER_APPDATALENTOOBIG		-34
+#define ERR_RTP_RTCPCOMPPACKBUILDER_BUFFERSIZETOOSMALL		-35
+#define ERR_RTP_RTCPCOMPPACKBUILDER_ILLEGALAPPDATALENGTH	-36
+#define ERR_RTP_RTCPCOMPPACKBUILDER_ILLEGALSUBTYPE		-37
+#define ERR_RTP_RTCPCOMPPACKBUILDER_INVALIDITEMTYPE		-38
+#define ERR_RTP_RTCPCOMPPACKBUILDER_MAXPACKETSIZETOOSMALL	-39
+#define ERR_RTP_RTCPCOMPPACKBUILDER_NOCURRENTSOURCE		-40
+#define ERR_RTP_RTCPCOMPPACKBUILDER_NOREPORTPRESENT		-41
+#define ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING			-42
+#define ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT		-43
+#define ERR_RTP_RTCPCOMPPACKBUILDER_REPORTNOTSTARTED		-44
+#define ERR_RTP_RTCPCOMPPACKBUILDER_TOOMANYSSRCS		-45
+#define ERR_RTP_RTCPCOMPPACKBUILDER_TOTALITEMLENGTHTOOBIG	-46
+#define ERR_RTP_RTCPPACKETBUILDER_ALREADYINIT			-47
+#define ERR_RTP_RTCPPACKETBUILDER_ILLEGALMAXPACKSIZE		-48
+#define ERR_RTP_RTCPPACKETBUILDER_ILLEGALTIMESTAMPUNIT		-49
+#define ERR_RTP_RTCPPACKETBUILDER_NOTINIT			-50
+#define ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON		-51
+#define ERR_RTP_SCHEDPARAMS_BADFRACTION				-52
+#define ERR_RTP_SCHEDPARAMS_BADMINIMUMINTERVAL			-53
+#define ERR_RTP_SCHEDPARAMS_INVALIDBANDWIDTH			-54
+#define ERR_RTP_SDES_LENGTHTOOBIG				-55
+#define ERR_RTP_SDES_MAXPRIVITEMS				-56
+#define ERR_RTP_SDES_PREFIXNOTFOUND				-57
+#define ERR_RTP_SESSION_ALREADYCREATED				-58
+#define ERR_RTP_SESSION_CANTGETLOGINNAME			-59
+#define ERR_RTP_SESSION_CANTINITMUTEX				-60
+#define ERR_RTP_SESSION_MAXPACKETSIZETOOSMALL			-61
+#define ERR_RTP_SESSION_NOTCREATED				-62
+#define ERR_RTP_SESSION_UNSUPPORTEDTRANSMISSIONPROTOCOL		-63
+#define ERR_RTP_SESSION_USINGPOLLTHREAD				-64
+#define ERR_RTP_SOURCES_ALREADYHAVEOWNSSRC			-65
+#define ERR_RTP_SOURCES_DONTHAVEOWNSSRC				-66
+#define ERR_RTP_SOURCES_ILLEGALSDESTYPE				-67
+#define ERR_RTP_SOURCES_SSRCEXISTS				-68
+#define ERR_RTP_TRANS_BUFFERLENGTHTOOSMALL			-69
+#define ERR_RTP_UDPV4TRANS_ALREADYCREATED			-70
+#define ERR_RTP_UDPV4TRANS_ALREADYINIT				-71
+#define ERR_RTP_UDPV4TRANS_ALREADYWAITING			-72
+#define ERR_RTP_UDPV4TRANS_CANTBINDRTCPSOCKET			-73
+#define ERR_RTP_UDPV4TRANS_CANTBINDRTPSOCKET			-74
+#define ERR_RTP_UDPV4TRANS_CANTCALCULATELOCALIP			-75
+#define ERR_RTP_UDPV4TRANS_CANTCREATEABORTDESCRIPTORS		-76
+#define ERR_RTP_UDPV4TRANS_CANTCREATEPIPE			-77
+#define ERR_RTP_UDPV4TRANS_CANTCREATESOCKET			-78
+#define ERR_RTP_UDPV4TRANS_CANTINITMUTEX			-79
+#define ERR_RTP_UDPV4TRANS_CANTSETRTCPRECEIVEBUF		-80
+#define ERR_RTP_UDPV4TRANS_CANTSETRTCPTRANSMITBUF		-81
+#define ERR_RTP_UDPV4TRANS_CANTSETRTPRECEIVEBUF			-82
+#define ERR_RTP_UDPV4TRANS_CANTSETRTPTRANSMITBUF		-83
+#define ERR_RTP_UDPV4TRANS_COULDNTJOINMULTICASTGROUP		-84
+#define ERR_RTP_UDPV4TRANS_DIFFERENTRECEIVEMODE			-85
+#define ERR_RTP_UDPV4TRANS_ERRORINSELECT			-86
+#define ERR_RTP_UDPV4TRANS_ILLEGALPARAMETERS			-87
+#define ERR_RTP_UDPV4TRANS_INVALIDADDRESSTYPE			-88
+#define ERR_RTP_UDPV4TRANS_NOLOCALIPS				-89
+#define ERR_RTP_UDPV4TRANS_NOMULTICASTSUPPORT			-90
+#define ERR_RTP_UDPV4TRANS_NOSUCHENTRY				-91
+#define ERR_RTP_UDPV4TRANS_NOTAMULTICASTADDRESS			-92
+#define ERR_RTP_UDPV4TRANS_NOTCREATED				-93
+#define ERR_RTP_UDPV4TRANS_NOTINIT				-94
+#define ERR_RTP_UDPV4TRANS_NOTWAITING				-95
+#define ERR_RTP_UDPV4TRANS_PORTBASENOTEVEN			-96
+#define ERR_RTP_UDPV4TRANS_SPECIFIEDSIZETOOBIG			-97
+#define ERR_RTP_UDPV6TRANS_ALREADYCREATED			-98
+#define ERR_RTP_UDPV6TRANS_ALREADYINIT				-99
+#define ERR_RTP_UDPV6TRANS_ALREADYWAITING			-100
+#define ERR_RTP_UDPV6TRANS_CANTBINDRTCPSOCKET			-101
+#define ERR_RTP_UDPV6TRANS_CANTBINDRTPSOCKET			-102
+#define ERR_RTP_UDPV6TRANS_CANTCALCULATELOCALIP			-103
+#define ERR_RTP_UDPV6TRANS_CANTCREATEABORTDESCRIPTORS		-104
+#define ERR_RTP_UDPV6TRANS_CANTCREATEPIPE			-105
+#define ERR_RTP_UDPV6TRANS_CANTCREATESOCKET			-106
+#define ERR_RTP_UDPV6TRANS_CANTINITMUTEX			-107
+#define ERR_RTP_UDPV6TRANS_CANTSETRTCPRECEIVEBUF		-108
+#define ERR_RTP_UDPV6TRANS_CANTSETRTCPTRANSMITBUF		-109
+#define ERR_RTP_UDPV6TRANS_CANTSETRTPRECEIVEBUF			-110
+#define ERR_RTP_UDPV6TRANS_CANTSETRTPTRANSMITBUF		-111
+#define ERR_RTP_UDPV6TRANS_COULDNTJOINMULTICASTGROUP		-112
+#define ERR_RTP_UDPV6TRANS_DIFFERENTRECEIVEMODE			-113
+#define ERR_RTP_UDPV6TRANS_ERRORINSELECT			-114
+#define ERR_RTP_UDPV6TRANS_ILLEGALPARAMETERS			-115
+#define ERR_RTP_UDPV6TRANS_INVALIDADDRESSTYPE			-116
+#define ERR_RTP_UDPV6TRANS_NOLOCALIPS				-117
+#define ERR_RTP_UDPV6TRANS_NOMULTICASTSUPPORT			-118
+#define ERR_RTP_UDPV6TRANS_NOSUCHENTRY				-119
+#define ERR_RTP_UDPV6TRANS_NOTAMULTICASTADDRESS			-120
+#define ERR_RTP_UDPV6TRANS_NOTCREATED				-121
+#define ERR_RTP_UDPV6TRANS_NOTINIT				-122
+#define ERR_RTP_UDPV6TRANS_NOTWAITING				-123
+#define ERR_RTP_UDPV6TRANS_PORTBASENOTEVEN			-124
+#define ERR_RTP_UDPV6TRANS_SPECIFIEDSIZETOOBIG			-125
+#define ERR_RTP_INTERNALSOURCEDATA_INVALIDPROBATIONTYPE		-126
+#define ERR_RTP_SESSION_USERDEFINEDTRANSMITTERNULL		-127
+#define ERR_RTP_GSTV4TRANS_ALREADYCREATED			-128
+#define ERR_RTP_GSTV4TRANS_ALREADYINIT				-129
+#define ERR_RTP_GSTV4TRANS_ALREADYWAITING			-130
+#define ERR_RTP_GSTV4TRANS_CANTBINDRTCPSOCKET			-131
+#define ERR_RTP_GSTV4TRANS_CANTBINDRTPSOCKET			-132
+#define ERR_RTP_GSTV4TRANS_CANTCALCULATELOCALIP			-133
+#define ERR_RTP_GSTV4TRANS_CANTCREATEABORTDESCRIPTORS		-134
+#define ERR_RTP_GSTV4TRANS_CANTCREATEPIPE			-135
+#define ERR_RTP_GSTV4TRANS_CANTCREATESOCKET			-136
+#define ERR_RTP_GSTV4TRANS_CANTINITMUTEX			-137
+#define ERR_RTP_GSTV4TRANS_CANTSETRTCPRECEIVEBUF		-138
+#define ERR_RTP_GSTV4TRANS_CANTSETRTCPTRANSMITBUF		-139
+#define ERR_RTP_GSTV4TRANS_CANTSETRTPRECEIVEBUF			-140
+#define ERR_RTP_GSTV4TRANS_CANTSETRTPTRANSMITBUF		-141
+#define ERR_RTP_GSTV4TRANS_COULDNTJOINMULTICASTGROUP		-142
+#define ERR_RTP_GSTV4TRANS_DIFFERENTRECEIVEMODE			-143
+#define ERR_RTP_GSTV4TRANS_ERRORINSELECT			-144
+#define ERR_RTP_GSTV4TRANS_ILLEGALPARAMETERS			-145
+#define ERR_RTP_GSTV4TRANS_INVALIDADDRESSTYPE			-146
+#define ERR_RTP_GSTV4TRANS_NOLOCALIPS				-147
+#define ERR_RTP_GSTV4TRANS_NOMULTICASTSUPPORT			-148
+#define ERR_RTP_GSTV4TRANS_NOSUCHENTRY				-149
+#define ERR_RTP_GSTV4TRANS_NOTAMULTICASTADDRESS			-150
+#define ERR_RTP_GSTV4TRANS_NOTCREATED				-151
+#define ERR_RTP_GSTV4TRANS_NOTINIT				-152
+#define ERR_RTP_GSTV4TRANS_NOTWAITING				-153
+#define ERR_RTP_GSTV4TRANS_PORTBASENOTEVEN			-154
+#define ERR_RTP_GSTV4TRANS_SPECIFIEDSIZETOOBIG			-155
+#define ERR_RTP_GSTV4TRANS_INVALIDEVENT         		-156
+#define ERR_RTP_GSTV4TRANS_SRCADDRNOTSET        		-157
+#define ERR_RTP_GSTV4TRANS_NOTNETBUFFER         		-158
+#define ERR_RTP_GSTV4TRANS_WAITNOTIMPLEMENTED			-159
+
+#endif // RTPERRORS_H
+

Added: konference/src/rtp/jrtplib/rtpgsttransmitter.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpgsttransmitter.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpgsttransmitter.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,1806 @@
+/*
+
+  This class allows for jrtp to send GstBuffers. Allows for integration of RTP 
+  into gstreamer.
+  Copyright (c) 2005 Philippe Khalaf &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">burger at speedy.org</A>&gt;
+  
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2004 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.luc.ac.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.luc.ac.be">http://www.edm.luc.ac.be</A>), a research center of the &quot;Limburgs Universitair
+  Centrum&quot; (<A HREF="http://www.luc.ac.be">http://www.luc.ac.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtpgsttransmitter.h&quot;
+
+#ifdef RTP_SUPPORT_GST
+
+#include &quot;rtprawpacket.h&quot;
+#include &quot;rtpipv4address.h&quot;
+#include &quot;rtptimeutilities.h&quot;
+#include &lt;stdio.h&gt;
+
+#include &lt;net/if.h&gt;
+#include &lt;string.h&gt;
+#include &lt;netdb.h&gt;
+#include &lt;unistd.h&gt;
+
+#ifdef RTP_HAVE_SYS_FILIO
+#include &lt;sys/filio.h&gt;
+#endif // RTP_HAVE_SYS_FILIO
+
+#define RTPIOCTL								ioctl
+
+#ifdef RTPDEBUG
+	#include &lt;iostream&gt;
+#endif // RTPDEBUG
+
+#include &quot;rtpdebug.h&quot;
+
+//GST_DEBUG_CATEGORY (gst_rtp_bin_debug);
+//#define GST_CAT_DEFAULT (gst_rtp_bin_debug)
+
+#define RTPGSTv4TRANS_RTPRECEIVEBUFFER							32768
+#define RTPGSTv4TRANS_RTCPRECEIVEBUFFER							32768
+#define RTPGSTv4TRANS_RTPTRANSMITBUFFER							32768
+#define RTPGSTv4TRANS_RTCPTRANSMITBUFFER						32768
+#define RTPGSTv4TRANS_MAXPACKSIZE							65535
+#define RTPGSTv4TRANS_IFREQBUFSIZE							8192
+
+//#define RTPGSTv4TRANS_IS_MCASTADDR(x)							(((x)&amp;0xF0000000) == 0xE0000000)
+
+/*#define RTPGSTv4TRANS_MCASTMEMBERSHIP(socket,type,mcastip,status)	{\
+										struct ip_mreq mreq;\
+										\
+										mreq.imr_multiaddr.s_addr = htonl(mcastip);\
+										mreq.imr_interface.s_addr = htonl(bindIP);\
+										status = setsockopt(socket,IPPROTO_IP,type,(const char *)&amp;mreq,sizeof(struct ip_mreq));\
+									}*/
+#ifndef RTP_SUPPORT_INLINETEMPLATEPARAM
+	int RTPGSTv4Trans_GetHashIndex_IPv4Dest(const RTPIPv4Destination &amp;d)				{ return d.GetIP_HBO()%RTPGSTv4TRANS_HASHSIZE; }
+	int RTPGSTv4Trans_GetHashIndex_u_int32_t(const u_int32_t &amp;k)					{ return k%RTPGSTv4TRANS_HASHSIZE; }
+#endif // !RTP_SUPPORT_INLINETEMPLATEPARAM
+	
+#ifdef RTP_SUPPORT_THREAD
+	#define MAINMUTEX_LOCK 		{ if (threadsafe) mainmutex.Lock(); }
+	#define MAINMUTEX_UNLOCK	{ if (threadsafe) mainmutex.Unlock(); }
+	#define WAITMUTEX_LOCK		{ if (threadsafe) waitmutex.Lock(); }
+	#define WAITMUTEX_UNLOCK	{ if (threadsafe) waitmutex.Unlock(); }
+#else
+	#define MAINMUTEX_LOCK
+	#define MAINMUTEX_UNLOCK
+	#define WAITMUTEX_LOCK
+	#define WAITMUTEX_UNLOCK
+#endif // RTP_SUPPORT_THREAD
+
+RTPGSTv4Transmitter::RTPGSTv4Transmitter()
+{
+	created = false;
+	init = false;
+}
+
+RTPGSTv4Transmitter::~RTPGSTv4Transmitter()
+{
+	Destroy();
+}
+
+int RTPGSTv4Transmitter::Init(bool tsafe)
+{
+	if (init)
+		return ERR_RTP_GSTV4TRANS_ALREADYINIT;
+	
+#ifdef RTP_SUPPORT_THREAD
+	threadsafe = tsafe;
+	if (threadsafe)
+	{
+		int status;
+		
+		status = mainmutex.Init();
+		if (status &lt; 0)
+			return ERR_RTP_GSTV4TRANS_CANTINITMUTEX;
+		status = waitmutex.Init();
+		if (status &lt; 0)
+			return ERR_RTP_GSTV4TRANS_CANTINITMUTEX;
+	}
+#else
+	if (tsafe)
+		return ERR_RTP_NOTHREADSUPPORT;
+#endif // RTP_SUPPORT_THREAD
+
+	init = true;
+	return 0;
+}
+
+int RTPGSTv4Transmitter::Create(size_t maximumpacketsize,const RTPTransmissionParams *transparams)
+{
+	struct sockaddr_in addr;
+	int status;
+
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+
+	if (created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_ALREADYCREATED;
+	}
+	
+	// Obtain transmission parameters
+	
+	if (transparams == 0)
+		params = new RTPGSTv4TransmissionParams;
+	else
+	{
+		if (transparams-&gt;GetTransmissionProtocol() != RTPTransmitter::IPv4GSTProto)
+			return ERR_RTP_GSTV4TRANS_ILLEGALPARAMETERS;
+		params = (RTPGSTv4TransmissionParams *)transparams;
+	}
+
+	// Check if portbase is even
+	//if (params-&gt;GetPortbase()%2 != 0)
+	//{
+	//	MAINMUTEX_UNLOCK
+	//	return ERR_RTP_GSTV4TRANS_PORTBASENOTEVEN;
+	//}
+
+	// Try to obtain local IP addresses
+
+	localIPs = params-&gt;GetLocalIPList();
+	if (localIPs.empty()) // User did not provide list of local IP addresses, calculate them
+	{
+		int status;
+		
+		if ((status = CreateLocalIPList()) &lt; 0)
+		{
+			MAINMUTEX_UNLOCK
+			return status;
+		}
+#ifdef RTPDEBUG
+		std::cout &lt;&lt; &quot;Found these local IP addresses:&quot; &lt;&lt; std::endl;
+		
+		std::list&lt;u_int32_t&gt;::const_iterator it;
+
+		for (it = localIPs.begin() ; it != localIPs.end() ; it++)
+		{
+			RTPIPv4Address a(*it);
+
+			std::cout &lt;&lt; a.GetAddressString() &lt;&lt; std::endl;
+		}
+#endif // RTPDEBUG
+	}
+
+//#ifdef RTP_SUPPORT_IPV4MULTICAST
+//	if (SetMulticastTTL(params-&gt;GetMulticastTTL()))
+//		supportsmulticasting = true;
+//	else
+//		supportsmulticasting = false;
+//#else // no multicast support enabled
+	supportsmulticasting = false;
+//#endif // RTP_SUPPORT_IPV4MULTICAST
+
+	if (maximumpacketsize &gt; RTPGSTv4TRANS_MAXPACKSIZE)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_SPECIFIEDSIZETOOBIG;
+	}
+	
+	maxpacksize = maximumpacketsize;
+	portbase = params-&gt;GetPortbase();
+	multicastTTL = params-&gt;GetMulticastTTL();
+	receivemode = RTPTransmitter::AcceptAll;
+
+	localhostname = 0;
+	localhostnamelength = 0;
+
+	rtppackcount = 0;
+	rtcppackcount = 0;
+	
+	waitingfordata = false;
+	created = true;
+
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+void RTPGSTv4Transmitter::Destroy()
+{
+	if (!init)
+		return;
+
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK;
+		return;
+	}
+
+	if (localhostname)
+	{
+		delete [] localhostname;
+		localhostname = 0;
+		localhostnamelength = 0;
+	}
+	
+	destinations.Clear();
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+//	multicastgroups.Clear();
+#endif // RTP_SUPPORT_IPV4MULTICAST
+	FlushPackets();
+	ClearAcceptIgnoreInfo();
+	localIPs.clear();
+	created = false;
+    delete params;
+	
+	MAINMUTEX_UNLOCK
+}
+
+RTPTransmissionInfo *RTPGSTv4Transmitter::GetTransmissionInfo()
+{
+	if (!init)
+		return 0;
+
+	MAINMUTEX_LOCK
+	RTPTransmissionInfo *tinf = new RTPGSTv4TransmissionInfo(localIPs, 
+            params-&gt;GetGstRTPSrc(), params-&gt;GetGstRTPSrc(), params);
+	MAINMUTEX_UNLOCK
+	return tinf;
+}
+
+int RTPGSTv4Transmitter::GetLocalHostName(u_int8_t *buffer,size_t *bufferlength)
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+
+	if (localhostname == 0)
+	{
+		if (localIPs.empty())
+		{
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_GSTV4TRANS_NOLOCALIPS;
+		}
+		
+		std::list&lt;u_int32_t&gt;::const_iterator it;
+		std::list&lt;std::string&gt; hostnames;
+	
+		for (it = localIPs.begin() ; it != localIPs.end() ; it++)
+		{
+			struct hostent *he;
+			u_int8_t addr[4];
+			u_int32_t ip = (*it);
+	
+			addr[0] = (u_int8_t)((ip&gt;&gt;24)&amp;0xFF);
+			addr[1] = (u_int8_t)((ip&gt;&gt;16)&amp;0xFF);
+			addr[2] = (u_int8_t)((ip&gt;&gt;8)&amp;0xFF);
+			addr[3] = (u_int8_t)(ip&amp;0xFF);
+			he = gethostbyaddr((char *)addr,4,AF_INET);
+			if (he != 0)
+			{
+				std::string hname = std::string(he-&gt;h_name);
+				hostnames.push_back(hname);
+			}
+		}
+	
+		bool found  = false;
+		
+		if (!hostnames.empty())	// try to select the most appropriate hostname
+		{
+			std::list&lt;std::string&gt;::const_iterator it;
+			
+			for (it = hostnames.begin() ; !found &amp;&amp; it != hostnames.end() ; it++)
+			{
+				if ((*it).find('.') != std::string::npos)
+				{
+					found = true;
+					localhostnamelength = (*it).length();
+					localhostname = new u_int8_t [localhostnamelength+1];
+					if (localhostname == 0)
+					{
+						MAINMUTEX_UNLOCK
+						return ERR_RTP_OUTOFMEM;
+					}
+					memcpy(localhostname,(*it).c_str(),localhostnamelength);
+					localhostname[localhostnamelength] = 0;
+				}
+			}
+		}
+	
+		if (!found) // use an IP address
+		{
+			u_int32_t ip;
+			int len;
+			char str[256];
+			
+			it = localIPs.begin();
+			ip = (*it);
+			
+			sprintf(str,&quot;%d.%d.%d.%d&quot;,(int)((ip&gt;&gt;24)&amp;0xFF),(int)((ip&gt;&gt;16)&amp;0xFF),(int)((ip&gt;&gt;8)&amp;0xFF),(int)(ip&amp;0xFF));
+			len = strlen(str);
+	
+			localhostnamelength = len;
+			localhostname = new u_int8_t [localhostnamelength + 1];
+			if (localhostname == 0)
+			{
+				MAINMUTEX_UNLOCK
+				return ERR_RTP_OUTOFMEM;
+			}
+			memcpy(localhostname,str,localhostnamelength);
+			localhostname[localhostnamelength] = 0;
+		}
+	}
+	
+	if ((*bufferlength) &lt; localhostnamelength)
+	{
+		*bufferlength = localhostnamelength; // tell the application the required size of the buffer
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_TRANS_BUFFERLENGTHTOOSMALL;
+	}
+
+	memcpy(buffer,localhostname,localhostnamelength);
+	*bufferlength = localhostnamelength;
+	
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+bool RTPGSTv4Transmitter::ComesFromThisTransmitter(const RTPAddress *addr)
+{
+	if (!init)
+		return false;
+
+	if (addr == 0)
+		return false;
+	
+	MAINMUTEX_LOCK
+	
+	bool v;
+		
+	if (created &amp;&amp; addr-&gt;GetAddressType() == RTPAddress::IPv4Address)
+	{	
+		const RTPIPv4Address *addr2 = (const RTPIPv4Address *)addr;
+		bool found = false;
+		std::list&lt;u_int32_t&gt;::const_iterator it;
+	
+		it = localIPs.begin();
+		while (!found &amp;&amp; it != localIPs.end())
+		{
+			if (addr2-&gt;GetIP() == *it)
+				found = true;
+			else
+				++it;
+		}
+	
+		if (!found)
+			v = false;
+		else
+		{
+			if (addr2-&gt;GetPort() == params-&gt;GetPortbase()) // check for RTP port
+				v = true;
+			else if (addr2-&gt;GetPort() == (params-&gt;GetPortbase()+1)) // check for RTCP port
+				v = true;
+			else 
+				v = false;
+		}
+	}
+	else
+		v = false;
+
+	MAINMUTEX_UNLOCK
+	return v;
+}
+
+int RTPGSTv4Transmitter::Poll()
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+
+	int status;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	status = FakePoll(); // poll RTP socket
+    params-&gt;SetCurrentData(NULL);
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPGSTv4Transmitter::WaitForIncomingData(const RTPTime &amp;delay,bool *dataavailable)
+{
+/*	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	fd_set fdset;
+	struct timeval tv;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (waitingfordata)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_ALREADYWAITING;
+	}
+	
+	FD_ZERO(&amp;fdset);
+	FD_SET(rtpsock,&amp;fdset);
+	FD_SET(rtcpsock,&amp;fdset);
+	FD_SET(abortdesc[0],&amp;fdset);
+	tv.tv_sec = delay.GetSeconds();
+	tv.tv_usec = delay.GetMicroSeconds();
+	
+	waitingfordata = true;
+	
+	WAITMUTEX_LOCK
+	MAINMUTEX_UNLOCK
+
+	if (select(FD_SETSIZE,&amp;fdset,0,0,&amp;tv) &lt; 0)
+	{
+		MAINMUTEX_LOCK
+		waitingfordata = false;
+		MAINMUTEX_UNLOCK
+		WAITMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_ERRORINSELECT;
+	}
+	
+	MAINMUTEX_LOCK
+	waitingfordata = false;
+	if (!created) // destroy called
+	{
+		MAINMUTEX_UNLOCK;
+		WAITMUTEX_UNLOCK
+		return 0;
+	}
+		
+	// if aborted, read from abort buffer
+	if (FD_ISSET(abortdesc[0],&amp;fdset))
+	{
+#ifdef WIN32
+		char buf[1];
+		
+		recv(abortdesc[0],buf,1,0);
+#else 
+		unsigned char buf[1];
+
+		read(abortdesc[0],buf,1);
+#endif // WIN32
+	}
+	
+	MAINMUTEX_UNLOCK
+	WAITMUTEX_UNLOCK
+	return 0;*/
+	return ERR_RTP_GSTV4TRANS_WAITNOTIMPLEMENTED;
+}
+
+int RTPGSTv4Transmitter::AbortWait()
+{
+/*	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (!waitingfordata)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTWAITING;
+	}
+
+	AbortWaitInternal();
+	
+	MAINMUTEX_UNLOCK
+	return 0;*/
+	return 0;
+}
+
+int RTPGSTv4Transmitter::SendRTPData(const void *data,size_t len)	
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+    GstNetBuffer *out_buf;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (len &gt; maxpacksize)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_SPECIFIEDSIZETOOBIG;
+	}
+
+
+	destinations.GotoFirstElement();
+    // send to each destination
+	while (destinations.HasCurrentElement())
+	{
+        // create GstNetBuffer from data
+        out_buf = gst_netbuffer_new ();
+        GST_BUFFER_DATA (out_buf) = (guint8*)data;
+        GST_BUFFER_SIZE (out_buf) = len;
+        gst_netaddress_set_ip4_address (&amp;out_buf-&gt;to, destinations.GetCurrentElement().GetIP_NBO(),
+                destinations.GetCurrentElement().GetRTPPort_NBO());
+        GST_DEBUG(&quot;Sending RTP packet to ip %d port %d&quot;, destinations.GetCurrentElement().GetIP_NBO(), 
+                destinations.GetCurrentElement().GetRTPPort_NBO());
+
+        // push data
+        gst_pad_push( params-&gt;GetGstRTPSrc(), GST_BUFFER(out_buf) );
+		destinations.GotoNextElement();
+	}
+	
+	rtppackcount++;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+int RTPGSTv4Transmitter::SendRTCPData(const void *data,size_t len)
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+
+    // if it's NULL we dont want to transmit RTCPs
+    if (params-&gt;GetGstRTCPSrc() == NULL)
+    {
+        return 0;
+    }
+    
+	MAINMUTEX_LOCK
+
+    GstNetBuffer *out_buf;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (len &gt; maxpacksize)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_SPECIFIEDSIZETOOBIG;
+	}
+
+	destinations.GotoFirstElement();
+    // send to each destination
+	while (destinations.HasCurrentElement())
+	{
+        // create GstNetBuffer from data
+        out_buf = gst_netbuffer_new ();
+        GST_BUFFER_DATA (out_buf) = (guint8 *)data;
+        GST_BUFFER_SIZE (out_buf) = len;
+        gst_netaddress_set_ip4_address (&amp;out_buf-&gt;to, destinations.GetCurrentElement().GetIP_NBO(),
+                destinations.GetCurrentElement().GetRTCPPort_NBO());
+        GST_DEBUG(&quot;Sending RTCP packet&quot;);
+
+        // push data
+        gst_pad_push( params-&gt;GetGstRTCPSrc(), GST_BUFFER(out_buf) );
+		destinations.GotoNextElement();
+	}
+	
+	rtcppackcount++;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+void RTPGSTv4Transmitter::ResetPacketCount()
+{
+	if (!init)
+		return;
+
+	MAINMUTEX_LOCK
+	if (created)
+	{
+		rtppackcount = 0;
+		rtcppackcount = 0;	
+	}
+	MAINMUTEX_UNLOCK	
+}
+
+u_int32_t RTPGSTv4Transmitter::GetNumRTPPacketsSent()
+{
+	if (!init)
+		return 0;
+
+	MAINMUTEX_LOCK
+	
+	u_int32_t num;
+
+	if (!created)
+		num = 0;
+	else
+		num = rtppackcount;
+
+	MAINMUTEX_UNLOCK
+
+	return num;
+}
+
+u_int32_t RTPGSTv4Transmitter::GetNumRTCPPacketsSent()
+{
+	if (!init)
+		return 0;
+	
+	MAINMUTEX_LOCK
+	
+	u_int32_t num;
+
+	if (!created)
+		num = 0;
+	else
+		num = rtcppackcount;
+
+	MAINMUTEX_UNLOCK
+
+	return num;
+}
+	
+int RTPGSTv4Transmitter::AddDestination(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	RTPIPv4Address &amp;address = (RTPIPv4Address &amp;)addr;
+	RTPIPv4Destination dest(address.GetIP(),address.GetPort());
+	int status = destinations.AddElement(dest);
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPGSTv4Transmitter::DeleteDestination(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	RTPIPv4Address &amp;address = (RTPIPv4Address &amp;)addr;	
+	RTPIPv4Destination dest(address.GetIP(),address.GetPort());
+	int status = destinations.DeleteElement(dest);
+	
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPGSTv4Transmitter::ClearDestinations()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created)
+		destinations.Clear();
+	MAINMUTEX_UNLOCK
+}
+
+bool RTPGSTv4Transmitter::SupportsMulticasting()
+{
+	if (!init)
+		return false;
+	
+	MAINMUTEX_LOCK
+	
+	bool v;
+		
+	if (!created)
+		v = false;
+	else
+		v = supportsmulticasting;
+
+	MAINMUTEX_UNLOCK
+	return v;
+}
+
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+
+int RTPGSTv4Transmitter::JoinMulticastGroup(const RTPAddress &amp;addr)
+{
+// hrrm wonder how will manage to get multicast info thru to the UDPSINK
+/*	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	const RTPIPv4Address &amp;address = (const RTPIPv4Address &amp;)addr;
+	u_int32_t mcastIP = address.GetIP();
+	
+	if (!RTPGSTv4TRANS_IS_MCASTADDR(mcastIP))
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTAMULTICASTADDRESS;
+	}
+	
+	status = multicastgroups.AddElement(mcastIP);
+	if (status &gt;= 0)
+	{
+		RTPGSTv4TRANS_MCASTMEMBERSHIP(rtpsock,IP_ADD_MEMBERSHIP,mcastIP,status);
+		if (status != 0)
+		{
+			multicastgroups.DeleteElement(mcastIP);
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_GSTV4TRANS_COULDNTJOINMULTICASTGROUP;
+		}
+		RTPGSTv4TRANS_MCASTMEMBERSHIP(rtcpsock,IP_ADD_MEMBERSHIP,mcastIP,status);
+		if (status != 0)
+		{
+			RTPGSTv4TRANS_MCASTMEMBERSHIP(rtpsock,IP_DROP_MEMBERSHIP,mcastIP,status);
+			multicastgroups.DeleteElement(mcastIP);
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_GSTV4TRANS_COULDNTJOINMULTICASTGROUP;
+		}
+	}
+	MAINMUTEX_UNLOCK	
+	return status;*/
+	return ERR_RTP_GSTV4TRANS_NOMULTICASTSUPPORT;
+}
+
+int RTPGSTv4Transmitter::LeaveMulticastGroup(const RTPAddress &amp;addr)
+{
+    /*
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	const RTPIPv4Address &amp;address = (const RTPIPv4Address &amp;)addr;
+	u_int32_t mcastIP = address.GetIP();
+	
+	if (!RTPGSTv4TRANS_IS_MCASTADDR(mcastIP))
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTAMULTICASTADDRESS;
+	}
+	
+	status = multicastgroups.DeleteElement(mcastIP);
+	if (status &gt;= 0)
+	{	
+		RTPGSTv4TRANS_MCASTMEMBERSHIP(rtpsock,IP_DROP_MEMBERSHIP,mcastIP,status);
+		RTPGSTv4TRANS_MCASTMEMBERSHIP(rtcpsock,IP_DROP_MEMBERSHIP,mcastIP,status);
+		status = 0;
+	}
+	
+	MAINMUTEX_UNLOCK
+	return status;
+    */
+	return ERR_RTP_GSTV4TRANS_NOMULTICASTSUPPORT;
+}
+
+void RTPGSTv4Transmitter::LeaveAllMulticastGroups()
+{
+/*	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created)
+	{
+		multicastgroups.GotoFirstElement();
+		while (multicastgroups.HasCurrentElement())
+		{
+			u_int32_t mcastIP;
+			int status = 0;
+
+			mcastIP = multicastgroups.GetCurrentElement();
+			RTPGSTv4TRANS_MCASTMEMBERSHIP(rtpsock,IP_DROP_MEMBERSHIP,mcastIP,status);
+			RTPGSTv4TRANS_MCASTMEMBERSHIP(rtcpsock,IP_DROP_MEMBERSHIP,mcastIP,status);
+			multicastgroups.GotoNextElement();
+		}
+		multicastgroups.Clear();
+	}
+	MAINMUTEX_UNLOCK*/
+}
+
+#else // no multicast support
+
+int RTPGSTv4Transmitter::JoinMulticastGroup(const RTPAddress &amp;addr)
+{
+	return ERR_RTP_GSTV4TRANS_NOMULTICASTSUPPORT;
+}
+
+int RTPGSTv4Transmitter::LeaveMulticastGroup(const RTPAddress &amp;addr)
+{
+	return ERR_RTP_GSTV4TRANS_NOMULTICASTSUPPORT;
+}
+
+void RTPGSTv4Transmitter::LeaveAllMulticastGroups()
+{
+}
+
+#endif // RTP_SUPPORT_IPV4MULTICAST
+
+int RTPGSTv4Transmitter::SetReceiveMode(RTPTransmitter::ReceiveMode m)
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (m != receivemode)
+	{
+		receivemode = m;
+		acceptignoreinfo.Clear();
+	}
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+int RTPGSTv4Transmitter::AddToIgnoreList(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	int status;
+
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::IgnoreSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv4Address &amp;address = (const RTPIPv4Address &amp;)addr;
+	status = ProcessAddAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+	
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPGSTv4Transmitter::DeleteFromIgnoreList(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::IgnoreSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv4Address &amp;address = (const RTPIPv4Address &amp;)addr;	
+	status = ProcessDeleteAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPGSTv4Transmitter::ClearIgnoreList()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created &amp;&amp; receivemode == RTPTransmitter::IgnoreSome)
+		ClearAcceptIgnoreInfo();
+	MAINMUTEX_UNLOCK
+}
+
+int RTPGSTv4Transmitter::AddToAcceptList(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::AcceptSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv4Address &amp;address = (const RTPIPv4Address &amp;)addr;
+	status = ProcessAddAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPGSTv4Transmitter::DeleteFromAcceptList(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::AcceptSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv4Address &amp;address = (const RTPIPv4Address &amp;)addr;
+	status = ProcessDeleteAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPGSTv4Transmitter::ClearAcceptList()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created &amp;&amp; receivemode == RTPTransmitter::AcceptSome)
+		ClearAcceptIgnoreInfo();
+	MAINMUTEX_UNLOCK
+}
+
+int RTPGSTv4Transmitter::SetMaximumPacketSize(size_t s)	
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (s &gt; RTPGSTv4TRANS_MAXPACKSIZE)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_SPECIFIEDSIZETOOBIG;
+	}
+	maxpacksize = s;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+bool RTPGSTv4Transmitter::NewDataAvailable()
+{
+	if (!init)
+		return false;
+	
+	MAINMUTEX_LOCK
+	
+	bool v;
+		
+	if (!created)
+		v = false;
+	else
+	{
+		if (rawpacketlist.empty())
+			v = false;
+		else
+			v = true;
+	}
+	
+	MAINMUTEX_UNLOCK
+	return v;
+}
+
+RTPRawPacket *RTPGSTv4Transmitter::GetNextPacket()
+{
+	if (!init)
+		return 0;
+	
+	MAINMUTEX_LOCK
+	
+	RTPRawPacket *p;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return 0;
+	}
+	if (rawpacketlist.empty())
+	{
+		MAINMUTEX_UNLOCK
+		return 0;
+	}
+
+	p = *(rawpacketlist.begin());
+	rawpacketlist.pop_front();
+
+	MAINMUTEX_UNLOCK
+	return p;
+}
+
+// Here the private functions start...
+
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+bool RTPGSTv4Transmitter::SetMulticastTTL(u_int8_t ttl)
+{
+/*	int ttl2,status;
+
+	ttl2 = (int)ttl;
+	status = setsockopt(rtpsock,IPPROTO_IP,IP_MULTICAST_TTL,(const char *)&amp;ttl2,sizeof(int));
+	if (status != 0)
+		return false;
+	status = setsockopt(rtcpsock,IPPROTO_IP,IP_MULTICAST_TTL,(const char *)&amp;ttl2,sizeof(int));
+	if (status != 0)
+		return false;
+	return true;*/
+}
+#endif // RTP_SUPPORT_IPV4MULTICAST
+
+void RTPGSTv4Transmitter::FlushPackets()
+{
+	std::list&lt;RTPRawPacket*&gt;::const_iterator it;
+
+	for (it = rawpacketlist.begin() ; it != rawpacketlist.end() ; ++it)
+		delete (*it);
+	rawpacketlist.clear();
+}
+
+int RTPGSTv4Transmitter::FakePoll()
+{
+    int recvlen;
+    GstNetBuffer *packetbuffer;
+
+    RTPTime curtime = RTPTime::CurrentTime();
+
+    packetbuffer = params-&gt;GetCurrentData();
+    bool rtp = params-&gt;GetCurrentDataType();
+    // lets make sure we got something
+    if (packetbuffer == NULL )
+    {
+        //GST_DEBUG(&quot;No packetbuffer to poll&quot;);
+        return 0;
+    }
+    // should be a netbuffer
+    if (GST_IS_NETBUFFER (packetbuffer))
+    {
+        guint16 senderport;
+        guint32 senderaddr;
+        // let's get the address from the netbuffer
+        gst_netaddress_get_ip4_address (&amp;packetbuffer-&gt;from, &amp;senderaddr, &amp;senderport);
+        RTPIPv4Address *addr = new RTPIPv4Address(ntohl(senderaddr), ntohs(senderport));
+        if (addr == 0)
+        {
+            return ERR_RTP_OUTOFMEM;
+        }
+        GST_DEBUG(&quot;Got netbuffer, saving src info %d %d&quot;, addr-&gt;GetIP(), addr-&gt;GetPort());
+        // ok we got the src addr, now this should be the actual packet
+        recvlen = GST_BUFFER_SIZE(packetbuffer);
+        if (GST_BUFFER_DATA(packetbuffer) &amp;&amp; recvlen &gt; 0)
+        {
+            GST_DEBUG(&quot;Got packet %d&quot;, recvlen);
+            bool acceptdata;
+
+            // got data, process it
+            if (receivemode == RTPTransmitter::AcceptAll)
+                acceptdata = true;
+            else
+                acceptdata = ShouldAcceptData(addr-&gt;GetIP(),addr-&gt;GetPort());
+
+            if (acceptdata)
+            {
+                GST_DEBUG(&quot;Adding packet to queue&quot;);
+                RTPRawPacket *pack;
+                u_int8_t *datacopy;
+
+                datacopy = new u_int8_t[recvlen];
+                if (datacopy == 0)
+                {
+                    delete addr;
+                    return ERR_RTP_OUTOFMEM;
+                }
+                memcpy(datacopy, GST_BUFFER_DATA(packetbuffer),recvlen);
+                pack = new RTPRawPacket(datacopy,recvlen,addr,curtime,rtp);
+
+                GST_DEBUG(&quot;lenght %d is RTP? %d&quot;, pack-&gt;GetDataLength(), pack-&gt;IsRTP());
+                if (pack == 0)
+                {
+                    delete addr;
+                    delete [] datacopy;
+                    return ERR_RTP_OUTOFMEM;
+                }
+                rawpacketlist.push_back(pack);	
+            }
+        }
+    } else {
+        return ERR_RTP_GSTV4TRANS_NOTNETBUFFER;
+    }
+    return 0;
+}
+
+int RTPGSTv4Transmitter::ProcessAddAcceptIgnoreEntry(u_int32_t ip,u_int16_t port)
+{
+	acceptignoreinfo.GotoElement(ip);
+	if (acceptignoreinfo.HasCurrentElement()) // An entry for this IP address already exists
+	{
+		PortInfo *portinf = acceptignoreinfo.GetCurrentElement();
+		
+		if (port == 0) // select all ports
+		{
+			portinf-&gt;all = true;
+			portinf-&gt;portlist.clear();
+		}
+		else if (!portinf-&gt;all)
+		{
+			std::list&lt;u_int16_t&gt;::const_iterator it,begin,end;
+
+			begin = portinf-&gt;portlist.begin();
+			end = portinf-&gt;portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == port) // already in list
+					return 0;
+			}
+			portinf-&gt;portlist.push_front(port);
+		}
+	}
+	else // got to create an entry for this IP address
+	{
+		PortInfo *portinf;
+		int status;
+		
+		portinf = new PortInfo();
+		if (port == 0) // select all ports
+			portinf-&gt;all = true;
+		else
+			portinf-&gt;portlist.push_front(port);
+		
+		status = acceptignoreinfo.AddElement(ip,portinf);
+		if (status &lt; 0)
+		{
+			delete portinf;
+			return status;
+		}
+	}
+
+	return 0;
+}
+
+void RTPGSTv4Transmitter::ClearAcceptIgnoreInfo()
+{
+	acceptignoreinfo.GotoFirstElement();
+	while (acceptignoreinfo.HasCurrentElement())
+	{
+		PortInfo *inf;
+
+		inf = acceptignoreinfo.GetCurrentElement();
+		delete inf;
+		acceptignoreinfo.GotoNextElement();
+	}
+	acceptignoreinfo.Clear();
+}
+	
+int RTPGSTv4Transmitter::ProcessDeleteAcceptIgnoreEntry(u_int32_t ip,u_int16_t port)
+{
+	acceptignoreinfo.GotoElement(ip);
+	if (!acceptignoreinfo.HasCurrentElement())
+		return ERR_RTP_GSTV4TRANS_NOSUCHENTRY;
+	
+	PortInfo *inf;
+
+	inf = acceptignoreinfo.GetCurrentElement();
+	if (port == 0) // delete all entries
+	{
+		inf-&gt;all = false;
+		inf-&gt;portlist.clear();
+	}
+	else // a specific port was selected
+	{
+		if (inf-&gt;all) // currently, all ports are selected. Add the one to remove to the list
+		{
+			// we have to check if the list doesn't contain the port already
+			std::list&lt;u_int16_t&gt;::const_iterator it,begin,end;
+
+			begin = inf-&gt;portlist.begin();
+			end = inf-&gt;portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == port) // already in list: this means we already deleted the entry
+					return ERR_RTP_GSTV4TRANS_NOSUCHENTRY;
+			}
+			inf-&gt;portlist.push_front(port);
+		}
+		else // check if we can find the port in the list
+		{
+			std::list&lt;u_int16_t&gt;::iterator it,begin,end;
+			
+			begin = inf-&gt;portlist.begin();
+			end = inf-&gt;portlist.end();
+			for (it = begin ; it != end ; ++it)
+			{
+				if (*it == port) // found it!
+				{
+					inf-&gt;portlist.erase(it);
+					return 0;
+				}
+			}
+			// didn't find it
+			return ERR_RTP_GSTV4TRANS_NOSUCHENTRY;			
+		}
+	}
+	return 0;
+}
+
+bool RTPGSTv4Transmitter::ShouldAcceptData(u_int32_t srcip,u_int16_t srcport)
+{
+	if (receivemode == RTPTransmitter::AcceptSome)
+	{
+		PortInfo *inf;
+
+		acceptignoreinfo.GotoElement(srcip);
+		if (!acceptignoreinfo.HasCurrentElement())
+			return false;
+		
+		inf = acceptignoreinfo.GetCurrentElement();
+		if (!inf-&gt;all) // only accept the ones in the list
+		{
+			std::list&lt;u_int16_t&gt;::const_iterator it,begin,end;
+
+			begin = inf-&gt;portlist.begin();
+			end = inf-&gt;portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return true;
+			}
+			return false;
+		}
+		else // accept all, except the ones in the list
+		{
+			std::list&lt;u_int16_t&gt;::const_iterator it,begin,end;
+
+			begin = inf-&gt;portlist.begin();
+			end = inf-&gt;portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return false;
+			}
+			return true;
+		}
+	}
+	else // IgnoreSome
+	{
+		PortInfo *inf;
+
+		acceptignoreinfo.GotoElement(srcip);
+		if (!acceptignoreinfo.HasCurrentElement())
+			return true;
+		
+		inf = acceptignoreinfo.GetCurrentElement();
+		if (!inf-&gt;all) // ignore the ports in the list
+		{
+			std::list&lt;u_int16_t&gt;::const_iterator it,begin,end;
+
+			begin = inf-&gt;portlist.begin();
+			end = inf-&gt;portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return false;
+			}
+			return true;
+		}
+		else // ignore all, except the ones in the list
+		{
+			std::list&lt;u_int16_t&gt;::const_iterator it,begin,end;
+
+			begin = inf-&gt;portlist.begin();
+			end = inf-&gt;portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return true;
+			}
+			return false;
+		}
+	}
+	return true;
+}
+
+#ifdef WIN32
+
+int RTPGSTv4Transmitter::CreateAbortDescriptors()
+{
+    // no need for these no more
+/*
+	SOCKET listensock;
+	int size;
+	struct sockaddr_in addr;
+
+	listensock = socket(PF_INET,SOCK_STREAM,0);
+	if (listensock == RTPSOCKERR)
+		return ERR_RTP_GSTV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	
+	memset(&amp;addr,0,sizeof(struct sockaddr_in));
+	addr.sin_family = AF_INET;
+	if (bind(listensock,(struct sockaddr *)&amp;addr,sizeof(struct sockaddr_in)) != 0)
+	{
+		RTPCLOSE(listensock);
+		return ERR_RTP_GSTV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&amp;addr,0,sizeof(struct sockaddr_in));
+	size = sizeof(struct sockaddr_in);
+	if (getsockname(listensock,(struct sockaddr*)&amp;addr,&amp;size) != 0)
+	{
+		RTPCLOSE(listensock);
+		return ERR_RTP_GSTV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	unsigned short connectport = ntohs(addr.sin_port);
+
+	abortdesc[0] = socket(PF_INET,SOCK_STREAM,0);
+	if (abortdesc[0] == RTPSOCKERR)
+	{
+		RTPCLOSE(listensock);
+		return ERR_RTP_GSTV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&amp;addr,0,sizeof(struct sockaddr_in));
+	addr.sin_family = AF_INET;
+	if (bind(abortdesc[0],(struct sockaddr *)&amp;addr,sizeof(struct sockaddr_in)) != 0)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_GSTV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	if (listen(listensock,1) != 0)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_GSTV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&amp;addr,0,sizeof(struct sockaddr_in));
+	addr.sin_family = AF_INET;
+	addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);
+	addr.sin_port = htons(connectport);
+	
+	if (connect(abortdesc[0],(struct sockaddr *)&amp;addr,sizeof(struct sockaddr_in)) != 0)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_GSTV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&amp;addr,0,sizeof(struct sockaddr_in));
+	size = sizeof(struct sockaddr_in);
+	abortdesc[1] = accept(listensock,(struct sockaddr *)&amp;addr,&amp;size);
+	if (abortdesc[1] == RTPSOCKERR)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_GSTV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	// okay, got the connection, close the listening socket
+
+	RTPCLOSE(listensock);
+	return 0;*/
+}
+
+void RTPGSTv4Transmitter::DestroyAbortDescriptors()
+{
+//	RTPCLOSE(abortdesc[0]);
+//	RTPCLOSE(abortdesc[1]);
+}
+
+#else // in a non winsock environment we can use pipes
+
+int RTPGSTv4Transmitter::CreateAbortDescriptors()
+{
+//	if (pipe(abortdesc) &lt; 0)
+//		return ERR_RTP_GSTV4TRANS_CANTCREATEPIPE;
+//	return 0;
+}
+
+void RTPGSTv4Transmitter::DestroyAbortDescriptors()
+{
+//	close(abortdesc[0]);
+//	close(abortdesc[1]);
+}
+
+#endif // WIN32
+
+int RTPGSTv4Transmitter::CreateLocalIPList()
+{
+	 // first try to obtain the list from the network interface info
+
+	if (!GetLocalIPList_Interfaces())
+	{
+		// If this fails, we'll have to depend on DNS info
+		GetLocalIPList_DNS();
+	}
+	AddLoopbackAddress();
+	return 0;
+}
+
+//#ifdef WIN32
+
+bool RTPGSTv4Transmitter::GetLocalIPList_Interfaces()
+{
+	// REMINDER: got to find out how to do this
+	return false;
+}
+/*
+#else // use ioctl
+
+bool RTPGSTv4Transmitter::GetLocalIPList_Interfaces()
+{
+	int status;
+	char buffer[RTPGSTv4TRANS_IFREQBUFSIZE];
+	struct ifconf ifc;
+	struct ifreq *ifr;
+	struct sockaddr *sa;
+	char *startptr,*endptr;
+	int remlen;
+	
+	ifc.ifc_len = RTPGSTv4TRANS_IFREQBUFSIZE;
+	ifc.ifc_buf = buffer;
+	status = ioctl(rtpsock,SIOCGIFCONF,&amp;ifc);
+	if (status &lt; 0)
+		return false;
+	
+	startptr = (char *)ifc.ifc_req;
+	endptr = startptr + ifc.ifc_len;
+	remlen = ifc.ifc_len;
+	while((startptr &lt; endptr) &amp;&amp; remlen &gt;= (int)sizeof(struct ifreq))
+	{
+		ifr = (struct ifreq *)startptr;
+		sa = &amp;(ifr-&gt;ifr_addr);
+#ifdef RTP_HAVE_SOCKADDR_LEN
+		if (sa-&gt;sa_len &lt;= sizeof(struct sockaddr))
+		{
+			if (sa-&gt;sa_len == sizeof(struct sockaddr_in) &amp;&amp; sa-&gt;sa_family == PF_INET)
+			{
+				u_int32_t ip;
+				struct sockaddr_in *addr = (struct sockaddr_in *)sa;
+				
+				ip = ntohl(addr-&gt;sin_addr.s_addr);
+				localIPs.push_back(ip);
+			}
+			remlen -= sizeof(struct ifreq);
+			startptr += sizeof(struct ifreq);
+		}
+		else
+		{
+			int l = sa-&gt;sa_len-sizeof(struct sockaddr)+sizeof(struct ifreq);
+			
+			remlen -= l;
+			startptr += l;
+		}
+#else // don't have sa_len in struct sockaddr
+		if (sa-&gt;sa_family == PF_INET)
+		{
+			u_int32_t ip;
+			struct sockaddr_in *addr = (struct sockaddr_in *)sa;
+		
+			ip = ntohl(addr-&gt;sin_addr.s_addr);
+			localIPs.push_back(ip);
+		}
+		remlen -= sizeof(struct ifreq);
+		startptr += sizeof(struct ifreq);
+	
+#endif // RTP_HAVE_SOCKADDR_LEN
+	}
+
+	if (localIPs.empty())
+		return false;
+	return true;
+}
+
+#endif // WIN32
+*/
+void RTPGSTv4Transmitter::GetLocalIPList_DNS()
+{
+	struct hostent *he;
+	char name[1024];
+	u_int32_t ip;
+	bool done;
+	int i,j;
+
+	gethostname(name,1023);
+	name[1023] = 0;
+	he = gethostbyname(name);
+	if (he == 0)
+		return;
+	
+	ip = 0;
+	i = 0;
+	done = false;
+	while (!done)
+	{
+		if (he-&gt;h_addr_list[i] == NULL)
+			done = true;
+		else
+		{
+			ip = 0;
+			for (j = 0 ; j &lt; 4 ; j++)
+				ip |= ((u_int32_t)((unsigned char)he-&gt;h_addr_list[i][j])&lt;&lt;((3-j)*8));
+			localIPs.push_back(ip);
+			i++;
+		}
+	}
+}
+
+void RTPGSTv4Transmitter::AbortWaitInternal()
+{
+/*#ifdef WIN32
+	send(abortdesc[1],&quot;*&quot;,1,0);
+#else
+	write(abortdesc[1],&quot;*&quot;,1);
+#endif // WIN32*/
+}
+
+void RTPGSTv4Transmitter::AddLoopbackAddress()
+{
+	u_int32_t loopbackaddr = (((u_int32_t)127)&lt;&lt;24)|((u_int32_t)1);
+	std::list&lt;u_int32_t&gt;::const_iterator it;
+	bool found = false;
+	
+	for (it = localIPs.begin() ; !found &amp;&amp; it != localIPs.end() ; it++)
+	{
+		if (*it == loopbackaddr)
+			found = true;
+	}
+
+	if (!found)
+		localIPs.push_back(loopbackaddr);
+}
+
+#ifdef RTPDEBUG
+void RTPGSTv4Transmitter::Dump()
+{
+	if (!init)
+		std::cout &lt;&lt; &quot;Not initialized&quot; &lt;&lt; std::endl;
+	else
+	{
+		MAINMUTEX_LOCK
+	
+		if (!created)
+			std::cout &lt;&lt; &quot;Not created&quot; &lt;&lt; std::endl;
+		else
+		{
+			char str[1024];
+			u_int32_t ip;
+			std::list&lt;u_int32_t&gt;::const_iterator it;
+			
+			std::cout &lt;&lt; &quot;Portbase:                       &quot; &lt;&lt; params-&gt;GetPortbase() &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;Local IP addresses:&quot; &lt;&lt; std::endl;
+			for (it = localIPs.begin() ; it != localIPs.end() ; it++)
+			{
+				ip = (*it);
+				sprintf(str,&quot;%d.%d.%d.%d&quot;,(int)((ip&gt;&gt;24)&amp;0xFF),(int)((ip&gt;&gt;16)&amp;0xFF),(int)((ip&gt;&gt;8)&amp;0xFF),(int)(ip&amp;0xFF));
+				std::cout &lt;&lt; &quot;    &quot; &lt;&lt; str &lt;&lt; std::endl;
+			}
+//			std::cout &lt;&lt; &quot;Multicast TTL:                  &quot; &lt;&lt; (int)multicastTTL &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;Receive mode:                   &quot;;
+			switch (receivemode)
+			{
+			case RTPTransmitter::AcceptAll:
+				std::cout &lt;&lt; &quot;Accept all&quot;;
+				break;
+			case RTPTransmitter::AcceptSome:
+				std::cout &lt;&lt; &quot;Accept some&quot;;
+				break;
+			case RTPTransmitter::IgnoreSome:
+				std::cout &lt;&lt; &quot;Ignore some&quot;;
+			}
+			std::cout &lt;&lt; std::endl;
+			if (receivemode != RTPTransmitter::AcceptAll)
+			{
+				acceptignoreinfo.GotoFirstElement();
+				while(acceptignoreinfo.HasCurrentElement())
+				{
+					ip = acceptignoreinfo.GetCurrentKey();
+					sprintf(str,&quot;%d.%d.%d.%d&quot;,(int)((ip&gt;&gt;24)&amp;0xFF),(int)((ip&gt;&gt;16)&amp;0xFF),(int)((ip&gt;&gt;8)&amp;0xFF),(int)(ip&amp;0xFF));
+					PortInfo *pinfo = acceptignoreinfo.GetCurrentElement();
+					std::cout &lt;&lt; &quot;    &quot; &lt;&lt; str &lt;&lt; &quot;: &quot;;
+					if (pinfo-&gt;all)
+					{
+						std::cout &lt;&lt; &quot;All ports&quot;;
+						if (!pinfo-&gt;portlist.empty())
+							std::cout &lt;&lt; &quot;, except &quot;;
+					}
+					
+					std::list&lt;u_int16_t&gt;::const_iterator it;
+					
+					for (it = pinfo-&gt;portlist.begin() ; it != pinfo-&gt;portlist.end() ; )
+					{
+						std::cout &lt;&lt; (*it);
+						it++;
+						if (it != pinfo-&gt;portlist.end())
+							std::cout &lt;&lt; &quot;, &quot;;
+					}
+					std::cout &lt;&lt; std::endl;
+				}
+			}
+			
+			std::cout &lt;&lt; &quot;Local host name:                &quot;;
+			if (localhostname == 0)
+				std::cout &lt;&lt; &quot;Not set&quot;;
+			else
+				std::cout &lt;&lt; localhostname;
+			std::cout &lt;&lt; std::endl;
+
+			std::cout &lt;&lt; &quot;List of destinations:           &quot;;
+			destinations.GotoFirstElement();
+			if (destinations.HasCurrentElement())
+			{
+				std::cout &lt;&lt; std::endl;
+				do
+				{
+					std::cout &lt;&lt; &quot;    &quot; &lt;&lt; destinations.GetCurrentElement().GetDestinationString() &lt;&lt; std::endl;
+					destinations.GotoNextElement();
+				} while (destinations.HasCurrentElement());
+			}
+			else
+				std::cout &lt;&lt; &quot;Empty&quot; &lt;&lt; std::endl;
+		
+			std::cout &lt;&lt; &quot;Supports multicasting:          &quot; &lt;&lt; ((supportsmulticasting)?&quot;Yes&quot;:&quot;No&quot;) &lt;&lt; std::endl;
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+/*			std::cout &lt;&lt; &quot;List of multicast groups:       &quot;;
+			multicastgroups.GotoFirstElement();
+			if (multicastgroups.HasCurrentElement())
+			{
+				std::cout &lt;&lt; std::endl;
+				do
+				{
+					ip = multicastgroups.GetCurrentElement();
+					sprintf(str,&quot;%d.%d.%d.%d&quot;,(int)((ip&gt;&gt;24)&amp;0xFF),(int)((ip&gt;&gt;16)&amp;0xFF),(int)((ip&gt;&gt;8)&amp;0xFF),(int)(ip&amp;0xFF));
+					std::cout &lt;&lt; &quot;    &quot; &lt;&lt; str &lt;&lt; std::endl;
+					multicastgroups.GotoNextElement();
+				} while (multicastgroups.HasCurrentElement());
+			}
+			else
+				std::cout &lt;&lt; &quot;Empty&quot; &lt;&lt; std::endl;*/
+#endif // RTP_SUPPORT_IPV4MULTICAST
+			
+			std::cout &lt;&lt; &quot;Number of raw packets in queue: &quot; &lt;&lt; rawpacketlist.size() &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;Maximum allowed packet size:    &quot; &lt;&lt; maxpacksize &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;RTP packet count:               &quot; &lt;&lt; rtppackcount &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;RTCP packet count:              &quot; &lt;&lt; rtcppackcount &lt;&lt; std::endl;
+		}
+		
+		MAINMUTEX_UNLOCK
+	}
+}
+#endif // RTPDEBUG
+
+#endif // RTP_SUPPORT_GST
+

Added: konference/src/rtp/jrtplib/rtpgsttransmitter.h
===================================================================
--- konference/src/rtp/jrtplib/rtpgsttransmitter.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpgsttransmitter.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,234 @@
+/*
+
+  This class allows for jrtp to send GstBuffers. Allows for integration of RTP 
+  into gstreamer.
+  Copyright (c) 2005 Philippe Khalaf &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">burger at speedy.org</A>&gt;
+  
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2004 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.luc.ac.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.luc.ac.be">http://www.edm.luc.ac.be</A>), a research center of the &quot;Limburgs Universitair
+  Centrum&quot; (<A HREF="http://www.luc.ac.be">http://www.luc.ac.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPGSTV4TRANSMITTER_H
+
+#define RTPGSTV4TRANSMITTER_H
+
+#include &quot;rtpconfig.h&quot;
+
+#ifdef RTP_SUPPORT_GST
+
+#include &quot;rtptransmitter.h&quot;
+#include &quot;rtpipv4destination.h&quot;
+#include &quot;rtphashtable.h&quot;
+#include &quot;rtpkeyhashtable.h&quot;
+#include &lt;list&gt;
+
+#include &lt;gst/gst.h&gt;
+#include &lt;gst/net/gstnetbuffer.h&gt;
+
+#ifdef RTP_SUPPORT_THREAD
+	#include &lt;jmutex.h&gt;
+#endif // RTP_SUPPORT_THREAD
+
+#define RTPGSTv4TRANS_HASHSIZE									8317
+#define RTPGSTv4TRANS_DEFAULTPORTBASE								5000
+
+class RTPGSTv4TransmissionParams : public RTPTransmissionParams
+{
+public:
+	RTPGSTv4TransmissionParams():RTPTransmissionParams(RTPTransmitter::IPv4GSTProto)	{ portbase = RTPGSTv4TRANS_DEFAULTPORTBASE; bindIP = 0; multicastTTL = 1; rtpsrcpad = NULL, rtcpsrcpad = NULL; currentdata = NULL;}
+	void SetBindIP(u_int32_t ip)								{ bindIP = ip; }
+	void SetPortbase(u_int16_t pbase)							{ portbase = pbase; }
+	void SetMulticastTTL(u_int8_t mcastTTL)							{ multicastTTL = mcastTTL; }
+	void SetLocalIPList(std::list&lt;u_int32_t&gt; &amp;iplist)					{ localIPs = iplist; } 
+	void ClearLocalIPList()									{ localIPs.clear(); }
+    void SetGstRTPSrc(GstPad *src)                          { rtpsrcpad = src; }
+    void SetGstRTCPSrc(GstPad *src)                          { rtcpsrcpad = src; }
+    void SetCurrentData(GstNetBuffer *data)                      { currentdata = data; }
+    void SetCurrentDataType(bool type)                      { currentdatatype = type; }
+	u_int32_t GetBindIP() const								{ return bindIP; }
+	u_int16_t GetPortbase() const								{ return portbase; }
+	u_int8_t GetMulticastTTL() const							{ return multicastTTL; }
+	const std::list&lt;u_int32_t&gt; &amp;GetLocalIPList() const					{ return localIPs; }
+    GstPad* GetGstRTPSrc() const                         { return rtpsrcpad; }
+    GstPad* GetGstRTCPSrc() const                          { return rtcpsrcpad; }
+    GstNetBuffer* GetCurrentData() const                     { return currentdata; }
+    bool GetCurrentDataType() const                     { return currentdatatype; }
+private:
+	u_int16_t portbase;
+	u_int32_t bindIP;
+	std::list&lt;u_int32_t&gt; localIPs;
+	u_int8_t multicastTTL;
+    GstPad *rtpsrcpad;
+    GstPad *rtcpsrcpad;
+    bool currentdatatype;
+    GstNetBuffer* currentdata;
+};
+
+class RTPGSTv4TransmissionInfo : public RTPTransmissionInfo
+{
+public:
+	RTPGSTv4TransmissionInfo(std::list&lt;u_int32_t&gt; iplist,
+            GstPad* rtpsrc, GstPad* rtcpsrc, RTPGSTv4TransmissionParams *transparams) : 
+        RTPTransmissionInfo(RTPTransmitter::IPv4GSTProto) 
+    { localIPlist = iplist; rtpsrcpad = rtpsrc;
+        rtcpsrcpad = rtcpsrc; params = transparams; } 
+
+	~RTPGSTv4TransmissionInfo()								{ }
+	std::list&lt;u_int32_t&gt; GetLocalIPList() const						{ return localIPlist; }
+    GstPad* GetGstRTPSrc()                          { return rtpsrcpad; }
+    GstPad* GetGstRTCPSrc()                          { return rtcpsrcpad; }
+    RTPGSTv4TransmissionParams* GetTransParams()             { return params; }
+private:
+	std::list&lt;u_int32_t&gt; localIPlist;
+    GstPad *rtpsrcpad;
+    GstPad *rtcpsrcpad;
+    RTPGSTv4TransmissionParams *params;
+};
+	
+#ifdef RTP_SUPPORT_INLINETEMPLATEPARAM
+	inline int RTPGSTv4Trans_GetHashIndex_IPv4Dest(const RTPIPv4Destination &amp;d)				{ return d.GetIP_HBO()%RTPGSTv4TRANS_HASHSIZE; }
+	inline int RTPGSTv4Trans_GetHashIndex_u_int32_t(const u_int32_t &amp;k)					{ return k%RTPGSTv4TRANS_HASHSIZE; }
+#else // No support for inline function as template parameter
+	int RTPGSTv4Trans_GetHashIndex_IPv4Dest(const RTPIPv4Destination &amp;d);
+	int RTPGSTv4Trans_GetHashIndex_u_int32_t(const u_int32_t &amp;k);
+#endif // RTP_SUPPORT_INLINETEMPLATEPARAM
+
+#define RTPGSTv4TRANS_HEADERSIZE						(20+8)
+	
+class RTPGSTv4Transmitter : public RTPTransmitter
+{
+public:
+	RTPGSTv4Transmitter();
+	~RTPGSTv4Transmitter();
+
+	int Init(bool treadsafe);
+	int Create(size_t maxpacksize,const RTPTransmissionParams *transparams);
+	void Destroy();
+	RTPTransmissionInfo *GetTransmissionInfo();
+
+	int GetLocalHostName(u_int8_t *buffer,size_t *bufferlength);
+	bool ComesFromThisTransmitter(const RTPAddress *addr);
+	size_t GetHeaderOverhead()							{ return RTPGSTv4TRANS_HEADERSIZE; }
+	
+	int Poll();
+	int WaitForIncomingData(const RTPTime &amp;delay,bool *dataavailable = 0);
+	int AbortWait();
+	
+	int SendRTPData(const void *data,size_t len);	
+	int SendRTCPData(const void *data,size_t len);
+
+	void ResetPacketCount();
+	u_int32_t GetNumRTPPacketsSent();
+	u_int32_t GetNumRTCPPacketsSent();
+				
+	int AddDestination(const RTPAddress &amp;addr);
+	int DeleteDestination(const RTPAddress &amp;addr);
+	void ClearDestinations();
+
+	bool SupportsMulticasting();
+	int JoinMulticastGroup(const RTPAddress &amp;addr);
+	int LeaveMulticastGroup(const RTPAddress &amp;addr);
+	void LeaveAllMulticastGroups();
+
+	int SetReceiveMode(RTPTransmitter::ReceiveMode m);
+	int AddToIgnoreList(const RTPAddress &amp;addr);
+	int DeleteFromIgnoreList(const RTPAddress &amp;addr);
+	void ClearIgnoreList();
+	int AddToAcceptList(const RTPAddress &amp;addr);
+	int DeleteFromAcceptList(const RTPAddress &amp;addr);
+	void ClearAcceptList();
+	int SetMaximumPacketSize(size_t s);	
+	
+	bool NewDataAvailable();
+	RTPRawPacket *GetNextPacket();
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+private:
+	int CreateLocalIPList();
+	bool GetLocalIPList_Interfaces();
+	void GetLocalIPList_DNS();
+	void AddLoopbackAddress();
+	void FlushPackets();
+	int FakePoll();
+	int ProcessAddAcceptIgnoreEntry(u_int32_t ip,u_int16_t port);
+	int ProcessDeleteAcceptIgnoreEntry(u_int32_t ip,u_int16_t port);
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+	bool SetMulticastTTL(u_int8_t ttl);
+#endif // RTP_SUPPORT_IPV4MULTICAST
+	bool ShouldAcceptData(u_int32_t srcip,u_int16_t srcport);
+	void ClearAcceptIgnoreInfo();
+	
+    RTPGSTv4TransmissionParams *params;
+	bool init;
+	bool created;
+	bool waitingfordata;
+	std::list&lt;u_int32_t&gt; localIPs;
+	u_int16_t portbase;
+	u_int8_t multicastTTL;
+	RTPTransmitter::ReceiveMode receivemode;
+
+	u_int8_t *localhostname;
+	size_t localhostnamelength;
+	
+	RTPHashTable&lt;const RTPIPv4Destination,RTPGSTv4Trans_GetHashIndex_IPv4Dest,RTPGSTv4TRANS_HASHSIZE&gt; destinations;
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+//	RTPHashTable&lt;const u_int32_t,RTPGSTv4Trans_GetHashIndex_u_int32_t,RTPGSTv4TRANS_HASHSIZE&gt; multicastgroups;
+#endif // RTP_SUPPORT_IPV4MULTICAST
+	std::list&lt;RTPRawPacket*&gt; rawpacketlist;
+
+	bool supportsmulticasting;
+	size_t maxpacksize;
+
+	class PortInfo
+	{
+	public:
+		PortInfo() { all = false; }
+		
+		bool all;
+		std::list&lt;u_int16_t&gt; portlist;
+	};
+
+	RTPKeyHashTable&lt;const u_int32_t,PortInfo*,RTPGSTv4Trans_GetHashIndex_u_int32_t,RTPGSTv4TRANS_HASHSIZE&gt; acceptignoreinfo;
+
+	int CreateAbortDescriptors();
+	void DestroyAbortDescriptors();
+	void AbortWaitInternal();
+#ifdef RTP_SUPPORT_THREAD
+	JMutex mainmutex,waitmutex;
+	int threadsafe;
+#endif // RTP_SUPPORT_THREAD
+
+	u_int32_t rtppackcount,rtcppackcount;
+};
+
+#endif // RTP_SUPPORT_GST
+
+#endif // RTPGSTv4TRANSMITTER_H
+

Added: konference/src/rtp/jrtplib/rtphashtable.h
===================================================================
--- konference/src/rtp/jrtplib/rtphashtable.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtphashtable.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,325 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPHASHTABLE_H
+
+#define RTPHASHTABLE_H
+
+#include &quot;rtperrors.h&quot;
+
+#ifdef RTPDEBUG
+#include &lt;iostream&gt;
+#endif // RTPDEBUG
+
+template&lt;class Element,int GetIndex(const Element &amp;k),int hashsize&gt;
+class RTPHashTable
+{
+public:
+	RTPHashTable();
+	~RTPHashTable()						{ Clear(); }
+
+	void GotoFirstElement()					{ curhashelem = firsthashelem; }
+	void GotoLastElement()					{ curhashelem = lasthashelem; }
+	bool HasCurrentElement()				{ return (curhashelem == 0)?false:true; }
+	int DeleteCurrentElement();
+	Element &amp;GetCurrentElement()				{ return curhashelem-&gt;GetElement(); }
+	int GotoElement(const Element &amp;e);
+	bool HasElement(const Element &amp;e);
+	void GotoNextElement();
+	void GotoPreviousElement();
+	void Clear();
+
+	int AddElement(const Element &amp;elem);
+	int DeleteElement(const Element &amp;elem);
+
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+private:
+	class HashElement
+	{
+	public:
+		HashElement(const Element &amp;e,int index):element(e) { hashprev = 0; hashnext = 0; listnext = 0; listprev = 0; hashindex = index; }
+		int GetHashIndex() 						{ return hashindex; }
+		Element &amp;GetElement()						{ return element; }
+#ifdef RTPDEBUG
+		void Dump()							{ std::cout &lt;&lt; &quot;\tHash index &quot; &lt;&lt; hashindex &lt;&lt; &quot; | Element &quot; &lt;&lt; element &lt;&lt; std::endl; }
+#endif // RTPDEBUG
+	private:
+		int hashindex;
+		Element element;
+	public:
+		HashElement *hashprev,*hashnext;
+		HashElement *listprev,*listnext;
+	};
+
+	HashElement *table[hashsize];
+	HashElement *firsthashelem,*lasthashelem;
+	HashElement *curhashelem;
+};
+
+template&lt;class Element,int GetIndex(const Element &amp;e),int hashsize&gt;
+inline RTPHashTable&lt;Element,GetIndex,hashsize&gt;::RTPHashTable()
+{
+	for (int i = 0 ; i &lt; hashsize ; i++)
+		table[i] = 0;
+	firsthashelem = 0;
+	lasthashelem = 0;
+}
+
+template&lt;class Element,int GetIndex(const Element &amp;e),int hashsize&gt;
+inline int RTPHashTable&lt;Element,GetIndex,hashsize&gt;::DeleteCurrentElement()
+{
+	if (curhashelem)
+	{
+		HashElement *tmp1,*tmp2;
+		int index;
+		
+		// First, relink elements in current hash bucket
+		
+		index = curhashelem-&gt;GetHashIndex();
+		tmp1 = curhashelem-&gt;hashprev;
+		tmp2 = curhashelem-&gt;hashnext;
+		if (tmp1 == 0) // no previous element in hash bucket
+		{
+			table[index] = tmp2;
+			if (tmp2 != 0)
+				tmp2-&gt;hashprev = 0;
+		}
+		else // there is a previous element in the hash bucket
+		{
+			tmp1-&gt;hashnext = tmp2;
+			if (tmp2 != 0)
+				tmp2-&gt;hashprev = 0;
+		}
+
+		// Relink elements in list
+		
+		tmp1 = curhashelem-&gt;listprev;
+		tmp2 = curhashelem-&gt;listnext;
+		if (tmp1 == 0) // curhashelem is first in list
+		{
+			firsthashelem = tmp2;
+			if (tmp2 != 0)
+				tmp2-&gt;listprev = 0;
+			else // curhashelem is also last in list
+				lasthashelem = 0;	
+		}
+		else
+		{
+			tmp1-&gt;listnext = tmp2;
+			if (tmp2 != 0)
+				tmp2-&gt;listprev = tmp1;
+			else // curhashelem is last in list
+				lasthashelem = tmp1;
+		}
+		
+		// finally, with everything being relinked, we can delete curhashelem
+		delete curhashelem;
+		curhashelem = tmp2; // Set to next element in the list
+	}
+	else
+		return ERR_RTP_HASHTABLE_NOCURRENTELEMENT;
+	return 0;
+}
+
+template&lt;class Element,int GetIndex(const Element &amp;e),int hashsize&gt;
+inline int RTPHashTable&lt;Element,GetIndex,hashsize&gt;::GotoElement(const Element &amp;e)
+{
+	int index;
+	bool found;
+	
+	index = GetIndex(e);
+	if (index &gt;= hashsize)
+		return ERR_RTP_HASHTABLE_FUNCTIONRETURNEDINVALIDHASHINDEX;
+	
+	curhashelem = table[index]; 
+	found = false;
+	while(!found &amp;&amp; curhashelem != 0)
+	{
+		if (curhashelem-&gt;GetElement() == e)
+			found = true;
+		else
+			curhashelem = curhashelem-&gt;hashnext;
+	}
+	if (!found)
+		return ERR_RTP_HASHTABLE_ELEMENTNOTFOUND;
+	return 0;
+}
+
+template&lt;class Element,int GetIndex(const Element &amp;e),int hashsize&gt;
+inline bool RTPHashTable&lt;Element,GetIndex,hashsize&gt;::HasElement(const Element &amp;e)
+{
+	int index;
+	bool found;
+	HashElement *tmp;
+	
+	index = GetIndex(e);
+	if (index &gt;= hashsize)
+		return false;
+	
+	tmp = table[index]; 
+	found = false;
+	while(!found &amp;&amp; tmp != 0)
+	{
+		if (tmp-&gt;GetElement() == e)
+			found = true;
+		else
+			tmp = tmp-&gt;hashnext;
+	}
+	return found;
+}
+
+template&lt;class Element,int GetIndex(const Element &amp;e),int hashsize&gt;
+inline void RTPHashTable&lt;Element,GetIndex,hashsize&gt;::GotoNextElement()
+{
+	if (curhashelem)
+		curhashelem = curhashelem-&gt;listnext;
+}
+
+template&lt;class Element,int GetIndex(const Element &amp;e),int hashsize&gt;
+inline void RTPHashTable&lt;Element,GetIndex,hashsize&gt;::GotoPreviousElement()
+{
+	if (curhashelem)
+		curhashelem = curhashelem-&gt;listprev;
+}
+
+template&lt;class Element,int GetIndex(const Element &amp;e),int hashsize&gt;
+inline void RTPHashTable&lt;Element,GetIndex,hashsize&gt;::Clear()
+{
+	HashElement *tmp1,*tmp2;
+	
+	for (int i = 0 ; i &lt; hashsize ; i++)
+		table[i] = 0;
+	
+	tmp1 = firsthashelem;
+	while (tmp1 != 0)
+	{
+		tmp2 = tmp1-&gt;listnext;
+		delete tmp1;
+		tmp1 = tmp2;
+	}
+	firsthashelem = 0;
+	lasthashelem = 0;
+}
+
+template&lt;class Element,int GetIndex(const Element &amp;e),int hashsize&gt;
+inline int RTPHashTable&lt;Element,GetIndex,hashsize&gt;::AddElement(const Element &amp;elem)
+{
+	int index;
+	bool found;
+	HashElement *e,*newelem;
+	
+	index = GetIndex(elem);
+	if (index &gt;= hashsize)
+		return ERR_RTP_HASHTABLE_FUNCTIONRETURNEDINVALIDHASHINDEX;
+	
+	e = table[index];
+	found = false;
+	while(!found &amp;&amp; e != 0)
+	{
+		if (e-&gt;GetElement() == elem)
+			found = true;
+		else
+			e = e-&gt;hashnext;
+	}
+	if (found)
+		return ERR_RTP_HASHTABLE_ELEMENTALREADYEXISTS;
+	
+	// Okay, the key doesn't exist, so we can add the new element in the hash table
+	
+	newelem = new HashElement(elem,index);
+	if (newelem == 0)
+		return ERR_RTP_OUTOFMEM;
+
+	e = table[index];
+	table[index] = newelem;
+	newelem-&gt;hashnext = e;
+	if (e != 0)
+		e-&gt;hashprev = newelem;
+	
+	// Now, we still got to add it to the linked list
+	
+	if (firsthashelem == 0)
+	{
+		firsthashelem = newelem;
+		lasthashelem = newelem;
+	}
+	else // there already are some elements in the list
+	{
+		lasthashelem-&gt;listnext = newelem;
+		newelem-&gt;listprev = lasthashelem;
+		lasthashelem = newelem;
+	}
+	return 0;
+}
+
+template&lt;class Element,int GetIndex(const Element &amp;e),int hashsize&gt;
+inline int RTPHashTable&lt;Element,GetIndex,hashsize&gt;::DeleteElement(const Element &amp;elem)
+{
+	int status;
+
+	status = GotoElement(elem);
+	if (status &lt; 0)
+		return status;
+	return DeleteCurrentElement();
+}
+
+#ifdef RTPDEBUG
+template&lt;class Element,int GetIndex(const Element &amp;e),int hashsize&gt;
+inline void RTPHashTable&lt;Element,GetIndex,hashsize&gt;::Dump()
+{
+	HashElement *e;
+	
+	std::cout &lt;&lt; &quot;DUMPING TABLE CONTENTS:&quot; &lt;&lt; std::endl;
+	for (int i = 0 ; i &lt; hashsize ; i++)
+	{
+		e = table[i];
+		while (e != 0)
+		{
+			e-&gt;Dump();
+			e = e-&gt;hashnext;
+		}
+	}
+	
+	std::cout &lt;&lt; &quot;DUMPING LIST CONTENTS:&quot; &lt;&lt; std::endl;
+	e = firsthashelem;
+	while (e != 0)
+	{
+		e-&gt;Dump();
+		e = e-&gt;listnext;
+	}
+}
+#endif // RTPDEBUG
+
+#endif // RTPHASHTABLE_H
+

Added: konference/src/rtp/jrtplib/rtpinternalsourcedata.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpinternalsourcedata.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpinternalsourcedata.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,282 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtpinternalsourcedata.h&quot;
+#include &quot;rtppacket.h&quot;
+#include &lt;string.h&gt;
+
+#include &quot;rtpdebug.h&quot;
+
+#define RTPINTERNALSOURCEDATA_MAXPROBATIONPACKETS		32
+
+RTPInternalSourceData::RTPInternalSourceData(u_int32_t ssrc,RTPSources::ProbationType probtype):RTPSourceData(ssrc)
+{
+#ifdef RTP_SUPPORT_PROBATION
+	probationtype = probtype;
+#endif // RTP_SUPPORT_PROBATION
+}
+
+RTPInternalSourceData::~RTPInternalSourceData()
+{
+}
+
+// The following function should delete rtppack if necessary
+int RTPInternalSourceData::ProcessRTPPacket(RTPPacket *rtppack,const RTPTime &amp;receivetime,bool *stored)
+{
+	bool accept,onprobation,applyprobation;
+	double tsunit;
+	
+	*stored = false;
+	
+	if (timestampunit &lt; 0) 
+		tsunit = INF_GetEstimatedTimestampUnit();
+	else
+		tsunit = timestampunit;
+
+#ifdef RTP_SUPPORT_PROBATION
+	if (validated) 				// If the source is our own process, we can already be validated. No 
+		applyprobation = false;		// probation should be applied in that case.
+	else
+	{
+		if (probationtype == RTPSources::NoProbation)
+			applyprobation = false;
+		else
+			applyprobation = true;
+	}
+#else
+	applyprobation = false;
+#endif // RTP_SUPPORT_PROBATION
+
+	stats.ProcessPacket(rtppack,receivetime,tsunit,ownssrc,&amp;accept,applyprobation,&amp;onprobation);
+
+#ifdef RTP_SUPPORT_PROBATION
+	switch (probationtype)
+	{
+		case RTPSources::ProbationStore:
+			if (!(onprobation || accept))
+				return 0;
+			if (accept)
+				validated = true;
+			break;
+		case RTPSources::ProbationDiscard:
+		case RTPSources::NoProbation:
+			if (!accept)
+				return 0;
+			validated = true;
+			break;
+		default:
+			return ERR_RTP_INTERNALSOURCEDATA_INVALIDPROBATIONTYPE;
+	}
+#else
+	if (!accept)
+		return 0;
+	validated = true;
+#endif // RTP_SUPPORT_PROBATION;
+	
+	if (validated &amp;&amp; !ownssrc) // for own ssrc these variables depend on the outgoing packets, not on the incoming
+		issender = true;
+	
+	// Now, we can place the packet in the queue
+	
+	if (packetlist.empty())
+	{
+		*stored = true;
+		packetlist.push_back(rtppack);
+		return 0;
+	}
+	
+	if (!validated) // still on probation
+	{
+		// Make sure that we don't buffer too much packets to avoid wasting memory
+		// on a bad source. Delete the packet in the queue with the lowest sequence
+		// number.
+		if (packetlist.size() == RTPINTERNALSOURCEDATA_MAXPROBATIONPACKETS)
+		{
+			RTPPacket *p = *(packetlist.begin());
+			packetlist.pop_front();
+			delete p;
+		}
+	}
+
+	// find the right position to insert the packet
+	
+	std::list&lt;RTPPacket*&gt;::iterator it,start;
+	bool done = false;
+	u_int32_t newseqnr = rtppack-&gt;GetExtendedSequenceNumber();
+	
+	it = packetlist.end();
+	--it;
+	start = packetlist.begin();
+	
+	while (!done)
+	{
+		RTPPacket *p;
+		u_int32_t seqnr;
+		
+		p = *it;
+		seqnr = p-&gt;GetExtendedSequenceNumber();
+		if (seqnr &gt; newseqnr)
+		{
+			if (it != start)
+				--it;
+			else // we're at the start of the list
+			{
+				*stored = true;
+				done = true;
+				packetlist.push_front(rtppack);
+			}
+		}
+		else if (seqnr &lt; newseqnr) // insert after this packet
+		{
+			++it;
+			packetlist.insert(it,rtppack);
+			done = true;
+			*stored = true;
+		}
+		else // they're equal !! Drop packet
+		{
+			done = true;
+		}
+	}
+
+	return 0;
+}
+
+int RTPInternalSourceData::ProcessSDESItem(u_int8_t id,const u_int8_t *data,size_t itemlen,const RTPTime &amp;receivetime,bool *cnamecollis)
+{
+	*cnamecollis = false;
+	
+	stats.SetLastMessageTime(receivetime);
+	
+	switch(id)
+	{
+	case RTCP_SDES_ID_CNAME:
+		{
+			size_t curlen;
+			u_int8_t *oldcname;
+			
+			// NOTE: we're going to make sure that the CNAME is only set once.
+			oldcname = SDESinf.GetCNAME(&amp;curlen);
+			if (curlen == 0)
+			{
+				// if CNAME is set, the source is validated
+				SDESinf.SetCNAME(data,itemlen);
+				validated = true;
+			}
+			else // check if this CNAME is equal to the one that is already present
+			{
+				if (curlen != itemlen)
+					*cnamecollis = true;
+				else
+				{
+					if (memcmp(data,oldcname,itemlen) != 0)
+						*cnamecollis = true;
+				}
+			}
+		}
+		break;
+	case RTCP_SDES_ID_NAME:
+		{
+			u_int8_t *oldname;
+			size_t oldlen;
+
+			oldname = SDESinf.GetName(&amp;oldlen);
+			if (oldlen == 0) // Name not set
+				return SDESinf.SetName(data,itemlen);
+		}
+		break;
+	case RTCP_SDES_ID_EMAIL:
+		{
+			u_int8_t *oldemail;
+			size_t oldlen;
+
+			oldemail = SDESinf.GetEMail(&amp;oldlen);
+			if (oldlen == 0)
+				return SDESinf.SetEMail(data,itemlen);
+		}
+		break;
+	case RTCP_SDES_ID_PHONE:
+		return SDESinf.SetPhone(data,itemlen);
+	case RTCP_SDES_ID_LOCATION:
+		return SDESinf.SetLocation(data,itemlen);
+	case RTCP_SDES_ID_TOOL:
+		{
+			u_int8_t *oldtool;
+			size_t oldlen;
+
+			oldtool = SDESinf.GetTool(&amp;oldlen);
+			if (oldlen == 0)
+				return SDESinf.SetTool(data,itemlen);
+		}
+		break;
+	case RTCP_SDES_ID_NOTE:
+		stats.SetLastNoteTime(receivetime);
+		return SDESinf.SetNote(data,itemlen);
+	}
+	return 0;
+}
+
+#ifdef RTP_SUPPORT_SDESPRIV
+
+int RTPInternalSourceData::ProcessPrivateSDESItem(const u_int8_t *prefix,size_t prefixlen,const u_int8_t *value,size_t valuelen,const RTPTime &amp;receivetime)
+{
+	int status;
+	
+	stats.SetLastMessageTime(receivetime);
+	status = SDESinf.SetPrivateValue(prefix,prefixlen,value,valuelen);
+	if (status == ERR_RTP_SDES_MAXPRIVITEMS)
+		return 0; // don't stop processing just because the number of items is full
+	return status;
+}
+
+#endif // RTP_SUPPORT_SDESPRIV
+
+int RTPInternalSourceData::ProcessBYEPacket(const u_int8_t *reason,size_t reasonlen,const RTPTime &amp;receivetime)
+{
+	if (byereason)
+	{
+		delete [] byereason;
+		byereason = 0;
+		byereasonlen = 0;
+	}
+
+	byetime = receivetime;
+	byereason = new u_int8_t[reasonlen];
+	if (byereason == 0)
+		return ERR_RTP_OUTOFMEM;
+	memcpy(byereason,reason,reasonlen);
+	byereasonlen = reasonlen;
+	receivedbye = true;
+	stats.SetLastMessageTime(receivetime);
+	return 0;
+}
+

Added: konference/src/rtp/jrtplib/rtpinternalsourcedata.h
===================================================================
--- konference/src/rtp/jrtplib/rtpinternalsourcedata.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpinternalsourcedata.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,126 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPINTERNALSOURCEDATA_H
+
+#define RTPINTERNALSOURCEDATA_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtpsourcedata.h&quot;
+#include &quot;rtpaddress.h&quot;
+#include &quot;rtptimeutilities.h&quot;
+#include &quot;rtpsources.h&quot;
+
+class RTPInternalSourceData : public RTPSourceData
+{
+public:
+	RTPInternalSourceData(u_int32_t ssrc, RTPSources::ProbationType probtype);
+	~RTPInternalSourceData();
+
+	int ProcessRTPPacket(RTPPacket *rtppack,const RTPTime &amp;receivetime,bool *stored);
+	void ProcessSenderInfo(const RTPNTPTime &amp;ntptime,u_int32_t rtptime,u_int32_t packetcount,
+	                       u_int32_t octetcount,const RTPTime &amp;receivetime)				{ SRprevinf = SRinf; SRinf.Set(ntptime,rtptime,packetcount,octetcount,receivetime); stats.SetLastMessageTime(receivetime); }
+	void ProcessReportBlock(u_int8_t fractionlost,int32_t lostpackets,u_int32_t exthighseqnr,
+	                        u_int32_t jitter,u_int32_t lsr,u_int32_t dlsr,
+				const RTPTime &amp;receivetime)						{ RRprevinf = RRinf; RRinf.Set(fractionlost,lostpackets,exthighseqnr,jitter,lsr,dlsr,receivetime); stats.SetLastMessageTime(receivetime); }
+	void UpdateMessageTime(const RTPTime &amp;receivetime)						{ stats.SetLastMessageTime(receivetime); }
+	int ProcessSDESItem(u_int8_t id,const u_int8_t *data,size_t itemlen,const RTPTime &amp;receivetime,bool *cnamecollis);
+#ifdef RTP_SUPPORT_SDESPRIV
+	int ProcessPrivateSDESItem(const u_int8_t *prefix,size_t prefixlen,const u_int8_t *value,size_t valuelen,const RTPTime &amp;receivetime);
+#endif // RTP_SUPPORT_SDESPRIV
+	int ProcessBYEPacket(const u_int8_t *reason,size_t reasonlen,const RTPTime &amp;receivetime);
+		
+	int SetRTPDataAddress(const RTPAddress *a);
+	int SetRTCPDataAddress(const RTPAddress *a);
+
+	void ClearSenderFlag()										{ issender = false; }
+	void SentRTPPacket()										{ if (!ownssrc) return; RTPTime t = RTPTime::CurrentTime(); issender = true; stats.SetLastRTPPacketTime(t); stats.SetLastMessageTime(t); }
+	void SetOwnSSRC()										{ ownssrc = true; validated = true; }
+	void SetCSRC()											{ validated = true; iscsrc = true; }
+	void ClearNote()										{ SDESinf.SetNote(0,0); }
+	
+#ifdef RTP_SUPPORT_PROBATION
+private:
+	RTPSources::ProbationType probationtype;
+#endif // RTP_SUPPORT_PROBATION
+};
+
+inline int RTPInternalSourceData::SetRTPDataAddress(const RTPAddress *a)
+{
+	if (a == 0)
+	{
+		if (rtpaddr)
+		{
+			delete rtpaddr;
+			rtpaddr = 0;
+		}
+	}
+	else
+	{
+		RTPAddress *newaddr = a-&gt;CreateCopy();
+		if (newaddr == 0)
+			return ERR_RTP_OUTOFMEM;
+		
+		if (rtpaddr &amp;&amp; a != rtpaddr)
+			delete rtpaddr;
+		rtpaddr = newaddr;
+	}
+	isrtpaddrset = true;
+	return 0;
+}
+
+inline int RTPInternalSourceData::SetRTCPDataAddress(const RTPAddress *a)
+{
+	if (a == 0)
+	{
+		if (rtcpaddr)
+		{
+			delete rtcpaddr;
+			rtcpaddr = 0;
+		}
+	}
+	else
+	{
+		RTPAddress *newaddr = a-&gt;CreateCopy();
+		if (newaddr == 0)
+			return ERR_RTP_OUTOFMEM;
+		
+		if (rtcpaddr &amp;&amp; a != rtcpaddr)
+			delete rtcpaddr;
+		rtcpaddr = newaddr;
+	}
+	isrtcpaddrset = true;
+	return 0;
+}
+	
+#endif // RTPINTERNALSOURCEDATA_H
+

Added: konference/src/rtp/jrtplib/rtpipv4address.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpipv4address.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpipv4address.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,81 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtpipv4address.h&quot;
+#ifdef RTPDEBUG
+	#include &lt;stdio.h&gt;
+#endif // RTPDEBUG
+
+#include &quot;rtpdebug.h&quot;
+
+bool RTPIPv4Address::IsSameAddress(const RTPAddress *addr) const
+{
+	if (addr == 0)
+		return false;
+	if (addr-&gt;GetAddressType() != IPv4Address)
+		return false;
+
+	const RTPIPv4Address *addr2 = (const RTPIPv4Address *)addr;
+	if (addr2-&gt;GetIP() == ip &amp;&amp; addr2-&gt;GetPort() == port)
+		return true;
+	return false;
+}
+
+bool RTPIPv4Address::IsFromSameHost(const RTPAddress *addr) const
+{
+	if (addr == 0)
+		return false;
+	if (addr-&gt;GetAddressType() != IPv4Address)
+		return false;
+	
+	const RTPIPv4Address *addr2 = (const RTPIPv4Address *)addr;
+	if (addr2-&gt;GetIP() == ip)
+		return true;
+	return false;
+}
+
+RTPAddress *RTPIPv4Address::CreateCopy() const
+{
+	RTPIPv4Address *a = new RTPIPv4Address(ip,port);
+	return a;
+}
+
+#ifdef RTPDEBUG
+std::string RTPIPv4Address::GetAddressString() const
+{
+	char str[1024];
+
+	sprintf(str,&quot;%d.%d.%d.%d:%d&quot;,(int)((ip&gt;&gt;24)&amp;0xFF),(int)((ip&gt;&gt;16)&amp;0xFF),(int)((ip&gt;&gt;8)&amp;0xFF),
+	                             (int)(ip&amp;0xFF),(int)port);
+	return std::string(str);
+}
+#endif // RTPDEBUG

Added: konference/src/rtp/jrtplib/rtpipv4address.h
===================================================================
--- konference/src/rtp/jrtplib/rtpipv4address.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpipv4address.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,64 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPIPV4ADDRESS_H
+
+#define RTPIPV4ADDRESS_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtpaddress.h&quot;
+#include &quot;rtptypes.h&quot;
+
+class RTPIPv4Address : public RTPAddress
+{
+public:
+	RTPIPv4Address(u_int32_t ip = 0, u_int16_t port = 0):RTPAddress(IPv4Address) 		{ RTPIPv4Address::ip = ip; RTPIPv4Address::port = port; }
+	RTPIPv4Address(const u_int8_t ip[4],u_int16_t port = 0):RTPAddress(IPv4Address)		{ RTPIPv4Address::ip = (u_int32_t)ip[3]; RTPIPv4Address::ip |= (((u_int32_t)ip[2])&lt;&lt;8); RTPIPv4Address::ip |= (((u_int32_t)ip[1])&lt;&lt;16); RTPIPv4Address::ip |= (((u_int32_t)ip[0])&lt;&lt;24); RTPIPv4Address::port = port; }
+	~RTPIPv4Address()									{ }
+	void SetIP(u_int32_t ip)								{ RTPIPv4Address::ip = ip; }
+	void SetIP(const u_int8_t ip[4])							{ RTPIPv4Address::ip = (u_int32_t)ip[3]; RTPIPv4Address::ip |= (((u_int32_t)ip[2])&lt;&lt;8); RTPIPv4Address::ip |= (((u_int32_t)ip[1])&lt;&lt;16); RTPIPv4Address::ip |= (((u_int32_t)ip[0])&lt;&lt;24); }
+	void SetPort(u_int16_t port)								{ RTPIPv4Address::port = port; }
+	u_int32_t GetIP() const									{ return ip; }
+	u_int16_t GetPort() const								{ return port; }
+	RTPAddress *CreateCopy() const;
+	bool IsSameAddress(const RTPAddress *addr) const;
+	bool IsFromSameHost(const RTPAddress *addr) const;
+#ifdef RTPDEBUG
+	std::string GetAddressString() const;
+#endif // RTPDEBUG
+private:
+	u_int32_t ip;
+	u_int16_t port;
+};
+
+#endif // RTPIPV4ADDRESS_H
+

Added: konference/src/rtp/jrtplib/rtpipv4destination.h
===================================================================
--- konference/src/rtp/jrtplib/rtpipv4destination.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpipv4destination.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,79 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPIPV4DESTINATION
+
+#define RTPIPV4DESTINATION
+
+#include &quot;rtpconfig.h&quot;
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include &lt;netinet/in.h&gt;
+#endif // WIN32
+#ifdef RTPDEBUG
+	#include &lt;stdio.h&gt;
+	#include &lt;string&gt;
+#endif // RTPDEBUG
+
+class RTPIPv4Destination
+{
+public:
+	// (nbo = network byte order, hbo = host byte order)
+	
+	RTPIPv4Destination(u_int32_t ip,u_int16_t rtpportbase)					{ ipaddr_hbo = ip; ipaddr_nbo = htonl(ip); rtpport_nbo = htons(rtpportbase); rtcpport_nbo = htons(rtpportbase+1); }
+	u_int32_t GetIP_HBO() const								{ return ipaddr_hbo; }
+	u_int32_t GetIP_NBO() const								{ return ipaddr_nbo; }
+	u_int16_t GetRTPPort_NBO() const							{ return rtpport_nbo; }
+	u_int16_t GetRTCPPort_NBO() const							{ return rtcpport_nbo; }
+	bool operator==(const RTPIPv4Destination &amp;src) const		{ if (src.ipaddr_nbo == ipaddr_nbo &amp;&amp; src.rtpport_nbo == rtpport_nbo) return true; return false; } // NOTE: I only check IP and portbase
+#ifdef RTPDEBUG
+	std::string GetDestinationString() const;
+#endif // RTPDEBUG
+private:
+	u_int32_t ipaddr_hbo;
+	u_int32_t ipaddr_nbo;
+	u_int16_t rtpport_nbo;
+	u_int16_t rtcpport_nbo;
+};
+
+#ifdef RTPDEBUG
+inline std::string RTPIPv4Destination::GetDestinationString() const
+{
+	char str[1024];
+	u_int32_t ip = ipaddr_hbo;
+	u_int16_t portbase = ntohs(rtpport_nbo);
+	
+	sprintf(str,&quot;%d.%d.%d.%d:%d&quot;,(int)((ip&gt;&gt;24)&amp;0xFF),(int)((ip&gt;&gt;16)&amp;0xFF),(int)((ip&gt;&gt;8)&amp;0xFF),(int)(ip&amp;0xFF),(int)(portbase));
+	return std::string(str);
+}
+#endif // RTPDEBUG
+
+#endif // RTPIPV4DESTINATION

Added: konference/src/rtp/jrtplib/rtpipv6address.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpipv6address.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpipv6address.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,106 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtpipv6address.h&quot;
+
+#ifdef RTP_SUPPORT_IPV6
+
+#ifdef RTPDEBUG
+	#include &lt;stdio.h&gt;
+#endif // RTPDEBUG
+
+#include &quot;rtpdebug.h&quot;
+
+RTPAddress *RTPIPv6Address::CreateCopy() const
+{
+	RTPIPv6Address *newaddr = new RTPIPv6Address(ip,port);
+	return newaddr;
+}
+
+bool RTPIPv6Address::IsSameAddress(const RTPAddress *addr) const
+{
+	if (addr == 0)
+		return false;
+	if (addr-&gt;GetAddressType() != RTPAddress::IPv6Address)
+		return false;
+
+	const RTPIPv6Address *addr2 = (const RTPIPv6Address *)addr;
+	const u_int8_t *ip2 = addr2-&gt;ip.s6_addr;
+	
+	if (port != addr2-&gt;port)
+		return false;
+	
+	for (int i = 0 ; i &lt; 16 ; i++)
+	{
+		if (ip.s6_addr[i] != ip2[i])
+			return false;
+	}
+	return true;
+}
+
+bool RTPIPv6Address::IsFromSameHost(const RTPAddress *addr) const
+{
+	if (addr == 0)
+		return false;
+	if (addr-&gt;GetAddressType() != RTPAddress::IPv6Address)
+		return false;
+
+	const RTPIPv6Address *addr2 = (const RTPIPv6Address *)addr;
+	const u_int8_t *ip2 = addr2-&gt;ip.s6_addr;
+	for (int i = 0 ; i &lt; 16 ; i++)
+	{
+		if (ip.s6_addr[i] != ip2[i])
+			return false;
+	}
+	return true;
+}
+
+#ifdef RTPDEBUG
+std::string RTPIPv6Address::GetAddressString() const
+{
+	char str[256];
+	u_int16_t ip16[8];
+	int i,j;
+
+	for (i = 0,j = 0 ; j &lt; 8 ; j++,i += 2)
+	{
+		ip16[j] = (((u_int16_t)ip.s6_addr[i])&lt;&lt;8);
+		ip16[j] |= ((u_int16_t)ip.s6_addr[i+1]);
+	}
+	
+	sprintf(str,&quot;%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X - %d&quot;,(int)ip16[0],(int)ip16[1],(int)ip16[2],(int)ip16[3],(int)ip16[4],(int)ip16[5],(int)ip16[6],(int)ip16[7],(int)port);
+	return std::string(str);
+}
+#endif // RTPDEBUG
+
+#endif // RTP_SUPPORT_IPV6
+

Added: konference/src/rtp/jrtplib/rtpipv6address.h
===================================================================
--- konference/src/rtp/jrtplib/rtpipv6address.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpipv6address.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,75 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPIPV6ADDRESS_H
+
+#define RTPIPV6ADDRESS_H
+
+#include &quot;rtpconfig.h&quot;
+
+#ifdef RTP_SUPPORT_IPV6
+
+#include &quot;rtpaddress.h&quot;
+#include &quot;rtptypes.h&quot;
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include &lt;netinet/in.h&gt;
+#endif // WIN32
+
+class RTPIPv6Address : public RTPAddress
+{
+public:
+	RTPIPv6Address():RTPAddress(IPv6Address)						{ for (int i = 0 ; i &lt; 16 ; i++) ip.s6_addr[i] = 0; port = 0; }
+	RTPIPv6Address(const u_int8_t ip[16],u_int16_t port = 0):RTPAddress(IPv6Address)	{ SetIP(ip); RTPIPv6Address::port = port; }
+	RTPIPv6Address(in6_addr ip,u_int16_t port = 0):RTPAddress(IPv6Address)			{ RTPIPv6Address::ip = ip; RTPIPv6Address::port = port; }
+	~RTPIPv6Address()									{ }
+	void SetIP(in6_addr ip)									{ RTPIPv6Address::ip = ip; }
+	void SetIP(const u_int8_t ip[16])							{ for (int i = 0 ; i &lt; 16 ; i++) RTPIPv6Address::ip.s6_addr[i] = ip[i]; }
+	void SetPort(u_int16_t port)								{ RTPIPv6Address::port = port; }
+	void GetIP(u_int8_t ip[16]) const							{ for (int i = 0 ; i &lt; 16 ; i++) ip[i] = RTPIPv6Address::ip.s6_addr[i]; }
+	in6_addr GetIP() const									{ return ip; }
+	u_int16_t GetPort() const								{ return port; }
+
+	RTPAddress *CreateCopy() const;
+	bool IsSameAddress(const RTPAddress *addr) const;
+	bool IsFromSameHost(const RTPAddress *addr) const;
+#ifdef RTPDEBUG
+	std::string GetAddressString() const;
+#endif // RTPDEBUG
+private:
+	in6_addr ip;
+	u_int16_t port;
+};
+
+#endif // RTP_SUPPORT_IPV6
+
+#endif // RTPIPV6ADDRESS_H
+

Added: konference/src/rtp/jrtplib/rtpipv6destination.h
===================================================================
--- konference/src/rtp/jrtplib/rtpipv6destination.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpipv6destination.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,83 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPIPV6DESTINATION
+
+#define RTPIPV6DESTINATION
+
+#include &quot;rtpconfig.h&quot;
+
+#ifdef RTP_SUPPORT_IPV6
+
+#include &quot;rtptypes.h&quot;
+#include &lt;string.h&gt;
+#ifndef WIN32
+	#include &lt;netinet/in.h&gt;
+#endif // WIN32
+#ifdef RTPDEBUG
+	#include &lt;stdio.h&gt;
+	#include &lt;string&gt;
+#endif // RTPDEBUG
+
+class RTPIPv6Destination
+{
+public:
+	RTPIPv6Destination(in6_addr ip,u_int16_t portbase)	 			{ RTPIPv6Destination::ip = ip; rtpport_nbo = htons(portbase); rtcpport_nbo = htons(portbase+1); }
+	in6_addr GetIP() const								{ return ip; }
+	u_int16_t GetRTPPort_NBO() const						{ return rtpport_nbo; }
+	u_int16_t GetRTCPPort_NBO() const						{ return rtcpport_nbo; }
+	bool operator==(const RTPIPv6Destination &amp;src) const				{ if (src.rtpport_nbo == rtpport_nbo &amp;&amp; (memcmp(&amp;(src.ip),&amp;ip,sizeof(in6_addr)) == 0)) return true; return false; } // NOTE: I only check IP and portbase
+#ifdef RTPDEBUG
+	std::string GetDestinationString() const;
+#endif // RTPDEBUG
+private:
+	in6_addr ip;
+	u_int16_t rtpport_nbo,rtcpport_nbo;
+};
+
+#ifdef RTPDEBUG
+inline std::string RTPIPv6Destination::GetDestinationString() const
+{
+	u_int16_t ip16[8];
+	char str[1024];
+	u_int16_t portbase = ntohs(rtpport_nbo);
+	int i,j;
+	for (i = 0,j = 0 ; j &lt; 8 ; j++,i += 2)	{ ip16[j] = (((u_int16_t)ip.s6_addr[i])&lt;&lt;8); ip16[j] |= ((u_int16_t)ip.s6_addr[i+1]); }
+	sprintf(str,&quot;%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X/%d&quot;,(int)ip16[0],(int)ip16[1],(int)ip16[2],(int)ip16[3],(int)ip16[4],(int)ip16[5],(int)ip16[6],(int)ip16[7],(int)portbase);
+	return std::string(str);
+}
+#endif // RTPDEBUG
+
+#endif // RTP_SUPPORT_IPV6
+
+#endif // RTPIPV6DESTINATION
+

Added: konference/src/rtp/jrtplib/rtpkeyhashtable.h
===================================================================
--- konference/src/rtp/jrtplib/rtpkeyhashtable.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpkeyhashtable.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,328 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPKEYHASHTABLE_H
+
+#define RTPKEYHASHTABLE_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtperrors.h&quot;
+
+#ifdef RTPDEBUG
+#include &lt;iostream&gt;
+#endif // RTPDEBUG
+
+template&lt;class Key,class Element,int GetIndex(const Key &amp;k),int hashsize&gt;
+class RTPKeyHashTable
+{
+public:
+	RTPKeyHashTable();
+	~RTPKeyHashTable()					{ Clear(); }
+
+	void GotoFirstElement()					{ curhashelem = firsthashelem; }
+	void GotoLastElement()					{ curhashelem = lasthashelem; }
+	bool HasCurrentElement()				{ return (curhashelem == 0)?false:true; }
+	int DeleteCurrentElement();
+	Element &amp;GetCurrentElement()				{ return curhashelem-&gt;GetElement(); }
+	Key &amp;GetCurrentKey()					{ return curhashelem-&gt;GetKey(); }
+	int GotoElement(const Key &amp;k);
+	bool HasElement(const Key &amp;k);
+	void GotoNextElement();
+	void GotoPreviousElement();
+	void Clear();
+
+	int AddElement(const Key &amp;k,const Element &amp;elem);
+	int DeleteElement(const Key &amp;k);
+
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+private:
+	class HashElement
+	{
+	public:
+		HashElement(const Key &amp;k,const Element &amp;e,int index):key(k),element(e) { hashprev = 0; hashnext = 0; listnext = 0; listprev = 0; hashindex = index; }
+		int GetHashIndex() 						{ return hashindex; }
+		Key &amp;GetKey()							{ return key; }
+		Element &amp;GetElement()						{ return element; }
+#ifdef RTPDEBUG
+		void Dump()							{ std::cout &lt;&lt; &quot;\tHash index &quot; &lt;&lt; hashindex &lt;&lt; &quot; | Key &quot; &lt;&lt; key &lt;&lt; &quot; | Element &quot; &lt;&lt; element &lt;&lt; std::endl; }
+#endif // RTPDEBUG
+	private:
+		int hashindex;
+		Key key;
+		Element element;
+	public:
+		HashElement *hashprev,*hashnext;
+		HashElement *listprev,*listnext;
+	};
+
+	HashElement *table[hashsize];
+	HashElement *firsthashelem,*lasthashelem;
+	HashElement *curhashelem;
+};
+
+template&lt;class Key,class Element,int GetIndex(const Key &amp;k),int hashsize&gt;
+inline RTPKeyHashTable&lt;Key,Element,GetIndex,hashsize&gt;::RTPKeyHashTable()
+{
+	for (int i = 0 ; i &lt; hashsize ; i++)
+		table[i] = 0;
+	firsthashelem = 0;
+	lasthashelem = 0;
+}
+
+template&lt;class Key,class Element,int GetIndex(const Key &amp;k),int hashsize&gt;
+inline int RTPKeyHashTable&lt;Key,Element,GetIndex,hashsize&gt;::DeleteCurrentElement()
+{
+	if (curhashelem)
+	{
+		HashElement *tmp1,*tmp2;
+		int index;
+		
+		// First, relink elements in current hash bucket
+		
+		index = curhashelem-&gt;GetHashIndex();
+		tmp1 = curhashelem-&gt;hashprev;
+		tmp2 = curhashelem-&gt;hashnext;
+		if (tmp1 == 0) // no previous element in hash bucket
+		{
+			table[index] = tmp2;
+			if (tmp2 != 0)
+				tmp2-&gt;hashprev = 0;
+		}
+		else // there is a previous element in the hash bucket
+		{
+			tmp1-&gt;hashnext = tmp2;
+			if (tmp2 != 0)
+				tmp2-&gt;hashprev = 0;
+		}
+
+		// Relink elements in list
+		
+		tmp1 = curhashelem-&gt;listprev;
+		tmp2 = curhashelem-&gt;listnext;
+		if (tmp1 == 0) // curhashelem is first in list
+		{
+			firsthashelem = tmp2;
+			if (tmp2 != 0)
+				tmp2-&gt;listprev = 0;
+			else // curhashelem is also last in list
+				lasthashelem = 0;	
+		}
+		else
+		{
+			tmp1-&gt;listnext = tmp2;
+			if (tmp2 != 0)
+				tmp2-&gt;listprev = tmp1;
+			else // curhashelem is last in list
+				lasthashelem = tmp1;
+		}
+		
+		// finally, with everything being relinked, we can delete curhashelem
+		delete curhashelem;
+		curhashelem = tmp2; // Set to next element in list
+	}
+	else
+		return ERR_RTP_KEYHASHTABLE_NOCURRENTELEMENT;
+	return 0;
+}
+	
+template&lt;class Key,class Element,int GetIndex(const Key &amp;k),int hashsize&gt;
+inline int RTPKeyHashTable&lt;Key,Element,GetIndex,hashsize&gt;::GotoElement(const Key &amp;k)
+{
+	int index;
+	bool found;
+	
+	index = GetIndex(k);
+	if (index &gt;= hashsize)
+		return ERR_RTP_KEYHASHTABLE_FUNCTIONRETURNEDINVALIDHASHINDEX;
+	
+	curhashelem = table[index]; 
+	found = false;
+	while(!found &amp;&amp; curhashelem != 0)
+	{
+		if (curhashelem-&gt;GetKey() == k)
+			found = true;
+		else
+			curhashelem = curhashelem-&gt;hashnext;
+	}
+	if (!found)
+		return ERR_RTP_KEYHASHTABLE_KEYNOTFOUND;
+	return 0;
+}
+
+template&lt;class Key,class Element,int GetIndex(const Key &amp;k),int hashsize&gt;
+inline bool RTPKeyHashTable&lt;Key,Element,GetIndex,hashsize&gt;::HasElement(const Key &amp;k)
+{
+	int index;
+	bool found;
+	HashElement *tmp;
+	
+	index = GetIndex(k);
+	if (index &gt;= hashsize)
+		return false;
+	
+	tmp = table[index]; 
+	found = false;
+	while(!found &amp;&amp; tmp != 0)
+	{
+		if (tmp-&gt;GetKey() == k)
+			found = true;
+		else
+			tmp = tmp-&gt;hashnext;
+	}
+	return found;
+}
+
+template&lt;class Key,class Element,int GetIndex(const Key &amp;k),int hashsize&gt;
+inline void RTPKeyHashTable&lt;Key,Element,GetIndex,hashsize&gt;::GotoNextElement()
+{
+	if (curhashelem)
+		curhashelem = curhashelem-&gt;listnext;
+}
+
+template&lt;class Key,class Element,int GetIndex(const Key &amp;k),int hashsize&gt;
+inline void RTPKeyHashTable&lt;Key,Element,GetIndex,hashsize&gt;::GotoPreviousElement()
+{
+	if (curhashelem)
+		curhashelem = curhashelem-&gt;listprev;
+}
+
+template&lt;class Key,class Element,int GetIndex(const Key &amp;k),int hashsize&gt;
+inline void RTPKeyHashTable&lt;Key,Element,GetIndex,hashsize&gt;::Clear()
+{
+	HashElement *tmp1,*tmp2;
+	
+	for (int i = 0 ; i &lt; hashsize ; i++)
+		table[i] = 0;
+	
+	tmp1 = firsthashelem;
+	while (tmp1 != 0)
+	{
+		tmp2 = tmp1-&gt;listnext;
+		delete tmp1;
+		tmp1 = tmp2;
+	}
+	firsthashelem = 0;
+	lasthashelem = 0;
+}
+
+template&lt;class Key,class Element,int GetIndex(const Key &amp;k),int hashsize&gt;
+inline int RTPKeyHashTable&lt;Key,Element,GetIndex,hashsize&gt;::AddElement(const Key &amp;k,const Element &amp;elem)
+{
+	int index;
+	bool found;
+	HashElement *e,*newelem;
+	
+	index = GetIndex(k);
+	if (index &gt;= hashsize)
+		return ERR_RTP_KEYHASHTABLE_FUNCTIONRETURNEDINVALIDHASHINDEX;
+	
+	e = table[index];
+	found = false;
+	while(!found &amp;&amp; e != 0)
+	{
+		if (e-&gt;GetKey() == k)
+			found = true;
+		else
+			e = e-&gt;hashnext;
+	}
+	if (found)
+		return ERR_RTP_KEYHASHTABLE_KEYALREADYEXISTS;
+	
+	// Okay, the key doesn't exist, so we can add the new element in the hash table
+	
+	newelem = new HashElement(k,elem,index);
+	if (newelem == 0)
+		return ERR_RTP_OUTOFMEM;
+
+	e = table[index];
+	table[index] = newelem;
+	newelem-&gt;hashnext = e;
+	if (e != 0)
+		e-&gt;hashprev = newelem;
+	
+	// Now, we still got to add it to the linked list
+	
+	if (firsthashelem == 0)
+	{
+		firsthashelem = newelem;
+		lasthashelem = newelem;
+	}
+	else // there already are some elements in the list
+	{
+		lasthashelem-&gt;listnext = newelem;
+		newelem-&gt;listprev = lasthashelem;
+		lasthashelem = newelem;
+	}
+	return 0;
+}
+
+template&lt;class Key,class Element,int GetIndex(const Key &amp;k),int hashsize&gt;
+inline int RTPKeyHashTable&lt;Key,Element,GetIndex,hashsize&gt;::DeleteElement(const Key &amp;k)
+{
+	int status;
+
+	status = GotoElement(k);
+	if (status &lt; 0)
+		return status;
+	return DeleteCurrentElement();
+}
+
+#ifdef RTPDEBUG
+template&lt;class Key,class Element,int GetIndex(const Key &amp;k),int hashsize&gt;
+inline void RTPKeyHashTable&lt;Key,Element,GetIndex,hashsize&gt;::Dump()
+{
+	HashElement *e;
+	
+	std::cout &lt;&lt; &quot;DUMPING TABLE CONTENTS:&quot; &lt;&lt; std::endl;
+	for (int i = 0 ; i &lt; hashsize ; i++)
+	{
+		e = table[i];
+		while (e != 0)
+		{
+			e-&gt;Dump();
+			e = e-&gt;hashnext;
+		}
+	}
+	
+	std::cout &lt;&lt; &quot;DUMPING LIST CONTENTS:&quot; &lt;&lt; std::endl;
+	e = firsthashelem;
+	while (e != 0)
+	{
+		e-&gt;Dump();
+		e = e-&gt;listnext;
+	}
+}
+#endif // RTPDEBUG
+
+#endif // RTPKEYHASHTABLE_H

Added: konference/src/rtp/jrtplib/rtplibraryversion.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtplibraryversion.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtplibraryversion.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,39 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtplibraryversion.h&quot;
+
+RTPLibraryVersion RTPLibraryVersion::GetVersion()
+{
+	return RTPLibraryVersion(3,3,0);
+}
+

Added: konference/src/rtp/jrtplib/rtplibraryversion.h
===================================================================
--- konference/src/rtp/jrtplib/rtplibraryversion.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtplibraryversion.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,65 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPLIBRARYVERSION_H
+
+#define RTPLIBRARYVERSION_H
+
+#include &lt;string&gt;
+#include &lt;stdio.h&gt;
+
+class RTPLibraryVersion
+{
+public:
+      	static RTPLibraryVersion GetVersion();
+private:
+	RTPLibraryVersion(int major,int minor,int debug) 			{ majornr = major; minornr = minor; debugnr = debug; }
+public:
+	int GetMajorNumber() const						{ return majornr; }
+	int GetMinorNumber() const						{ return minornr; }
+	int GetDebugNumber() const						{ return debugnr; }
+	std::string GetVersionString() const;
+private:
+	int debugnr,minornr,majornr;
+};
+
+inline std::string RTPLibraryVersion::GetVersionString() const
+{
+	char str[16];
+
+	sprintf(str,&quot;%d.%d.%d&quot;,majornr,minornr,debugnr);
+	
+	return std::string(str);
+}
+
+#endif // RTPLIBRARYVERSION_H
+

Added: konference/src/rtp/jrtplib/rtppacket.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtppacket.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtppacket.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,344 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtppacket.h&quot;
+#include &quot;rtpstructs.h&quot;
+#include &quot;rtpdefines.h&quot;
+#include &quot;rtperrors.h&quot;
+#include &quot;rtprawpacket.h&quot;
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include &lt;netinet/in.h&gt;
+#endif // WIN32
+
+#ifdef RTPDEBUG
+	#include &lt;stdio.h&gt;
+#endif // RTPDEBUG
+
+#include &quot;rtpdebug.h&quot;
+
+void RTPPacket::Clear()
+{
+	hasextension = false;
+	hasmarker = false;
+	numcsrcs = 0;
+	payloadtype = 0;
+	extseqnr = 0;
+	timestamp = 0;
+	ssrc = 0;
+	packet = 0;
+	payload = 0; 
+	packetlength = 0;
+	payloadlength = 0;
+	extid = 0;
+	extension = 0;
+	extensionlength = 0;
+	error = 0;
+	externalbuffer = false;
+}
+
+RTPPacket::RTPPacket(RTPRawPacket &amp;rawpack) : receivetime(rawpack.GetReceiveTime())
+{
+	Clear();
+	error = ParseRawPacket(rawpack);
+}
+
+RTPPacket::RTPPacket(u_int8_t payloadtype,const void *payloaddata,size_t payloadlen,u_int16_t seqnr,
+		  u_int32_t timestamp,u_int32_t ssrc,bool gotmarker,u_int8_t numcsrcs,const u_int32_t *csrcs,
+		  bool gotextension,u_int16_t extensionid,u_int16_t extensionlen_numwords,const void *extensiondata,
+		  size_t maxpacksize /* = 0 */ ) : receivetime(0,0)
+{
+	Clear();
+	error = BuildPacket(payloadtype,payloaddata,payloadlen,seqnr,timestamp,ssrc,gotmarker,numcsrcs,
+	       	            csrcs,gotextension,extensionid,extensionlen_numwords,extensiondata,0,maxpacksize);
+}
+
+RTPPacket::RTPPacket(u_int8_t payloadtype,const void *payloaddata,size_t payloadlen,u_int16_t seqnr,
+		  u_int32_t timestamp,u_int32_t ssrc,bool gotmarker,u_int8_t numcsrcs,const u_int32_t *csrcs,
+		  bool gotextension,u_int16_t extensionid,u_int16_t extensionlen_numwords,const void *extensiondata,
+		  void *buffer,size_t buffersize) : receivetime(0,0)
+{
+	Clear();
+	if (buffer == 0)
+		error = ERR_RTP_PACKET_EXTERNALBUFFERNULL;
+	else if (buffersize &lt;= 0)
+		error = ERR_RTP_PACKET_ILLEGALBUFFERSIZE;
+	else
+		error = BuildPacket(payloadtype,payloaddata,payloadlen,seqnr,timestamp,ssrc,gotmarker,numcsrcs,
+		                    csrcs,gotextension,extensionid,extensionlen_numwords,extensiondata,buffer,buffersize);
+}
+
+int RTPPacket::ParseRawPacket(RTPRawPacket &amp;rawpack)
+{
+	u_int8_t *packetbytes;
+	size_t packetlen;
+	u_int8_t payloadtype;
+	RTPHeader *rtpheader;
+	bool marker;
+	int csrccount;
+	bool hasextension;
+	int payloadoffset,payloadlength;
+	int numpadbytes;
+	RTPExtensionHeader *rtpextheader;
+	u_int16_t exthdrlen;
+	
+	if (!rawpack.IsRTP()) // If we didn't receive it on the RTP port, we'll ignore it
+		return ERR_RTP_PACKET_INVALIDPACKET;
+	
+	// The length should be at least the size of the RTP header
+	packetlen = rawpack.GetDataLength();
+	if (packetlen &lt; sizeof(RTPHeader))
+		return ERR_RTP_PACKET_INVALIDPACKET;
+	
+	packetbytes = (u_int8_t *)rawpack.GetData();
+	rtpheader = (RTPHeader *)packetbytes;
+	
+	// The version number should be correct
+	if (rtpheader-&gt;version != RTP_VERSION)
+		return ERR_RTP_PACKET_INVALIDPACKET;
+	
+	// We'll check if this is possibly a RTCP packet. For this to be possible
+	// the marker bit and payload type combined should be either an SR or RR
+	// identifier
+	marker = (rtpheader-&gt;marker == 0)?false:true;
+	payloadtype = rtpheader-&gt;payloadtype;
+	if (marker)
+	{
+		if (payloadtype == (RTP_RTCPTYPE_SR &amp; 127)) // don't check high bit (this was the marker!!)
+			return ERR_RTP_PACKET_INVALIDPACKET;
+		if (payloadtype == (RTP_RTCPTYPE_RR &amp; 127))
+			return ERR_RTP_PACKET_INVALIDPACKET;
+	}
+
+	csrccount = rtpheader-&gt;csrccount;
+	payloadoffset = sizeof(RTPHeader)+(int)(csrccount*sizeof(u_int32_t));
+	
+	if (rtpheader-&gt;padding) // adjust payload length to take padding into account
+	{
+		numpadbytes = (int)packetbytes[packetlen-1]; // last byte contains number of padding bytes
+		if (numpadbytes &lt;= 0)
+			return ERR_RTP_PACKET_INVALIDPACKET;
+	}
+	else
+		numpadbytes = 0;
+
+	hasextension = (rtpheader-&gt;extension == 0)?false:true;
+	if (hasextension) // got header extension
+	{
+		rtpextheader = (RTPExtensionHeader *)(packetbytes+payloadoffset);
+		payloadoffset += sizeof(RTPExtensionHeader);
+		exthdrlen = ntohs(rtpextheader-&gt;length);
+		payloadoffset += ((int)exthdrlen)*sizeof(u_int32_t);
+	}
+	else
+	{
+		rtpextheader = 0;
+		exthdrlen = 0;
+	}	
+	
+	payloadlength = packetlen-numpadbytes-payloadoffset;
+	if (payloadlength &lt; 0)
+		return ERR_RTP_PACKET_INVALIDPACKET;
+
+	// Now, we've got a valid packet, so we can create a new instance of RTPPacket
+	// and fill in the members
+	
+	RTPPacket::hasextension = hasextension;
+	if (hasextension)
+	{
+		RTPPacket::extid = ntohs(rtpextheader-&gt;id);
+		RTPPacket::extensionlength = ((int)ntohs(rtpextheader-&gt;length))*sizeof(u_int32_t);
+		RTPPacket::extension = ((u_int8_t *)rtpextheader)+sizeof(RTPExtensionHeader);
+	}
+
+	RTPPacket::hasmarker = marker;
+	RTPPacket::numcsrcs = csrccount;
+	RTPPacket::payloadtype = payloadtype;
+	
+	// Note: we don't fill in the EXTENDED sequence number here, since we
+	// don't have information about the source here. We just fill in the low
+	// 16 bits
+	RTPPacket::extseqnr = (u_int32_t)ntohs(rtpheader-&gt;sequencenumber);
+
+	RTPPacket::timestamp = ntohl(rtpheader-&gt;timestamp);
+	RTPPacket::ssrc = ntohl(rtpheader-&gt;ssrc);
+	RTPPacket::packet = packetbytes;
+	RTPPacket::payload = packetbytes+payloadoffset;
+	RTPPacket::packetlength = packetlen;
+	RTPPacket::payloadlength = payloadlength;
+
+	// We'll zero the data of the raw packet, since we're using it here now!
+	rawpack.ZeroData();
+
+	return 0;
+}
+
+u_int32_t RTPPacket::GetCSRC(int num) const
+{
+	if (num &gt;= numcsrcs)
+		return 0;
+
+	u_int8_t *csrcpos;
+	u_int32_t *csrcval_nbo;
+	u_int32_t csrcval_hbo;
+	
+	csrcpos = packet+sizeof(RTPHeader)+num*sizeof(u_int32_t);
+	csrcval_nbo = (u_int32_t *)csrcpos;
+	csrcval_hbo = ntohl(*csrcval_nbo);
+	return csrcval_hbo;
+}
+
+int RTPPacket::BuildPacket(u_int8_t payloadtype,const void *payloaddata,size_t payloadlen,u_int16_t seqnr,
+		  u_int32_t timestamp,u_int32_t ssrc,bool gotmarker,u_int8_t numcsrcs,const u_int32_t *csrcs,
+		  bool gotextension,u_int16_t extensionid,u_int16_t extensionlen_numwords,const void *extensiondata,
+		  void *buffer,size_t maxsize)
+{
+	if (numcsrcs &gt; RTP_MAXCSRCS)
+		return ERR_RTP_PACKET_TOOMANYCSRCS;
+
+	if (payloadtype &gt; 127) // high bit should not be used
+		return ERR_RTP_PACKET_BADPAYLOADTYPE;
+	if (payloadtype == 72 || payloadtype == 73) // could cause confusion with rtcp types
+		return ERR_RTP_PACKET_BADPAYLOADTYPE;
+	
+	packetlength = sizeof(RTPHeader);
+	packetlength += sizeof(u_int32_t)*((size_t)numcsrcs);
+	if (gotextension)
+	{
+		packetlength += sizeof(RTPExtensionHeader);
+		packetlength += sizeof(u_int32_t)*((size_t)extensionlen_numwords);
+	}
+	packetlength += payloadlen;
+
+	if (maxsize &gt; 0 &amp;&amp; packetlength &gt; maxsize)
+	{
+		packetlength = 0;
+		return ERR_RTP_PACKET_DATAEXCEEDSMAXSIZE;
+	}
+
+	// Ok, now we'll just fill in...
+	
+	RTPHeader *rtphdr;
+	
+	if (buffer == 0)
+	{
+		packet = new u_int8_t [packetlength];
+		if (packet == 0)
+		{
+			packetlength = 0;
+			return ERR_RTP_OUTOFMEM;
+		}
+		externalbuffer = false;
+	}
+	else
+	{
+		packet = (u_int8_t *)buffer;
+		externalbuffer = true;
+	}
+	
+	RTPPacket::hasmarker = gotmarker;
+	RTPPacket::hasextension = gotextension;
+	RTPPacket::numcsrcs = numcsrcs;
+	RTPPacket::payloadtype = payloadtype;
+	RTPPacket::extseqnr = (u_int32_t)seqnr;
+	RTPPacket::timestamp = timestamp;
+	RTPPacket::ssrc = ssrc;
+	RTPPacket::payloadlength = payloadlen;
+	RTPPacket::extid = extensionid;
+	RTPPacket::extensionlength = ((size_t)extensionlen_numwords)*sizeof(u_int32_t);
+	
+	rtphdr = (RTPHeader *)packet;
+	rtphdr-&gt;version = RTP_VERSION;
+	rtphdr-&gt;padding = 0;
+	if (gotmarker)
+		rtphdr-&gt;marker = 1;
+	else
+		rtphdr-&gt;marker = 0;
+	if (gotextension)
+		rtphdr-&gt;extension = 1;
+	else
+		rtphdr-&gt;extension = 0;
+	rtphdr-&gt;csrccount = numcsrcs;
+	rtphdr-&gt;payloadtype = payloadtype&amp;127; // make sure high bit isn't set
+	rtphdr-&gt;sequencenumber = htons(seqnr);
+	rtphdr-&gt;timestamp = htonl(timestamp);
+	rtphdr-&gt;ssrc = htonl(ssrc);
+	
+	u_int32_t *curcsrc;
+	int i;
+
+	curcsrc = (u_int32_t *)(packet+sizeof(RTPHeader));
+	for (i = 0 ; i &lt; numcsrcs ; i++,curcsrc++)
+		*curcsrc = htonl(csrcs[i]);
+
+	payload = packet+sizeof(RTPHeader)+((size_t)numcsrcs)*sizeof(u_int32_t); 
+	if (gotextension)
+	{
+		RTPExtensionHeader *rtpexthdr = (RTPExtensionHeader *)payload;
+
+		rtpexthdr-&gt;id = htons(extensionid);
+		rtpexthdr-&gt;length = htons((u_int16_t)extensionlen_numwords);
+		
+		payload += sizeof(RTPExtensionHeader);
+		memcpy(payload,extensiondata,RTPPacket::extensionlength);
+		
+		payload += RTPPacket::extensionlength;
+	}
+	memcpy(payload,payloaddata,payloadlen);
+	return 0;
+}
+
+#ifdef RTPDEBUG	
+void RTPPacket::Dump()
+{
+	int i;
+	
+	printf(&quot;Payload type:                %d\n&quot;,(int)GetPayloadType());
+	printf(&quot;Extended sequence number:    0x%08x\n&quot;,GetExtendedSequenceNumber());
+	printf(&quot;Timestamp:                   0x%08x\n&quot;,GetTimestamp());
+	printf(&quot;SSRC:                        0x%08x\n&quot;,GetSSRC());
+	printf(&quot;Marker:                      %s\n&quot;,HasMarker()?&quot;yes&quot;:&quot;no&quot;);
+	printf(&quot;CSRC count:                  %d\n&quot;,GetCSRCCount());
+	for (i = 0 ; i &lt; GetCSRCCount() ; i++)
+		printf(&quot;    CSRC[%02d]:                0x%08x\n&quot;,i,GetCSRC(i));
+	printf(&quot;Payload:                     %s\n&quot;,GetPayloadData());
+	printf(&quot;Payload length:              %d\n&quot;,GetPayloadLength());
+	printf(&quot;Packet length:               %d\n&quot;,GetPacketLength());
+	printf(&quot;Extension:                   %s\n&quot;,HasExtension()?&quot;yes&quot;:&quot;no&quot;);
+	if (HasExtension())
+	{
+		printf(&quot;    Extension ID:            0x%04x\n&quot;,GetExtensionID());
+		printf(&quot;    Extension data:          %s\n&quot;,GetExtensionData());
+		printf(&quot;    Extension length:        %d\n&quot;,GetExtensionLength());
+	}
+}
+#endif // RTPDEBUG
+

Added: konference/src/rtp/jrtplib/rtppacket.h
===================================================================
--- konference/src/rtp/jrtplib/rtppacket.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtppacket.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,125 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPPACKET_H
+
+#define RTPPACKET_H
+
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtptypes.h&quot;
+#include &quot;rtptimeutilities.h&quot;
+
+class RTPRawPacket;
+
+class RTPPacket
+{
+public:
+	// If successfull, the data is moved from the raw packet to the RTPPacket instance
+	RTPPacket(RTPRawPacket &amp;rawpack);
+
+	// if maxpacksize == 0, it is ignored
+	RTPPacket(u_int8_t payloadtype,const void *payloaddata,size_t payloadlen,u_int16_t seqnr,
+		  u_int32_t timestamp,u_int32_t ssrc,bool gotmarker,u_int8_t numcsrcs,const u_int32_t *csrcs,
+		  bool gotextension,u_int16_t extensionid,u_int16_t extensionlen_numwords,const void *extensiondata,
+		  size_t maxpacksize = 0);
+	// pretty much the same function, except that here the data is placed in an external buffer
+	RTPPacket(u_int8_t payloadtype,const void *payloaddata,size_t payloadlen,u_int16_t seqnr,
+		  u_int32_t timestamp,u_int32_t ssrc,bool gotmarker,u_int8_t numcsrcs,const u_int32_t *csrcs,
+		  bool gotextension,u_int16_t extensionid,u_int16_t extensionlen_numwords,const void *extensiondata,
+		  void *buffer,size_t buffersize);
+
+	virtual ~RTPPacket()							{ if (packet &amp;&amp; !externalbuffer) delete [] packet; }
+	int GetCreationError() const						{ return error; }
+
+	bool HasExtension() const						{ return hasextension; }
+	bool HasMarker() const							{ return hasmarker; }
+	
+	int GetCSRCCount() const						{ return numcsrcs; }
+	u_int32_t GetCSRC(int num) const;
+	
+	u_int8_t GetPayloadType() const						{ return payloadtype; }
+
+	// On reception, this is actually a 16 bit value. The high 16 bits
+	// are filled in when the packet is processed in the source
+	// table
+	u_int32_t GetExtendedSequenceNumber() const				{ return extseqnr; }
+	u_int16_t GetSequenceNumber() const					{ return (u_int16_t)(extseqnr&amp;0x0000FFFF); }
+	void SetExtendedSequenceNumber(u_int32_t seq)				{ extseqnr = seq; }
+
+	u_int32_t GetTimestamp() const						{ return timestamp; }
+	u_int32_t GetSSRC() const						{ return ssrc; }
+
+	u_int8_t *GetPacketData() const						{ return packet; }
+	u_int8_t *GetPayloadData() const					{ return payload; }
+	size_t GetPacketLength() const						{ return packetlength; }
+	size_t GetPayloadLength() const						{ return payloadlength; }
+	
+	u_int16_t GetExtensionID() const					{ return extid; }
+	u_int8_t *GetExtensionData() const					{ return extension; }
+	size_t GetExtensionLength() const					{ return extensionlength; }
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+
+	// If parsed from a raw packet, the receive time is also copied.
+	// This function can be used to retrieve it.
+	RTPTime GetReceiveTime() const						{ return receivetime; }
+private:
+	void Clear();
+	int ParseRawPacket(RTPRawPacket &amp;rawpack);
+	int BuildPacket(u_int8_t payloadtype,const void *payloaddata,size_t payloadlen,u_int16_t seqnr,
+	                u_int32_t timestamp,u_int32_t ssrc,bool gotmarker,u_int8_t numcsrcs,const u_int32_t *csrcs,
+	                bool gotextension,u_int16_t extensionid,u_int16_t extensionlen_numwords,const void *extensiondata,
+	                void *buffer,size_t maxsize);
+
+	int error;
+	
+	bool hasextension,hasmarker;
+	int numcsrcs;
+
+	u_int8_t payloadtype;
+	u_int32_t extseqnr,timestamp,ssrc;
+	u_int8_t *packet,*payload;
+	size_t packetlength,payloadlength;
+
+	u_int16_t extid;
+	u_int8_t *extension;
+	size_t extensionlength;
+
+	bool externalbuffer;
+
+	RTPTime receivetime;
+};
+
+#endif // RTPPACKET_H
+

Added: konference/src/rtp/jrtplib/rtppacketbuilder.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtppacketbuilder.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtppacketbuilder.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,269 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtppacketbuilder.h&quot;
+#include &quot;rtperrors.h&quot;
+#include &quot;rtppacket.h&quot;
+#include &quot;rtpsources.h&quot;
+#include &lt;time.h&gt;
+#include &lt;stdlib.h&gt;
+#ifdef RTPDEBUG
+	#include &lt;iostream&gt;
+#endif // RTPDEBUG
+
+#include &quot;rtpdebug.h&quot;
+
+RTPPacketBuilder::RTPPacketBuilder() : lastwallclocktime(0,0)
+{
+	init = false;
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	timeinit.Dummy();
+#endif // WIN32 || _WIN32_WCE
+}
+
+RTPPacketBuilder::~RTPPacketBuilder()
+{
+	Destroy();
+}
+
+int RTPPacketBuilder::Init(size_t max)
+{
+	if (init)
+		return ERR_RTP_PACKBUILD_ALREADYINIT;
+	if (max &lt;= 0)
+		return ERR_RTP_PACKBUILD_INVALIDMAXPACKETSIZE;
+	
+	maxpacksize = max;
+	buffer = new u_int8_t [max];
+	if (buffer == 0)
+		return ERR_RTP_OUTOFMEM;
+	packetlength = 0;
+	
+	CreateNewSSRC();
+
+	deftsset = false;
+	defptset = false;
+	defmarkset = false;
+		
+	numcsrcs = 0;
+	
+	init = true;
+	return 0;
+}
+
+void RTPPacketBuilder::Destroy()
+{
+	if (!init)
+		return;
+	delete [] buffer;
+	init = false;
+}
+
+int RTPPacketBuilder::SetMaximumPacketSize(size_t max)
+{
+	u_int8_t *newbuf;
+
+	if (max &lt;= 0)
+		return ERR_RTP_PACKBUILD_INVALIDMAXPACKETSIZE;
+	newbuf = new u_int8_t[max];
+	if (newbuf == 0)
+		return ERR_RTP_OUTOFMEM;
+	
+	delete [] buffer;
+	buffer = newbuf;
+	maxpacksize = max;
+	return 0;
+}
+
+int RTPPacketBuilder::AddCSRC(u_int32_t csrc)
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	if (numcsrcs &gt;= RTP_MAXCSRCS)
+		return ERR_RTP_PACKBUILD_CSRCLISTFULL;
+
+	int i;
+	
+	for (i = 0 ; i &lt; numcsrcs ; i++)
+	{
+		if (csrcs[i] == csrc)
+			return ERR_RTP_PACKBUILD_CSRCALREADYINLIST;
+	}
+	csrcs[numcsrcs] = csrc;
+	numcsrcs++;
+	return 0;
+}
+
+int RTPPacketBuilder::DeleteCSRC(u_int32_t csrc)
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	
+	int i = 0;
+	bool found = false;
+
+	while (!found &amp;&amp; i &lt; numcsrcs)
+	{
+		if (csrcs[i] == csrc)
+			found = true;
+		else
+			i++;
+	}
+
+	if (!found)
+		return ERR_RTP_PACKBUILD_CSRCNOTINLIST;
+	
+	// move the last csrc in the place of the deleted one
+	numcsrcs--;
+	if (numcsrcs &gt; 0 &amp;&amp; numcsrcs != i)
+		csrcs[i] = csrcs[numcsrcs];
+	return 0;
+}
+
+void RTPPacketBuilder::ClearCSRCList()
+{
+	if (!init)
+		return;
+	numcsrcs = 0;
+}
+
+u_int32_t RTPPacketBuilder::CreateNewSSRC()
+{
+	ssrc = rtprnd.GetRandom32();
+	timestamp = rtprnd.GetRandom32();
+	seqnr = rtprnd.GetRandom16();
+
+	// p 38: the count SHOULD be reset if the sender changes its SSRC identifier
+	numpayloadbytes = 0;
+	numpackets = 0;
+	return ssrc;
+}
+
+u_int32_t RTPPacketBuilder::CreateNewSSRC(RTPSources &amp;sources)
+{
+	bool found;
+	
+	do
+	{
+		ssrc = rtprnd.GetRandom32();
+		found = sources.GotEntry(ssrc);
+	} while (found);
+	
+	timestamp = rtprnd.GetRandom32();
+	seqnr = rtprnd.GetRandom16();
+
+	// p 38: the count SHOULD be reset if the sender changes its SSRC identifier
+	numpayloadbytes = 0;
+	numpackets = 0;
+	return ssrc;
+}
+
+int RTPPacketBuilder::BuildPacket(const void *data,size_t len)
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	if (!defptset)
+		return ERR_RTP_PACKBUILD_DEFAULTPAYLOADTYPENOTSET;
+	if (!defmarkset)
+		return ERR_RTP_PACKBUILD_DEFAULTMARKNOTSET;
+	if (!deftsset)
+		return ERR_RTP_PACKBUILD_DEFAULTTSINCNOTSET;
+	return PrivateBuildPacket(data,len,defaultpayloadtype,defaultmark,defaulttimestampinc,false);
+}
+
+int RTPPacketBuilder::BuildPacket(const void *data,size_t len,
+                u_int8_t pt,bool mark,u_int32_t timestampinc)
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	return PrivateBuildPacket(data,len,pt,mark,timestampinc,false);
+}
+
+int RTPPacketBuilder::BuildPacketEx(const void *data,size_t len,
+                  u_int16_t hdrextID,const void *hdrextdata,size_t numhdrextwords)
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	if (!defptset)
+		return ERR_RTP_PACKBUILD_DEFAULTPAYLOADTYPENOTSET;
+	if (!defmarkset)
+		return ERR_RTP_PACKBUILD_DEFAULTMARKNOTSET;
+	if (!deftsset)
+		return ERR_RTP_PACKBUILD_DEFAULTTSINCNOTSET;
+	return PrivateBuildPacket(data,len,defaultpayloadtype,defaultmark,defaulttimestampinc,true,hdrextID,hdrextdata,numhdrextwords);
+}
+
+int RTPPacketBuilder::BuildPacketEx(const void *data,size_t len,
+                  u_int8_t pt,bool mark,u_int32_t timestampinc,
+		  u_int16_t hdrextID,const void *hdrextdata,size_t numhdrextwords)
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	return PrivateBuildPacket(data,len,pt,mark,timestampinc,true,hdrextID,hdrextdata,numhdrextwords);
+
+}
+
+int RTPPacketBuilder::PrivateBuildPacket(const void *data,size_t len,
+	                  u_int8_t pt,bool mark,u_int32_t timestampinc,bool gotextension,
+	                  u_int16_t hdrextID,const void *hdrextdata,size_t numhdrextwords)
+{
+	RTPPacket p(pt,data,len,seqnr,timestamp,ssrc,mark,numcsrcs,csrcs,gotextension,hdrextID,
+	            (u_int16_t)numhdrextwords,hdrextdata,buffer,maxpacksize);
+	int status = p.GetCreationError();
+
+	if (status &lt; 0)
+		return status;
+	packetlength = p.GetPacketLength();
+
+	if (numpackets == 0) // first packet
+	{
+		lastwallclocktime = RTPTime::CurrentTime();
+		lastrtptimestamp = timestamp;
+		prevrtptimestamp = timestamp;
+	}
+	else if (timestamp != prevrtptimestamp)
+	{
+		lastwallclocktime = RTPTime::CurrentTime();
+		lastrtptimestamp = timestamp;
+		prevrtptimestamp = timestamp;
+	}
+	
+	numpayloadbytes += (u_int32_t)p.GetPayloadLength();
+	numpackets++;
+	timestamp += timestampinc;
+	seqnr++;
+
+
+	return 0;
+}
+
+

Added: konference/src/rtp/jrtplib/rtppacketbuilder.h
===================================================================
--- konference/src/rtp/jrtplib/rtppacketbuilder.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtppacketbuilder.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,165 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPPACKETBUILDER_H
+
+#define RTPPACKETBUILDER_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtperrors.h&quot;
+#include &quot;rtpdefines.h&quot;
+#include &quot;rtprandom.h&quot;
+#include &quot;rtptimeutilities.h&quot;
+#include &quot;rtptypes.h&quot;
+
+class RTPSources;
+
+class RTPPacketBuilder
+{
+public:
+	RTPPacketBuilder();
+	~RTPPacketBuilder();
+	int Init(size_t maxpacksize);
+	void Destroy();
+	u_int32_t GetPacketCount()					{ if (!init) return 0; return numpackets; }
+	u_int32_t GetPayloadOctetCount()				{ if (!init) return 0; return numpayloadbytes; }
+	int SetMaximumPacketSize(size_t maxpacksize);
+
+	int AddCSRC(u_int32_t csrc);
+	int DeleteCSRC(u_int32_t csrc);
+	void ClearCSRCList();	
+	
+	int BuildPacket(const void *data,size_t len);
+	int BuildPacket(const void *data,size_t len,
+	                u_int8_t pt,bool mark,u_int32_t timestampinc);
+	int BuildPacketEx(const void *data,size_t len,
+	                  u_int16_t hdrextID,const void *hdrextdata,size_t numhdrextwords);
+	int BuildPacketEx(const void *data,size_t len,
+	                  u_int8_t pt,bool mark,u_int32_t timestampinc,
+	                  u_int16_t hdrextID,const void *hdrextdata,size_t numhdrextwords);
+	u_int8_t *GetPacket()						{ if (!init) return 0; return buffer; }
+	size_t GetPacketLength()					{ if (!init) return 0; return packetlength; }
+	
+	int SetDefaultPayloadType(u_int8_t pt);
+	int SetDefaultMark(bool m);
+	int SetDefaultTimestampIncrement(u_int32_t timestampinc);
+	int IncrementTimestamp(u_int32_t inc);
+	int IncrementTimestampDefault();
+	
+	u_int32_t CreateNewSSRC();
+	u_int32_t CreateNewSSRC(RTPSources &amp;sources);
+	u_int32_t GetSSRC() const					{ if (!init) return 0; return ssrc; }
+	u_int32_t GetTimestamp() const					{ if (!init) return 0; return timestamp; }
+	u_int16_t GetSequenceNumber() const				{ if (!init) return 0; return seqnr; }
+
+	// note: these are not necessarily from the last packet!
+	RTPTime GetPacketTime() const					{ if (!init) return RTPTime(0,0); return lastwallclocktime; }
+	u_int32_t GetPacketTimestamp() const				{ if (!init) return 0; return lastrtptimestamp; }
+private:
+	int PrivateBuildPacket(const void *data,size_t len,
+	                  u_int8_t pt,bool mark,u_int32_t timestampinc,bool gotextension,
+	                  u_int16_t hdrextID = 0,const void *hdrextdata = 0,size_t numhdrextwords = 0);
+
+	RTPRandom rtprnd;	
+	size_t maxpacksize;
+	u_int8_t *buffer;
+	size_t packetlength;
+	
+	u_int32_t numpayloadbytes;
+	u_int32_t numpackets;
+	bool init;
+
+	u_int32_t ssrc;
+	u_int32_t timestamp;
+	u_int16_t seqnr;
+
+	u_int32_t defaulttimestampinc;
+	u_int8_t defaultpayloadtype;
+	bool defaultmark;
+
+	bool deftsset,defptset,defmarkset;
+
+	u_int32_t csrcs[RTP_MAXCSRCS];
+	int numcsrcs;
+
+	RTPTime lastwallclocktime;
+	u_int32_t lastrtptimestamp;
+	u_int32_t prevrtptimestamp;
+};
+
+inline int RTPPacketBuilder::SetDefaultPayloadType(u_int8_t pt)
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	defptset = true;
+	defaultpayloadtype = pt;
+	return 0;
+}
+
+inline int RTPPacketBuilder::SetDefaultMark(bool m)
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	defmarkset = true;
+	defaultmark = m;
+	return 0;
+}
+
+inline int RTPPacketBuilder::SetDefaultTimestampIncrement(u_int32_t timestampinc)
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	deftsset = true;
+	defaulttimestampinc = timestampinc;
+	return 0;
+}
+
+inline int RTPPacketBuilder::IncrementTimestamp(u_int32_t inc)
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	timestamp += inc;
+	return 0;
+}
+
+inline int RTPPacketBuilder::IncrementTimestampDefault()
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	if (!deftsset)
+		return ERR_RTP_PACKBUILD_DEFAULTTSINCNOTSET;
+	timestamp += defaulttimestampinc;
+	return 0;
+}
+
+#endif // RTPPACKETBUILDER_H
+

Added: konference/src/rtp/jrtplib/rtppollthread.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtppollthread.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtppollthread.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,169 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtppollthread.h&quot;
+
+#ifdef RTP_SUPPORT_THREAD
+
+#include &quot;rtpsession.h&quot;
+#include &quot;rtcpscheduler.h&quot;
+#include &quot;rtperrors.h&quot;
+#include &quot;rtprawpacket.h&quot;
+#include &lt;time.h&gt;
+
+#ifndef _WIN32_WCE
+	#include &lt;iostream&gt;
+#endif // _WIN32_WCE
+
+#include &quot;rtpdebug.h&quot;
+
+RTPPollThread::RTPPollThread(RTPSession &amp;session,RTCPScheduler &amp;sched):rtpsession(session),rtcpsched(sched)
+{
+	stop = false;
+	transmitter = 0;
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	timeinit.Dummy();
+#endif // WIN32 || _WIN32_WCE
+}
+
+RTPPollThread::~RTPPollThread()
+{
+	Stop();
+}
+ 
+int RTPPollThread::Start(RTPTransmitter *trans)
+{
+	if (JThread::IsRunning())
+		return ERR_RTP_POLLTHREAD_ALREADYRUNNING;
+	
+	transmitter = trans;
+	if (!stopmutex.IsInitialized())
+	{
+		if (stopmutex.Init() &lt; 0)
+			return ERR_RTP_POLLTHREAD_CANTINITMUTEX;
+	}
+	stop = false;
+	if (JThread::Start() &lt; 0)
+		return ERR_RTP_POLLTHREAD_CANTSTARTTHREAD;
+	return 0;
+}
+
+void RTPPollThread::Stop()
+{	
+	if (!IsRunning())
+		return;
+	
+	stopmutex.Lock();
+	stop = true;
+	stopmutex.Unlock();
+	
+	if (transmitter)
+		transmitter-&gt;AbortWait();
+	
+	RTPTime thetime = RTPTime::CurrentTime();
+	bool done = false;
+
+	while (JThread::IsRunning() &amp;&amp; !done)
+	{
+		// wait max 5 sec
+		RTPTime curtime = RTPTime::CurrentTime();
+		if ((curtime.GetDouble()-thetime.GetDouble()) &gt; 5.0)
+			done = true;
+		RTPTime::Wait(RTPTime(0,10000));
+	}
+
+	if (JThread::IsRunning())
+	{
+#ifndef _WIN32_WCE
+		std::cerr &lt;&lt; &quot;RTPPollThread: Warning! Having to kill thread!&quot; &lt;&lt; std::endl;
+#endif // _WIN32_WCE
+		JThread::Kill();
+	}
+	stop = false;
+	transmitter = 0;
+}
+
+void *RTPPollThread::Thread()
+{
+	JThread::ThreadStarted();
+	
+	bool stopthread;
+
+	stopmutex.Lock();
+	stopthread = stop;
+	stopmutex.Unlock();
+	while (!stopthread)
+	{
+		int status;
+
+		rtpsession.schedmutex.Lock();
+		rtpsession.sourcesmutex.Lock();
+		
+		RTPTime rtcpdelay = rtcpsched.GetTransmissionDelay();
+		
+		rtpsession.sourcesmutex.Unlock();
+		rtpsession.schedmutex.Unlock();
+		
+		if ((status = transmitter-&gt;WaitForIncomingData(rtcpdelay)) &lt; 0)
+		{
+			stopthread = true;
+			rtpsession.OnPollThreadError(status);
+		}
+		else
+		{
+			if ((status = transmitter-&gt;Poll()) &lt; 0)
+			{
+				stopthread = true;
+				rtpsession.OnPollThreadError(status);
+			}
+			else
+			{
+				if ((status = rtpsession.ProcessPolledData()) &lt; 0)
+				{
+					stopthread = true;
+					rtpsession.OnPollThreadError(status);
+				}
+				else
+				{
+					rtpsession.OnPollThreadStep();
+					stopmutex.Lock();
+					stopthread = stop;
+					stopmutex.Unlock();
+				}
+			}
+		}
+	}
+	return 0;
+}
+
+#endif // RTP_SUPPORT_THREAD
+

Added: konference/src/rtp/jrtplib/rtppollthread.h
===================================================================
--- konference/src/rtp/jrtplib/rtppollthread.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtppollthread.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,70 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPPOLLTHREAD_H
+
+#define RTPPOLLTHREAD_H
+
+#include &quot;rtpconfig.h&quot;
+
+#ifdef RTP_SUPPORT_THREAD
+
+#include &quot;rtptransmitter.h&quot;
+
+#include &lt;jthread.h&gt;
+#include &lt;jmutex.h&gt;
+#include &lt;list&gt;
+
+class RTPSession;
+class RTCPScheduler;
+
+class RTPPollThread : private JThread
+{
+public:
+	RTPPollThread(RTPSession &amp;session,RTCPScheduler &amp;rtcpsched);
+	~RTPPollThread();
+	int Start(RTPTransmitter *trans);
+	void Stop();
+private:
+	void *Thread();
+	
+	bool stop;
+	JMutex stopmutex;
+	RTPTransmitter *transmitter;
+	
+	RTPSession &rtpsession;
+	RTCPScheduler &rtcpsched;
+};
+
+#endif // RTP_SUPPORT_THREAD
+
+#endif // RTPPOLLTHREAD_H

Added: konference/src/rtp/jrtplib/rtprandom.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtprandom.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtprandom.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,213 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtprandom.h&quot;
+#include &lt;time.h&gt;
+#ifndef WIN32
+	#include &lt;unistd.h&gt;
+#else
+	#ifndef _WIN32_WCE
+		#include &lt;process.h&gt;
+	#else
+		#include &lt;windows.h&gt;
+		#include &lt;kfuncs.h&gt;
+	#endif // _WIN32_WINCE
+	#include &lt;stdlib.h&gt;
+#endif // WIN32
+
+#include &quot;rtpdebug.h&quot;
+
+#if !defined(RTP_SUPPORT_GNUDRAND) &amp;&amp; !defined(RTP_SUPPORT_RANDR)
+bool RTPRandom::init = false;
+#endif // WIN32
+
+RTPRandom::RTPRandom()
+{
+#if defined(RTP_SUPPORT_GNUDRAND) || defined(RTP_SUPPORT_RANDR)
+	u_int32_t x;
+
+	x = (u_int32_t)getpid();
+	x += (u_int32_t)time(0);
+	x -= (u_int32_t)clock();
+	x ^= (u_int32_t)(this);
+
+#ifdef RTP_SUPPORT_GNUDRAND
+	srand48_r(x,&amp;drandbuffer);
+#else
+	state = (unsigned int)x;
+#endif
+	
+#else // use simple rand and srand functions
+	if (init)
+		return;
+
+	u_int32_t x;
+
+#ifndef _WIN32_WCE
+	x = (u_int32_t)getpid();
+	x += (u_int32_t)time(0);
+	x -= (u_int32_t)clock();
+#else
+	x = (u_int32_t)GetCurrentProcessId();
+
+	FILETIME ft;
+	SYSTEMTIME st;
+	
+	GetSystemTime(&amp;st);
+	SystemTimeToFileTime(&amp;st,&amp;ft);
+	
+	x += ft.dwLowDateTime;
+#endif // _WIN32_WCE
+	x ^= (u_int32_t)(this);
+	srand((unsigned int)x);
+
+	init = true;
+#endif
+}
+
+RTPRandom::~RTPRandom()
+{
+}
+
+#ifdef RTP_SUPPORT_GNUDRAND
+
+u_int8_t RTPRandom::GetRandom8()
+{
+	double x;
+	drand48_r(&amp;drandbuffer,&amp;x);
+	u_int8_t y = (u_int8_t)(x*256.0);
+	return y;
+}
+
+u_int16_t RTPRandom::GetRandom16()
+{
+	double x;
+	drand48_r(&amp;drandbuffer,&amp;x);
+	u_int16_t y = (u_int16_t)(x*65536.0);
+	return y;
+}
+
+u_int32_t RTPRandom::GetRandom32()
+{
+	u_int32_t a = GetRandom16();
+	u_int32_t b = GetRandom16();
+	u_int32_t y = (a &lt;&lt; 16)|b;
+	return y;
+}
+
+double RTPRandom::GetRandomDouble()
+{
+	double x;
+	drand48_r(&amp;drandbuffer,&amp;x);
+	return x;
+}
+
+#else 
+#ifdef RTP_SUPPORT_RANDR
+
+u_int8_t RTPRandom::GetRandom8()
+{
+	u_int8_t x;
+
+	x = (u_int8_t)(256.0*((double)rand_r(&amp;state))/((double)RAND_MAX+1.0));
+	return x;
+}
+
+u_int16_t RTPRandom::GetRandom16()
+{
+	u_int16_t x;
+
+	x = (u_int16_t)(65536.0*((double)rand_r(&amp;state))/((double)RAND_MAX+1.0));
+	return x;
+}
+
+u_int32_t RTPRandom::GetRandom32()
+{
+	u_int32_t x,y;
+
+	x = (u_int32_t)(65536.0*((double)rand_r(&amp;state))/((double)RAND_MAX+1.0));
+	y = x;
+	x = (u_int32_t)(65536.0*((double)rand_r(&amp;state))/((double)RAND_MAX+1.0));
+	y ^= (x&lt;&lt;8);
+	x = (u_int32_t)(65536.0*((double)rand_r(&amp;state))/((double)RAND_MAX+1.0));
+	y ^= (x&lt;&lt;16);
+
+	return y;
+}
+
+double RTPRandom::GetRandomDouble()
+{
+	double x = ((double)rand_r(&amp;state))/((double)RAND_MAX+1.0);
+	return x;
+}
+
+#else
+
+u_int8_t RTPRandom::GetRandom8()
+{
+	u_int8_t x;
+
+	x = (u_int8_t)(256.0*((double)rand())/((double)RAND_MAX+1.0));
+	return x;
+}
+
+u_int16_t RTPRandom::GetRandom16()
+{
+	u_int16_t x;
+
+	x = (u_int16_t)(65536.0*((double)rand())/((double)RAND_MAX+1.0));
+	return x;
+}
+
+u_int32_t RTPRandom::GetRandom32()
+{
+	u_int32_t x,y;
+
+	x = (u_int32_t)(65536.0*((double)rand())/((double)RAND_MAX+1.0));
+	y = x;
+	x = (u_int32_t)(65536.0*((double)rand())/((double)RAND_MAX+1.0));
+	y ^= (x&lt;&lt;8);
+	x = (u_int32_t)(65536.0*((double)rand())/((double)RAND_MAX+1.0));
+	y ^= (x&lt;&lt;16);
+
+	return y;
+}
+
+double RTPRandom::GetRandomDouble()
+{
+	double x = ((double)rand())/((double)RAND_MAX+1.0);
+	return x;
+}
+
+#endif // RTP_SUPPORT_RANDR
+#endif // RTP_SUPPORT_GNUDRAND
+

Added: konference/src/rtp/jrtplib/rtprandom.h
===================================================================
--- konference/src/rtp/jrtplib/rtprandom.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtprandom.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,62 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPRANDOM_H
+
+#define RTPRANDOM_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtptypes.h&quot;
+#include &lt;stdlib.h&gt;
+
+class RTPRandom
+{
+public:
+	RTPRandom();
+	~RTPRandom();
+	u_int8_t GetRandom8();
+	u_int16_t GetRandom16();
+	u_int32_t GetRandom32();
+	double GetRandomDouble(); // returns random value between 0.0 and 1.0
+private:
+#ifdef RTP_SUPPORT_GNUDRAND
+	struct drand48_data drandbuffer;
+#else
+#ifdef RTP_SUPPORT_RANDR
+	unsigned int state;
+#else
+	static bool init;
+#endif // RTP_SUPPORT_RANDR
+#endif // RTP_SUPPORT_GNUDRAND
+};
+
+#endif // RTPRANDOM_H

Added: konference/src/rtp/jrtplib/rtprawpacket.h
===================================================================
--- konference/src/rtp/jrtplib/rtprawpacket.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtprawpacket.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,79 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPRAWPACKET_H
+
+#define RTPRAWPACKET_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtptimeutilities.h&quot;
+#include &quot;rtpaddress.h&quot;
+#include &quot;rtptypes.h&quot;
+
+class RTPRawPacket
+{
+public:	
+	RTPRawPacket(u_int8_t *data,size_t datalen,RTPAddress *address,RTPTime &amp;recvtime,bool rtp);
+	~RTPRawPacket();
+	
+	u_int8_t *GetData()						{ return packetdata; }
+	size_t GetDataLength() const					{ return packetdatalength; }
+	RTPTime GetReceiveTime() const					{ return receivetime; }
+	const RTPAddress *GetSenderAddress() const			{ return senderaddress; }
+	bool IsRTP() const						{ return isrtp; }
+	void ZeroData()							{ packetdata = 0; packetdatalength = 0; }
+private:
+	u_int8_t *packetdata;
+	size_t packetdatalength;
+	RTPTime receivetime;
+	RTPAddress *senderaddress;
+	bool isrtp;
+};
+
+inline RTPRawPacket::RTPRawPacket(u_int8_t *data,size_t datalen,RTPAddress *address,RTPTime &amp;recvtime,bool rtp):receivetime(recvtime)
+{
+	packetdata = data;
+	packetdatalength = datalen;
+	senderaddress = address;
+	isrtp = rtp;
+}
+
+inline RTPRawPacket::~RTPRawPacket()
+{
+	if (packetdata)
+		delete [] packetdata;
+	if (senderaddress)
+		delete senderaddress;
+}
+
+#endif // RTPRAWPACKET_H
+

Added: konference/src/rtp/jrtplib/rtpsession.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpsession.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpsession.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,1284 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtpsession.h&quot;
+#include &quot;rtperrors.h&quot;
+#include &quot;rtppollthread.h&quot;
+#include &quot;rtpudpv4transmitter.h&quot;
+#include &quot;rtpudpv6transmitter.h&quot;
+#include &quot;rtpgsttransmitter.h&quot;
+#include &quot;rtpsessionparams.h&quot;
+#include &quot;rtpdefines.h&quot;
+#include &quot;rtprawpacket.h&quot;
+#include &quot;rtppacket.h&quot;
+#include &quot;rtptimeutilities.h&quot;
+#include &quot;rtcpcompoundpacket.h&quot;
+#ifndef WIN32
+	#include &lt;unistd.h&gt;
+	#include &lt;stdlib.h&gt;
+#else
+	#include &lt;winbase.h&gt;
+#endif // WIN32
+
+#ifdef RTPDEBUG
+	#include &lt;iostream&gt;
+#endif // RTPDEBUG
+
+#include &quot;rtpdebug.h&quot;
+
+#ifdef RTP_SUPPORT_THREAD
+	#define SOURCES_LOCK					{ if (usingpollthread) sourcesmutex.Lock(); }
+	#define SOURCES_UNLOCK					{ if (usingpollthread) sourcesmutex.Unlock(); }
+	#define BUILDER_LOCK					{ if (usingpollthread) buildermutex.Lock(); }
+	#define BUILDER_UNLOCK					{ if (usingpollthread) buildermutex.Unlock(); }
+	#define SCHED_LOCK					{ if (usingpollthread) schedmutex.Lock(); }
+	#define SCHED_UNLOCK					{ if (usingpollthread) schedmutex.Unlock(); }
+#else
+	#define SOURCES_LOCK
+	#define SOURCES_UNLOCK
+	#define BUILDER_LOCK
+	#define BUILDER_UNLOCK
+	#define SCHED_LOCK
+	#define SCHED_UNLOCK
+#endif // RTP_SUPPORT_THREAD
+
+RTPSession::RTPSession(RTPTransmitter::TransmissionProtocol proto /* = RTPTransmitter::IPv4UDPProto */ ) 
+	: protocol(proto),sources(*this),rtcpsched(sources),rtcpbuilder(sources,packetbuilder)
+{
+	created = false;
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	timeinit.Dummy();
+#endif // WIN32 || _WIN32_WCE
+}
+
+RTPSession::~RTPSession()
+{
+	Destroy();
+}
+
+int RTPSession::Create(const RTPSessionParams &amp;sessparams,const RTPTransmissionParams *transparams /* = 0 */)
+{
+	int status;
+	
+	if (created)
+		return ERR_RTP_SESSION_ALREADYCREATED;
+
+	usingpollthread = sessparams.IsUsingPollThread();
+	useSR_BYEifpossible = sessparams.GetSenderReportForBYE();
+	
+	// Check max packet size
+	
+	if ((maxpacksize = sessparams.GetMaximumPacketSize()) &lt; RTP_MINPACKETSIZE)
+		return ERR_RTP_SESSION_MAXPACKETSIZETOOSMALL;
+		
+	// Initialize the transmission component
+	
+	rtptrans = 0;
+	switch(protocol)
+	{
+	case RTPTransmitter::IPv4UDPProto:
+		rtptrans = new RTPUDPv4Transmitter();
+		break;
+#ifdef RTP_SUPPORT_IPV6
+	case RTPTransmitter::IPv6UDPProto:
+		rtptrans = new RTPUDPv6Transmitter();
+		break;
+#endif // RTP_SUPPORT_IPV6
+#ifdef RTP_SUPPORT_GST
+	case RTPTransmitter::IPv4GSTProto:
+		rtptrans = new RTPGSTv4Transmitter();
+		break;
+#endif // RTP_SUPPORT_GST
+	case RTPTransmitter::UserDefinedProto:
+		rtptrans = NewUserDefinedTransmitter();
+		if (rtptrans == 0)
+			return ERR_RTP_SESSION_USERDEFINEDTRANSMITTERNULL;
+		break;
+	default:
+		return ERR_RTP_SESSION_UNSUPPORTEDTRANSMISSIONPROTOCOL;
+	}
+	
+	if (rtptrans == 0)
+		return ERR_RTP_OUTOFMEM;
+	if ((status = rtptrans-&gt;Init(usingpollthread)) &lt; 0)
+	{
+		delete rtptrans;
+		return status;
+	}
+	if ((status = rtptrans-&gt;Create(maxpacksize,transparams)) &lt; 0)
+	{
+		delete rtptrans;
+		return status;
+	}
+
+	// Initialize packet builder
+	
+	if ((status = packetbuilder.Init(maxpacksize)) &lt; 0)
+	{
+		delete rtptrans;
+		return status;
+	}
+
+#ifdef RTP_SUPPORT_PROBATION
+
+	// Set probation type
+	sources.SetProbationType(sessparams.GetProbationType());
+
+#endif // RTP_SUPPORT_PROBATION
+
+	// Add our own ssrc to the source table
+	
+	if ((status = sources.CreateOwnSSRC(packetbuilder.GetSSRC())) &lt; 0)
+	{
+		packetbuilder.Destroy();
+		delete rtptrans;
+		return status;
+	}
+
+	// Set the initial receive mode
+	
+	if ((status = rtptrans-&gt;SetReceiveMode(sessparams.GetReceiveMode())) &lt; 0)
+	{
+		packetbuilder.Destroy();
+		sources.Clear();
+		delete rtptrans;
+		return status;
+	}
+
+	// Init the RTCP packet builder
+	
+	double timestampunit = sessparams.GetOwnTimestampUnit();
+	u_int8_t buf[1024];
+	size_t buflen = 1024;
+	
+	if ((status = CreateCNAME(buf,&amp;buflen,sessparams.GetResolveLocalHostname())) &lt; 0)
+	{
+		packetbuilder.Destroy();
+		sources.Clear();
+		delete rtptrans;
+		return status;
+	}
+	
+	if ((status = rtcpbuilder.Init(maxpacksize,timestampunit,buf,buflen)) &lt; 0)
+	{
+		packetbuilder.Destroy();
+		sources.Clear();
+		delete rtptrans;
+		return status;
+	}
+
+	// Set scheduler parameters
+	
+	rtcpsched.Reset();
+	rtcpsched.SetHeaderOverhead(rtptrans-&gt;GetHeaderOverhead());
+
+	RTCPSchedulerParams schedparams;
+
+	sessionbandwidth = sessparams.GetSessionBandwidth();
+	controlfragment = sessparams.GetControlTrafficFraction();
+	
+	if ((status = schedparams.SetRTCPBandwidth(sessionbandwidth*controlfragment)) &lt; 0)
+	{
+		delete rtptrans;
+		packetbuilder.Destroy();
+		sources.Clear();
+		rtcpbuilder.Destroy();
+		return status;
+	}
+	if ((status = schedparams.SetSenderBandwidthFraction(sessparams.GetSenderControlBandwidthFraction())) &lt; 0)
+	{
+		delete rtptrans;
+		packetbuilder.Destroy();
+		sources.Clear();
+		rtcpbuilder.Destroy();
+		return status;
+	}
+	if ((status = schedparams.SetMinimumTransmissionInterval(sessparams.GetMinimumRTCPTransmissionInterval())) &lt; 0)
+	{
+		delete rtptrans;
+		packetbuilder.Destroy();
+		sources.Clear();
+		rtcpbuilder.Destroy();
+		return status;
+	}
+	schedparams.SetUseHalfAtStartup(sessparams.GetUseHalfRTCPIntervalAtStartup());
+	schedparams.SetRequestImmediateBYE(sessparams.GetRequestImmediateBYE());
+	
+	rtcpsched.SetParameters(schedparams);
+
+	// copy other parameters
+	
+	acceptownpackets = sessparams.AcceptOwnPackets();
+	membermultiplier = sessparams.GetSourceTimeoutMultiplier();
+	sendermultiplier = sessparams.GetSenderTimeoutMultiplier();
+	byemultiplier = sessparams.GetBYETimeoutMultiplier();
+	collisionmultiplier = sessparams.GetCollisionTimeoutMultiplier();
+	notemultiplier = sessparams.GetNoteTimeoutMultiplier();
+
+	// Do thread stuff if necessary
+	
+#ifdef RTP_SUPPORT_THREAD
+	pollthread = 0;
+	if (usingpollthread)
+	{
+		if (!sourcesmutex.IsInitialized())	
+		{
+			if (sourcesmutex.Init() &lt; 0)
+			{
+				delete rtptrans;
+				packetbuilder.Destroy();
+				sources.Clear();
+				rtcpbuilder.Destroy();
+				return ERR_RTP_SESSION_CANTINITMUTEX;
+			}
+		}
+		if (!buildermutex.IsInitialized())
+		{
+			if (buildermutex.Init() &lt; 0)
+			{
+				delete rtptrans;
+				packetbuilder.Destroy();
+				sources.Clear();
+				rtcpbuilder.Destroy();
+				return ERR_RTP_SESSION_CANTINITMUTEX;
+			}
+		}
+		if (!schedmutex.IsInitialized())
+		{
+			if (schedmutex.Init() &lt; 0)
+			{
+				delete rtptrans;
+				packetbuilder.Destroy();
+				sources.Clear();
+				rtcpbuilder.Destroy();
+				return ERR_RTP_SESSION_CANTINITMUTEX;
+			}
+		}
+		
+		pollthread = new RTPPollThread(*this,rtcpsched);
+		if (pollthread == 0)
+		{
+			delete rtptrans;
+			packetbuilder.Destroy();
+			sources.Clear();
+			rtcpbuilder.Destroy();
+			return ERR_RTP_OUTOFMEM;
+		}
+		if ((status = pollthread-&gt;Start(rtptrans)) &lt; 0)
+		{
+			delete rtptrans;
+			delete pollthread;
+			packetbuilder.Destroy();
+			sources.Clear();
+			rtcpbuilder.Destroy();
+			return status;
+		}
+	}
+#endif // RTP_SUPPORT_THREAD	
+	
+	created = true;
+	return 0;
+}
+
+void RTPSession::Destroy()
+{
+	if (!created)
+		return;
+
+#ifdef RTP_SUPPORT_THREAD
+	if (pollthread)
+		delete pollthread;
+#endif // RTP_SUPPORT_THREAD
+	
+	delete rtptrans;
+	packetbuilder.Destroy();
+	rtcpbuilder.Destroy();
+	rtcpsched.Reset();
+	collisionlist.Clear();
+	sources.Clear();
+
+	std::list&lt;RTCPCompoundPacket *&gt;::const_iterator it;
+
+	for (it = byepackets.begin() ; it != byepackets.end() ; it++)
+		delete (*it);
+	byepackets.clear();
+	
+	created = false;
+}
+
+void RTPSession::BYEDestroy(const RTPTime &amp;maxwaittime,const void *reason,size_t reasonlength)
+{
+	if (!created)
+		return;
+
+	// first, stop the thread so we have full control over all components
+	
+#ifdef RTP_SUPPORT_THREAD
+	if (pollthread)
+		delete pollthread;
+#endif // RTP_SUPPORT_THREAD
+
+	RTPTime stoptime = RTPTime::CurrentTime();
+	stoptime += maxwaittime;
+
+	// add bye packet to the list if we've sent data
+
+	RTCPCompoundPacket *pack;
+
+	if (rtptrans-&gt;GetNumRTPPacketsSent() != 0 || rtptrans-&gt;GetNumRTCPPacketsSent() != 0)
+	{
+		int status;
+		
+		reasonlength = (reasonlength&gt;RTCP_BYE_MAXREASONLENGTH)?RTCP_BYE_MAXREASONLENGTH:reasonlength;
+	       	status = rtcpbuilder.BuildBYEPacket(&amp;pack,reason,reasonlength,useSR_BYEifpossible);
+		if (status &gt;= 0)
+		{
+			byepackets.push_back(pack);
+	
+			if (byepackets.size() == 1)
+				rtcpsched.ScheduleBYEPacket(pack-&gt;GetCompoundPacketLength());
+		}
+	}
+	
+	if (!byepackets.empty())
+	{
+		bool done = false;
+		
+		while (!done)
+		{
+			RTPTime curtime = RTPTime::CurrentTime();
+			
+			if (curtime &gt;= stoptime)
+				done = true;
+		
+			if (rtcpsched.IsTime())
+			{
+				pack = *(byepackets.begin());
+				byepackets.pop_front();
+			
+				rtptrans-&gt;SendRTCPData(pack-&gt;GetCompoundPacketData(),pack-&gt;GetCompoundPacketLength());
+				delete pack;
+				if (!byepackets.empty()) // more bye packets to send, schedule them
+					rtcpsched.ScheduleBYEPacket((*(byepackets.begin()))-&gt;GetCompoundPacketLength());
+				else
+					done = true;
+			}
+			if (!done)
+				RTPTime::Wait(RTPTime(0,100000));
+		}
+	}
+	
+	delete rtptrans;
+	packetbuilder.Destroy();
+	rtcpbuilder.Destroy();
+	rtcpsched.Reset();
+	collisionlist.Clear();
+	sources.Clear();
+
+	// clear rest of bye packets
+	std::list&lt;RTCPCompoundPacket *&gt;::const_iterator it;
+
+	for (it = byepackets.begin() ; it != byepackets.end() ; it++)
+		delete (*it);
+	byepackets.clear();
+	
+	created = false;
+}
+
+bool RTPSession::IsActive()
+{
+	return created;
+}
+
+u_int32_t RTPSession::GetLocalSSRC()
+{
+	if (!created)
+		return 0;
+	
+	u_int32_t ssrc;
+
+	BUILDER_LOCK
+	ssrc = packetbuilder.GetSSRC();
+	BUILDER_UNLOCK
+	return ssrc;
+}
+
+int RTPSession::AddDestination(const RTPAddress &amp;addr)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	return rtptrans-&gt;AddDestination(addr);
+}
+
+int RTPSession::DeleteDestination(const RTPAddress &amp;addr)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	return rtptrans-&gt;DeleteDestination(addr);
+}
+
+void RTPSession::ClearDestinations()
+{
+	if (!created)
+		return;
+	rtptrans-&gt;ClearDestinations();
+}
+
+bool RTPSession::SupportsMulticasting()
+{
+	if (!created)
+		return false;
+	return rtptrans-&gt;SupportsMulticasting();
+}
+
+int RTPSession::JoinMulticastGroup(const RTPAddress &amp;addr)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	return rtptrans-&gt;JoinMulticastGroup(addr);
+}
+
+int RTPSession::LeaveMulticastGroup(const RTPAddress &amp;addr)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	return rtptrans-&gt;LeaveMulticastGroup(addr);
+}
+
+void RTPSession::LeaveAllMulticastGroups()
+{
+	if (!created)
+		return;
+	rtptrans-&gt;LeaveAllMulticastGroups();
+}
+
+int RTPSession::SendPacket(const void *data,size_t len)
+{
+	int status;
+	
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	BUILDER_LOCK
+	if ((status = packetbuilder.BuildPacket(data,len)) &lt; 0)
+	{
+		BUILDER_UNLOCK
+		return status;
+	}
+	if ((status = rtptrans-&gt;SendRTPData(packetbuilder.GetPacket(),packetbuilder.GetPacketLength())) &lt; 0)
+	{
+		BUILDER_UNLOCK
+		return status;
+	}
+	BUILDER_UNLOCK
+
+	SOURCES_LOCK
+	sources.SentRTPPacket();
+	SOURCES_UNLOCK
+	return 0;
+}
+
+int RTPSession::SendPacket(const void *data,size_t len,
+                u_int8_t pt,bool mark,u_int32_t timestampinc)
+{
+	int status;
+
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	
+	BUILDER_LOCK
+	if ((status = packetbuilder.BuildPacket(data,len,pt,mark,timestampinc)) &lt; 0)
+	{
+		BUILDER_UNLOCK
+		return status;
+	}
+	if ((status = rtptrans-&gt;SendRTPData(packetbuilder.GetPacket(),packetbuilder.GetPacketLength())) &lt; 0)
+	{
+		BUILDER_UNLOCK
+		return status;
+	}
+	BUILDER_UNLOCK
+	
+	SOURCES_LOCK
+	sources.SentRTPPacket();
+	SOURCES_UNLOCK
+	return 0;
+}
+
+int RTPSession::SendPacketEx(const void *data,size_t len,
+                  u_int16_t hdrextID,const void *hdrextdata,size_t numhdrextwords)
+{
+	int status;
+	
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	BUILDER_LOCK
+	if ((status = packetbuilder.BuildPacketEx(data,len,hdrextID,hdrextdata,numhdrextwords)) &lt; 0)
+	{
+		BUILDER_UNLOCK
+		return status;
+	}
+	if ((status = rtptrans-&gt;SendRTPData(packetbuilder.GetPacket(),packetbuilder.GetPacketLength())) &lt; 0)
+	{
+		BUILDER_UNLOCK
+		return status;
+	}
+	BUILDER_UNLOCK
+
+	SOURCES_LOCK
+	sources.SentRTPPacket();
+	SOURCES_UNLOCK
+	return 0;
+}
+
+int RTPSession::SendPacketEx(const void *data,size_t len,
+                  u_int8_t pt,bool mark,u_int32_t timestampinc,
+                  u_int16_t hdrextID,const void *hdrextdata,size_t numhdrextwords)
+{
+	int status;
+	
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	
+	BUILDER_LOCK
+	if ((status = packetbuilder.BuildPacketEx(data,len,pt,mark,timestampinc,hdrextID,hdrextdata,numhdrextwords)) &lt; 0)
+	{
+		BUILDER_UNLOCK
+		return status;
+	}
+	if ((status = rtptrans-&gt;SendRTPData(packetbuilder.GetPacket(),packetbuilder.GetPacketLength())) &lt; 0)
+	{
+		BUILDER_UNLOCK
+		return status;
+	}
+	BUILDER_UNLOCK
+
+	SOURCES_LOCK
+	sources.SentRTPPacket();
+	SOURCES_UNLOCK
+	return 0;
+}
+
+int RTPSession::SetDefaultPayloadType(u_int8_t pt)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	
+	int status;
+	
+	BUILDER_LOCK
+	status = packetbuilder.SetDefaultPayloadType(pt);
+	BUILDER_UNLOCK
+	return status;
+}
+
+int RTPSession::SetDefaultMark(bool m)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+
+	BUILDER_LOCK
+	status = packetbuilder.SetDefaultMark(m);
+	BUILDER_UNLOCK
+	return status;
+}
+
+int RTPSession::SetDefaultTimestampIncrement(u_int32_t timestampinc)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+
+	BUILDER_LOCK
+	status = packetbuilder.SetDefaultTimestampIncrement(timestampinc);
+	BUILDER_UNLOCK
+	return status;
+}
+
+int RTPSession::IncrementTimestamp(u_int32_t inc)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+
+	BUILDER_LOCK
+	status = packetbuilder.IncrementTimestamp(inc);
+	BUILDER_UNLOCK
+	return status;
+}
+
+int RTPSession::IncrementTimestampDefault()
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+	
+	BUILDER_LOCK
+	status = packetbuilder.IncrementTimestampDefault();
+	BUILDER_UNLOCK
+	return status;
+}
+
+RTPTransmissionInfo *RTPSession::GetTransmissionInfo()
+{
+	if (!created)
+		return 0;
+	return rtptrans-&gt;GetTransmissionInfo();
+}
+
+int RTPSession::Poll()
+{
+	int status;
+	
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	if (usingpollthread)
+		return ERR_RTP_SESSION_USINGPOLLTHREAD;
+	if ((status = rtptrans-&gt;Poll()) &lt; 0)
+		return status;
+	return ProcessPolledData();
+}
+
+int RTPSession::WaitForIncomingData(const RTPTime &amp;delay,bool *dataavailable)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	if (usingpollthread)
+		return ERR_RTP_SESSION_USINGPOLLTHREAD;
+	return rtptrans-&gt;WaitForIncomingData(delay,dataavailable);
+}
+
+int RTPSession::AbortWait()
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	if (usingpollthread)
+		return ERR_RTP_SESSION_USINGPOLLTHREAD;
+	return rtptrans-&gt;AbortWait();
+}
+
+RTPTime RTPSession::GetRTCPDelay()
+{
+	if (!created)
+		return RTPTime(0,0);
+	if (usingpollthread)
+		return RTPTime(0,0);
+
+	SOURCES_LOCK
+	SCHED_LOCK
+	RTPTime t = rtcpsched.GetTransmissionDelay();
+	SCHED_UNLOCK
+	SOURCES_UNLOCK
+	return t;
+}
+
+int RTPSession::BeginDataAccess()
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	SOURCES_LOCK
+	return 0;
+}
+
+bool RTPSession::GotoFirstSource()
+{
+	if (!created)
+		return false;
+	return sources.GotoFirstSource();
+}
+
+bool RTPSession::GotoNextSource()
+{
+	if (!created)
+		return false;
+	return sources.GotoNextSource();
+}
+
+bool RTPSession::GotoPreviousSource()
+{
+	if (!created)
+		return false;
+	return sources.GotoPreviousSource();
+}
+
+bool RTPSession::GotoFirstSourceWithData()
+{
+	if (!created)
+		return false;
+	return sources.GotoFirstSourceWithData();
+}
+
+bool RTPSession::GotoNextSourceWithData()
+{
+	if (!created)
+		return false;
+	return sources.GotoNextSourceWithData();
+}
+
+bool RTPSession::GotoPreviousSourceWithData()
+{
+	if (!created)
+		return false;
+	return sources.GotoPreviousSourceWithData();
+}
+
+RTPSourceData *RTPSession::GetCurrentSourceInfo()
+{
+	if (!created)
+		return 0;
+	return sources.GetCurrentSourceInfo();
+}
+
+RTPSourceData *RTPSession::GetSourceInfo(u_int32_t ssrc)
+{
+	if (!created)
+		return 0;
+	return sources.GetSourceInfo(ssrc);
+}
+
+RTPPacket *RTPSession::GetNextPacket()
+{
+	if (!created)
+		return 0;
+	return sources.GetNextPacket();
+}
+
+int RTPSession::EndDataAccess()
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	SOURCES_UNLOCK
+	return 0;
+}
+
+int RTPSession::SetReceiveMode(RTPTransmitter::ReceiveMode m)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	return rtptrans-&gt;SetReceiveMode(m);
+}
+
+int RTPSession::AddToIgnoreList(const RTPAddress &amp;addr)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	return rtptrans-&gt;AddToIgnoreList(addr);
+}
+
+int RTPSession::DeleteFromIgnoreList(const RTPAddress &amp;addr)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	return rtptrans-&gt;DeleteFromIgnoreList(addr);
+}
+
+void RTPSession::ClearIgnoreList()
+{
+	if (!created)
+		return;
+	rtptrans-&gt;ClearIgnoreList();
+}
+
+int RTPSession::AddToAcceptList(const RTPAddress &amp;addr)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	return rtptrans-&gt;AddToAcceptList(addr);
+}
+
+int RTPSession::DeleteFromAcceptList(const RTPAddress &amp;addr)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	return rtptrans-&gt;DeleteFromAcceptList(addr);
+}
+
+void RTPSession::ClearAcceptList()
+{
+	if (!created)
+		return;
+	rtptrans-&gt;ClearAcceptList();
+}
+
+int RTPSession::SetMaximumPacketSize(size_t s)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	if (s &lt; RTP_MINPACKETSIZE)
+		return ERR_RTP_SESSION_MAXPACKETSIZETOOSMALL;
+	
+	int status;
+
+	if ((status = rtptrans-&gt;SetMaximumPacketSize(s)) &lt; 0)
+		return status;
+
+	BUILDER_LOCK
+	if ((status = packetbuilder.SetMaximumPacketSize(s)) &lt; 0)
+	{
+		BUILDER_UNLOCK
+		// restore previous max packet size
+		rtptrans-&gt;SetMaximumPacketSize(maxpacksize);
+		return status;
+	}
+	if ((status = rtcpbuilder.SetMaximumPacketSize(s)) &lt; 0)
+	{
+		// restore previous max packet size
+		packetbuilder.SetMaximumPacketSize(maxpacksize);
+		BUILDER_UNLOCK
+		rtptrans-&gt;SetMaximumPacketSize(maxpacksize);
+		return status;
+	}
+	BUILDER_UNLOCK
+	maxpacksize = s;
+	return 0;
+}
+
+int RTPSession::SetSessionBandwidth(double bw)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+	SCHED_LOCK
+	RTCPSchedulerParams p = rtcpsched.GetParameters();
+	status = p.SetRTCPBandwidth(bw*controlfragment);
+	if (status &gt;= 0)
+	{
+		rtcpsched.SetParameters(p);
+		sessionbandwidth = bw;
+	}
+	SCHED_UNLOCK
+	return status;
+}
+
+int RTPSession::SetTimestampUnit(double u)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+
+	BUILDER_LOCK
+	status = rtcpbuilder.SetTimestampUnit(u);
+	BUILDER_UNLOCK
+	return status;
+}
+
+void RTPSession::SetNameInterval(int count)
+{
+	if (!created)
+		return;
+	BUILDER_LOCK
+	rtcpbuilder.SetNameInterval(count);
+	BUILDER_UNLOCK
+}
+
+void RTPSession::SetEMailInterval(int count)
+{
+	if (!created)
+		return;
+	BUILDER_LOCK
+	rtcpbuilder.SetEMailInterval(count);
+	BUILDER_UNLOCK
+}
+
+void RTPSession::SetLocationInterval(int count)
+{
+	if (!created)
+		return;
+	BUILDER_LOCK
+	rtcpbuilder.SetLocationInterval(count);
+	BUILDER_UNLOCK
+}
+
+void RTPSession::SetPhoneInterval(int count)
+{
+	if (!created)
+		return;
+	BUILDER_LOCK
+	rtcpbuilder.SetPhoneInterval(count);
+	BUILDER_UNLOCK
+}
+
+void RTPSession::SetToolInterval(int count)
+{
+	if (!created)
+		return;
+	BUILDER_LOCK
+	rtcpbuilder.SetToolInterval(count);
+	BUILDER_UNLOCK
+}
+
+void RTPSession::SetNoteInterval(int count)
+{
+	if (!created)
+		return;
+	BUILDER_LOCK
+	rtcpbuilder.SetNoteInterval(count);
+	BUILDER_UNLOCK
+}
+
+int RTPSession::SetLocalName(const void *s,size_t len)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+	BUILDER_LOCK
+	status = rtcpbuilder.SetLocalName(s,len);
+	BUILDER_UNLOCK
+	return status;
+}
+
+int RTPSession::SetLocalEMail(const void *s,size_t len)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+	BUILDER_LOCK
+	status = rtcpbuilder.SetLocalEMail(s,len);
+	BUILDER_UNLOCK
+	return status;
+}
+
+int RTPSession::SetLocalLocation(const void *s,size_t len)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+	BUILDER_LOCK
+	status = rtcpbuilder.SetLocalLocation(s,len);
+	BUILDER_UNLOCK
+	return status;
+}
+
+int RTPSession::SetLocalPhone(const void *s,size_t len)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+	BUILDER_LOCK
+	status = rtcpbuilder.SetLocalPhone(s,len);
+	BUILDER_UNLOCK
+	return status;
+}
+
+int RTPSession::SetLocalTool(const void *s,size_t len)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+	BUILDER_LOCK
+	status = rtcpbuilder.SetLocalTool(s,len);
+	BUILDER_UNLOCK
+	return status;
+}
+
+int RTPSession::SetLocalNote(const void *s,size_t len)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+	BUILDER_LOCK
+	status = rtcpbuilder.SetLocalNote(s,len);
+	BUILDER_UNLOCK
+	return status;
+}
+
+int RTPSession::ProcessPolledData()
+{
+	RTPRawPacket *rawpack;
+	int status;
+	
+	SOURCES_LOCK
+	while ((rawpack = rtptrans-&gt;GetNextPacket()) != 0)
+	{
+		sources.ClearOwnCollisionFlag();
+
+		// since our sources instance also uses the scheduler (analysis of incoming packets)
+		// we'll lock it
+		SCHED_LOCK
+		if ((status = sources.ProcessRawPacket(rawpack,rtptrans,acceptownpackets)) &lt; 0)
+		{
+			SCHED_UNLOCK
+			SOURCES_UNLOCK
+			delete rawpack;
+			return status;
+		}
+		SCHED_UNLOCK
+				
+		if (sources.DetectedOwnCollision()) // collision handling!
+		{
+			bool created;
+			
+			if ((status = collisionlist.UpdateAddress(rawpack-&gt;GetSenderAddress(),rawpack-&gt;GetReceiveTime(),&amp;created)) &lt; 0)
+			{
+				SOURCES_UNLOCK
+				delete rawpack;
+				return status;
+			}
+
+			if (created) // first time we've encountered this address, send bye packet and
+			{            // change our own SSRC
+				if (rtptrans-&gt;GetNumRTPPacketsSent() != 0 || rtptrans-&gt;GetNumRTCPPacketsSent() != 0)
+				{
+					// Only send BYE packet if we've actually sent data using this
+					// SSRC
+					
+					RTCPCompoundPacket *rtcpcomppack;
+
+					BUILDER_LOCK
+					if ((status = rtcpbuilder.BuildBYEPacket(&amp;rtcpcomppack,0,0,useSR_BYEifpossible)) &lt; 0)
+					{
+						BUILDER_UNLOCK
+						SOURCES_UNLOCK
+						delete rawpack;
+						return status;
+					}
+					BUILDER_UNLOCK
+
+					byepackets.push_back(rtcpcomppack);
+					if (byepackets.size() == 1) // was the first packet, schedule a BYE packet (otherwise there's already one scheduled)
+					{
+						SCHED_LOCK
+						rtcpsched.ScheduleBYEPacket(rtcpcomppack-&gt;GetCompoundPacketLength());
+						SCHED_UNLOCK
+					}
+				}
+				// bye packet is built and scheduled, now change our SSRC
+				// and reset the packet count in the transmitter
+				
+				BUILDER_LOCK
+				u_int32_t newssrc = packetbuilder.CreateNewSSRC(sources);
+				BUILDER_UNLOCK
+					
+				rtptrans-&gt;ResetPacketCount();
+
+				// remove old entry in source table and add new one
+
+				if ((status = sources.DeleteOwnSSRC()) &lt; 0)
+				{
+					SOURCES_UNLOCK
+					delete rawpack;
+					return status;
+				}
+				if ((status = sources.CreateOwnSSRC(newssrc)) &lt; 0)
+				{
+					SOURCES_UNLOCK
+					delete rawpack;
+					return status;
+				}
+			}
+		}
+		
+		delete rawpack;
+	}
+
+	SCHED_LOCK
+	RTPTime d = rtcpsched.CalculateDeterministicInterval(false);
+	SCHED_UNLOCK
+	
+	RTPTime t = RTPTime::CurrentTime();
+	double Td = d.GetDouble();
+	RTPTime sendertimeout = RTPTime(Td*sendermultiplier);
+	RTPTime generaltimeout = RTPTime(Td*membermultiplier);
+	RTPTime byetimeout = RTPTime(Td*byemultiplier);
+	RTPTime colltimeout = RTPTime(Td*collisionmultiplier);
+	RTPTime notetimeout = RTPTime(Td*notemultiplier);
+	
+	sources.MultipleTimeouts(t,sendertimeout,byetimeout,generaltimeout,notetimeout);
+	collisionlist.Timeout(t,colltimeout);
+	
+	// We'll check if it's time for RTCP stuff
+
+	SCHED_LOCK
+	bool istime = rtcpsched.IsTime();
+	SCHED_UNLOCK
+	
+	if (istime)
+	{
+		RTCPCompoundPacket *pack;
+	
+		// we'll check if there's a bye packet to send, or just a normal packet
+
+		if (byepackets.empty())
+		{
+			BUILDER_LOCK
+			if ((status = rtcpbuilder.BuildNextPacket(&amp;pack)) &lt; 0)
+			{
+				BUILDER_UNLOCK
+				SOURCES_UNLOCK
+				return status;
+			}
+			BUILDER_UNLOCK
+			if ((status = rtptrans-&gt;SendRTCPData(pack-&gt;GetCompoundPacketData(),pack-&gt;GetCompoundPacketLength())) &lt; 0)
+			{
+				SOURCES_UNLOCK
+				delete pack;
+				return status;
+			}
+		}
+		else
+		{
+			pack = *(byepackets.begin());
+			byepackets.pop_front();
+			
+			if ((status = rtptrans-&gt;SendRTCPData(pack-&gt;GetCompoundPacketData(),pack-&gt;GetCompoundPacketLength())) &lt; 0)
+			{
+				SOURCES_UNLOCK
+				delete pack;
+				return status;
+			}
+			
+			if (!byepackets.empty()) // more bye packets to send, schedule them
+			{
+				SCHED_LOCK
+				rtcpsched.ScheduleBYEPacket((*(byepackets.begin()))-&gt;GetCompoundPacketLength());
+				SCHED_UNLOCK
+			}
+		}
+		
+		SCHED_LOCK
+		rtcpsched.AnalyseOutgoing(*pack);
+		SCHED_UNLOCK
+
+		delete pack;
+	}
+	SOURCES_UNLOCK
+	return 0;
+}
+
+int RTPSession::CreateCNAME(u_int8_t *buffer,size_t *bufferlength,bool resolve)
+{
+#ifndef WIN32
+	bool gotlogin = true;
+#ifdef RTP_SUPPORT_GETLOGINR
+	buffer[0] = 0;
+	if (getlogin_r((char *)buffer,*bufferlength) != 0)
+		gotlogin = false;
+	else
+	{
+		if (buffer[0] == 0)
+			gotlogin = false;
+	}
+	
+	if (!gotlogin) // try regular getlogin
+	{
+		char *loginname = getlogin();
+		if (loginname == 0)
+			gotlogin = false;
+		else
+			strncpy((char *)buffer,loginname,*bufferlength);
+	}
+#else
+	char *loginname = getlogin();
+	if (loginname == 0)
+		gotlogin = false;
+	else
+		strncpy((char *)buffer,loginname,*bufferlength);
+#endif // RTP_SUPPORT_GETLOGINR
+	if (!gotlogin)
+	{
+		char *logname = getenv(&quot;LOGNAME&quot;);
+		if (logname == 0)
+			return ERR_RTP_SESSION_CANTGETLOGINNAME;
+		strncpy((char *)buffer,logname,*bufferlength);
+	}
+#else // Win32 version
+
+#ifndef _WIN32_WCE
+	DWORD len = *bufferlength;
+	if (!GetUserName((LPTSTR)buffer,&amp;len))
+		strcpy((char *)buffer,&quot;unknown&quot;);
+#else 
+	strcpy((char *)buffer,&quot;unknown&quot;);
+#endif // _WIN32_WCE
+	
+#endif // WIN32
+	buffer[*bufferlength-1] = 0;
+
+	size_t offset = strlen((const char *)buffer);
+	if (offset &lt; (*bufferlength-1))
+		buffer[offset] = (u_int8_t)'@';
+	offset++;
+
+	size_t buflen2 = *bufferlength-offset;
+	int status;
+	
+	if (resolve)
+	{
+		if ((status = rtptrans-&gt;GetLocalHostName(buffer+offset,&amp;buflen2)) &lt; 0)
+			return status;
+		*bufferlength = buflen2+offset;
+	}
+	else
+	{
+		char hostname[1024];
+		
+		strcpy(hostname,&quot;localhost&quot;); // just in case gethostname fails
+		gethostname(hostname,1024);
+		strncpy((char *)(buffer+offset),hostname,buflen2);
+		*bufferlength = offset+strlen(hostname);
+	}
+	if (*bufferlength &gt; RTCP_SDES_MAXITEMLENGTH)
+		*bufferlength = RTCP_SDES_MAXITEMLENGTH;
+	return 0;
+}
+
+#ifdef RTPDEBUG
+void RTPSession::DumpSources()
+{
+	BeginDataAccess();
+	std::cout &lt;&lt; &quot;----------------------------------------------------------------&quot; &lt;&lt; std::endl;
+	sources.Dump();
+	EndDataAccess();
+}
+
+void RTPSession::DumpTransmitter()
+{
+	if (created)
+		rtptrans-&gt;Dump();
+}
+#endif // RTPDEBUG
+

Added: konference/src/rtp/jrtplib/rtpsession.h
===================================================================
--- konference/src/rtp/jrtplib/rtpsession.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpsession.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,215 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPSESSION_H
+
+#define RTPSESSION_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtplibraryversion.h&quot;
+#include &quot;rtppacketbuilder.h&quot;
+#include &quot;rtpsessionsources.h&quot;
+#include &quot;rtptransmitter.h&quot;
+#include &quot;rtpcollisionlist.h&quot;
+#include &quot;rtcpscheduler.h&quot;
+#include &quot;rtcppacketbuilder.h&quot;
+#include &quot;rtptimeutilities.h&quot;
+#include &lt;list&gt;
+
+#ifdef RTP_SUPPORT_THREAD
+	#include &lt;jmutex.h&gt;	
+#endif // RTP_SUPPORT_THREAD
+
+class RTPTransmitter;
+class RTPSessionParams;
+class RTPTransmissionParams;
+class RTPAddress;
+class RTPSourceData;
+class RTPPacket;
+class RTPPollThread;
+class RTPTransmissionInfo;
+class RTCPCompoundPacket;
+class RTCPPacket;
+class RTCPAPPPacket;
+
+class RTPSession
+{
+public:
+	RTPSession(RTPTransmitter::TransmissionProtocol proto = RTPTransmitter::IPv4UDPProto);
+	virtual ~RTPSession();
+	
+	int Create(const RTPSessionParams &amp;sessparams,const RTPTransmissionParams *transparams = 0);
+	void Destroy();
+	void BYEDestroy(const RTPTime &amp;maxwaittime,const void *reason,size_t reasonlength);
+	bool IsActive();
+	
+	u_int32_t GetLocalSSRC();
+	
+	int AddDestination(const RTPAddress &amp;addr);
+	int DeleteDestination(const RTPAddress &amp;addr);
+	void ClearDestinations();
+
+	bool SupportsMulticasting();
+	int JoinMulticastGroup(const RTPAddress &amp;addr);
+	int LeaveMulticastGroup(const RTPAddress &amp;addr);
+	void LeaveAllMulticastGroups();
+
+	int SendPacket(const void *data,size_t len);
+	int SendPacket(const void *data,size_t len,
+	                u_int8_t pt,bool mark,u_int32_t timestampinc);
+	int SendPacketEx(const void *data,size_t len,
+	                  u_int16_t hdrextID,const void *hdrextdata,size_t numhdrextwords);
+	int SendPacketEx(const void *data,size_t len,
+	                  u_int8_t pt,bool mark,u_int32_t timestampinc,
+	                  u_int16_t hdrextID,const void *hdrextdata,size_t numhdrextwords);
+	int SetDefaultPayloadType(u_int8_t pt);
+	int SetDefaultMark(bool m);
+	int SetDefaultTimestampIncrement(u_int32_t timestampinc);
+	int IncrementTimestamp(u_int32_t inc);
+	int IncrementTimestampDefault();
+	
+	RTPTransmissionInfo *GetTransmissionInfo();
+	int Poll();
+	int WaitForIncomingData(const RTPTime &amp;delay,bool *dataavailable = 0);
+	int AbortWait();
+	RTPTime GetRTCPDelay();
+
+	// The following methods (GotoFirstSource till GetNextPacket) should
+	// be called between calls to BeginDataAccess end EndDataAccess. This
+	// makes sure that nasty things don't happen (e.g. when a background
+	// thread is polling for data)
+	int BeginDataAccess();
+	bool GotoFirstSource();
+	bool GotoNextSource();
+	bool GotoPreviousSource();
+	bool GotoFirstSourceWithData();
+	bool GotoNextSourceWithData();
+	bool GotoPreviousSourceWithData();
+	RTPSourceData *GetCurrentSourceInfo();
+	RTPSourceData *GetSourceInfo(u_int32_t ssrc);
+	RTPPacket *GetNextPacket();
+	int EndDataAccess();
+	
+	int SetReceiveMode(RTPTransmitter::ReceiveMode m);
+	int AddToIgnoreList(const RTPAddress &amp;addr);
+	int DeleteFromIgnoreList(const RTPAddress &amp;addr);
+	void ClearIgnoreList();
+	int AddToAcceptList(const RTPAddress &amp;addr);
+	int DeleteFromAcceptList(const RTPAddress &amp;addr);
+	void ClearAcceptList();
+	
+	int SetMaximumPacketSize(size_t s);
+	int SetSessionBandwidth(double bw);
+	int SetTimestampUnit(double u);
+	
+	void SetNameInterval(int count);
+	void SetEMailInterval(int count);
+	void SetLocationInterval(int count);
+	void SetPhoneInterval(int count);
+	void SetToolInterval(int count);
+	void SetNoteInterval(int count);
+	int SetLocalName(const void *s,size_t len);
+	int SetLocalEMail(const void *s,size_t len);
+	int SetLocalLocation(const void *s,size_t len);
+	int SetLocalPhone(const void *s,size_t len);
+	int SetLocalTool(const void *s,size_t len);
+	int SetLocalNote(const void *s,size_t len);
+
+#ifdef RTPDEBUG
+	void DumpSources();
+	void DumpTransmitter();
+#endif // RTPDEBUG
+protected:
+	virtual RTPTransmitter *NewUserDefinedTransmitter()						{ return 0; }
+	
+	virtual void OnRTPPacket(RTPPacket *pack,const RTPTime &amp;receivetime,
+	                         const RTPAddress *senderaddress) 					{ }
+	virtual void OnRTCPCompoundPacket(RTCPCompoundPacket *pack,const RTPTime &amp;receivetime,
+	                                  const RTPAddress *senderaddress) 				{ }
+	virtual void OnSSRCCollision(RTPSourceData *srcdat,const RTPAddress *senderaddress,bool isrtp)	{ }
+	virtual void OnCNAMECollision(RTPSourceData *srcdat,const RTPAddress *senderaddress,
+	                              const u_int8_t *cname,size_t cnamelength)				{ }
+	virtual void OnNewSource(RTPSourceData *srcdat)			 				{ }
+	virtual void OnRemoveSource(RTPSourceData *srcdat)						{ }
+	virtual void OnTimeout(RTPSourceData *srcdat)							{ }
+	virtual void OnBYETimeout(RTPSourceData *srcdat)						{ }
+	virtual void OnAPPPacket(RTCPAPPPacket *apppacket,const RTPTime &amp;receivetime,
+	                         const RTPAddress *senderaddress)					{ }
+	virtual void OnUnknownPacketType(RTCPPacket *rtcppack,const RTPTime &amp;receivetime,
+	                                 const RTPAddress *senderaddress)				{ }
+	virtual void OnUnknownPacketFormat(RTCPPacket *rtcppack,const RTPTime &amp;receivetime,
+	                                   const RTPAddress *senderaddress)				{ }
+	virtual void OnNoteTimeout(RTPSourceData *srcdat)						{ }
+	virtual void OnBYEPacket(RTPSourceData *srcdat)							{ }
+#ifdef RTP_SUPPORT_THREAD
+	virtual void OnPollThreadError(int errcode)							{ }
+	virtual void OnPollThreadStep()									{ }
+#endif // RTP_SUPPORT_THREAD
+private:
+	int CreateCNAME(u_int8_t *buffer,size_t *bufferlength,bool resolve);
+	int ProcessPolledData();
+	int ProcessRTCPCompoundPacket(RTCPCompoundPacket &amp;rtcpcomppack,RTPRawPacket *pack);
+	
+	RTPTransmitter *rtptrans;
+	const RTPTransmitter::TransmissionProtocol protocol;	
+	bool created;
+	bool usingpollthread;
+	bool acceptownpackets;
+	bool useSR_BYEifpossible;
+	size_t maxpacksize;
+	double sessionbandwidth;
+	double controlfragment;
+	double sendermultiplier;
+	double byemultiplier;
+	double membermultiplier;
+	double collisionmultiplier;
+	double notemultiplier;
+
+	RTPSessionSources sources;
+	RTPPacketBuilder packetbuilder;
+	RTCPScheduler rtcpsched;
+	RTCPPacketBuilder rtcpbuilder;
+	RTPCollisionList collisionlist;
+
+	std::list&lt;RTCPCompoundPacket *&gt; byepackets;
+	
+#ifdef RTP_SUPPORT_THREAD
+	RTPPollThread *pollthread;
+	JMutex sourcesmutex,buildermutex,schedmutex;
+
+	friend class RTPPollThread;
+#endif // RTP_SUPPORT_THREAD
+	friend class RTPSessionSources;
+};
+
+#endif // RTPSESSION_H
+

Added: konference/src/rtp/jrtplib/rtpsessionparams.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpsessionparams.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpsessionparams.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,80 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtpsessionparams.h&quot;
+#include &quot;rtpdefines.h&quot;
+#include &quot;rtperrors.h&quot;
+
+#include &quot;rtpdebug.h&quot;
+
+RTPSessionParams::RTPSessionParams() : mininterval(0,0)
+{
+#ifdef RTP_SUPPORT_THREAD
+	usepollthread = true;
+#else
+	usepollthread = false;
+#endif // RTP_SUPPORT_THREAD
+	maxpacksize = RTP_DEFAULTPACKETSIZE;
+	receivemode = RTPTransmitter::AcceptAll;
+	acceptown = false;
+	owntsunit = -1; // The user will have to set it to the correct value himself
+	resolvehostname = false;
+#ifdef RTP_SUPPORT_PROBATION
+	probationtype = RTPSources::ProbationStore;
+#endif // RTP_SUPPORT_PROBATION
+
+	mininterval = RTPTime(RTCP_DEFAULTMININTERVAL);
+	sessionbandwidth = RTP_DEFAULTSESSIONBANDWIDTH;
+	controlfrac = RTCP_DEFAULTBANDWIDTHFRACTION;
+	senderfrac = RTCP_DEFAULTSENDERFRACTION;
+	usehalfatstartup = RTCP_DEFAULTHALFATSTARTUP;
+	immediatebye = RTCP_DEFAULTIMMEDIATEBYE;
+	SR_BYE = RTCP_DEFAULTSRBYE;
+
+	sendermultiplier = RTP_SENDERTIMEOUTMULTIPLIER;
+	generaltimeoutmultiplier = RTP_MEMBERTIMEOUTMULTIPLIER;
+	byetimeoutmultiplier = RTP_BYETIMEOUTMULTIPLIER;
+	collisionmultiplier = RTP_COLLISIONTIMEOUTMULTIPLIER;
+	notemultiplier = RTP_NOTETTIMEOUTMULTIPLIER;
+}
+
+int RTPSessionParams::SetUsePollThread(bool usethread)
+{
+#ifndef RTP_SUPPORT_THREAD
+	return ERR_RTP_NOTHREADSUPPORT;
+#else
+	usepollthread = usethread;
+	return 0;
+#endif // RTP_SUPPORT_THREAD
+}
+

Added: konference/src/rtp/jrtplib/rtpsessionparams.h
===================================================================
--- konference/src/rtp/jrtplib/rtpsessionparams.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpsessionparams.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,117 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPSESSIONPARAMS_H
+
+#define RTPSESSIONPARAMS_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtptypes.h&quot;
+#include &quot;rtptransmitter.h&quot;
+#include &quot;rtptimeutilities.h&quot;
+#include &quot;rtpsources.h&quot;
+
+class RTPSessionParams
+{
+public:
+	RTPSessionParams();
+
+	int SetUsePollThread(bool usethread);
+	bool IsUsingPollThread() const						{ return usepollthread; }
+	void SetMaximumPacketSize(size_t max)					{ maxpacksize = max; }
+	size_t GetMaximumPacketSize() const					{ return maxpacksize; }
+	void SetAcceptOwnPackets(bool accept)					{ acceptown = accept; }
+	bool AcceptOwnPackets() const						{ return acceptown; }
+	void SetReceiveMode(RTPTransmitter::ReceiveMode recvmode)		{ receivemode = recvmode; }
+	RTPTransmitter::ReceiveMode GetReceiveMode() const			{ return receivemode; }
+	void SetOwnTimestampUnit(double tsunit)					{ owntsunit = tsunit; }
+	double GetOwnTimestampUnit() const					{ return owntsunit; }
+	void SetResolveLocalHostname(bool v)					{ resolvehostname = v; }
+	bool GetResolveLocalHostname() const					{ return resolvehostname; }
+#ifdef RTP_SUPPORT_PROBATION
+	void SetProbationType(RTPSources::ProbationType probtype)		{ probationtype = probtype; }
+	RTPSources::ProbationType GetProbationType() const			{ return probationtype; }
+#endif // RTP_SUPPORT_PROBATION
+
+	void SetSessionBandwidth(double sessbw)					{ sessionbandwidth = sessbw; }
+	double GetSessionBandwidth() const					{ return sessionbandwidth; }
+	void SetControlTrafficFraction(double frac)				{ controlfrac = frac; }
+	double GetControlTrafficFraction() const				{ return controlfrac; }
+	void SetSenderControlBandwidthFraction(double frac)			{ senderfrac = frac; }
+	double GetSenderControlBandwidthFraction() const			{ return senderfrac; }
+	void SetMinimumRTCPTransmissionInterval(const RTPTime &amp;t)		{ mininterval = t; }
+	RTPTime GetMinimumRTCPTransmissionInterval() const			{ return mininterval; }
+	void SetUseHalfRTCPIntervalAtStartup(bool usehalf)			{ usehalfatstartup = usehalf; }
+	bool GetUseHalfRTCPIntervalAtStartup() const				{ return usehalfatstartup; }
+	void SetRequestImmediateBYE(bool v) 					{ immediatebye = v; }
+	bool GetRequestImmediateBYE() const					{ return immediatebye; }
+	void SetSenderReportForBYE(bool v)					{ SR_BYE = v; }
+	bool GetSenderReportForBYE() const					{ return SR_BYE; }
+
+	void SetSenderTimeoutMultiplier(double m)				{ sendermultiplier = m; }
+	double GetSenderTimeoutMultiplier() const				{ return sendermultiplier; }
+	void SetSourceTimeoutMultiplier(double m)				{ generaltimeoutmultiplier = m; }
+	double GetSourceTimeoutMultiplier() const				{ return generaltimeoutmultiplier; }
+	void SetBYETimeoutMultiplier(double m)					{ byetimeoutmultiplier = m; }
+	double GetBYETimeoutMultiplier() const					{ return byetimeoutmultiplier; }
+	void SetCollisionTimeoutMultiplier(double m)				{ collisionmultiplier = m; }
+	double GetCollisionTimeoutMultiplier() const				{ return collisionmultiplier; }
+	void SetNoteTimeoutMultiplier(double m)					{ notemultiplier = m; }
+	double GetNoteTimeoutMultiplier() const					{ return notemultiplier; }
+private:
+	bool acceptown;
+	bool usepollthread;
+	int maxpacksize;
+	double owntsunit;
+	RTPTransmitter::ReceiveMode receivemode;
+	bool resolvehostname;
+#ifdef RTP_SUPPORT_PROBATION
+	RTPSources::ProbationType probationtype;
+#endif // RTP_SUPPORT_PROBATION
+	
+	double sessionbandwidth;
+	double controlfrac;
+	double senderfrac;
+	RTPTime mininterval;
+	bool usehalfatstartup;
+	bool immediatebye;
+	bool SR_BYE;
+
+	double sendermultiplier;
+	double generaltimeoutmultiplier;
+	double byetimeoutmultiplier;
+	double collisionmultiplier;
+	double notemultiplier;
+};
+
+#endif // RTPSESSIONPARAMS_H
+

Added: konference/src/rtp/jrtplib/rtpsessionsources.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpsessionsources.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpsessionsources.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,109 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtpsessionsources.h&quot;
+#include &quot;rtpsession.h&quot;
+#include &quot;rtpsourcedata.h&quot;
+
+#include &quot;rtpdebug.h&quot;
+
+void RTPSessionSources::OnRTPPacket(RTPPacket *pack,const RTPTime &amp;receivetime,const RTPAddress *senderaddress)
+{
+	rtpsession.OnRTPPacket(pack,receivetime,senderaddress);
+}
+
+void RTPSessionSources::OnRTCPCompoundPacket(RTCPCompoundPacket *pack,const RTPTime &amp;receivetime,const RTPAddress *senderaddress)
+{
+	if (senderaddress != 0) // don't analyse own RTCP packets again (they're already analysed on their way out)
+		rtpsession.rtcpsched.AnalyseIncoming(*pack);
+	rtpsession.OnRTCPCompoundPacket(pack,receivetime,senderaddress);
+}
+
+void RTPSessionSources::OnSSRCCollision(RTPSourceData *srcdat,const RTPAddress *senderaddress,bool isrtp)
+{
+	if (srcdat-&gt;IsOwnSSRC())
+		owncollision = true;
+	rtpsession.OnSSRCCollision(srcdat,senderaddress,isrtp);
+}
+
+void RTPSessionSources::OnCNAMECollision(RTPSourceData *srcdat,const RTPAddress *senderaddress,const u_int8_t *cname,size_t cnamelength)
+{
+	rtpsession.OnCNAMECollision(srcdat,senderaddress,cname,cnamelength);
+}
+
+void RTPSessionSources::OnNewSource(RTPSourceData *srcdat)
+{
+	rtpsession.OnNewSource(srcdat);
+}
+
+void RTPSessionSources::OnRemoveSource(RTPSourceData *srcdat)
+{
+	rtpsession.OnRemoveSource(srcdat);
+}
+
+void RTPSessionSources::OnTimeout(RTPSourceData *srcdat)
+{
+	rtpsession.rtcpsched.ActiveMemberDecrease();
+	rtpsession.OnTimeout(srcdat);
+}
+
+void RTPSessionSources::OnBYETimeout(RTPSourceData *srcdat)
+{
+	rtpsession.OnBYETimeout(srcdat);
+}
+
+void RTPSessionSources::OnBYEPacket(RTPSourceData *srcdat)
+{
+	rtpsession.rtcpsched.ActiveMemberDecrease();
+	rtpsession.OnBYEPacket(srcdat);
+}
+
+void RTPSessionSources::OnAPPPacket(RTCPAPPPacket *apppacket,const RTPTime &amp;receivetime,const RTPAddress *senderaddress)
+{
+	rtpsession.OnAPPPacket(apppacket,receivetime,senderaddress);
+}
+
+void RTPSessionSources::OnUnknownPacketType(RTCPPacket *rtcppack,const RTPTime &amp;receivetime, const RTPAddress *senderaddress)
+{
+	rtpsession.OnUnknownPacketType(rtcppack,receivetime,senderaddress);
+}
+
+void RTPSessionSources::OnUnknownPacketFormat(RTCPPacket *rtcppack,const RTPTime &amp;receivetime,const RTPAddress *senderaddress)
+{
+	rtpsession.OnUnknownPacketFormat(rtcppack,receivetime,senderaddress);
+}
+
+void RTPSessionSources::OnNoteTimeout(RTPSourceData *srcdat)
+{
+	rtpsession.OnNoteTimeout(srcdat);
+}
+

Added: konference/src/rtp/jrtplib/rtpsessionsources.h
===================================================================
--- konference/src/rtp/jrtplib/rtpsessionsources.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpsessionsources.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,74 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPSESSIONSOURCES_H
+
+#define RTPSESSIONSOURCES_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtpsources.h&quot;
+
+class RTPSession;
+
+class RTPSessionSources : public RTPSources
+{
+public:
+	RTPSessionSources(RTPSession &amp;sess) : rtpsession(sess) 					{ owncollision = false; }
+	~RTPSessionSources()									{ }
+	void ClearOwnCollisionFlag()								{ owncollision = false; }
+	bool DetectedOwnCollision() const							{ return owncollision; }
+private:
+	void OnRTPPacket(RTPPacket *pack,const RTPTime &amp;receivetime,
+	                 const RTPAddress *senderaddress);
+	void OnRTCPCompoundPacket(RTCPCompoundPacket *pack,const RTPTime &amp;receivetime,
+	                          const RTPAddress *senderaddress);
+	void OnSSRCCollision(RTPSourceData *srcdat,const RTPAddress *senderaddress,bool isrtp);
+	void OnCNAMECollision(RTPSourceData *srcdat,const RTPAddress *senderaddress,
+	                              const u_int8_t *cname,size_t cnamelength);
+	void OnNewSource(RTPSourceData *srcdat);
+	void OnRemoveSource(RTPSourceData *srcdat);
+	void OnTimeout(RTPSourceData *srcdat);
+	void OnBYETimeout(RTPSourceData *srcdat);
+	void OnBYEPacket(RTPSourceData *srcdat);
+	void OnAPPPacket(RTCPAPPPacket *apppacket,const RTPTime &amp;receivetime,
+	                 const RTPAddress *senderaddress);
+	void OnUnknownPacketType(RTCPPacket *rtcppack,const RTPTime &amp;receivetime,
+	                         const RTPAddress *senderaddress);
+	void OnUnknownPacketFormat(RTCPPacket *rtcppack,const RTPTime &amp;receivetime,
+	                           const RTPAddress *senderaddress);
+	void OnNoteTimeout(RTPSourceData *srcdat);
+	
+	RTPSession &rtpsession;
+	bool owncollision;
+};
+
+#endif // RTPSESSIONSOURCES_H

Added: konference/src/rtp/jrtplib/rtpsourcedata.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpsourcedata.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpsourcedata.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,445 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtpsourcedata.h&quot;
+#include &quot;rtpdefines.h&quot;
+#include &quot;rtpaddress.h&quot;
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include &lt;netinet/in.h&gt;
+#endif // WIN32
+
+#ifdef RTPDEBUG
+	#include &lt;iostream&gt;
+	#include &lt;string&gt;
+#endif // RTPDEBUG
+
+#include &quot;rtpdebug.h&quot;
+
+#define ACCEPTPACKETCODE									\
+		*accept = true;									\
+												\
+		sentdata = true;								\
+		packetsreceived++;								\
+		numnewpackets++;								\
+												\
+		if (pack-&gt;GetExtendedSequenceNumber() == 0)					\
+		{										\
+			baseseqnr = 0x0000FFFF;							\
+			numcycles = 0x00010000;							\
+		}										\
+		else										\
+			baseseqnr = pack-&gt;GetExtendedSequenceNumber() - 1;			\
+												\
+		exthighseqnr = baseseqnr + 1;							\
+		prevpacktime = receivetime;							\
+		prevexthighseqnr = baseseqnr;							\
+		savedextseqnr = baseseqnr;							\
+												\
+		pack-&gt;SetExtendedSequenceNumber(exthighseqnr);					\
+												\
+		prevtimestamp = pack-&gt;GetTimestamp();						\
+		lastmsgtime = prevpacktime;							\
+		if (!ownpacket) /* for own packet, this value is set on an outgoing packet */	\
+			lastrtptime = prevpacktime;
+
+void RTPSourceStats::ProcessPacket(RTPPacket *pack,const RTPTime &amp;receivetime,double tsunit,
+                                   bool ownpacket,bool *accept,bool applyprobation,bool *onprobation)
+{
+	// Note that the sequence number in the RTP packet is still just the
+	// 16 bit number contained in the RTP header
+
+	*onprobation = false;
+	
+	if (!sentdata) // no valid packets received yet
+	{
+#ifdef RTP_SUPPORT_PROBATION
+		if (applyprobation)
+		{
+			bool acceptpack = false;
+
+			if (probation)  
+			{	
+				u_int16_t pseq;
+				u_int32_t pseq2;
+	
+				pseq = prevseqnr;
+				pseq++;
+				pseq2 = (u_int32_t)pseq;
+				if (pseq2 == pack-&gt;GetExtendedSequenceNumber()) // ok, its the next expected packet
+				{
+					prevseqnr = (u_int16_t)pack-&gt;GetExtendedSequenceNumber();
+					probation--;	
+					if (probation == 0) // probation over
+						acceptpack = true;
+					else
+						*onprobation = true;
+				}
+				else // not next packet
+				{
+					probation = RTP_PROBATIONCOUNT;
+					prevseqnr = (u_int16_t)pack-&gt;GetExtendedSequenceNumber();
+					*onprobation = true;
+				}
+			}
+			else // first packet received with this SSRC ID, start probation
+			{
+				probation = RTP_PROBATIONCOUNT;
+				prevseqnr = (u_int16_t)pack-&gt;GetExtendedSequenceNumber();	
+				*onprobation = true;
+			}
+	
+			if (acceptpack)
+			{
+				ACCEPTPACKETCODE
+			}
+			else
+			{
+				*accept = false;
+				lastmsgtime = receivetime;
+			}
+		}
+		else // No probation
+		{
+			ACCEPTPACKETCODE
+		}
+#else // No compiled-in probation support
+
+		ACCEPTPACKETCODE
+
+#endif // RTP_SUPPORT_PROBATION
+	}
+	else // already got packets
+	{
+		u_int16_t maxseq16;
+		u_int32_t extseqnr;
+
+		// Adjust max extended sequence number and set extende seq nr of packet
+
+		*accept = true;
+		packetsreceived++;
+		numnewpackets++;
+
+		maxseq16 = (u_int16_t)(exthighseqnr&amp;0x0000FFFF);
+		if (pack-&gt;GetExtendedSequenceNumber() &gt;= maxseq16)
+		{
+			extseqnr = numcycles+pack-&gt;GetExtendedSequenceNumber();
+			exthighseqnr = extseqnr;
+		}
+		else
+		{
+			u_int16_t dif1,dif2;
+
+			dif1 = ((u_int16_t)pack-&gt;GetExtendedSequenceNumber());
+			dif1 -= maxseq16;
+			dif2 = maxseq16;
+			dif2 -= ((u_int16_t)pack-&gt;GetExtendedSequenceNumber());
+			if (dif1 &lt; dif2)
+			{
+				numcycles += 0x00010000;
+				extseqnr = numcycles+pack-&gt;GetExtendedSequenceNumber();
+				exthighseqnr = extseqnr;
+			}
+			else
+				extseqnr = numcycles+pack-&gt;GetExtendedSequenceNumber();
+		}
+
+		pack-&gt;SetExtendedSequenceNumber(extseqnr);
+
+		// Calculate jitter
+
+		if (tsunit &gt; 0)
+		{
+			RTPTime curtime = receivetime;
+			double diffts1,diffts2,diff;
+
+			curtime -= prevpacktime;
+			diffts1 = curtime.GetDouble()/tsunit;	
+			diffts2 = (double)pack-&gt;GetTimestamp() - (double)prevtimestamp;
+			diff = diffts1 - diffts2;
+			if (diff &lt; 0)
+				diff = -diff;
+			diff -= djitter;
+			diff /= 16.0;
+			djitter += diff;
+			jitter = (u_int32_t)djitter;
+		}
+		else
+		{
+			djitter = 0;
+			jitter = 0;
+		}
+
+		prevpacktime = receivetime;
+		prevtimestamp = pack-&gt;GetTimestamp();
+		lastmsgtime = prevpacktime;
+		if (!ownpacket) // for own packet, this value is set on an outgoing packet
+			lastrtptime = prevpacktime;
+	}
+}
+
+RTPSourceData::RTPSourceData(u_int32_t s) : byetime(0,0)
+{
+	ssrc = s;
+	issender = false;
+	iscsrc = false;
+	timestampunit = -1;
+	receivedbye = false;
+	byereason = 0;
+	byereasonlen = 0;
+	rtpaddr = 0;
+	rtcpaddr = 0;
+	ownssrc = false;
+	validated = false;
+	processedinrtcp = false;			
+	isrtpaddrset = false;
+	isrtcpaddrset = false;
+}
+
+RTPSourceData::~RTPSourceData()
+{
+	FlushPackets();
+	if (byereason)
+		delete [] byereason;
+	if (rtpaddr)
+		delete rtpaddr;
+	if (rtcpaddr)
+		delete rtcpaddr;
+}
+
+double RTPSourceData::INF_GetEstimatedTimestampUnit() const
+{
+	if (!SRprevinf.HasInfo())
+		return -1.0;
+	
+	RTPTime t1 = RTPTime(SRinf.GetNTPTimestamp());
+	RTPTime t2 = RTPTime(SRprevinf.GetNTPTimestamp());
+	if ((t1.GetSeconds() == 0 &amp;&amp; t1.GetMicroSeconds() == 0) ||
+	    (t2.GetSeconds() == 0 &amp;&amp; t2.GetMicroSeconds() == 0)) // one of the times couldn't be calculated
+		return -1.0;
+
+	if (t1 &lt; t2)
+		return -1.0;
+
+	t1 -= t2; // get the time difference
+	
+	u_int32_t tsdiff = SRinf.GetRTPTimestamp()-SRprevinf.GetRTPTimestamp();
+	
+	return (t1.GetDouble()/((double)tsdiff));
+}
+
+RTPTime RTPSourceData::INF_GetRoundtripTime() const
+{
+	if (!RRinf.HasInfo())
+		return RTPTime(0,0);
+	if (RRinf.GetDelaySinceLastSR() == 0 &amp;&amp; RRinf.GetLastSRTimestamp() == 0)
+		return RTPTime(0,0);
+
+	RTPNTPTime recvtime = RRinf.GetReceiveTime().GetNTPTime();
+	u_int32_t rtt = ((recvtime.GetMSW()&amp;0xFFFF)&lt;&lt;16)|((recvtime.GetLSW()&gt;&gt;16)&amp;0xFFFF);
+	rtt -= RRinf.GetLastSRTimestamp();
+	rtt -= RRinf.GetDelaySinceLastSR();
+
+	double drtt = (((double)rtt)/65536.0);
+	return RTPTime(drtt);
+}
+
+#ifdef RTPDEBUG
+void RTPSourceData::Dump()
+{
+	std::cout &lt;&lt; &quot;Source data for SSRC:     &quot; &lt;&lt; ssrc &lt;&lt; std::endl;
+	std::cout &lt;&lt; &quot;    Active:               &quot; &lt;&lt; ((IsActive())?&quot;Yes&quot;:&quot;No&quot;) &lt;&lt; std::endl;
+	std::cout &lt;&lt; &quot;    Sender:               &quot; &lt;&lt; ((issender)?&quot;Yes&quot;:&quot;No&quot;) &lt;&lt; std::endl;
+	std::cout &lt;&lt; &quot;    CSRC:                 &quot; &lt;&lt; ((iscsrc)?&quot;Yes&quot;:&quot;No&quot;) &lt;&lt; std::endl;
+	std::cout &lt;&lt; &quot;    Received bye:         &quot; &lt;&lt; ((receivedbye)?&quot;Yes&quot;:&quot;No&quot;) &lt;&lt; std::endl;
+	std::cout &lt;&lt; &quot;    ProcessedInRTCP:      &quot; &lt;&lt; ((processedinrtcp)?&quot;Yes&quot;:&quot;No&quot;) &lt;&lt; std::endl;
+	std::cout &lt;&lt; &quot;    Timestamp unit:       &quot; &lt;&lt; timestampunit &lt;&lt; std::endl;
+	std::cout &lt;&lt; &quot;    RTP address:          &quot;;
+	if (!isrtpaddrset)
+		std::cout &lt;&lt; &quot;Not set&quot; &lt;&lt; std::endl;
+	else
+	{
+		if (rtpaddr == 0)
+			std::cout &lt;&lt; &quot;Own session&quot; &lt;&lt; std::endl;
+		else
+			std::cout &lt;&lt; rtpaddr-&gt;GetAddressString() &lt;&lt; std::endl;
+	}
+	std::cout &lt;&lt; &quot;    RTCP address:         &quot;;
+	if (!isrtcpaddrset)
+		std::cout &lt;&lt; &quot;Not set&quot; &lt;&lt; std::endl;
+	else
+	{
+		if (rtcpaddr == 0)
+			std::cout &lt;&lt; &quot;Own session&quot; &lt;&lt; std::endl;
+		else
+			std::cout &lt;&lt; rtcpaddr-&gt;GetAddressString() &lt;&lt; std::endl;
+	}
+	if (SRinf.HasInfo())
+	{
+		if (!SRprevinf.HasInfo())
+		{
+			std::cout &lt;&lt; &quot;    SR Info:&quot; &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        NTP timestamp:    &quot; &lt;&lt; SRinf.GetNTPTimestamp().GetMSW() &lt;&lt; &quot;:&quot; &lt;&lt; SRinf.GetNTPTimestamp().GetLSW() &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        RTP timestamp:    &quot; &lt;&lt; SRinf.GetRTPTimestamp() &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Packet count:     &quot; &lt;&lt; SRinf.GetPacketCount() &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Octet count:      &quot; &lt;&lt; SRinf.GetByteCount() &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Receive time:     &quot; &lt;&lt; SRinf.GetReceiveTime().GetSeconds() &lt;&lt; std::endl;
+		}	
+		else
+		{
+			std::cout &lt;&lt; &quot;    SR Info:&quot; &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        NTP timestamp:    &quot; &lt;&lt; SRinf.GetNTPTimestamp().GetMSW() &lt;&lt; &quot;:&quot; &lt;&lt; SRinf.GetNTPTimestamp().GetLSW()
+				  &lt;&lt; &quot; (&quot; &lt;&lt; SRprevinf.GetNTPTimestamp().GetMSW() &lt;&lt; &quot;:&quot; &lt;&lt; SRprevinf.GetNTPTimestamp().GetLSW() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        RTP timestamp:    &quot; &lt;&lt; SRinf.GetRTPTimestamp()
+			          &lt;&lt; &quot; (&quot; &lt;&lt; SRprevinf.GetRTPTimestamp() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Packet count:     &quot; &lt;&lt; SRinf.GetPacketCount()
+			          &lt;&lt; &quot; (&quot; &lt;&lt; SRprevinf.GetPacketCount() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Octet count:      &quot; &lt;&lt; SRinf.GetByteCount() 
+			          &lt;&lt; &quot; (&quot; &lt;&lt; SRprevinf.GetByteCount() &lt;&lt;&quot;)&quot; &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Receive time:     &quot; &lt;&lt; SRinf.GetReceiveTime().GetSeconds()
+			          &lt;&lt; &quot; (&quot; &lt;&lt; SRprevinf.GetReceiveTime().GetSeconds() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+		}
+	}
+	if (RRinf.HasInfo())
+	{
+		if (!RRprevinf.HasInfo())
+		{
+			std::cout &lt;&lt; &quot;    RR Info:&quot; &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Fraction lost:    &quot; &lt;&lt; RRinf.GetFractionLost() &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Packets lost:     &quot; &lt;&lt; RRinf.GetPacketsLost() &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Ext.High.Seq:     &quot; &lt;&lt; RRinf.GetExtendedHighestSequenceNumber() &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Jitter:           &quot; &lt;&lt; RRinf.GetJitter() &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        LSR:              &quot; &lt;&lt; RRinf.GetLastSRTimestamp() &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        DLSR:             &quot; &lt;&lt; RRinf.GetDelaySinceLastSR() &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Receive time:     &quot; &lt;&lt; RRinf.GetReceiveTime().GetSeconds() &lt;&lt; std::endl;
+		}
+		else
+		{
+			std::cout &lt;&lt; &quot;    RR Info:&quot; &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Fraction lost:    &quot; &lt;&lt; RRinf.GetFractionLost() 
+				  &lt;&lt; &quot; (&quot; &lt;&lt; RRprevinf.GetFractionLost() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Packets lost:     &quot; &lt;&lt; RRinf.GetPacketsLost() 
+			          &lt;&lt; &quot; (&quot; &lt;&lt; RRprevinf.GetPacketsLost() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Ext.High.Seq:     &quot; &lt;&lt; RRinf.GetExtendedHighestSequenceNumber() 
+			          &lt;&lt; &quot; (&quot; &lt;&lt; RRprevinf.GetExtendedHighestSequenceNumber() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Jitter:           &quot; &lt;&lt; RRinf.GetJitter() 
+			          &lt;&lt; &quot; (&quot; &lt;&lt; RRprevinf.GetJitter() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        LSR:              &quot; &lt;&lt; RRinf.GetLastSRTimestamp() 
+			          &lt;&lt; &quot; (&quot; &lt;&lt; RRprevinf.GetLastSRTimestamp() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        DLSR:             &quot; &lt;&lt; RRinf.GetDelaySinceLastSR() 
+			          &lt;&lt; &quot; (&quot; &lt;&lt; RRprevinf.GetDelaySinceLastSR() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;        Receive time:     &quot; &lt;&lt; RRinf.GetReceiveTime().GetSeconds() 
+			          &lt;&lt; &quot; (&quot; &lt;&lt; RRprevinf.GetReceiveTime().GetSeconds() &lt;&lt;&quot;)&quot; &lt;&lt; std::endl;
+		}
+	}
+	std::cout &lt;&lt; &quot;    Stats:&quot; &lt;&lt; std::endl;
+	std::cout &lt;&lt; &quot;        Sent data:        &quot; &lt;&lt; ((stats.HasSentData())?&quot;Yes&quot;:&quot;No&quot;) &lt;&lt; std::endl;
+	std::cout &lt;&lt; &quot;        Packets received: &quot; &lt;&lt; stats.GetNumPacketsReceived() &lt;&lt; std::endl;
+	std::cout &lt;&lt; &quot;        Seq. base:        &quot; &lt;&lt; stats.GetBaseSequenceNumber() &lt;&lt; std::endl;
+	std::cout &lt;&lt; &quot;        Ext.High.Seq:     &quot; &lt;&lt; stats.GetExtendedHighestSequenceNumber() &lt;&lt; std::endl;
+	std::cout &lt;&lt; &quot;        Jitter:           &quot; &lt;&lt; stats.GetJitter() &lt;&lt; std::endl;
+	std::cout &lt;&lt; &quot;        New packets:      &quot; &lt;&lt; stats.GetNumPacketsReceivedInInterval() &lt;&lt; std::endl;	
+	std::cout &lt;&lt; &quot;        Saved seq. nr.:   &quot; &lt;&lt; stats.GetSavedExtendedSequenceNumber() &lt;&lt; std::endl;	
+	std::cout &lt;&lt; &quot;        RTT:              &quot; &lt;&lt; INF_GetRoundtripTime().GetDouble() &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;
+	if (INF_GetEstimatedTimestampUnit() &gt; 0)
+		std::cout &lt;&lt; &quot;        Estimated:        &quot; &lt;&lt; (1.0/INF_GetEstimatedTimestampUnit()) &lt;&lt; &quot; samples per second&quot; &lt;&lt; std::endl;
+	std::cout &lt;&lt; &quot;    SDES Info:&quot; &lt;&lt; std::endl;
+
+	size_t len;
+	char str[1024];
+	u_int8_t *val;
+	
+	if ((val = SDESinf.GetCNAME(&amp;len)) != 0)
+	{
+		memcpy(str,val,len);
+		str[len] = 0;
+		std::cout &lt;&lt; &quot;        CNAME:            &quot; &lt;&lt; std::string(str) &lt;&lt; std::endl;
+	}
+	if ((val = SDESinf.GetName(&amp;len)) != 0)
+	{
+		memcpy(str,val,len);
+		str[len] = 0;
+		std::cout &lt;&lt; &quot;        Name:             &quot; &lt;&lt; std::string(str) &lt;&lt; std::endl;
+	}
+	if ((val = SDESinf.GetEMail(&amp;len)) != 0)
+	{
+		memcpy(str,val,len);
+		str[len] = 0;
+		std::cout &lt;&lt; &quot;        EMail:            &quot; &lt;&lt; std::string(str) &lt;&lt; std::endl;
+	}
+	if ((val = SDESinf.GetPhone(&amp;len)) != 0)
+	{
+		memcpy(str,val,len);
+		str[len] = 0;
+		std::cout &lt;&lt; &quot;        phone:            &quot; &lt;&lt; std::string(str) &lt;&lt; std::endl;
+	}
+	if ((val = SDESinf.GetLocation(&amp;len)) != 0)
+	{
+		memcpy(str,val,len);
+		str[len] = 0;
+		std::cout &lt;&lt; &quot;        Location:         &quot; &lt;&lt; std::string(str) &lt;&lt; std::endl;
+	}
+	if ((val = SDESinf.GetTool(&amp;len)) != 0)
+	{
+		memcpy(str,val,len);
+		str[len] = 0;
+		std::cout &lt;&lt; &quot;        Tool:             &quot; &lt;&lt; std::string(str) &lt;&lt; std::endl;
+	}	
+	if ((val = SDESinf.GetNote(&amp;len)) != 0)
+	{
+		memcpy(str,val,len);
+		str[len] = 0;
+		std::cout &lt;&lt; &quot;        Note:             &quot; &lt;&lt; std::string(str) &lt;&lt; std::endl;
+	}
+#ifdef RTP_SUPPORT_SDESPRIV
+	SDESinf.GotoFirstPrivateValue();
+	u_int8_t *pref;
+	size_t preflen;
+	while (SDESinf.GetNextPrivateValue(&amp;pref,&amp;preflen,&amp;val,&amp;len))
+	{
+		char prefstr[1024];
+		memcpy(prefstr,pref,preflen);
+		memcpy(str,val,len);
+		prefstr[preflen] = 0;
+		str[len] = 0;
+		std::cout &lt;&lt; &quot;        Private:          &quot; &lt;&lt; std::string(prefstr) &lt;&lt; &quot;:&quot; &lt;&lt; std::string(str) &lt;&lt; std::endl;
+	}
+#endif // RTP_SUPPORT_SDESPRIV
+	if (byereason)
+	{
+		memcpy(str,byereason,byereasonlen);
+		str[byereasonlen] = 0;
+		std::cout &lt;&lt; &quot;    BYE Reason:           &quot; &lt;&lt; std::string(str) &lt;&lt; std::endl;
+	}
+}
+
+#endif // RTPDEBUG
+

Added: konference/src/rtp/jrtplib/rtpsourcedata.h
===================================================================
--- konference/src/rtp/jrtplib/rtpsourcedata.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpsourcedata.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,305 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPSOURCEDATA_H
+
+#define RTPSOURCEDATA_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtptimeutilities.h&quot;
+#include &quot;rtppacket.h&quot;
+#include &quot;rtcpsdesinfo.h&quot;
+#include &quot;rtptypes.h&quot;
+#include &quot;rtpsources.h&quot;
+#include &lt;list&gt;
+
+class RTPAddress;
+
+class RTCPSenderReportInfo
+{
+public:
+	RTCPSenderReportInfo():ntptimestamp(0,0),receivetime(0,0)		{ hasinfo = false; rtptimestamp = 0; packetcount = 0; bytecount = 0; }
+	void Set(const RTPNTPTime &amp;ntptime,u_int32_t rtptime,u_int32_t pcount,
+	         u_int32_t bcount,const RTPTime &amp;rcvtime)			{ ntptimestamp = ntptime; rtptimestamp = rtptime; packetcount = pcount; bytecount = bcount; receivetime = rcvtime; hasinfo = true; }
+	
+	bool HasInfo() const							{ return hasinfo; }
+	RTPNTPTime GetNTPTimestamp() const					{ return ntptimestamp; }
+	u_int32_t GetRTPTimestamp() const					{ return rtptimestamp; }
+	u_int32_t GetPacketCount() const					{ return packetcount; }
+	u_int32_t GetByteCount() const						{ return bytecount; }
+	RTPTime GetReceiveTime() const						{ return receivetime; }
+private:
+	bool hasinfo;
+	RTPNTPTime ntptimestamp;
+	u_int32_t rtptimestamp;
+	u_int32_t packetcount;
+	u_int32_t bytecount;
+	RTPTime receivetime;
+};
+
+class RTCPReceiverReportInfo
+{
+public:
+	RTCPReceiverReportInfo():receivetime(0,0)				{ hasinfo = false; fractionlost = 0; packetslost = 0; exthighseqnr = 0; jitter = 0; lsr = 0; dlsr = 0; } 
+	void Set(u_int8_t fraclost,int32_t plost,u_int32_t exthigh,
+	         u_int32_t jit,u_int32_t l,u_int32_t dl,const RTPTime &amp;rcvtime) { fractionlost = ((double)fraclost)/256.0; packetslost = plost; exthighseqnr = exthigh; jitter = jit; lsr = l; dlsr = dl; receivetime = rcvtime; hasinfo = true; }
+		
+	bool HasInfo() const							{ return hasinfo; }
+	double GetFractionLost() const						{ return fractionlost; }
+	int32_t	GetPacketsLost() const						{ return packetslost; }
+	u_int32_t GetExtendedHighestSequenceNumber() const			{ return exthighseqnr; }
+	u_int32_t GetJitter() const						{ return jitter; }
+	u_int32_t GetLastSRTimestamp() const					{ return lsr; }
+	u_int32_t GetDelaySinceLastSR() const					{ return dlsr; }
+	RTPTime GetReceiveTime() const						{ return receivetime; }
+private:
+	bool hasinfo;
+	double fractionlost;
+	int32_t packetslost;
+	u_int32_t exthighseqnr;
+	u_int32_t jitter;
+	u_int32_t lsr;
+	u_int32_t dlsr;
+	RTPTime receivetime;
+};
+
+class RTPSourceStats
+{
+public:
+	RTPSourceStats();
+	void ProcessPacket(RTPPacket *pack,const RTPTime &amp;receivetime,double tsunit,bool ownpacket,bool *accept,bool applyprobation,bool *onprobation);
+
+	bool HasSentData() const						{ return sentdata; }
+	u_int32_t GetNumPacketsReceived() const					{ return packetsreceived; }
+	u_int32_t GetBaseSequenceNumber() const					{ return baseseqnr; }
+	u_int32_t GetExtendedHighestSequenceNumber() const			{ return exthighseqnr; }
+	u_int32_t GetJitter() const						{ return jitter; }
+
+	int32_t GetNumPacketsReceivedInInterval() const				{ return numnewpackets; }
+	u_int32_t GetSavedExtendedSequenceNumber() const			{ return savedextseqnr; }
+	void StartNewInterval()							{ numnewpackets = 0; savedextseqnr = exthighseqnr; }
+	
+	void SetLastMessageTime(const RTPTime &amp;t)				{ lastmsgtime = t; }
+	RTPTime GetLastMessageTime() const					{ return lastmsgtime; }
+	void SetLastRTPPacketTime(const RTPTime &amp;t)				{ lastrtptime = t; }
+	RTPTime GetLastRTPPacketTime() const					{ return lastrtptime; }
+
+	void SetLastNoteTime(const RTPTime &amp;t)					{ lastnotetime = t; }
+	RTPTime GetLastNoteTime() const						{ return lastnotetime; }
+private:
+	bool sentdata;
+	u_int32_t packetsreceived;
+	u_int32_t numcycles; // shifted left 16 bits
+	u_int32_t baseseqnr;
+	u_int32_t exthighseqnr,prevexthighseqnr;
+	u_int32_t jitter,prevtimestamp;
+	double djitter;
+	RTPTime prevpacktime;
+	RTPTime lastmsgtime;
+	RTPTime lastrtptime;
+	RTPTime lastnotetime;
+	u_int32_t numnewpackets;
+	u_int32_t savedextseqnr;
+#ifdef RTP_SUPPORT_PROBATION
+	u_int16_t prevseqnr;
+	int probation;
+	RTPSources::ProbationType probationtype;
+#endif // RTP_SUPPORT_PROBATION
+};
+	
+inline RTPSourceStats::RTPSourceStats():prevpacktime(0,0),lastmsgtime(0,0),lastrtptime(0,0),lastnotetime(0,0)
+{ 
+	sentdata = false; 
+	packetsreceived = 0; 
+	baseseqnr = 0; 
+	exthighseqnr = 0; 
+	prevexthighseqnr = 0; 
+	jitter = 0; 
+	numcycles = 0;
+	numnewpackets = 0;
+	prevtimestamp = 0;
+	djitter = 0;
+	savedextseqnr = 0;
+#ifdef RTP_SUPPORT_PROBATION
+	probation = 0; 
+	prevseqnr = 0; 
+#endif // RTP_SUPPORT_PROBATION
+}
+
+class RTPSourceData
+{
+protected:
+	RTPSourceData(u_int32_t ssrc);
+	virtual ~RTPSourceData();
+public:
+	RTPPacket *GetNextPacket();
+	void FlushPackets();
+	bool HasData() const							{ if (!validated) return false; return packetlist.empty()?false:true; }
+	u_int32_t GetSSRC() const						{ return ssrc; }
+	bool IsOwnSSRC() const							{ return ownssrc; }
+	bool IsCSRC() const							{ return iscsrc; }
+	bool IsSender() const							{ return issender; }
+	bool IsValidated() const						{ return validated; }
+	bool IsActive() const							{ if (!validated) return false; if (receivedbye) return false; return true; }
+
+	void SetProcessedInRTCP(bool v)						{ processedinrtcp = v; }
+	bool IsProcessedInRTCP() const						{ return processedinrtcp; }
+	
+	bool IsRTPAddressSet() const						{ return isrtpaddrset; }
+	bool IsRTCPAddressSet() const						{ return isrtcpaddrset; }
+	const RTPAddress *GetRTPDataAddress() const				{ return rtpaddr; }
+	const RTPAddress *GetRTCPDataAddress() const				{ return rtcpaddr; }
+	
+	bool ReceivedBYE() const						{ return receivedbye; }
+	u_int8_t *GetBYEReason(size_t *len) const				{ *len = byereasonlen; return byereason; }
+	RTPTime GetBYETime() const						{ return byetime; }
+		
+	void SetTimestampUnit(double tsu)					{ timestampunit = tsu; }
+	double GetTimestampUnit() const						{ return timestampunit; }
+
+	// Here is the info received in the last RTCP SR packet from this source
+	bool SR_HasInfo() const							{ return SRinf.HasInfo(); }
+	RTPNTPTime SR_GetNTPTimestamp() const					{ return SRinf.GetNTPTimestamp(); }
+	u_int32_t SR_GetRTPTimestamp() const					{ return SRinf.GetRTPTimestamp(); }
+	u_int32_t SR_GetPacketCount() const					{ return SRinf.GetPacketCount(); }
+	u_int32_t SR_GetByteCount() const					{ return SRinf.GetByteCount(); }
+	RTPTime SR_GetReceiveTime() const					{ return SRinf.GetReceiveTime(); }
+	
+	// Here is the info received in the previous RTCP SR packet from this source
+	bool SR_Prev_HasInfo() const						{ return SRprevinf.HasInfo(); }
+	RTPNTPTime SR_Prev_GetNTPTimestamp() const				{ return SRprevinf.GetNTPTimestamp(); }
+	u_int32_t SR_Prev_GetRTPTimestamp() const				{ return SRprevinf.GetRTPTimestamp(); }
+	u_int32_t SR_Prev_GetPacketCount() const				{ return SRprevinf.GetPacketCount(); }
+	u_int32_t SR_Prev_GetByteCount() const					{ return SRprevinf.GetByteCount(); }
+	RTPTime SR_Prev_GetReceiveTime() const					{ return SRprevinf.GetReceiveTime(); }
+
+	// Here is the info received in the last RTCP RR packet from this source
+	bool RR_HasInfo() const							{ return RRinf.HasInfo(); }
+	double RR_GetFractionLost() const					{ return RRinf.GetFractionLost(); }
+	int32_t	RR_GetPacketsLost() const					{ return RRinf.GetPacketsLost(); }
+	u_int32_t RR_GetExtendedHighestSequenceNumber() const			{ return RRinf.GetExtendedHighestSequenceNumber(); }
+	u_int32_t RR_GetJitter() const						{ return RRinf.GetJitter(); }
+	u_int32_t RR_GetLastSRTimestamp() const					{ return RRinf.GetLastSRTimestamp(); }
+	u_int32_t RR_GetDelaySinceLastSR() const				{ return RRinf.GetDelaySinceLastSR(); }
+	RTPTime RR_GetReceiveTime() const					{ return RRinf.GetReceiveTime(); }
+	
+	// Here is the info received in the last RTCP RR packet from this source
+	bool RR_Prev_HasInfo() const						{ return RRprevinf.HasInfo(); }
+	double RR_Prev_GetFractionLost() const					{ return RRprevinf.GetFractionLost(); }
+	int32_t	RR_Prev_GetPacketsLost() const					{ return RRprevinf.GetPacketsLost(); }
+	u_int32_t RR_Prev_GetExtendedHighestSequenceNumber() const		{ return RRprevinf.GetExtendedHighestSequenceNumber(); }
+	u_int32_t RR_Prev_GetJitter() const					{ return RRprevinf.GetJitter(); }
+	u_int32_t RR_Prev_GetLastSRTimestamp() const				{ return RRprevinf.GetLastSRTimestamp(); }
+	u_int32_t RR_Prev_GetDelaySinceLastSR() const				{ return RRprevinf.GetDelaySinceLastSR(); }
+	RTPTime RR_Prev_GetReceiveTime() const					{ return RRprevinf.GetReceiveTime(); }
+
+	// Here is info which is used when sending RTCP packets to this source
+	bool INF_HasSentData() const						{ return stats.HasSentData(); }
+	int32_t INF_GetNumPacketsReceived() const				{ return stats.GetNumPacketsReceived(); }
+	u_int32_t INF_GetBaseSequenceNumber() const				{ return stats.GetBaseSequenceNumber(); }
+	u_int32_t INF_GetExtendedHighestSequenceNumber() const			{ return stats.GetExtendedHighestSequenceNumber(); }
+	u_int32_t INF_GetJitter() const						{ return stats.GetJitter(); }
+	RTPTime INF_GetLastMessageTime() const					{ return stats.GetLastMessageTime(); }
+	RTPTime INF_GetLastRTPPacketTime() const				{ return stats.GetLastRTPPacketTime(); }
+	double INF_GetEstimatedTimestampUnit() const;
+	u_int32_t INF_GetNumPacketsReceivedInInterval() const			{ return stats.GetNumPacketsReceivedInInterval(); }
+	u_int32_t INF_GetSavedExtendedSequenceNumber() const			{ return stats.GetSavedExtendedSequenceNumber(); }
+	void INF_StartNewInterval()						{ stats.StartNewInterval(); }
+	RTPTime INF_GetRoundtripTime() const;
+	RTPTime INF_GetLastSDESNoteTime() const					{ return stats.GetLastNoteTime(); }
+	
+	u_int8_t *SDES_GetCNAME(size_t *len) const				{ return SDESinf.GetCNAME(len); }
+	u_int8_t *SDES_GetName(size_t *len) const				{ return SDESinf.GetName(len); }
+	u_int8_t *SDES_GetEMail(size_t *len) const				{ return SDESinf.GetEMail(len); }
+	u_int8_t *SDES_GetPhone(size_t *len) const				{ return SDESinf.GetPhone(len); }
+	u_int8_t *SDES_GetLocation(size_t *len) const				{ return SDESinf.GetLocation(len); }
+	u_int8_t *SDES_GetTool(size_t *len) const				{ return SDESinf.GetTool(len); }
+	u_int8_t *SDES_GetNote(size_t *len) const				{ return SDESinf.GetNote(len); }
+	
+#ifdef RTP_SUPPORT_SDESPRIV
+	void SDES_GotoFirstPrivateValue()										{ SDESinf.GotoFirstPrivateValue(); }
+	bool SDES_GetNextPrivateValue(u_int8_t **prefix,size_t *prefixlen,u_int8_t **value,size_t *valuelen) 		{ return SDESinf.GetNextPrivateValue(prefix,prefixlen,value,valuelen); }
+	bool SDES_GetPrivateValue(u_int8_t *prefix,size_t prefixlen,u_int8_t **value,size_t *valuelen) const 		{ return SDESinf.GetPrivateValue(prefix,prefixlen,value,valuelen); }
+#endif // RTP_SUPPORT_SDESPRIV
+
+#ifdef RTPDEBUG
+	virtual void Dump();
+#endif // RTPDEBUG
+protected:
+	std::list&lt;RTPPacket *&gt; packetlist;
+
+	u_int32_t ssrc;
+	bool ownssrc;
+	bool iscsrc;
+	double timestampunit;
+	bool receivedbye;
+	bool validated;
+	bool processedinrtcp;
+	bool issender;
+	
+	RTCPSenderReportInfo SRinf,SRprevinf;
+	RTCPReceiverReportInfo RRinf,RRprevinf;
+	RTPSourceStats stats;
+	RTCPSDESInfo SDESinf;
+	
+	bool isrtpaddrset,isrtcpaddrset;
+	RTPAddress *rtpaddr,*rtcpaddr;
+	
+	RTPTime byetime;
+	u_int8_t *byereason;
+	size_t byereasonlen;
+};
+
+inline RTPPacket *RTPSourceData::GetNextPacket()
+{
+	if (!validated)
+		return 0;
+
+	RTPPacket *p;
+
+	if (packetlist.empty())
+		return 0;
+	p = *(packetlist.begin());
+	packetlist.pop_front();
+	return p;
+}
+
+inline void RTPSourceData::FlushPackets()
+{
+	std::list&lt;RTPPacket *&gt;::const_iterator it;
+
+	for (it = packetlist.begin() ; it != packetlist.end() ; ++it)
+		delete (*it);
+	packetlist.clear();
+}
+#endif // RTPSOURCEDATA_H
+

Added: konference/src/rtp/jrtplib/rtpsources.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpsources.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpsources.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,1412 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtpsources.h&quot;
+#include &quot;rtperrors.h&quot;
+#include &quot;rtprawpacket.h&quot;
+#include &quot;rtpinternalsourcedata.h&quot;
+#include &quot;rtptimeutilities.h&quot;
+#include &quot;rtpdefines.h&quot;
+#include &quot;rtcpcompoundpacket.h&quot;
+#include &quot;rtcppacket.h&quot;
+#include &quot;rtcpapppacket.h&quot;
+#include &quot;rtcpbyepacket.h&quot;
+#include &quot;rtcpsdespacket.h&quot;
+#include &quot;rtcpsrpacket.h&quot;
+#include &quot;rtcprrpacket.h&quot;
+#include &quot;rtptransmitter.h&quot;
+
+#ifdef RTPDEBUG
+	#include &lt;iostream&gt;
+#endif // RTPDEBUG
+
+#include &quot;rtpdebug.h&quot;
+
+#ifndef RTP_SUPPORT_INLINETEMPLATEPARAM
+	int RTPSources_GetHashIndex(const u_int32_t &amp;ssrc)       { return ssrc%RTPSOURCES_HASHSIZE; }
+#endif // !RTP_SUPPORT_INLINETEMPLATEPARAM
+	
+RTPSources::RTPSources(ProbationType probtype)
+{
+	totalcount = 0;
+	sendercount = 0;
+	activecount = 0;
+	owndata = 0;
+#ifdef RTP_SUPPORT_PROBATION
+	probationtype = probtype;
+#endif // RTP_SUPPORT_PROBATION
+}
+
+RTPSources::~RTPSources()
+{
+	Clear();
+}
+
+void RTPSources::Clear()
+{
+	ClearSourceList();
+}
+
+void RTPSources::ClearSourceList()
+{
+	sourcelist.GotoFirstElement();
+	while (sourcelist.HasCurrentElement())
+	{
+		RTPInternalSourceData *sourcedata;
+
+		sourcedata = sourcelist.GetCurrentElement();
+		delete sourcedata;
+		sourcelist.GotoNextElement();
+	}
+	sourcelist.Clear();
+	owndata = 0;
+}
+
+int RTPSources::CreateOwnSSRC(u_int32_t ssrc)
+{
+	if (owndata != 0)
+		return ERR_RTP_SOURCES_ALREADYHAVEOWNSSRC;
+	if (GotEntry(ssrc))
+		return ERR_RTP_SOURCES_SSRCEXISTS;
+
+	int status;
+	bool created;
+	
+	status = ObtainSourceDataInstance(ssrc,&amp;owndata,&amp;created);
+	if (status &lt; 0)
+	{
+		owndata = 0; // just to make sure
+		return status;
+	}
+	owndata-&gt;SetOwnSSRC();	
+	owndata-&gt;SetRTPDataAddress(0);
+	owndata-&gt;SetRTCPDataAddress(0);
+
+	// we've created a validated ssrc, so we should increase activecount
+	activecount++;
+
+	OnNewSource(owndata);
+	return 0;
+}
+
+int RTPSources::DeleteOwnSSRC()
+{
+	if (owndata == 0)
+		return ERR_RTP_SOURCES_DONTHAVEOWNSSRC;
+
+	u_int32_t ssrc = owndata-&gt;GetSSRC();
+
+	sourcelist.GotoElement(ssrc);
+	sourcelist.DeleteCurrentElement();
+
+	totalcount--;
+	if (owndata-&gt;IsSender())
+		sendercount--;
+	if (owndata-&gt;IsActive())
+		activecount--;
+
+	OnRemoveSource(owndata);
+	
+	delete owndata;
+	owndata = 0;
+	return 0;
+}
+
+void RTPSources::SentRTPPacket()
+{
+	if (owndata == 0)
+		return;
+
+	bool prevsender = owndata-&gt;IsSender();
+	
+	owndata-&gt;SentRTPPacket();
+	if (!prevsender &amp;&amp; owndata-&gt;IsSender())
+		sendercount++;
+}
+
+int RTPSources::ProcessRawPacket(RTPRawPacket *rawpack,RTPTransmitter *rtptrans,bool acceptownpackets)
+{
+	RTPTransmitter *transmitters[1];
+	int num;
+	
+	transmitters[0] = rtptrans;
+	if (rtptrans == 0)
+		num = 0;
+	else
+		num = 1;
+	return ProcessRawPacket(rawpack,transmitters,num,acceptownpackets);
+}
+
+int RTPSources::ProcessRawPacket(RTPRawPacket *rawpack,RTPTransmitter *rtptrans[],int numtrans,bool acceptownpackets)
+{
+	int status;
+	
+	if (rawpack-&gt;IsRTP()) // RTP packet
+	{
+		RTPPacket *rtppack;
+		
+		// First, we'll see if the packet can be parsed
+		rtppack = new RTPPacket(*rawpack);
+		if (rtppack == 0)
+			return ERR_RTP_OUTOFMEM;
+		if ((status = rtppack-&gt;GetCreationError()) &lt; 0)
+		{
+			if (status == ERR_RTP_PACKET_INVALIDPACKET)
+			{
+				delete rtppack;
+				rtppack = 0;
+			}
+			else
+			{
+				delete rtppack;
+				return status;
+			}
+		}
+				
+		// Check if the packet was valid
+		if (rtppack != 0)
+		{
+			bool stored = false;
+			bool ownpacket = false;
+			int i;
+			const RTPAddress *senderaddress = rawpack-&gt;GetSenderAddress();
+
+			for (i = 0 ; !ownpacket &amp;&amp; i &lt; numtrans ; i++)
+			{
+				if (rtptrans[i]-&gt;ComesFromThisTransmitter(senderaddress))
+					ownpacket = true;
+			}
+			
+			// Check if the packet is our own.
+			if (ownpacket)
+			{
+				// Now it depends on the user's preference
+				// what to do with this packet:
+				if (acceptownpackets)
+				{
+					// sender addres for own packets has to be NULL!
+					if ((status = ProcessRTPPacket(rtppack,rawpack-&gt;GetReceiveTime(),0,&amp;stored)) &lt; 0)
+					{
+						if (!stored)
+							delete rtppack;
+						return status;
+					}
+				}
+			}
+			else 
+			{
+				if ((status = ProcessRTPPacket(rtppack,rawpack-&gt;GetReceiveTime(),senderaddress,&amp;stored)) &lt; 0)
+				{
+					if (!stored)
+						delete rtppack;
+					return status;
+				}
+			}
+			if (!stored)
+				delete rtppack;
+		}
+	}
+	else // RTCP packet
+	{
+		RTCPCompoundPacket rtcpcomppack(*rawpack);
+		bool valid = false;
+		
+		if ((status = rtcpcomppack.GetCreationError()) &lt; 0)
+		{
+			if (status != ERR_RTP_RTCPCOMPOUND_INVALIDPACKET)
+				return status;
+		}
+		else
+			valid = true;
+
+
+		if (valid)
+		{
+			bool ownpacket = false;
+			int i;
+			const RTPAddress *senderaddress = rawpack-&gt;GetSenderAddress();
+
+			for (i = 0 ; !ownpacket &amp;&amp; i &lt; numtrans ; i++)
+			{
+				if (rtptrans[i]-&gt;ComesFromThisTransmitter(senderaddress))
+					ownpacket = true;
+			}
+
+			// First check if it's a packet of this session.
+			if (ownpacket)
+			{
+				if (acceptownpackets)
+				{
+					// sender address for own packets has to be NULL
+					status = ProcessRTCPCompoundPacket(&amp;rtcpcomppack,rawpack-&gt;GetReceiveTime(),0);
+					if (status &lt; 0)
+						return status;
+				}
+			}
+			else // not our own packet
+			{
+				status = ProcessRTCPCompoundPacket(&amp;rtcpcomppack,rawpack-&gt;GetReceiveTime(),rawpack-&gt;GetSenderAddress());
+				if (status &lt; 0)
+					return status;
+			}
+		}
+	}
+	
+	return 0;
+}
+
+int RTPSources::ProcessRTPPacket(RTPPacket *rtppack,const RTPTime &amp;receivetime,const RTPAddress *senderaddress,bool *stored)
+{
+	u_int32_t ssrc;
+	RTPInternalSourceData *srcdat;
+	int status;
+	bool created;
+
+	OnRTPPacket(rtppack,receivetime,senderaddress);
+
+	*stored = false;
+	
+	ssrc = rtppack-&gt;GetSSRC();
+	if ((status = ObtainSourceDataInstance(ssrc,&amp;srcdat,&amp;created)) &lt; 0)
+		return status;
+
+	if (created)
+	{
+		if ((status = srcdat-&gt;SetRTPDataAddress(senderaddress)) &lt; 0)
+			return status;
+	}
+	else // got a previously existing source
+	{
+		if (CheckCollision(srcdat,senderaddress,true))
+			return 0; // ignore packet on collision
+	}
+	
+	bool prevsender = srcdat-&gt;IsSender();
+	bool prevactive = srcdat-&gt;IsActive();
+	
+	// The packet comes from a valid source, we can process it further now
+	// The following function should delete rtppack itself if something goes
+	// wrong
+	if ((status = srcdat-&gt;ProcessRTPPacket(rtppack,receivetime,stored)) &lt; 0)
+		return status;
+
+	if (!prevsender &amp;&amp; srcdat-&gt;IsSender())
+		sendercount++;
+	if (!prevactive &amp;&amp; srcdat-&gt;IsActive())
+		activecount++;
+
+	if (created)
+		OnNewSource(srcdat);
+
+	if (srcdat-&gt;IsValidated()) // process the CSRCs
+	{
+		RTPInternalSourceData *csrcdat;
+		bool createdcsrc;
+
+		int num = rtppack-&gt;GetCSRCCount();
+		int i;
+
+		for (i = 0 ; i &lt; num ; i++)
+		{
+			if ((status = ObtainSourceDataInstance(rtppack-&gt;GetCSRC(i),&amp;csrcdat,&amp;createdcsrc)) &lt; 0)
+				return status;
+			if (createdcsrc)
+			{
+				csrcdat-&gt;SetCSRC();
+				if (csrcdat-&gt;IsActive())
+					activecount++;
+				OnNewSource(csrcdat);
+			}
+			else // already found an entry, possibly because of RTCP data
+			{
+				if (!CheckCollision(csrcdat,senderaddress,true))
+					csrcdat-&gt;SetCSRC();
+			}
+		}
+	}
+	
+	return 0;
+}
+
+int RTPSources::ProcessRTCPCompoundPacket(RTCPCompoundPacket *rtcpcomppack,const RTPTime &amp;receivetime,const RTPAddress *senderaddress)
+{
+	RTCPPacket *rtcppack;
+	int status;
+	bool gotownssrc = ((owndata == 0)?false:true);
+	u_int32_t ownssrc = ((owndata != 0)?owndata-&gt;GetSSRC():0);
+	
+	OnRTCPCompoundPacket(rtcpcomppack,receivetime,senderaddress);
+	
+	rtcpcomppack-&gt;GotoFirstPacket();	
+	while ((rtcppack = rtcpcomppack-&gt;GetNextPacket()) != 0)
+	{
+		if (rtcppack-&gt;IsKnownFormat())
+		{
+			switch (rtcppack-&gt;GetPacketType())
+			{
+			case RTCPPacket::SR:
+				{
+					RTCPSRPacket *p = (RTCPSRPacket *)rtcppack;
+					u_int32_t senderssrc = p-&gt;GetSenderSSRC();
+					
+					status = ProcessRTCPSenderInfo(senderssrc,p-&gt;GetNTPTimestamp(),p-&gt;GetRTPTimestamp(),
+						                       p-&gt;GetSenderPacketCount(),p-&gt;GetSenderOctetCount(),
+								       receivetime,senderaddress);
+					if (status &lt; 0)
+						return status;
+					
+					bool gotinfo = false;
+					if (gotownssrc)
+					{
+						int i;
+						int num = p-&gt;GetReceptionReportCount();
+						for (i = 0 ; i &lt; num ; i++)
+						{
+							if (p-&gt;GetSSRC(i) == ownssrc) // data is meant for us
+							{
+								gotinfo = true;
+								status = ProcessRTCPReportBlock(senderssrc,p-&gt;GetFractionLost(i),p-&gt;GetLostPacketCount(i),
+										                        p-&gt;GetExtendedHighestSequenceNumber(i),p-&gt;GetJitter(i),p-&gt;GetLSR(i),
+													p-&gt;GetDLSR(i),receivetime,senderaddress);
+								if (status &lt; 0)
+									return status;
+							}
+						}
+					}
+					if (!gotinfo)
+					{
+						status = UpdateReceiveTime(senderssrc,receivetime,senderaddress);
+						if (status &lt; 0)
+							return status;
+					}
+				}
+				break;
+			case RTCPPacket::RR:
+				{
+					RTCPRRPacket *p = (RTCPRRPacket *)rtcppack;
+					u_int32_t senderssrc = p-&gt;GetSenderSSRC();
+					
+					bool gotinfo = false;
+
+					if (gotownssrc)
+					{
+						int i;
+						int num = p-&gt;GetReceptionReportCount();
+						for (i = 0 ; i &lt; num ; i++)
+						{
+							if (p-&gt;GetSSRC(i) == ownssrc)
+							{
+								gotinfo = true;
+								status = ProcessRTCPReportBlock(senderssrc,p-&gt;GetFractionLost(i),p-&gt;GetLostPacketCount(i),
+										                        p-&gt;GetExtendedHighestSequenceNumber(i),p-&gt;GetJitter(i),p-&gt;GetLSR(i),
+													p-&gt;GetDLSR(i),receivetime,senderaddress);
+								if (status &lt; 0)
+									return status;
+							}
+						}
+					}
+					if (!gotinfo)
+					{
+						status = UpdateReceiveTime(senderssrc,receivetime,senderaddress);
+						if (status &lt; 0)
+							return status;
+					}
+				}
+				break;
+			case RTCPPacket::SDES:
+				{
+					RTCPSDESPacket *p = (RTCPSDESPacket *)rtcppack;
+					
+					if (p-&gt;GotoFirstChunk())
+					{
+						do
+						{
+							u_int32_t sdesssrc = p-&gt;GetChunkSSRC();
+							bool updated = false;
+							if (p-&gt;GotoFirstItem())
+							{
+								do
+								{
+									RTCPSDESPacket::ItemType t;
+				
+									if ((t = p-&gt;GetItemType()) != RTCPSDESPacket::PRIV)
+									{
+										updated = true;
+										status = ProcessSDESNormalItem(sdesssrc,t,p-&gt;GetItemLength(),p-&gt;GetItemData(),receivetime,senderaddress);
+										if (status &lt; 0)
+											return status;
+									}
+#ifdef RTP_SUPPORT_SDESPRIV
+									else
+									{
+										updated = true;
+										status = ProcessSDESPrivateItem(sdesssrc,p-&gt;GetPRIVPrefixLength(),p-&gt;GetPRIVPrefixData(),p-&gt;GetPRIVValueLength(),
+												                        p-&gt;GetPRIVValueData(),receivetime,senderaddress);
+										if (status &lt; 0)
+											return status;
+									}
+#endif // RTP_SUPPORT_SDESPRIV
+								} while (p-&gt;GotoNextItem());
+							}
+							if (!updated)
+							{
+								status = UpdateReceiveTime(sdesssrc,receivetime,senderaddress);
+								if (status &lt; 0)
+									return status;
+							}
+						} while (p-&gt;GotoNextChunk());
+					}
+				}
+				break;
+			case RTCPPacket::BYE:
+				{
+					RTCPBYEPacket *p = (RTCPBYEPacket *)rtcppack;
+					int i;
+					int num = p-&gt;GetSSRCCount();
+
+					for (i = 0 ; i &lt; num ; i++)
+					{
+						u_int32_t byessrc = p-&gt;GetSSRC(i);
+						status = ProcessBYE(byessrc,p-&gt;GetReasonLength(),p-&gt;GetReasonData(),receivetime,senderaddress);
+						if (status &lt; 0)
+							return status;
+					}
+				}
+				break;
+			case RTCPPacket::APP:
+				{
+					RTCPAPPPacket *p = (RTCPAPPPacket *)rtcppack;
+
+					OnAPPPacket(p,receivetime,senderaddress);
+				}
+				break; 
+			case RTCPPacket::Unknown:
+			default:
+				{
+					OnUnknownPacketType(rtcppack,receivetime,senderaddress);
+				}
+				break;
+			}
+		}
+		else
+		{
+			OnUnknownPacketFormat(rtcppack,receivetime,senderaddress);
+		}
+	}
+
+	return 0;
+}
+
+bool RTPSources::GotoFirstSource()
+{
+	sourcelist.GotoFirstElement();
+	if (sourcelist.HasCurrentElement())
+		return true;
+	return false;
+}
+
+bool RTPSources::GotoNextSource()
+{
+	sourcelist.GotoNextElement();
+	if (sourcelist.HasCurrentElement())
+		return true;
+	return false;
+}
+
+bool RTPSources::GotoPreviousSource()
+{
+	sourcelist.GotoPreviousElement();
+	if (sourcelist.HasCurrentElement())
+		return true;
+	return false;
+}
+
+bool RTPSources::GotoFirstSourceWithData()
+{
+	bool found = false;
+	
+	sourcelist.GotoFirstElement();
+	while (!found &amp;&amp; sourcelist.HasCurrentElement())
+	{
+		RTPInternalSourceData *srcdat;
+
+		srcdat = sourcelist.GetCurrentElement();
+		if (srcdat-&gt;HasData())
+			found = true;
+		else
+			sourcelist.GotoNextElement();
+	}
+			
+	return found;
+}
+
+bool RTPSources::GotoNextSourceWithData()
+{
+	bool found = false;
+	
+	sourcelist.GotoNextElement();
+	while (!found &amp;&amp; sourcelist.HasCurrentElement())
+	{
+		RTPInternalSourceData *srcdat;
+
+		srcdat = sourcelist.GetCurrentElement();
+		if (srcdat-&gt;HasData())
+			found = true;
+		else
+			sourcelist.GotoNextElement();
+	}
+			
+	return found;
+}
+
+bool RTPSources::GotoPreviousSourceWithData()
+{
+	bool found = false;
+	
+	sourcelist.GotoPreviousElement();
+	while (!found &amp;&amp; sourcelist.HasCurrentElement())
+	{
+		RTPInternalSourceData *srcdat;
+
+		srcdat = sourcelist.GetCurrentElement();
+		if (srcdat-&gt;HasData())
+			found = true;
+		else
+			sourcelist.GotoNextElement();
+	}
+			
+	return found;
+}
+
+RTPSourceData *RTPSources::GetCurrentSourceInfo()
+{
+	if (!sourcelist.HasCurrentElement())
+		return 0;
+	return sourcelist.GetCurrentElement();
+}
+
+RTPSourceData *RTPSources::GetSourceInfo(u_int32_t ssrc)
+{
+	if (sourcelist.GotoElement(ssrc) &lt; 0)
+		return 0;
+	if (!sourcelist.HasCurrentElement())
+		return 0;
+	return sourcelist.GetCurrentElement();
+}
+
+bool RTPSources::GotEntry(u_int32_t ssrc)
+{
+	return sourcelist.HasElement(ssrc);
+}
+
+RTPPacket *RTPSources::GetNextPacket()
+{
+	if (!sourcelist.HasCurrentElement())
+		return 0;
+	
+	RTPInternalSourceData *srcdat = sourcelist.GetCurrentElement();
+	RTPPacket *pack = srcdat-&gt;GetNextPacket();
+	return pack;
+}
+
+int RTPSources::ProcessRTCPSenderInfo(u_int32_t ssrc,const RTPNTPTime &amp;ntptime,u_int32_t rtptime,
+                          u_int32_t packetcount,u_int32_t octetcount,const RTPTime &amp;receivetime,
+			  const RTPAddress *senderaddress)
+{
+	RTPInternalSourceData *srcdat;
+	bool created;
+	int status;
+	
+	status = GetRTCPSourceData(ssrc,senderaddress,&amp;srcdat,&amp;created);
+	if (status &lt; 0)
+		return status;
+	if (srcdat == 0)
+		return 0;
+	
+	srcdat-&gt;ProcessSenderInfo(ntptime,rtptime,packetcount,octetcount,receivetime);
+	
+	// Call the callback
+	if (created)
+		OnNewSource(srcdat);
+
+	return 0;
+}
+
+int RTPSources::ProcessRTCPReportBlock(u_int32_t ssrc,u_int8_t fractionlost,int32_t lostpackets,
+                           u_int32_t exthighseqnr,u_int32_t jitter,u_int32_t lsr,
+			   u_int32_t dlsr,const RTPTime &amp;receivetime,const RTPAddress *senderaddress)
+{
+	RTPInternalSourceData *srcdat;
+	bool created;
+	int status;
+	
+	status = GetRTCPSourceData(ssrc,senderaddress,&amp;srcdat,&amp;created);
+	if (status &lt; 0)
+		return status;
+	if (srcdat == 0)
+		return 0;
+	
+	srcdat-&gt;ProcessReportBlock(fractionlost,lostpackets,exthighseqnr,jitter,lsr,dlsr,receivetime);
+
+	// Call the callback
+	if (created)
+		OnNewSource(srcdat);
+			
+	return 0;
+}
+
+int RTPSources::ProcessSDESNormalItem(u_int32_t ssrc,RTCPSDESPacket::ItemType t,size_t itemlength,
+                          const void *itemdata,const RTPTime &amp;receivetime,const RTPAddress *senderaddress)
+{
+	RTPInternalSourceData *srcdat;
+	bool created,cnamecollis;
+	int status;
+	u_int8_t id;
+	bool prevactive;
+
+	switch(t)
+	{
+	case RTCPSDESPacket::CNAME:
+		id = RTCP_SDES_ID_CNAME;
+		break;
+	case RTCPSDESPacket::NAME:
+		id = RTCP_SDES_ID_NAME;
+		break;
+	case RTCPSDESPacket::EMAIL:
+		id = RTCP_SDES_ID_EMAIL;
+		break;
+	case RTCPSDESPacket::PHONE:
+		id = RTCP_SDES_ID_PHONE;
+		break;
+	case RTCPSDESPacket::LOC:
+		id = RTCP_SDES_ID_LOCATION;
+		break;
+	case RTCPSDESPacket::TOOL:
+		id = RTCP_SDES_ID_TOOL;
+		break;
+	case RTCPSDESPacket::NOTE:
+		id = RTCP_SDES_ID_NOTE;
+		break;
+	default:
+		return ERR_RTP_SOURCES_ILLEGALSDESTYPE;
+	}	
+	
+	status = GetRTCPSourceData(ssrc,senderaddress,&amp;srcdat,&amp;created);
+	if (status &lt; 0)
+		return status;
+	if (srcdat == 0)
+		return 0;
+
+	prevactive = srcdat-&gt;IsActive();
+	status = srcdat-&gt;ProcessSDESItem(id,(const u_int8_t *)itemdata,itemlength,receivetime,&amp;cnamecollis);
+	if (!prevactive &amp;&amp; srcdat-&gt;IsActive())
+		activecount++;
+	
+	// Call the callback
+	if (created)
+		OnNewSource(srcdat);
+	if (cnamecollis)
+		OnCNAMECollision(srcdat,senderaddress,(const u_int8_t *)itemdata,itemlength);
+	
+	return status;
+}
+
+#ifdef RTP_SUPPORT_SDESPRIV
+int RTPSources::ProcessSDESPrivateItem(u_int32_t ssrc,size_t prefixlen,const void *prefixdata,
+                           size_t valuelen,const void *valuedata,const RTPTime &amp;receivetime,
+			   const RTPAddress *senderaddress)
+{
+	RTPInternalSourceData *srcdat;
+	bool created;
+	int status;
+	
+	status = GetRTCPSourceData(ssrc,senderaddress,&amp;srcdat,&amp;created);
+	if (status &lt; 0)
+		return status;
+	if (srcdat == 0)
+		return 0;
+
+	status = srcdat-&gt;ProcessPrivateSDESItem((const u_int8_t *)prefixdata,prefixlen,(const u_int8_t *)valuedata,valuelen,receivetime);
+	// Call the callback
+	if (created)
+		OnNewSource(srcdat);
+	return status;
+}
+#endif //RTP_SUPPORT_SDESPRIV
+
+int RTPSources::ProcessBYE(u_int32_t ssrc,size_t reasonlength,const void *reasondata,
+		           const RTPTime &amp;receivetime,const RTPAddress *senderaddress)
+{
+	RTPInternalSourceData *srcdat;
+	bool created;
+	int status;
+	bool prevactive;
+	
+	status = GetRTCPSourceData(ssrc,senderaddress,&amp;srcdat,&amp;created);
+	if (status &lt; 0)
+		return status;
+	if (srcdat == 0)
+		return 0;
+
+	// we'll ignore BYE packets for our own ssrc
+	if (srcdat == owndata)
+		return 0;
+	
+	prevactive = srcdat-&gt;IsActive();
+	srcdat-&gt;ProcessBYEPacket((const u_int8_t *)reasondata,reasonlength,receivetime);
+	if (prevactive &amp;&amp; !srcdat-&gt;IsActive())
+		activecount--;
+	
+	// Call the callback
+	if (created)
+		OnNewSource(srcdat);
+	OnBYEPacket(srcdat);
+	return 0;
+}
+
+int RTPSources::ObtainSourceDataInstance(u_int32_t ssrc,RTPInternalSourceData **srcdat,bool *created)
+{
+	RTPInternalSourceData *srcdat2;
+	int status;
+	
+	if (sourcelist.GotoElement(ssrc) &lt; 0) // No entry for this source
+	{
+#ifdef RTP_SUPPORT_PROBATION
+		srcdat2 = new RTPInternalSourceData(ssrc,probationtype);
+#else
+		srcdat2 = new RTPInternalSourceData(ssrc,RTPSources::NoProbation);
+#endif // RTP_SUPPORT_PROBATION
+		if (srcdat2 == 0)
+			return ERR_RTP_OUTOFMEM;
+		if ((status = sourcelist.AddElement(ssrc,srcdat2)) &lt; 0)
+		{
+			delete srcdat2;
+			return status;
+		}
+		*srcdat = srcdat2;
+		*created = true;
+		totalcount++;
+	}
+	else
+	{
+		*srcdat = sourcelist.GetCurrentElement();
+		*created = false;
+	}
+	return 0;
+}
+
+	
+int RTPSources::GetRTCPSourceData(u_int32_t ssrc,const RTPAddress *senderaddress,
+		                  RTPInternalSourceData **srcdat2,bool *newsource)
+{
+	int status;
+	bool created;
+	RTPInternalSourceData *srcdat;
+	
+	*srcdat2 = 0;
+	
+	if ((status = ObtainSourceDataInstance(ssrc,&amp;srcdat,&amp;created)) &lt; 0)
+		return status;
+	
+	if (created)
+	{
+		if ((status = srcdat-&gt;SetRTCPDataAddress(senderaddress)) &lt; 0)
+			return status;
+	}
+	else // got a previously existing source
+	{
+		if (CheckCollision(srcdat,senderaddress,false))
+			return 0; // ignore packet on collision
+	}
+	
+	*srcdat2 = srcdat;
+	*newsource = created;
+
+	return 0;
+}
+
+int RTPSources::UpdateReceiveTime(u_int32_t ssrc,const RTPTime &amp;receivetime,const RTPAddress *senderaddress)
+{
+	RTPInternalSourceData *srcdat;
+	bool created;
+	int status;
+	
+	status = GetRTCPSourceData(ssrc,senderaddress,&amp;srcdat,&amp;created);
+	if (status &lt; 0)
+		return status;
+	if (srcdat == 0)
+		return 0;
+	
+	// We got valid SSRC info
+	srcdat-&gt;UpdateMessageTime(receivetime);
+	
+	// Call the callback
+	if (created)
+		OnNewSource(srcdat);
+
+	return 0;
+}
+
+void RTPSources::Timeout(const RTPTime &amp;curtime,const RTPTime &amp;timeoutdelay)
+{
+	int newtotalcount = 0;
+	int newsendercount = 0;
+	int newactivecount = 0;
+	RTPTime checktime = curtime;
+	checktime -= timeoutdelay;
+	
+	sourcelist.GotoFirstElement();
+	while (sourcelist.HasCurrentElement())
+	{
+		RTPInternalSourceData *srcdat = sourcelist.GetCurrentElement();
+		RTPTime lastmsgtime = srcdat-&gt;INF_GetLastMessageTime();
+
+		// we don't want to time out ourselves
+		if ((srcdat != owndata) &amp;&amp; (lastmsgtime &lt; checktime)) // timeout
+		{
+			
+			totalcount--;
+			if (srcdat-&gt;IsSender())
+				sendercount--;
+			if (srcdat-&gt;IsActive())
+				activecount--;
+			
+			sourcelist.DeleteCurrentElement();
+
+			OnTimeout(srcdat);
+			OnRemoveSource(srcdat);
+			delete srcdat;
+		}
+		else
+		{
+			newtotalcount++;
+			if (srcdat-&gt;IsSender())
+				newsendercount++;
+			if (srcdat-&gt;IsActive())
+				newactivecount++;
+			sourcelist.GotoNextElement();
+		}
+	}
+	
+#ifdef RTPDEBUG
+	if (newtotalcount != totalcount)
+	{
+		std::cout &lt;&lt; &quot;New total count &quot; &lt;&lt; newtotalcount &lt;&lt; &quot; doesnt match old total count &quot; &lt;&lt; totalcount &lt;&lt; std::endl;
+		SafeCountTotal();
+	}
+	if (newsendercount != sendercount)
+	{
+		std::cout &lt;&lt; &quot;New sender count &quot; &lt;&lt; newsendercount &lt;&lt; &quot; doesnt match old sender count &quot; &lt;&lt; sendercount &lt;&lt; std::endl;
+		SafeCountSenders();
+	}
+	if (newactivecount != activecount)
+	{
+		std::cout &lt;&lt; &quot;New active count &quot; &lt;&lt; newactivecount &lt;&lt; &quot; doesnt match old active count &quot; &lt;&lt; activecount &lt;&lt; std::endl;
+		SafeCountActive();
+	}
+#endif // RTPDEBUG
+	
+	totalcount = newtotalcount; // just to play it safe
+	sendercount = newsendercount;
+	activecount = newactivecount;
+}
+
+void RTPSources::SenderTimeout(const RTPTime &amp;curtime,const RTPTime &amp;timeoutdelay)
+{
+	int newtotalcount = 0;
+	int newsendercount = 0;
+	int newactivecount = 0;
+	RTPTime checktime = curtime;
+	checktime -= timeoutdelay;
+	
+	sourcelist.GotoFirstElement();
+	while (sourcelist.HasCurrentElement())
+	{
+		RTPInternalSourceData *srcdat = sourcelist.GetCurrentElement();
+
+		newtotalcount++;
+		if (srcdat-&gt;IsActive())
+			newactivecount++;
+
+		if (srcdat-&gt;IsSender())
+		{
+			RTPTime lastrtppacktime = srcdat-&gt;INF_GetLastRTPPacketTime();
+
+			if (lastrtppacktime &lt; checktime) // timeout
+			{
+				srcdat-&gt;ClearSenderFlag();
+				sendercount--;
+			}
+			else
+				newsendercount++;
+		}
+		sourcelist.GotoNextElement();
+	}
+	
+#ifdef RTPDEBUG
+	if (newtotalcount != totalcount)
+	{
+		std::cout &lt;&lt; &quot;New total count &quot; &lt;&lt; newtotalcount &lt;&lt; &quot; doesnt match old total count &quot; &lt;&lt; totalcount &lt;&lt; std::endl;
+		SafeCountTotal();
+	}
+	if (newsendercount != sendercount)
+	{
+		std::cout &lt;&lt; &quot;New sender count &quot; &lt;&lt; newsendercount &lt;&lt; &quot; doesnt match old sender count &quot; &lt;&lt; sendercount &lt;&lt; std::endl;
+		SafeCountSenders();
+	}
+	if (newactivecount != activecount)
+	{
+		std::cout &lt;&lt; &quot;New active count &quot; &lt;&lt; newactivecount &lt;&lt; &quot; doesnt match old active count &quot; &lt;&lt; activecount &lt;&lt; std::endl;
+		SafeCountActive();
+	}
+#endif // RTPDEBUG
+	
+	totalcount = newtotalcount; // just to play it safe
+	sendercount = newsendercount;
+	activecount = newactivecount;
+}
+
+void RTPSources::BYETimeout(const RTPTime &amp;curtime,const RTPTime &amp;timeoutdelay)
+{
+	int newtotalcount = 0;
+	int newsendercount = 0;
+	int newactivecount = 0;
+	RTPTime checktime = curtime;
+	checktime -= timeoutdelay;
+	
+	sourcelist.GotoFirstElement();
+	while (sourcelist.HasCurrentElement())
+	{
+		RTPInternalSourceData *srcdat = sourcelist.GetCurrentElement();
+		
+		if (srcdat-&gt;ReceivedBYE())
+		{
+			RTPTime byetime = srcdat-&gt;GetBYETime();
+
+			if ((srcdat != owndata) &amp;&amp; (checktime &gt; byetime))
+			{
+				totalcount--;
+				if (srcdat-&gt;IsSender())
+					sendercount--;
+				if (srcdat-&gt;IsActive())
+					activecount--;
+				sourcelist.DeleteCurrentElement();
+				OnBYETimeout(srcdat);
+				OnRemoveSource(srcdat);
+				delete srcdat;
+			}
+			else
+			{
+				newtotalcount++;
+				if (srcdat-&gt;IsSender())
+					newsendercount++;
+				if (srcdat-&gt;IsActive())
+					newactivecount++;
+				sourcelist.GotoNextElement();
+			}
+		}
+		else
+		{
+			newtotalcount++;
+			if (srcdat-&gt;IsSender())
+				newsendercount++;
+			if (srcdat-&gt;IsActive())
+				newactivecount++;
+			sourcelist.GotoNextElement();
+		}
+	}
+	
+#ifdef RTPDEBUG
+	if (newtotalcount != totalcount)
+	{
+		std::cout &lt;&lt; &quot;New total count &quot; &lt;&lt; newtotalcount &lt;&lt; &quot; doesnt match old total count &quot; &lt;&lt; totalcount &lt;&lt; std::endl;
+		SafeCountTotal();
+	}
+	if (newsendercount != sendercount)
+	{
+		std::cout &lt;&lt; &quot;New sender count &quot; &lt;&lt; newsendercount &lt;&lt; &quot; doesnt match old sender count &quot; &lt;&lt; sendercount &lt;&lt; std::endl;
+		SafeCountSenders();
+	}
+	if (newactivecount != activecount)
+	{
+		std::cout &lt;&lt; &quot;New active count &quot; &lt;&lt; newactivecount &lt;&lt; &quot; doesnt match old active count &quot; &lt;&lt; activecount &lt;&lt; std::endl;
+		SafeCountActive();
+	}
+#endif // RTPDEBUG
+	
+	totalcount = newtotalcount; // just to play it safe
+	sendercount = newsendercount;
+	activecount = newactivecount;
+}
+
+void RTPSources::NoteTimeout(const RTPTime &amp;curtime,const RTPTime &amp;timeoutdelay)
+{
+	int newtotalcount = 0;
+	int newsendercount = 0;
+	int newactivecount = 0;
+	RTPTime checktime = curtime;
+	checktime -= timeoutdelay;
+	
+	sourcelist.GotoFirstElement();
+	while (sourcelist.HasCurrentElement())
+	{
+		RTPInternalSourceData *srcdat = sourcelist.GetCurrentElement();
+		u_int8_t *note;
+		size_t notelen;
+
+		note = srcdat-&gt;SDES_GetNote(&amp;notelen);
+		if (notelen != 0) // Note has been set
+		{
+			RTPTime notetime = srcdat-&gt;INF_GetLastSDESNoteTime();
+			
+			if (checktime &gt; notetime)
+			{
+				srcdat-&gt;ClearNote();
+				OnNoteTimeout(srcdat);
+			}
+		}
+		
+		newtotalcount++;
+		if (srcdat-&gt;IsSender())
+			newsendercount++;
+		if (srcdat-&gt;IsActive())
+			newactivecount++;
+		sourcelist.GotoNextElement();
+	}
+	
+#ifdef RTPDEBUG
+	if (newtotalcount != totalcount)
+	{
+		std::cout &lt;&lt; &quot;New total count &quot; &lt;&lt; newtotalcount &lt;&lt; &quot; doesnt match old total count &quot; &lt;&lt; totalcount &lt;&lt; std::endl;
+		SafeCountTotal();
+	}
+	if (newsendercount != sendercount)
+	{
+		std::cout &lt;&lt; &quot;New sender count &quot; &lt;&lt; newsendercount &lt;&lt; &quot; doesnt match old sender count &quot; &lt;&lt; sendercount &lt;&lt; std::endl;
+		SafeCountSenders();
+	}
+	if (newactivecount != activecount)
+	{
+		std::cout &lt;&lt; &quot;New active count &quot; &lt;&lt; newactivecount &lt;&lt; &quot; doesnt match old active count &quot; &lt;&lt; activecount &lt;&lt; std::endl;
+		SafeCountActive();
+	}
+#endif // RTPDEBUG
+	
+	totalcount = newtotalcount; // just to play it safe
+	sendercount = newsendercount;
+	activecount = newactivecount;
+
+}
+	
+void RTPSources::MultipleTimeouts(const RTPTime &amp;curtime,const RTPTime &amp;sendertimeout,const RTPTime &amp;byetimeout,const RTPTime &amp;generaltimeout,const RTPTime &amp;notetimeout)
+{
+	int newtotalcount = 0;
+	int newsendercount = 0;
+	int newactivecount = 0;
+	RTPTime senderchecktime = curtime;
+	RTPTime byechecktime = curtime;
+	RTPTime generaltchecktime = curtime;
+	RTPTime notechecktime = curtime;
+	senderchecktime -= sendertimeout;
+	byechecktime -= byetimeout;
+	generaltchecktime -= generaltimeout;
+	notechecktime -= notetimeout;
+	
+	sourcelist.GotoFirstElement();
+	while (sourcelist.HasCurrentElement())
+	{
+		RTPInternalSourceData *srcdat = sourcelist.GetCurrentElement();
+		bool deleted,issender,isactive;
+		bool byetimeout,normaltimeout,notetimeout;
+		u_int8_t *note;
+		size_t notelen;
+		
+		issender = srcdat-&gt;IsSender();
+		isactive = srcdat-&gt;IsActive();
+		deleted = false;
+		byetimeout = false;
+		normaltimeout = false;
+		notetimeout = false;
+
+		note = srcdat-&gt;SDES_GetNote(&amp;notelen);
+		if (notelen != 0) // Note has been set
+		{
+			RTPTime notetime = srcdat-&gt;INF_GetLastSDESNoteTime();
+			
+			if (notechecktime &gt; notetime)
+			{
+				notetimeout = true;
+				srcdat-&gt;ClearNote();
+			}
+		}
+
+		if (srcdat-&gt;ReceivedBYE())
+		{
+			RTPTime byetime = srcdat-&gt;GetBYETime();
+
+			if ((srcdat != owndata) &amp;&amp; (byechecktime &gt; byetime))
+			{
+				sourcelist.DeleteCurrentElement();
+				deleted = true;
+				byetimeout = true;
+			}
+		}
+
+		if (!deleted)
+		{
+			RTPTime lastmsgtime = srcdat-&gt;INF_GetLastMessageTime();
+
+			if ((srcdat != owndata) &amp;&amp; (lastmsgtime &lt; generaltchecktime))
+			{
+				sourcelist.DeleteCurrentElement();
+				deleted = true;
+				normaltimeout = true;
+			}
+		}
+		
+		if (!deleted)
+		{
+			newtotalcount++;
+			
+			if (issender)
+			{
+				RTPTime lastrtppacktime = srcdat-&gt;INF_GetLastRTPPacketTime();
+
+				if (lastrtppacktime &lt; senderchecktime)
+				{
+					srcdat-&gt;ClearSenderFlag();
+					sendercount--;
+				}
+				else
+					newsendercount++;
+			}
+
+			if (isactive)
+				newactivecount++;
+
+			if (notetimeout)
+				OnNoteTimeout(srcdat);
+
+			sourcelist.GotoNextElement();
+		}
+		else // deleted entry
+		{
+			if (issender)
+				sendercount--;
+			if (isactive)
+				activecount--;
+			totalcount--;
+
+			if (byetimeout)
+				OnBYETimeout(srcdat);
+			if (normaltimeout)
+				OnTimeout(srcdat);
+			delete srcdat;
+		}
+	}	
+	
+#ifdef RTPDEBUG
+	if (newtotalcount != totalcount)
+	{
+		SafeCountTotal();
+		std::cout &lt;&lt; &quot;New total count &quot; &lt;&lt; newtotalcount &lt;&lt; &quot; doesnt match old total count &quot; &lt;&lt; totalcount &lt;&lt; std::endl;
+	}
+	if (newsendercount != sendercount)
+	{
+		SafeCountSenders();
+		std::cout &lt;&lt; &quot;New sender count &quot; &lt;&lt; newsendercount &lt;&lt; &quot; doesnt match old sender count &quot; &lt;&lt; sendercount &lt;&lt; std::endl;
+	}
+	if (newactivecount != activecount)
+	{
+		std::cout &lt;&lt; &quot;New active count &quot; &lt;&lt; newactivecount &lt;&lt; &quot; doesnt match old active count &quot; &lt;&lt; activecount &lt;&lt; std::endl;
+		SafeCountActive();
+	}
+#endif // RTPDEBUG
+	
+	totalcount = newtotalcount; // just to play it safe
+	sendercount = newsendercount;
+	activecount = newactivecount;
+}
+
+#ifdef RTPDEBUG
+void RTPSources::Dump()
+{
+	std::cout &lt;&lt; &quot;Total count:  &quot; &lt;&lt; totalcount &lt;&lt; std::endl;
+	std::cout &lt;&lt; &quot;Sender count: &quot; &lt;&lt; sendercount &lt;&lt; std::endl;
+	std::cout &lt;&lt; &quot;Active count: &quot; &lt;&lt; activecount &lt;&lt; std::endl;
+	if (GotoFirstSource())
+	{
+		do
+		{
+			RTPSourceData *s;
+			s = GetCurrentSourceInfo();
+			s-&gt;Dump();
+			std::cout &lt;&lt; std::endl;
+		} while (GotoNextSource());
+	}
+}
+
+void RTPSources::SafeCountTotal()
+{
+	int count = 0;
+	
+	if (GotoFirstSource())
+	{
+		do
+		{
+			count++;	
+		} while (GotoNextSource());
+	}
+	std::cout &lt;&lt; &quot;Actual total count: &quot; &lt;&lt; count &lt;&lt; std::endl;
+}
+
+void RTPSources::SafeCountSenders()
+{
+	int count = 0;
+	
+	if (GotoFirstSource())
+	{
+		do
+		{
+			RTPSourceData *s;
+			s = GetCurrentSourceInfo();
+			if (s-&gt;IsSender())
+				count++;	
+		} while (GotoNextSource());
+	}
+	std::cout &lt;&lt; &quot;Actual sender count: &quot; &lt;&lt; count &lt;&lt; std::endl;
+}
+
+void RTPSources::SafeCountActive()
+{
+	int count = 0;
+	
+	if (GotoFirstSource())
+	{
+		do
+		{
+			RTPSourceData *s;
+			s = GetCurrentSourceInfo();
+			if (s-&gt;IsActive())
+				count++;	
+		} while (GotoNextSource());
+	}
+	std::cout &lt;&lt; &quot;Actual active count: &quot; &lt;&lt; count &lt;&lt; std::endl;
+}
+
+#endif // RTPDEBUG
+
+bool RTPSources::CheckCollision(RTPInternalSourceData *srcdat,const RTPAddress *senderaddress,bool isrtp)
+{
+	bool isset,otherisset;
+	const RTPAddress *addr,*otheraddr;
+	
+	if (isrtp)
+	{
+		isset = srcdat-&gt;IsRTPAddressSet();
+		addr = srcdat-&gt;GetRTPDataAddress();
+		otherisset = srcdat-&gt;IsRTCPAddressSet();
+		otheraddr = srcdat-&gt;GetRTCPDataAddress();
+	}
+	else
+	{
+		isset = srcdat-&gt;IsRTCPAddressSet();
+		addr = srcdat-&gt;GetRTCPDataAddress();
+		otherisset = srcdat-&gt;IsRTPAddressSet();
+		otheraddr = srcdat-&gt;GetRTPDataAddress();
+	}
+
+	if (!isset)
+	{
+		if (otherisset) // got other address, can check if it comes from same host
+		{
+			if (otheraddr == 0) // other came from our own session
+			{
+				if (senderaddress != 0)
+				{
+					OnSSRCCollision(srcdat,senderaddress,isrtp);
+					return true;
+				}
+
+				// Ok, store it
+
+				if (isrtp)
+					srcdat-&gt;SetRTPDataAddress(senderaddress);
+				else
+					srcdat-&gt;SetRTCPDataAddress(senderaddress);
+			}
+			else
+			{
+				if (!otheraddr-&gt;IsFromSameHost(senderaddress))
+				{
+					OnSSRCCollision(srcdat,senderaddress,isrtp);
+					return true;
+				}
+
+				// Ok, comes from same host, store the address
+
+				if (isrtp)
+					srcdat-&gt;SetRTPDataAddress(senderaddress);
+				else
+					srcdat-&gt;SetRTCPDataAddress(senderaddress);
+			}
+		}
+		else // no other address, store this one
+		{
+			if (isrtp)
+				srcdat-&gt;SetRTPDataAddress(senderaddress);
+			else
+				srcdat-&gt;SetRTCPDataAddress(senderaddress);
+		}
+	}
+	else // already got an address
+	{
+		if (addr == 0)
+		{
+			if (senderaddress != 0)
+			{
+				OnSSRCCollision(srcdat,senderaddress,isrtp);
+				return true;
+			}
+		}
+		else
+		{
+			if (!addr-&gt;IsSameAddress(senderaddress))
+			{
+				OnSSRCCollision(srcdat,senderaddress,isrtp);
+				return true;
+			}
+		}
+	}
+	
+	return false;
+}

Added: konference/src/rtp/jrtplib/rtpsources.h
===================================================================
--- konference/src/rtp/jrtplib/rtpsources.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpsources.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,174 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPSOURCES_H
+
+#define RTPSOURCES_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtpkeyhashtable.h&quot;
+#include &quot;rtcpsdespacket.h&quot;
+#include &quot;rtptypes.h&quot;
+
+#define RTPSOURCES_HASHSIZE							8317
+
+#ifdef RTP_SUPPORT_INLINETEMPLATEPARAM
+	inline int RTPSources_GetHashIndex(const u_int32_t &amp;ssrc)	{ return ssrc%RTPSOURCES_HASHSIZE; }
+#else // can't use inline function as template parameter
+	int RTPSources_GetHashIndex(const u_int32_t &amp;ssrc);
+#endif // RTP_SUPPORT_INLINETEMPLATEPARAM
+	
+class RTPNTPTime;
+class RTPTransmitter;
+class RTCPAPPPacket;
+class RTPInternalSourceData;
+class RTPRawPacket;
+class RTPPacket;
+class RTPTime;
+class RTPAddress;
+class RTPSourceData;
+
+class RTPSources
+{
+public:
+	enum ProbationType { NoProbation, ProbationDiscard, ProbationStore };
+	
+	RTPSources(ProbationType = ProbationStore);
+	virtual ~RTPSources();
+	void Clear();
+#ifdef RTP_SUPPORT_PROBATION
+	void SetProbationType(ProbationType probtype)							{ probationtype = probtype; }
+#endif // RTP_SUPPORT_PROBATION
+
+	int CreateOwnSSRC(u_int32_t ssrc);
+	int DeleteOwnSSRC();
+	void SentRTPPacket();
+
+	int ProcessRawPacket(RTPRawPacket *rawpack,RTPTransmitter *trans,bool acceptownpackets);
+	int ProcessRawPacket(RTPRawPacket *rawpack,RTPTransmitter *trans[],int numtrans,bool acceptownpackets);
+
+	// Note: if the packet originated from our own session, senderaddress has to be NULL
+	int ProcessRTPPacket(RTPPacket *rtppack,const RTPTime &amp;receivetime,const RTPAddress *senderaddress,bool *stored);
+	int ProcessRTCPCompoundPacket(RTCPCompoundPacket *rtcpcomppack,const RTPTime &amp;receivetime,
+	                              const RTPAddress *senderaddress);
+	
+	int ProcessRTCPSenderInfo(u_int32_t ssrc,const RTPNTPTime &amp;ntptime,u_int32_t rtptime,
+	                          u_int32_t packetcount,u_int32_t octetcount,const RTPTime &amp;receivetime,
+				  const RTPAddress *senderaddress);
+	int ProcessRTCPReportBlock(u_int32_t ssrc,u_int8_t fractionlost,int32_t lostpackets,
+	                           u_int32_t exthighseqnr,u_int32_t jitter,u_int32_t lsr,
+				   u_int32_t dlsr,const RTPTime &amp;receivetime,const RTPAddress *senderaddress);
+	int ProcessSDESNormalItem(u_int32_t ssrc,RTCPSDESPacket::ItemType t,size_t itemlength,
+	                          const void *itemdata,const RTPTime &amp;receivetime,const RTPAddress *senderaddress);
+#ifdef RTP_SUPPORT_SDESPRIV
+	int ProcessSDESPrivateItem(u_int32_t ssrc,size_t prefixlen,const void *prefixdata,
+	                           size_t valuelen,const void *valuedata,const RTPTime &amp;receivetime,
+				   const RTPAddress *senderaddress);
+#endif //RTP_SUPPORT_SDESPRIV
+	int ProcessBYE(u_int32_t ssrc,size_t reasonlength,const void *reasondata,const RTPTime &amp;receivetime,
+	               const RTPAddress *senderaddress);
+
+	// If no specific info was sent to us, but we did receive a packet from a SSRC, the following
+	// function can be used to update the time at which we last heard something from the SSRC.
+	// This way, premature timeouts can be avoided. 
+	int UpdateReceiveTime(u_int32_t ssrc,const RTPTime &amp;receivetime,const RTPAddress *senderaddress);
+	
+	bool GotoFirstSource();
+	bool GotoNextSource();
+	bool GotoPreviousSource();
+	bool GotoFirstSourceWithData();
+	bool GotoNextSourceWithData();
+	bool GotoPreviousSourceWithData();
+	RTPSourceData *GetCurrentSourceInfo();
+	RTPSourceData *GetSourceInfo(u_int32_t ssrc);
+	RTPPacket *GetNextPacket();
+	bool GotEntry(u_int32_t ssrc);
+	RTPSourceData *GetOwnSourceInfo()								{ return (RTPSourceData *)owndata; }
+
+	void Timeout(const RTPTime &amp;curtime,const RTPTime &amp;timeoutdelay);
+	void SenderTimeout(const RTPTime &amp;curtime,const RTPTime &amp;timeoutdelay);
+	void BYETimeout(const RTPTime &amp;curtime,const RTPTime &amp;timeoutdelay);
+	void NoteTimeout(const RTPTime &amp;curtime,const RTPTime &amp;timeoutdelay);
+	void MultipleTimeouts(const RTPTime &amp;curtime,const RTPTime &amp;sendertimeout,
+			      const RTPTime &amp;byetimeout,const RTPTime &amp;generaltimeout,
+			      const RTPTime &amp;notetimeout);
+
+	int GetSenderCount() const									{ return sendercount; }
+	int GetTotalCount() const									{ return totalcount; }
+	int GetActiveMemberCount() const								{ return activecount; } 
+#ifdef RTPDEBUG
+	void Dump();
+	void SafeCountTotal();
+	void SafeCountSenders();
+	void SafeCountActive();
+#endif // RTPDEBUG
+protected:
+	virtual void OnRTPPacket(RTPPacket *pack,const RTPTime &amp;receivetime,
+	                         const RTPAddress *senderaddress) 					{ }
+	virtual void OnRTCPCompoundPacket(RTCPCompoundPacket *pack,const RTPTime &amp;receivetime,
+	                                  const RTPAddress *senderaddress) 				{ }
+	virtual void OnSSRCCollision(RTPSourceData *srcdat,const RTPAddress *senderaddress,bool isrtp)  { }
+	virtual void OnCNAMECollision(RTPSourceData *srcdat,const RTPAddress *senderaddress,
+	                              const u_int8_t *cname,size_t cnamelength)				{ }
+	virtual void OnNewSource(RTPSourceData *srcdat)			 				{ }
+	virtual void OnRemoveSource(RTPSourceData *srcdat)						{ }
+	virtual void OnTimeout(RTPSourceData *srcdat)							{ }
+	virtual void OnBYETimeout(RTPSourceData *srcdat)						{ }
+	virtual void OnBYEPacket(RTPSourceData *srcdat)							{ }
+	virtual void OnAPPPacket(RTCPAPPPacket *apppacket,const RTPTime &amp;receivetime,
+	                         const RTPAddress *senderaddress)					{ }
+	virtual void OnUnknownPacketType(RTCPPacket *rtcppack,const RTPTime &amp;receivetime,
+	                                 const RTPAddress *senderaddress)				{ }
+	virtual void OnUnknownPacketFormat(RTCPPacket *rtcppack,const RTPTime &amp;receivetime,
+	                                   const RTPAddress *senderaddress)				{ }
+	virtual void OnNoteTimeout(RTPSourceData *srcdat)						{ }
+private:
+	void ClearSourceList();
+	int ObtainSourceDataInstance(u_int32_t ssrc,RTPInternalSourceData **srcdat,bool *created);
+	int GetRTCPSourceData(u_int32_t ssrc,const RTPAddress *senderaddress,RTPInternalSourceData **srcdat,bool *newsource);
+	bool CheckCollision(RTPInternalSourceData *srcdat,const RTPAddress *senderaddress,bool isrtp);
+	
+	RTPKeyHashTable&lt;const u_int32_t,RTPInternalSourceData*,RTPSources_GetHashIndex,RTPSOURCES_HASHSIZE&gt; sourcelist;
+	
+	int sendercount;
+	int totalcount;
+	int activecount;
+
+#ifdef RTP_SUPPORT_PROBATION
+	ProbationType probationtype;
+#endif // RTP_SUPPORT_PROBATION
+
+	RTPInternalSourceData *owndata;
+};
+
+#endif // RTPSOURCES_H
+

Added: konference/src/rtp/jrtplib/rtpstructs.h
===================================================================
--- konference/src/rtp/jrtplib/rtpstructs.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpstructs.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,119 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPSTRUCTS_H
+
+#define RTPSTRUCTS_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtptypes.h&quot;
+
+struct RTPHeader
+{
+#ifdef RTP_BIG_ENDIAN
+	u_int8_t version:2;
+	u_int8_t padding:1;
+	u_int8_t extension:1;
+	u_int8_t csrccount:4;
+	
+	u_int8_t marker:1;
+	u_int8_t payloadtype:7;
+#else // little endian
+	u_int8_t csrccount:4;
+	u_int8_t extension:1;
+	u_int8_t padding:1;
+	u_int8_t version:2;
+	
+	u_int8_t payloadtype:7;
+	u_int8_t marker:1;
+#endif // RTP_BIG_ENDIAN
+	
+	u_int16_t sequencenumber;
+	u_int32_t timestamp;
+	u_int32_t ssrc;
+};
+
+struct RTPExtensionHeader
+{
+	u_int16_t id;
+	u_int16_t length;
+};
+
+struct RTPSourceIdentifier
+{
+	u_int32_t ssrc;
+};
+
+struct RTCPCommonHeader
+{
+#ifdef RTP_BIG_ENDIAN
+	u_int8_t version:2;
+	u_int8_t padding:1;
+	u_int8_t count:5;
+#else // little endian
+	u_int8_t count:5;
+	u_int8_t padding:1;
+	u_int8_t version:2;
+#endif // RTP_BIG_ENDIAN
+
+	u_int8_t packettype;
+	u_int16_t length;
+};
+
+struct RTCPSenderReport
+{
+	u_int32_t ntptime_msw;
+	u_int32_t ntptime_lsw;
+	u_int32_t rtptimestamp;
+	u_int32_t packetcount;
+	u_int32_t octetcount;
+};
+
+struct RTCPReceiverReport
+{
+	u_int32_t ssrc; // Identifies about which SSRC's data this report is...
+	u_int8_t fractionlost;
+	u_int8_t packetslost[3];
+	u_int32_t exthighseqnr;
+	u_int32_t jitter;
+	u_int32_t lsr;
+	u_int32_t dlsr;
+};
+
+struct RTCPSDESHeader
+{
+	u_int8_t id;
+	u_int8_t length;
+};
+
+#endif // RTPSTRUCTS
+

Added: konference/src/rtp/jrtplib/rtptimeutilities.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtptimeutilities.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtptimeutilities.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,51 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#if (defined(WIN32) || defined(_WIN32_WCE))
+
+#include &quot;rtptimeutilities.h&quot;
+#ifdef RTPDEBUG
+	#include &lt;iostream&gt;
+#endif // RTPDEBUG
+
+RTPTimeInitializer::RTPTimeInitializer()
+{
+#ifdef RTPDEBUG
+	std::cout &lt;&lt; &quot;RTPTimeInitializer: Initializing RTPTime::CurrentTime()&quot; &lt;&lt; std::endl;
+#endif // RTPDEBUG
+	RTPTime curtime = RTPTime::CurrentTime();
+}
+
+RTPTimeInitializer timeinit;
+
+#endif // WIN32 || _WIN32_WCE
+

Added: konference/src/rtp/jrtplib/rtptimeutilities.h
===================================================================
--- konference/src/rtp/jrtplib/rtptimeutilities.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtptimeutilities.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,262 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPTIMEUTILITIES_H
+
+#define RTPTIMEUTILITIES_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtptypes.h&quot;
+#ifndef WIN32
+	#include &lt;sys/time.h&gt;
+	#include &lt;time.h&gt;
+#else
+		#ifndef _WIN32_WCE
+        	#include &lt;sys/timeb.h&gt;
+        #endif // _WIN32_WINCE
+#endif // WIN32
+
+#define RTP_NTPTIMEOFFSET									2208988800UL
+
+class RTPNTPTime
+{
+public:
+	RTPNTPTime(u_int32_t m,u_int32_t l)							{ msw = m ; lsw = l; }
+	u_int32_t GetMSW() const								{ return msw; }
+	u_int32_t GetLSW() const								{ return lsw; }
+private:
+	u_int32_t msw,lsw;
+};
+
+class RTPTime
+{
+public:
+	static RTPTime CurrentTime();
+	static void Wait(const RTPTime &amp;delay);
+		
+	RTPTime(double t);
+	RTPTime(RTPNTPTime ntptime);
+	RTPTime(u_int32_t seconds,u_int32_t microseconds)				{ sec = seconds; microsec = microseconds; }
+	u_int32_t GetSeconds() const							{ return sec; }
+	u_int32_t GetMicroSeconds() const						{ return microsec; }
+	double GetDouble() const 							{ return (((double)sec)+(((double)microsec)/1000000.0)); }
+	RTPTime &amp;operator-=(const RTPTime &amp;t);
+	RTPTime &amp;operator+=(const RTPTime &amp;t);
+	RTPNTPTime GetNTPTime() const;
+	bool operator&lt;(const RTPTime &amp;t) const;
+	bool operator&gt;(const RTPTime &amp;t) const;
+	bool operator&lt;=(const RTPTime &amp;t) const;
+	bool operator&gt;=(const RTPTime &amp;t) const;
+private:
+	u_int32_t sec,microsec;
+};
+
+inline RTPTime::RTPTime(double t)
+{
+	sec = (u_int32_t)t;
+
+	double t2 = t-((double)sec);
+	t2 *= 1000000.0;
+	microsec = (u_int32_t)t2;
+}
+
+inline RTPTime::RTPTime(RTPNTPTime ntptime)
+{
+	if (ntptime.GetMSW() &lt; RTP_NTPTIMEOFFSET)
+	{
+		sec = 0;
+		microsec = 0;
+	}
+	else
+	{
+		sec = ntptime.GetMSW() - RTP_NTPTIMEOFFSET;
+		
+		double x = (double)ntptime.GetLSW();
+		x /= (65536.0*65536.0);
+		x *= 1000000.0;
+		microsec = (u_int32_t)x;
+	}
+}
+
+#if (defined(WIN32) || defined(_WIN32_WCE))
+
+inline RTPTime RTPTime::CurrentTime()
+{
+	static int inited = 0;
+	static unsigned __int64 microseconds, initmicroseconds;
+	static LARGE_INTEGER performancefrequency;
+
+	unsigned __int64 emulate_microseconds, microdiff;
+	SYSTEMTIME systemtime;
+	FILETIME filetime;
+
+	LARGE_INTEGER performancecount;
+
+	QueryPerformanceCounter(&amp;performancecount);
+    
+	if(!inited){
+		inited = 1;
+		QueryPerformanceFrequency(&amp;performancefrequency);
+		GetSystemTime(&amp;systemtime);
+		SystemTimeToFileTime(&amp;systemtime,&amp;filetime);
+		microseconds = ( ((unsigned __int64)(filetime.dwHighDateTime) &lt;&lt; 32) + (unsigned __int64)(filetime.dwLowDateTime) ) / 10ui64;
+		microseconds-= 11644473600000000ui64; // EPOCH
+		initmicroseconds = ( ( performancecount.QuadPart * 1000000ui64 ) / performancefrequency.QuadPart );
+	}
+    
+	emulate_microseconds = ( ( performancecount.QuadPart * 1000000ui64 ) / performancefrequency.QuadPart );
+
+	microdiff = emulate_microseconds - initmicroseconds;
+
+	return RTPTime((u_int32_t)((microseconds + microdiff) / 1000000ui64),((u_int32_t)((microseconds + microdiff) % 1000000ui64)));
+}
+
+inline void RTPTime::Wait(const RTPTime &amp;delay)
+{
+	DWORD t;
+
+	t = ((DWORD)delay.GetSeconds())*1000+(((DWORD)delay.GetMicroSeconds())/1000);
+	Sleep(t);
+}
+
+class RTPTimeInitializer
+{
+public:
+	RTPTimeInitializer();
+	void Dummy() { }
+};
+
+extern RTPTimeInitializer timeinit;
+
+#else // unix style
+
+inline RTPTime RTPTime::CurrentTime()
+{
+	struct timeval tv;
+	
+	gettimeofday(&amp;tv,0);
+	return RTPTime((u_int32_t)tv.tv_sec,(u_int32_t)tv.tv_usec);
+}
+
+inline void RTPTime::Wait(const RTPTime &amp;delay)
+{
+	struct timespec req,rem;
+
+	req.tv_sec = (time_t)delay.sec;
+	req.tv_nsec = ((long)delay.microsec)*1000;
+	nanosleep(&amp;req,&amp;rem);
+}
+
+#endif // WIN32
+
+inline RTPTime &amp;RTPTime::operator-=(const RTPTime &amp;t)
+{ 
+	sec -= t.sec; 
+	if (t.microsec &gt; microsec)
+	{
+		sec--;
+		microsec += 1000000;
+	}
+	microsec -= t.microsec;
+	return *this;
+}
+
+inline RTPTime &amp;RTPTime::operator+=(const RTPTime &amp;t)
+{ 
+	sec += t.sec; 
+	microsec += t.microsec;
+	if (microsec &gt;= 1000000)
+	{
+		sec++;
+		microsec -= 1000000;
+	}
+	return *this;
+}
+
+inline RTPNTPTime RTPTime::GetNTPTime() const
+{
+	u_int32_t msw = sec+RTP_NTPTIMEOFFSET;
+	u_int32_t lsw;
+	double x;
+	
+      	x = microsec/1000000.0;
+	x *= (65536.0*65536.0);
+	lsw = (u_int32_t)x;
+
+	return RTPNTPTime(msw,lsw);
+}
+
+inline bool RTPTime::operator&lt;(const RTPTime &amp;t) const
+{
+	if (sec &lt; t.sec)
+		return true;
+	if (sec &gt; t.sec)
+		return false;
+	if (microsec &lt; t.microsec)
+		return true;
+	return false;
+}
+
+inline bool RTPTime::operator&gt;(const RTPTime &amp;t) const
+{
+	if (sec &gt; t.sec)
+		return true;
+	if (sec &lt; t.sec)
+		return false;
+	if (microsec &gt; t.microsec)
+		return true;
+	return false;
+}
+
+inline bool RTPTime::operator&lt;=(const RTPTime &amp;t) const
+{
+	if (sec &lt; t.sec)
+		return true;
+	if (sec &gt; t.sec)
+		return false;
+	if (microsec &lt;= t.microsec)
+		return true;
+	return false;
+}
+
+inline bool RTPTime::operator&gt;=(const RTPTime &amp;t) const
+{
+	if (sec &gt; t.sec)
+		return true;
+	if (sec &lt; t.sec)
+		return false;
+	if (microsec &gt;= t.microsec)
+		return true;
+	return false;
+}
+#endif // RTPTIMEUTILITIES_H
+

Added: konference/src/rtp/jrtplib/rtptransmitter.h
===================================================================
--- konference/src/rtp/jrtplib/rtptransmitter.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtptransmitter.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,141 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPTRANSMITTER_H
+
+#define RTPTRANSMITTER_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtptypes.h&quot;
+
+class RTPRawPacket;
+class RTPAddress;
+class RTPTransmissionParams;
+class RTPTime;
+class RTPTransmissionInfo;
+
+// Abstract class from which actual transmission components should be derived
+
+class RTPTransmitter
+{
+public:
+	enum TransmissionProtocol { IPv4UDPProto, IPv6UDPProto, IPv4GSTProto, UserDefinedProto };
+	enum ReceiveMode { AcceptAll,AcceptSome,IgnoreSome };
+protected:
+	RTPTransmitter()															{ }
+public:
+	virtual ~RTPTransmitter()													{ }
+
+	// The init function is there for initialization before any other threads
+	// may access the object (e.g. initialization of mutexes)
+	virtual int Init(bool threadsafe) = 0;
+	virtual int Create(size_t maxpacksize,const RTPTransmissionParams *transparams) = 0;
+	virtual void Destroy() = 0;
+
+	// The user MUST delete the returned instance when it is no longer needed
+	virtual RTPTransmissionInfo *GetTransmissionInfo() = 0;
+
+	// If the buffersize ins't large enough, the transmitter must fill in the
+	// required length in 'bufferlength'
+	// If the size is ok, bufferlength is adjusted so that it indicates the
+	// amount of bytes in the buffer that are part of the hostname.
+	// The buffer is NOT null terminated!
+	virtual int GetLocalHostName(u_int8_t *buffer,size_t *bufferlength) = 0;
+
+	virtual bool ComesFromThisTransmitter(const RTPAddress *addr) = 0;
+	virtual size_t GetHeaderOverhead() = 0;
+	
+	virtual int Poll() = 0;
+	// If dataavailable is not NULL, it should be set to true if true if data was read
+	// and to false otherwise
+	virtual int WaitForIncomingData(const RTPTime &amp;delay,bool *dataavailable = 0) = 0;
+	virtual int AbortWait() = 0;
+	
+	virtual int SendRTPData(const void *data,size_t len) = 0;	
+	virtual int SendRTCPData(const void *data,size_t len) = 0;
+
+	virtual void ResetPacketCount() = 0;
+	virtual u_int32_t GetNumRTPPacketsSent() = 0;
+	virtual u_int32_t GetNumRTCPPacketsSent() = 0;
+	
+	virtual int AddDestination(const RTPAddress &amp;addr) = 0;
+	virtual int DeleteDestination(const RTPAddress &amp;addr) = 0;
+	virtual void ClearDestinations() = 0;
+
+	virtual bool SupportsMulticasting() = 0;
+	virtual int JoinMulticastGroup(const RTPAddress &amp;addr) = 0;
+	virtual int LeaveMulticastGroup(const RTPAddress &amp;addr) = 0;
+	virtual void LeaveAllMulticastGroups() = 0;
+
+	// Note: the list of addresses must be cleared when the receive mode is changed!
+	virtual int SetReceiveMode(RTPTransmitter::ReceiveMode m) = 0;
+	virtual int AddToIgnoreList(const RTPAddress &amp;addr) = 0;
+	virtual int DeleteFromIgnoreList(const RTPAddress &amp;addr)= 0;
+	virtual void ClearIgnoreList() = 0;
+	virtual int AddToAcceptList(const RTPAddress &amp;addr) = 0;
+	virtual int DeleteFromAcceptList(const RTPAddress &amp;addr) = 0;
+	virtual void ClearAcceptList() = 0;
+	virtual int SetMaximumPacketSize(size_t s) = 0;	
+	
+	virtual bool NewDataAvailable() = 0;
+	virtual RTPRawPacket *GetNextPacket() = 0;
+#ifdef RTPDEBUG
+	virtual void Dump() = 0;
+#endif // RTPDEBUG
+};
+
+// Abstract class from which actual transmission parameters should be derived
+
+class RTPTransmissionParams
+{
+protected:
+	RTPTransmissionParams(RTPTransmitter::TransmissionProtocol p)				{ protocol = p; }
+public:
+	virtual ~RTPTransmissionParams() { }
+	RTPTransmitter::TransmissionProtocol GetTransmissionProtocol() const			{ return protocol; }
+private:
+	RTPTransmitter::TransmissionProtocol protocol;
+};
+
+class RTPTransmissionInfo
+{
+protected:
+	RTPTransmissionInfo(RTPTransmitter::TransmissionProtocol p)				{ protocol = p; }
+public:
+	virtual ~RTPTransmissionInfo() { }
+	RTPTransmitter::TransmissionProtocol GetTransmissionProtocol() const			{ return protocol; }
+private:
+	RTPTransmitter::TransmissionProtocol protocol;
+};
+
+#endif // RTPTRANSMITTER_H
+

Added: konference/src/rtp/jrtplib/rtptypes.h
===================================================================
--- konference/src/rtp/jrtplib/rtptypes.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtptypes.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,37 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include &quot;rtptypes_unix.h&quot;
+#else
+	#include &quot;rtptypes_win.h&quot;
+#endif // WIN32

Added: konference/src/rtp/jrtplib/rtptypes_unix.h
===================================================================
--- konference/src/rtp/jrtplib/rtptypes_unix.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtptypes_unix.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+#include &lt;sys/types.h&gt;

Added: konference/src/rtp/jrtplib/rtptypes_win.h
===================================================================
--- konference/src/rtp/jrtplib/rtptypes_win.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtptypes_win.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,55 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPTYPES_H
+
+#define RTPTYPES_H
+
+#ifndef _WIN32_WCE
+	#include &lt;winsock2.h&gt;	
+	#include &lt;ws2tcpip.h&gt;
+	#include &lt;sys/types.h&gt;
+#else
+	#include &lt;winsock2.h&gt;	
+	#include &lt;ws2tcpip.h&gt;
+
+	typedef short int16_t;
+	typedef char int8_t;
+#endif // _WIN32_WCE
+
+typedef unsigned long u_int32_t;
+typedef unsigned short u_int16_t;
+typedef unsigned char u_int8_t;
+typedef long int32_t;
+
+#endif // RTPTYPES_H
+


Property changes on: konference/src/rtp/jrtplib/rtptypes_win.h
___________________________________________________________________
Name: svn:executable
   + *

Added: konference/src/rtp/jrtplib/rtpudpv4transmitter.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpudpv4transmitter.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpudpv4transmitter.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,1974 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtpudpv4transmitter.h&quot;
+#include &quot;rtprawpacket.h&quot;
+#include &quot;rtpipv4address.h&quot;
+#include &quot;rtptimeutilities.h&quot;
+#include &lt;stdio.h&gt;
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	#define RTPSOCKERR								INVALID_SOCKET
+	#define RTPCLOSE(x)								closesocket(x)
+	#define RTPSOCKLENTYPE								int
+	#define RTPIOCTL								ioctlsocket
+#else // not Win32
+	#include &lt;sys/socket.h&gt;
+	#include &lt;netinet/in.h&gt;
+	#include &lt;arpa/inet.h&gt;
+	#include &lt;sys/ioctl.h&gt;
+	#include &lt;net/if.h&gt;
+	#include &lt;string.h&gt;
+	#include &lt;netdb.h&gt;
+	#include &lt;unistd.h&gt;
+
+	#ifdef RTP_HAVE_SYS_FILIO
+		#include &lt;sys/filio.h&gt;
+	#endif // RTP_HAVE_SYS_FILIO
+	#ifdef RTP_HAVE_SYS_SOCKIO
+		#include &lt;sys/sockio.h&gt;
+	#endif // RTP_HAVE_SYS_SOCKIO
+	#ifdef RTP_SUPPORT_IFADDRS
+		#include &lt;ifaddrs.h&gt;
+	#endif // RTP_SUPPORT_IFADDRS
+
+	#define RTPSOCKERR								-1
+	#define RTPCLOSE(x)								close(x)
+
+	#ifdef RTP_SOCKLENTYPE_UINT
+		#define RTPSOCKLENTYPE							unsigned int
+	#else
+		#define RTPSOCKLENTYPE							int
+	#endif // RTP_SOCKLENTYPE_UINT
+
+	#define RTPIOCTL								ioctl
+#endif // WIN32
+#ifdef RTPDEBUG
+	#include &lt;iostream&gt;
+#endif // RTPDEBUG
+
+#include &quot;rtpdebug.h&quot;
+
+#ifndef _WIN32_WCE
+	#define RTPUDPV4TRANS_RTPRECEIVEBUFFER							32768
+	#define RTPUDPV4TRANS_RTCPRECEIVEBUFFER							32768
+	#define RTPUDPV4TRANS_RTPTRANSMITBUFFER							32768
+	#define RTPUDPV4TRANS_RTCPTRANSMITBUFFER						32768
+	#define RTPUDPV4TRANS_MAXPACKSIZE							65535
+	#define RTPUDPV4TRANS_IFREQBUFSIZE							8192
+#else
+	#define RTPUDPV4TRANS_RTPRECEIVEBUFFER							2048
+	#define RTPUDPV4TRANS_RTCPRECEIVEBUFFER							2048
+	#define RTPUDPV4TRANS_RTPTRANSMITBUFFER							2048
+	#define RTPUDPV4TRANS_RTCPTRANSMITBUFFER						2048
+	#define RTPUDPV4TRANS_MAXPACKSIZE							2048
+	#define RTPUDPV4TRANS_IFREQBUFSIZE							2048
+#endif // _WIN32_WCE
+
+#define RTPUDPV4TRANS_IS_MCASTADDR(x)							(((x)&amp;0xF0000000) == 0xE0000000)
+
+#define RTPUDPV4TRANS_MCASTMEMBERSHIP(socket,type,mcastip,status)	{\
+										struct ip_mreq mreq;\
+										\
+										mreq.imr_multiaddr.s_addr = htonl(mcastip);\
+										mreq.imr_interface.s_addr = htonl(bindIP);\
+										status = setsockopt(socket,IPPROTO_IP,type,(const char *)&amp;mreq,sizeof(struct ip_mreq));\
+									}
+#ifndef RTP_SUPPORT_INLINETEMPLATEPARAM
+	int RTPUDPv4Trans_GetHashIndex_IPv4Dest(const RTPIPv4Destination &amp;d)				{ return d.GetIP_HBO()%RTPUDPV4TRANS_HASHSIZE; }
+	int RTPUDPv4Trans_GetHashIndex_u_int32_t(const u_int32_t &amp;k)					{ return k%RTPUDPV4TRANS_HASHSIZE; }
+#endif // !RTP_SUPPORT_INLINETEMPLATEPARAM
+	
+#ifdef RTP_SUPPORT_THREAD
+	#define MAINMUTEX_LOCK 		{ if (threadsafe) mainmutex.Lock(); }
+	#define MAINMUTEX_UNLOCK	{ if (threadsafe) mainmutex.Unlock(); }
+	#define WAITMUTEX_LOCK		{ if (threadsafe) waitmutex.Lock(); }
+	#define WAITMUTEX_UNLOCK	{ if (threadsafe) waitmutex.Unlock(); }
+#else
+	#define MAINMUTEX_LOCK
+	#define MAINMUTEX_UNLOCK
+	#define WAITMUTEX_LOCK
+	#define WAITMUTEX_UNLOCK
+#endif // RTP_SUPPORT_THREAD
+
+RTPUDPv4Transmitter::RTPUDPv4Transmitter()
+{
+	created = false;
+	init = false;
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	timeinit.Dummy();
+#endif // WIN32 || _WIN32_WCE
+}
+
+RTPUDPv4Transmitter::~RTPUDPv4Transmitter()
+{
+	Destroy();
+}
+
+int RTPUDPv4Transmitter::Init(bool tsafe)
+{
+	if (init)
+		return ERR_RTP_UDPV4TRANS_ALREADYINIT;
+	
+#ifdef RTP_SUPPORT_THREAD
+	threadsafe = tsafe;
+	if (threadsafe)
+	{
+		int status;
+		
+		status = mainmutex.Init();
+		if (status &lt; 0)
+			return ERR_RTP_UDPV4TRANS_CANTINITMUTEX;
+		status = waitmutex.Init();
+		if (status &lt; 0)
+			return ERR_RTP_UDPV4TRANS_CANTINITMUTEX;
+	}
+#else
+	if (tsafe)
+		return ERR_RTP_NOTHREADSUPPORT;
+#endif // RTP_SUPPORT_THREAD
+
+	init = true;
+	return 0;
+}
+
+int RTPUDPv4Transmitter::Create(size_t maximumpacketsize,const RTPTransmissionParams *transparams)
+{
+	const RTPUDPv4TransmissionParams *params,defaultparams;
+	struct sockaddr_in addr;
+	RTPSOCKLENTYPE size;
+	int status;
+
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+
+	if (created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_ALREADYCREATED;
+	}
+	
+	// Obtain transmission parameters
+	
+	if (transparams == 0)
+		params = &defaultparams;
+	else
+	{
+		if (transparams-&gt;GetTransmissionProtocol() != RTPTransmitter::IPv4UDPProto)
+		{
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_UDPV4TRANS_ILLEGALPARAMETERS;
+		}
+		params = (const RTPUDPv4TransmissionParams *)transparams;
+	}
+
+	// Check if portbase is even
+	if (params-&gt;GetPortbase()%2 != 0)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_PORTBASENOTEVEN;
+	}
+
+	// create sockets
+	
+	rtpsock = socket(PF_INET,SOCK_DGRAM,0);
+	if (rtpsock == RTPSOCKERR)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_CANTCREATESOCKET;
+	}
+	rtcpsock = socket(PF_INET,SOCK_DGRAM,0);
+	if (rtcpsock == RTPSOCKERR)
+	{
+		RTPCLOSE(rtpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_CANTCREATESOCKET;
+	}
+
+	// set socket buffer sizes
+	
+	size = RTPUDPV4TRANS_RTPRECEIVEBUFFER;
+	if (setsockopt(rtpsock,SOL_SOCKET,SO_RCVBUF,(const char *)&amp;size,sizeof(int)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_CANTSETRTPRECEIVEBUF;
+	}
+	size = RTPUDPV4TRANS_RTPTRANSMITBUFFER;
+	if (setsockopt(rtpsock,SOL_SOCKET,SO_SNDBUF,(const char *)&amp;size,sizeof(int)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_CANTSETRTPTRANSMITBUF;
+	}
+	size = RTPUDPV4TRANS_RTCPRECEIVEBUFFER;
+	if (setsockopt(rtcpsock,SOL_SOCKET,SO_RCVBUF,(const char *)&amp;size,sizeof(int)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_CANTSETRTCPRECEIVEBUF;
+	}
+	size = RTPUDPV4TRANS_RTCPTRANSMITBUFFER;
+	if (setsockopt(rtcpsock,SOL_SOCKET,SO_SNDBUF,(const char *)&amp;size,sizeof(int)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_CANTSETRTCPTRANSMITBUF;
+	}
+	
+	// bind sockets
+
+	bindIP = params-&gt;GetBindIP();
+	
+	memset(&amp;addr,0,sizeof(struct sockaddr_in));
+	addr.sin_family = AF_INET;
+	addr.sin_port = htons(params-&gt;GetPortbase());
+	addr.sin_addr.s_addr = htonl(bindIP);
+	if (bind(rtpsock,(struct sockaddr *)&amp;addr,sizeof(struct sockaddr_in)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_CANTBINDRTPSOCKET;
+	}
+	memset(&amp;addr,0,sizeof(struct sockaddr_in));
+	addr.sin_family = AF_INET;
+	addr.sin_port = htons(params-&gt;GetPortbase()+1);
+	addr.sin_addr.s_addr = htonl(bindIP);
+	if (bind(rtcpsock,(struct sockaddr *)&amp;addr,sizeof(struct sockaddr_in)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_CANTBINDRTCPSOCKET;
+	}
+
+	// Try to obtain local IP addresses
+
+	localIPs = params-&gt;GetLocalIPList();
+	if (localIPs.empty()) // User did not provide list of local IP addresses, calculate them
+	{
+		int status;
+		
+		if ((status = CreateLocalIPList()) &lt; 0)
+		{
+			RTPCLOSE(rtpsock);
+			RTPCLOSE(rtcpsock);
+			MAINMUTEX_UNLOCK
+			return status;
+		}
+#ifdef RTPDEBUG
+		std::cout &lt;&lt; &quot;Found these local IP addresses:&quot; &lt;&lt; std::endl;
+		
+		std::list&lt;u_int32_t&gt;::const_iterator it;
+
+		for (it = localIPs.begin() ; it != localIPs.end() ; it++)
+		{
+			RTPIPv4Address a(*it);
+
+			std::cout &lt;&lt; a.GetAddressString() &lt;&lt; std::endl;
+		}
+#endif // RTPDEBUG
+	}
+
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+	if (SetMulticastTTL(params-&gt;GetMulticastTTL()))
+		supportsmulticasting = true;
+	else
+		supportsmulticasting = false;
+#else // no multicast support enabled
+	supportsmulticasting = false;
+#endif // RTP_SUPPORT_IPV4MULTICAST
+
+	if ((status = CreateAbortDescriptors()) &lt; 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return status;
+	}
+	
+	if (maximumpacketsize &gt; RTPUDPV4TRANS_MAXPACKSIZE)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		DestroyAbortDescriptors();
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_SPECIFIEDSIZETOOBIG;
+	}
+	
+	maxpacksize = maximumpacketsize;
+	portbase = params-&gt;GetPortbase();
+	multicastTTL = params-&gt;GetMulticastTTL();
+	receivemode = RTPTransmitter::AcceptAll;
+
+	localhostname = 0;
+	localhostnamelength = 0;
+
+	rtppackcount = 0;
+	rtcppackcount = 0;
+	
+	waitingfordata = false;
+	created = true;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+void RTPUDPv4Transmitter::Destroy()
+{
+	if (!init)
+		return;
+
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK;
+		return;
+	}
+
+	if (localhostname)
+	{
+		delete [] localhostname;
+		localhostname = 0;
+		localhostnamelength = 0;
+	}
+	
+	RTPCLOSE(rtpsock);
+	RTPCLOSE(rtcpsock);
+	destinations.Clear();
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+	multicastgroups.Clear();
+#endif // RTP_SUPPORT_IPV4MULTICAST
+	FlushPackets();
+	ClearAcceptIgnoreInfo();
+	localIPs.clear();
+	created = false;
+	
+	if (waitingfordata)
+	{
+		AbortWaitInternal();
+		DestroyAbortDescriptors();
+		MAINMUTEX_UNLOCK
+		WAITMUTEX_LOCK // to make sure that the WaitForIncomingData function ended
+		WAITMUTEX_UNLOCK
+	}
+	else
+		DestroyAbortDescriptors();
+
+	MAINMUTEX_UNLOCK
+}
+
+RTPTransmissionInfo *RTPUDPv4Transmitter::GetTransmissionInfo()
+{
+	if (!init)
+		return 0;
+
+	MAINMUTEX_LOCK
+	RTPTransmissionInfo *tinf = new RTPUDPv4TransmissionInfo(localIPs,rtpsock,rtcpsock);
+	MAINMUTEX_UNLOCK
+	return tinf;
+}
+
+int RTPUDPv4Transmitter::GetLocalHostName(u_int8_t *buffer,size_t *bufferlength)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+
+	if (localhostname == 0)
+	{
+		if (localIPs.empty())
+		{
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_UDPV4TRANS_NOLOCALIPS;
+		}
+		
+		std::list&lt;u_int32_t&gt;::const_iterator it;
+		std::list&lt;std::string&gt; hostnames;
+	
+		for (it = localIPs.begin() ; it != localIPs.end() ; it++)
+		{
+			struct hostent *he;
+			u_int8_t addr[4];
+			u_int32_t ip = (*it);
+	
+			addr[0] = (u_int8_t)((ip&gt;&gt;24)&amp;0xFF);
+			addr[1] = (u_int8_t)((ip&gt;&gt;16)&amp;0xFF);
+			addr[2] = (u_int8_t)((ip&gt;&gt;8)&amp;0xFF);
+			addr[3] = (u_int8_t)(ip&amp;0xFF);
+			he = gethostbyaddr((char *)addr,4,AF_INET);
+			if (he != 0)
+			{
+				std::string hname = std::string(he-&gt;h_name);
+				hostnames.push_back(hname);
+			}
+		}
+	
+		bool found  = false;
+		
+		if (!hostnames.empty())	// try to select the most appropriate hostname
+		{
+			std::list&lt;std::string&gt;::const_iterator it;
+			
+			for (it = hostnames.begin() ; !found &amp;&amp; it != hostnames.end() ; it++)
+			{
+				if ((*it).find('.') != std::string::npos)
+				{
+					found = true;
+					localhostnamelength = (*it).length();
+					localhostname = new u_int8_t [localhostnamelength+1];
+					if (localhostname == 0)
+					{
+						MAINMUTEX_UNLOCK
+						return ERR_RTP_OUTOFMEM;
+					}
+					memcpy(localhostname,(*it).c_str(),localhostnamelength);
+					localhostname[localhostnamelength] = 0;
+				}
+			}
+		}
+	
+		if (!found) // use an IP address
+		{
+			u_int32_t ip;
+			int len;
+			char str[256];
+			
+			it = localIPs.begin();
+			ip = (*it);
+			
+			sprintf(str,&quot;%d.%d.%d.%d&quot;,(int)((ip&gt;&gt;24)&amp;0xFF),(int)((ip&gt;&gt;16)&amp;0xFF),(int)((ip&gt;&gt;8)&amp;0xFF),(int)(ip&amp;0xFF));
+			len = strlen(str);
+	
+			localhostnamelength = len;
+			localhostname = new u_int8_t [localhostnamelength + 1];
+			if (localhostname == 0)
+			{
+				MAINMUTEX_UNLOCK
+				return ERR_RTP_OUTOFMEM;
+			}
+			memcpy(localhostname,str,localhostnamelength);
+			localhostname[localhostnamelength] = 0;
+		}
+	}
+	
+	if ((*bufferlength) &lt; localhostnamelength)
+	{
+		*bufferlength = localhostnamelength; // tell the application the required size of the buffer
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_TRANS_BUFFERLENGTHTOOSMALL;
+	}
+
+	memcpy(buffer,localhostname,localhostnamelength);
+	*bufferlength = localhostnamelength;
+	
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+bool RTPUDPv4Transmitter::ComesFromThisTransmitter(const RTPAddress *addr)
+{
+	if (!init)
+		return false;
+
+	if (addr == 0)
+		return false;
+	
+	MAINMUTEX_LOCK
+	
+	bool v;
+		
+	if (created &amp;&amp; addr-&gt;GetAddressType() == RTPAddress::IPv4Address)
+	{	
+		const RTPIPv4Address *addr2 = (const RTPIPv4Address *)addr;
+		bool found = false;
+		std::list&lt;u_int32_t&gt;::const_iterator it;
+	
+		it = localIPs.begin();
+		while (!found &amp;&amp; it != localIPs.end())
+		{
+			if (addr2-&gt;GetIP() == *it)
+				found = true;
+			else
+				++it;
+		}
+	
+		if (!found)
+			v = false;
+		else
+		{
+			if (addr2-&gt;GetPort() == portbase) // check for RTP port
+				v = true;
+			else if (addr2-&gt;GetPort() == (portbase+1)) // check for RTCP port
+				v = true;
+			else 
+				v = false;
+		}
+	}
+	else
+		v = false;
+
+	MAINMUTEX_UNLOCK
+	return v;
+}
+
+int RTPUDPv4Transmitter::Poll()
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+
+	int status;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	status = PollSocket(true); // poll RTP socket
+	if (status &gt;= 0)
+		status = PollSocket(false); // poll RTCP socket
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPUDPv4Transmitter::WaitForIncomingData(const RTPTime &amp;delay,bool *dataavailable)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	fd_set fdset;
+	struct timeval tv;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (waitingfordata)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_ALREADYWAITING;
+	}
+	
+	FD_ZERO(&amp;fdset);
+	FD_SET(rtpsock,&amp;fdset);
+	FD_SET(rtcpsock,&amp;fdset);
+	FD_SET(abortdesc[0],&amp;fdset);
+	tv.tv_sec = delay.GetSeconds();
+	tv.tv_usec = delay.GetMicroSeconds();
+	
+	waitingfordata = true;
+	
+	WAITMUTEX_LOCK
+	MAINMUTEX_UNLOCK
+
+	if (select(FD_SETSIZE,&amp;fdset,0,0,&amp;tv) &lt; 0)
+	{
+		MAINMUTEX_LOCK
+		waitingfordata = false;
+		MAINMUTEX_UNLOCK
+		WAITMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_ERRORINSELECT;
+	}
+	
+	MAINMUTEX_LOCK
+	waitingfordata = false;
+	if (!created) // destroy called
+	{
+		MAINMUTEX_UNLOCK;
+		WAITMUTEX_UNLOCK
+		return 0;
+	}
+		
+	// if aborted, read from abort buffer
+	if (FD_ISSET(abortdesc[0],&amp;fdset))
+	{
+#if (defined(WIN32) || defined(_WIN32_WCE))
+		char buf[1];
+		
+		recv(abortdesc[0],buf,1,0);
+#else 
+		unsigned char buf[1];
+
+		read(abortdesc[0],buf,1);
+#endif // WIN32
+	}
+
+	if (dataavailable != 0)
+	{
+		if (FD_ISSET(rtpsock,&amp;fdset) || FD_ISSET(rtcpsock,&amp;fdset))
+			*dataavailable = true;
+		else
+			*dataavailable = false;
+	}	
+	
+	MAINMUTEX_UNLOCK
+	WAITMUTEX_UNLOCK
+	return 0;
+}
+
+int RTPUDPv4Transmitter::AbortWait()
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (!waitingfordata)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTWAITING;
+	}
+
+	AbortWaitInternal();
+	
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+int RTPUDPv4Transmitter::SendRTPData(const void *data,size_t len)	
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	struct sockaddr_in saddr;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (len &gt; maxpacksize)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_SPECIFIEDSIZETOOBIG;
+	}
+	
+	memset(&amp;saddr,0,sizeof(struct sockaddr_in));
+	saddr.sin_family = AF_INET;
+	destinations.GotoFirstElement();
+	while (destinations.HasCurrentElement())
+	{
+		saddr.sin_port = destinations.GetCurrentElement().GetRTPPort_NBO();
+		saddr.sin_addr.s_addr = destinations.GetCurrentElement().GetIP_NBO();
+		sendto(rtpsock,(const char *)data,len,0,(struct sockaddr *)&amp;saddr,sizeof(struct sockaddr_in));
+		destinations.GotoNextElement();
+	}
+	
+	rtppackcount++;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+int RTPUDPv4Transmitter::SendRTCPData(const void *data,size_t len)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	struct sockaddr_in saddr;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (len &gt; maxpacksize)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_SPECIFIEDSIZETOOBIG;
+	}
+	
+	memset(&amp;saddr,0,sizeof(struct sockaddr_in));
+	saddr.sin_family = AF_INET;
+	destinations.GotoFirstElement();
+	while (destinations.HasCurrentElement())
+	{
+		saddr.sin_port = destinations.GetCurrentElement().GetRTCPPort_NBO();
+		saddr.sin_addr.s_addr = destinations.GetCurrentElement().GetIP_NBO();
+		sendto(rtcpsock,(const char *)data,len,0,(struct sockaddr *)&amp;saddr,sizeof(struct sockaddr_in));
+		destinations.GotoNextElement();
+	}
+	
+	rtcppackcount++;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+void RTPUDPv4Transmitter::ResetPacketCount()
+{
+	if (!init)
+		return;
+
+	MAINMUTEX_LOCK
+	if (created)
+	{
+		rtppackcount = 0;
+		rtcppackcount = 0;	
+	}
+	MAINMUTEX_UNLOCK	
+}
+
+u_int32_t RTPUDPv4Transmitter::GetNumRTPPacketsSent()
+{
+	if (!init)
+		return 0;
+
+	MAINMUTEX_LOCK
+	
+	u_int32_t num;
+
+	if (!created)
+		num = 0;
+	else
+		num = rtppackcount;
+
+	MAINMUTEX_UNLOCK
+
+	return num;
+}
+
+u_int32_t RTPUDPv4Transmitter::GetNumRTCPPacketsSent()
+{
+	if (!init)
+		return 0;
+	
+	MAINMUTEX_LOCK
+	
+	u_int32_t num;
+
+	if (!created)
+		num = 0;
+	else
+		num = rtcppackcount;
+
+	MAINMUTEX_UNLOCK
+
+	return num;
+}
+	
+int RTPUDPv4Transmitter::AddDestination(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	RTPIPv4Address &amp;address = (RTPIPv4Address &amp;)addr;
+	RTPIPv4Destination dest(address.GetIP(),address.GetPort());
+	int status = destinations.AddElement(dest);
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPUDPv4Transmitter::DeleteDestination(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	RTPIPv4Address &amp;address = (RTPIPv4Address &amp;)addr;	
+	RTPIPv4Destination dest(address.GetIP(),address.GetPort());
+	int status = destinations.DeleteElement(dest);
+	
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPUDPv4Transmitter::ClearDestinations()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created)
+		destinations.Clear();
+	MAINMUTEX_UNLOCK
+}
+
+bool RTPUDPv4Transmitter::SupportsMulticasting()
+{
+	if (!init)
+		return false;
+	
+	MAINMUTEX_LOCK
+	
+	bool v;
+		
+	if (!created)
+		v = false;
+	else
+		v = supportsmulticasting;
+
+	MAINMUTEX_UNLOCK
+	return v;
+}
+
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+
+int RTPUDPv4Transmitter::JoinMulticastGroup(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	const RTPIPv4Address &amp;address = (const RTPIPv4Address &amp;)addr;
+	u_int32_t mcastIP = address.GetIP();
+	
+	if (!RTPUDPV4TRANS_IS_MCASTADDR(mcastIP))
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTAMULTICASTADDRESS;
+	}
+	
+	status = multicastgroups.AddElement(mcastIP);
+	if (status &gt;= 0)
+	{
+		RTPUDPV4TRANS_MCASTMEMBERSHIP(rtpsock,IP_ADD_MEMBERSHIP,mcastIP,status);
+		if (status != 0)
+		{
+			multicastgroups.DeleteElement(mcastIP);
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_UDPV4TRANS_COULDNTJOINMULTICASTGROUP;
+		}
+		RTPUDPV4TRANS_MCASTMEMBERSHIP(rtcpsock,IP_ADD_MEMBERSHIP,mcastIP,status);
+		if (status != 0)
+		{
+			RTPUDPV4TRANS_MCASTMEMBERSHIP(rtpsock,IP_DROP_MEMBERSHIP,mcastIP,status);
+			multicastgroups.DeleteElement(mcastIP);
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_UDPV4TRANS_COULDNTJOINMULTICASTGROUP;
+		}
+	}
+	MAINMUTEX_UNLOCK	
+	return status;
+}
+
+int RTPUDPv4Transmitter::LeaveMulticastGroup(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	const RTPIPv4Address &amp;address = (const RTPIPv4Address &amp;)addr;
+	u_int32_t mcastIP = address.GetIP();
+	
+	if (!RTPUDPV4TRANS_IS_MCASTADDR(mcastIP))
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTAMULTICASTADDRESS;
+	}
+	
+	status = multicastgroups.DeleteElement(mcastIP);
+	if (status &gt;= 0)
+	{	
+		RTPUDPV4TRANS_MCASTMEMBERSHIP(rtpsock,IP_DROP_MEMBERSHIP,mcastIP,status);
+		RTPUDPV4TRANS_MCASTMEMBERSHIP(rtcpsock,IP_DROP_MEMBERSHIP,mcastIP,status);
+		status = 0;
+	}
+	
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPUDPv4Transmitter::LeaveAllMulticastGroups()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created)
+	{
+		multicastgroups.GotoFirstElement();
+		while (multicastgroups.HasCurrentElement())
+		{
+			u_int32_t mcastIP;
+			int status = 0;
+
+			mcastIP = multicastgroups.GetCurrentElement();
+			RTPUDPV4TRANS_MCASTMEMBERSHIP(rtpsock,IP_DROP_MEMBERSHIP,mcastIP,status);
+			RTPUDPV4TRANS_MCASTMEMBERSHIP(rtcpsock,IP_DROP_MEMBERSHIP,mcastIP,status);
+			multicastgroups.GotoNextElement();
+		}
+		multicastgroups.Clear();
+	}
+	MAINMUTEX_UNLOCK
+}
+
+#else // no multicast support
+
+int RTPUDPv4Transmitter::JoinMulticastGroup(const RTPAddress &amp;addr)
+{
+	return ERR_RTP_UDPV4TRANS_NOMULTICASTSUPPORT;
+}
+
+int RTPUDPv4Transmitter::LeaveMulticastGroup(const RTPAddress &amp;addr)
+{
+	return ERR_RTP_UDPV4TRANS_NOMULTICASTSUPPORT;
+}
+
+void RTPUDPv4Transmitter::LeaveAllMulticastGroups()
+{
+}
+
+#endif // RTP_SUPPORT_IPV4MULTICAST
+
+int RTPUDPv4Transmitter::SetReceiveMode(RTPTransmitter::ReceiveMode m)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (m != receivemode)
+	{
+		receivemode = m;
+		acceptignoreinfo.Clear();
+	}
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+int RTPUDPv4Transmitter::AddToIgnoreList(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	int status;
+
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::IgnoreSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv4Address &amp;address = (const RTPIPv4Address &amp;)addr;
+	status = ProcessAddAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+	
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPUDPv4Transmitter::DeleteFromIgnoreList(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::IgnoreSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv4Address &amp;address = (const RTPIPv4Address &amp;)addr;	
+	status = ProcessDeleteAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPUDPv4Transmitter::ClearIgnoreList()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created &amp;&amp; receivemode == RTPTransmitter::IgnoreSome)
+		ClearAcceptIgnoreInfo();
+	MAINMUTEX_UNLOCK
+}
+
+int RTPUDPv4Transmitter::AddToAcceptList(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::AcceptSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv4Address &amp;address = (const RTPIPv4Address &amp;)addr;
+	status = ProcessAddAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPUDPv4Transmitter::DeleteFromAcceptList(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::AcceptSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv4Address &amp;address = (const RTPIPv4Address &amp;)addr;
+	status = ProcessDeleteAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPUDPv4Transmitter::ClearAcceptList()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created &amp;&amp; receivemode == RTPTransmitter::AcceptSome)
+		ClearAcceptIgnoreInfo();
+	MAINMUTEX_UNLOCK
+}
+
+int RTPUDPv4Transmitter::SetMaximumPacketSize(size_t s)	
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (s &gt; RTPUDPV4TRANS_MAXPACKSIZE)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_SPECIFIEDSIZETOOBIG;
+	}
+	maxpacksize = s;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+bool RTPUDPv4Transmitter::NewDataAvailable()
+{
+	if (!init)
+		return false;
+	
+	MAINMUTEX_LOCK
+	
+	bool v;
+		
+	if (!created)
+		v = false;
+	else
+	{
+		if (rawpacketlist.empty())
+			v = false;
+		else
+			v = true;
+	}
+	
+	MAINMUTEX_UNLOCK
+	return v;
+}
+
+RTPRawPacket *RTPUDPv4Transmitter::GetNextPacket()
+{
+	if (!init)
+		return 0;
+	
+	MAINMUTEX_LOCK
+	
+	RTPRawPacket *p;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return 0;
+	}
+	if (rawpacketlist.empty())
+	{
+		MAINMUTEX_UNLOCK
+		return 0;
+	}
+
+	p = *(rawpacketlist.begin());
+	rawpacketlist.pop_front();
+
+	MAINMUTEX_UNLOCK
+	return p;
+}
+
+// Here the private functions start...
+
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+bool RTPUDPv4Transmitter::SetMulticastTTL(u_int8_t ttl)
+{
+	int ttl2,status;
+
+	ttl2 = (int)ttl;
+	status = setsockopt(rtpsock,IPPROTO_IP,IP_MULTICAST_TTL,(const char *)&amp;ttl2,sizeof(int));
+	if (status != 0)
+		return false;
+	status = setsockopt(rtcpsock,IPPROTO_IP,IP_MULTICAST_TTL,(const char *)&amp;ttl2,sizeof(int));
+	if (status != 0)
+		return false;
+	return true;
+}
+#endif // RTP_SUPPORT_IPV4MULTICAST
+
+void RTPUDPv4Transmitter::FlushPackets()
+{
+	std::list&lt;RTPRawPacket*&gt;::const_iterator it;
+
+	for (it = rawpacketlist.begin() ; it != rawpacketlist.end() ; ++it)
+		delete (*it);
+	rawpacketlist.clear();
+}
+
+int RTPUDPv4Transmitter::PollSocket(bool rtp)
+{
+	RTPSOCKLENTYPE fromlen;
+	int recvlen;
+	char packetbuffer[RTPUDPV4TRANS_MAXPACKSIZE];
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	SOCKET sock;
+	unsigned long len;
+#else 
+	size_t len;
+	int sock;
+#endif // WIN32
+	struct sockaddr_in srcaddr;
+	
+	if (rtp)
+		sock = rtpsock;
+	else
+		sock = rtcpsock;
+	
+	len = 0;
+	RTPIOCTL(sock,FIONREAD,&amp;len);
+	if (len &lt;= 0)
+		return 0;
+
+	while (len &gt; 0)
+	{
+		RTPTime curtime = RTPTime::CurrentTime();
+		fromlen = sizeof(struct sockaddr_in);
+		recvlen = recvfrom(sock,packetbuffer,(int)len,0,(struct sockaddr *)&amp;srcaddr,&amp;fromlen);
+		if (recvlen &gt; 0)
+		{
+			bool acceptdata;
+
+			// got data, process it
+			if (receivemode == RTPTransmitter::AcceptAll)
+				acceptdata = true;
+			else
+				acceptdata = ShouldAcceptData(ntohl(srcaddr.sin_addr.s_addr),htons(srcaddr.sin_port));
+			
+			if (acceptdata)
+			{
+				RTPRawPacket *pack;
+				RTPIPv4Address *addr;
+				u_int8_t *datacopy;
+
+				addr = new RTPIPv4Address(ntohl(srcaddr.sin_addr.s_addr),ntohs(srcaddr.sin_port));
+				if (addr == 0)
+					return ERR_RTP_OUTOFMEM;
+				datacopy = new u_int8_t[recvlen];
+				if (datacopy == 0)
+				{
+					delete addr;
+					return ERR_RTP_OUTOFMEM;
+				}
+				memcpy(datacopy,packetbuffer,recvlen);
+				pack = new RTPRawPacket(datacopy,recvlen,addr,curtime,rtp);
+
+				if (pack == 0)
+				{
+					delete addr;
+					delete [] datacopy;
+					return ERR_RTP_OUTOFMEM;
+				}
+				rawpacketlist.push_back(pack);	
+			}
+		}
+		len = 0;
+		RTPIOCTL(sock,FIONREAD,&amp;len);
+	}
+	return 0;
+}
+
+int RTPUDPv4Transmitter::ProcessAddAcceptIgnoreEntry(u_int32_t ip,u_int16_t port)
+{
+	acceptignoreinfo.GotoElement(ip);
+	if (acceptignoreinfo.HasCurrentElement()) // An entry for this IP address already exists
+	{
+		PortInfo *portinf = acceptignoreinfo.GetCurrentElement();
+		
+		if (port == 0) // select all ports
+		{
+			portinf-&gt;all = true;
+			portinf-&gt;portlist.clear();
+		}
+		else if (!portinf-&gt;all)
+		{
+			std::list&lt;u_int16_t&gt;::const_iterator it,begin,end;
+
+			begin = portinf-&gt;portlist.begin();
+			end = portinf-&gt;portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == port) // already in list
+					return 0;
+			}
+			portinf-&gt;portlist.push_front(port);
+		}
+	}
+	else // got to create an entry for this IP address
+	{
+		PortInfo *portinf;
+		int status;
+		
+		portinf = new PortInfo();
+		if (port == 0) // select all ports
+			portinf-&gt;all = true;
+		else
+			portinf-&gt;portlist.push_front(port);
+		
+		status = acceptignoreinfo.AddElement(ip,portinf);
+		if (status &lt; 0)
+		{
+			delete portinf;
+			return status;
+		}
+	}
+
+	return 0;
+}
+
+void RTPUDPv4Transmitter::ClearAcceptIgnoreInfo()
+{
+	acceptignoreinfo.GotoFirstElement();
+	while (acceptignoreinfo.HasCurrentElement())
+	{
+		PortInfo *inf;
+
+		inf = acceptignoreinfo.GetCurrentElement();
+		delete inf;
+		acceptignoreinfo.GotoNextElement();
+	}
+	acceptignoreinfo.Clear();
+}
+	
+int RTPUDPv4Transmitter::ProcessDeleteAcceptIgnoreEntry(u_int32_t ip,u_int16_t port)
+{
+	acceptignoreinfo.GotoElement(ip);
+	if (!acceptignoreinfo.HasCurrentElement())
+		return ERR_RTP_UDPV4TRANS_NOSUCHENTRY;
+	
+	PortInfo *inf;
+
+	inf = acceptignoreinfo.GetCurrentElement();
+	if (port == 0) // delete all entries
+	{
+		inf-&gt;all = false;
+		inf-&gt;portlist.clear();
+	}
+	else // a specific port was selected
+	{
+		if (inf-&gt;all) // currently, all ports are selected. Add the one to remove to the list
+		{
+			// we have to check if the list doesn't contain the port already
+			std::list&lt;u_int16_t&gt;::const_iterator it,begin,end;
+
+			begin = inf-&gt;portlist.begin();
+			end = inf-&gt;portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == port) // already in list: this means we already deleted the entry
+					return ERR_RTP_UDPV4TRANS_NOSUCHENTRY;
+			}
+			inf-&gt;portlist.push_front(port);
+		}
+		else // check if we can find the port in the list
+		{
+			std::list&lt;u_int16_t&gt;::iterator it,begin,end;
+			
+			begin = inf-&gt;portlist.begin();
+			end = inf-&gt;portlist.end();
+			for (it = begin ; it != end ; ++it)
+			{
+				if (*it == port) // found it!
+				{
+					inf-&gt;portlist.erase(it);
+					return 0;
+				}
+			}
+			// didn't find it
+			return ERR_RTP_UDPV4TRANS_NOSUCHENTRY;			
+		}
+	}
+	return 0;
+}
+
+bool RTPUDPv4Transmitter::ShouldAcceptData(u_int32_t srcip,u_int16_t srcport)
+{
+	if (receivemode == RTPTransmitter::AcceptSome)
+	{
+		PortInfo *inf;
+
+		acceptignoreinfo.GotoElement(srcip);
+		if (!acceptignoreinfo.HasCurrentElement())
+			return false;
+		
+		inf = acceptignoreinfo.GetCurrentElement();
+		if (!inf-&gt;all) // only accept the ones in the list
+		{
+			std::list&lt;u_int16_t&gt;::const_iterator it,begin,end;
+
+			begin = inf-&gt;portlist.begin();
+			end = inf-&gt;portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return true;
+			}
+			return false;
+		}
+		else // accept all, except the ones in the list
+		{
+			std::list&lt;u_int16_t&gt;::const_iterator it,begin,end;
+
+			begin = inf-&gt;portlist.begin();
+			end = inf-&gt;portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return false;
+			}
+			return true;
+		}
+	}
+	else // IgnoreSome
+	{
+		PortInfo *inf;
+
+		acceptignoreinfo.GotoElement(srcip);
+		if (!acceptignoreinfo.HasCurrentElement())
+			return true;
+		
+		inf = acceptignoreinfo.GetCurrentElement();
+		if (!inf-&gt;all) // ignore the ports in the list
+		{
+			std::list&lt;u_int16_t&gt;::const_iterator it,begin,end;
+
+			begin = inf-&gt;portlist.begin();
+			end = inf-&gt;portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return false;
+			}
+			return true;
+		}
+		else // ignore all, except the ones in the list
+		{
+			std::list&lt;u_int16_t&gt;::const_iterator it,begin,end;
+
+			begin = inf-&gt;portlist.begin();
+			end = inf-&gt;portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return true;
+			}
+			return false;
+		}
+	}
+	return true;
+}
+
+#if (defined(WIN32) || defined(_WIN32_WCE))
+
+int RTPUDPv4Transmitter::CreateAbortDescriptors()
+{
+	SOCKET listensock;
+	int size;
+	struct sockaddr_in addr;
+
+	listensock = socket(PF_INET,SOCK_STREAM,0);
+	if (listensock == RTPSOCKERR)
+		return ERR_RTP_UDPV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	
+	memset(&amp;addr,0,sizeof(struct sockaddr_in));
+	addr.sin_family = AF_INET;
+	if (bind(listensock,(struct sockaddr *)&amp;addr,sizeof(struct sockaddr_in)) != 0)
+	{
+		RTPCLOSE(listensock);
+		return ERR_RTP_UDPV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&amp;addr,0,sizeof(struct sockaddr_in));
+	size = sizeof(struct sockaddr_in);
+	if (getsockname(listensock,(struct sockaddr*)&amp;addr,&amp;size) != 0)
+	{
+		RTPCLOSE(listensock);
+		return ERR_RTP_UDPV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	unsigned short connectport = ntohs(addr.sin_port);
+
+	abortdesc[0] = socket(PF_INET,SOCK_STREAM,0);
+	if (abortdesc[0] == RTPSOCKERR)
+	{
+		RTPCLOSE(listensock);
+		return ERR_RTP_UDPV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&amp;addr,0,sizeof(struct sockaddr_in));
+	addr.sin_family = AF_INET;
+	if (bind(abortdesc[0],(struct sockaddr *)&amp;addr,sizeof(struct sockaddr_in)) != 0)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_UDPV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	if (listen(listensock,1) != 0)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_UDPV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&amp;addr,0,sizeof(struct sockaddr_in));
+	addr.sin_family = AF_INET;
+	addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);
+	addr.sin_port = htons(connectport);
+	
+	if (connect(abortdesc[0],(struct sockaddr *)&amp;addr,sizeof(struct sockaddr_in)) != 0)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_UDPV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&amp;addr,0,sizeof(struct sockaddr_in));
+	size = sizeof(struct sockaddr_in);
+	abortdesc[1] = accept(listensock,(struct sockaddr *)&amp;addr,&amp;size);
+	if (abortdesc[1] == RTPSOCKERR)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_UDPV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	// okay, got the connection, close the listening socket
+
+	RTPCLOSE(listensock);
+	return 0;
+}
+
+void RTPUDPv4Transmitter::DestroyAbortDescriptors()
+{
+	RTPCLOSE(abortdesc[0]);
+	RTPCLOSE(abortdesc[1]);
+}
+
+#else // in a non winsock environment we can use pipes
+
+int RTPUDPv4Transmitter::CreateAbortDescriptors()
+{
+	if (pipe(abortdesc) &lt; 0)
+		return ERR_RTP_UDPV4TRANS_CANTCREATEPIPE;
+	return 0;
+}
+
+void RTPUDPv4Transmitter::DestroyAbortDescriptors()
+{
+	close(abortdesc[0]);
+	close(abortdesc[1]);
+}
+
+#endif // WIN32
+
+int RTPUDPv4Transmitter::CreateLocalIPList()
+{
+	 // first try to obtain the list from the network interface info
+
+	if (!GetLocalIPList_Interfaces())
+	{
+		// If this fails, we'll have to depend on DNS info
+		GetLocalIPList_DNS();
+	}
+	AddLoopbackAddress();
+	return 0;
+}
+
+#if (defined(WIN32) || defined(_WIN32_WCE))
+
+bool RTPUDPv4Transmitter::GetLocalIPList_Interfaces()
+{
+	unsigned char buffer[RTPUDPV4TRANS_IFREQBUFSIZE];
+	DWORD outputsize;
+	DWORD numaddresses,i;
+	SOCKET_ADDRESS_LIST *addrlist;
+
+	if (WSAIoctl(rtpsock,SIO_ADDRESS_LIST_QUERY,NULL,0,&amp;buffer,RTPUDPV4TRANS_IFREQBUFSIZE,&amp;outputsize,NULL,NULL))
+		return false;
+	
+	addrlist = (SOCKET_ADDRESS_LIST *)buffer;
+	numaddresses = addrlist-&gt;iAddressCount;
+	for (i = 0 ; i &lt; numaddresses ; i++)
+	{
+		SOCKET_ADDRESS *sockaddr = &amp;(addrlist-&gt;Address[i]);
+		if (sockaddr-&gt;iSockaddrLength == sizeof(struct sockaddr_in)) // IPv4 address
+		{
+			struct sockaddr_in *addr = (struct sockaddr_in *)sockaddr-&gt;lpSockaddr;
+
+			localIPs.push_back(ntohl(addr-&gt;sin_addr.s_addr));
+		}
+	}
+
+	if (localIPs.empty())
+		return false;
+
+	return true;
+}
+
+#else // use either getifaddrs or ioctl
+
+#ifdef RTP_SUPPORT_IFADDRS
+
+bool RTPUDPv4Transmitter::GetLocalIPList_Interfaces()
+{
+	struct ifaddrs *addrs,*tmp;
+	
+	getifaddrs(&amp;addrs);
+	tmp = addrs;
+	
+	while (tmp != 0)
+	{
+		if (tmp-&gt;ifa_addr-&gt;sa_family == AF_INET)
+		{
+			struct sockaddr_in *inaddr = (struct sockaddr_in *)tmp-&gt;ifa_addr;
+			localIPs.push_back(ntohl(inaddr-&gt;sin_addr.s_addr));
+		}
+		tmp = tmp-&gt;ifa_next;
+	}
+	
+	freeifaddrs(addrs);
+	
+	if (localIPs.empty())
+		return false;
+	return true;
+}
+
+#else // user ioctl
+
+bool RTPUDPv4Transmitter::GetLocalIPList_Interfaces()
+{
+	int status;
+	char buffer[RTPUDPV4TRANS_IFREQBUFSIZE];
+	struct ifconf ifc;
+	struct ifreq *ifr;
+	struct sockaddr *sa;
+	char *startptr,*endptr;
+	int remlen;
+	
+	ifc.ifc_len = RTPUDPV4TRANS_IFREQBUFSIZE;
+	ifc.ifc_buf = buffer;
+	status = ioctl(rtpsock,SIOCGIFCONF,&amp;ifc);
+	if (status &lt; 0)
+		return false;
+	
+	startptr = (char *)ifc.ifc_req;
+	endptr = startptr + ifc.ifc_len;
+	remlen = ifc.ifc_len;
+	while((startptr &lt; endptr) &amp;&amp; remlen &gt;= (int)sizeof(struct ifreq))
+	{
+		ifr = (struct ifreq *)startptr;
+		sa = &amp;(ifr-&gt;ifr_addr);
+#ifdef RTP_HAVE_SOCKADDR_LEN
+		if (sa-&gt;sa_len &lt;= sizeof(struct sockaddr))
+		{
+			if (sa-&gt;sa_len == sizeof(struct sockaddr_in) &amp;&amp; sa-&gt;sa_family == PF_INET)
+			{
+				u_int32_t ip;
+				struct sockaddr_in *addr = (struct sockaddr_in *)sa;
+				
+				ip = ntohl(addr-&gt;sin_addr.s_addr);
+				localIPs.push_back(ip);
+			}
+			remlen -= sizeof(struct ifreq);
+			startptr += sizeof(struct ifreq);
+		}
+		else
+		{
+			int l = sa-&gt;sa_len-sizeof(struct sockaddr)+sizeof(struct ifreq);
+			
+			remlen -= l;
+			startptr += l;
+		}
+#else // don't have sa_len in struct sockaddr
+		if (sa-&gt;sa_family == PF_INET)
+		{
+			u_int32_t ip;
+			struct sockaddr_in *addr = (struct sockaddr_in *)sa;
+		
+			ip = ntohl(addr-&gt;sin_addr.s_addr);
+			localIPs.push_back(ip);
+		}
+		remlen -= sizeof(struct ifreq);
+		startptr += sizeof(struct ifreq);
+	
+#endif // RTP_HAVE_SOCKADDR_LEN
+	}
+
+	if (localIPs.empty())
+		return false;
+	return true;
+}
+
+#endif // RTP_SUPPORT_IFADDRS
+
+#endif // WIN32
+
+void RTPUDPv4Transmitter::GetLocalIPList_DNS()
+{
+	struct hostent *he;
+	char name[1024];
+	u_int32_t ip;
+	bool done;
+	int i,j;
+
+	gethostname(name,1023);
+	name[1023] = 0;
+	he = gethostbyname(name);
+	if (he == 0)
+		return;
+	
+	ip = 0;
+	i = 0;
+	done = false;
+	while (!done)
+	{
+		if (he-&gt;h_addr_list[i] == NULL)
+			done = true;
+		else
+		{
+			ip = 0;
+			for (j = 0 ; j &lt; 4 ; j++)
+				ip |= ((u_int32_t)((unsigned char)he-&gt;h_addr_list[i][j])&lt;&lt;((3-j)*8));
+			localIPs.push_back(ip);
+			i++;
+		}
+	}
+}
+
+void RTPUDPv4Transmitter::AbortWaitInternal()
+{
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	send(abortdesc[1],&quot;*&quot;,1,0);
+#else
+	write(abortdesc[1],&quot;*&quot;,1);
+#endif // WIN32
+}
+
+void RTPUDPv4Transmitter::AddLoopbackAddress()
+{
+	u_int32_t loopbackaddr = (((u_int32_t)127)&lt;&lt;24)|((u_int32_t)1);
+	std::list&lt;u_int32_t&gt;::const_iterator it;
+	bool found = false;
+	
+	for (it = localIPs.begin() ; !found &amp;&amp; it != localIPs.end() ; it++)
+	{
+		if (*it == loopbackaddr)
+			found = true;
+	}
+
+	if (!found)
+		localIPs.push_back(loopbackaddr);
+}
+
+#ifdef RTPDEBUG
+void RTPUDPv4Transmitter::Dump()
+{
+	if (!init)
+		std::cout &lt;&lt; &quot;Not initialized&quot; &lt;&lt; std::endl;
+	else
+	{
+		MAINMUTEX_LOCK
+	
+		if (!created)
+			std::cout &lt;&lt; &quot;Not created&quot; &lt;&lt; std::endl;
+		else
+		{
+			char str[1024];
+			u_int32_t ip;
+			std::list&lt;u_int32_t&gt;::const_iterator it;
+			
+			std::cout &lt;&lt; &quot;Portbase:                       &quot; &lt;&lt; portbase &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;RTP socket descriptor:          &quot; &lt;&lt; rtpsock &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;RTCP socket descriptor:         &quot; &lt;&lt; rtcpsock &lt;&lt; std::endl;
+			ip = bindIP;
+			sprintf(str,&quot;%d.%d.%d.%d&quot;,(int)((ip&gt;&gt;24)&amp;0xFF),(int)((ip&gt;&gt;16)&amp;0xFF),(int)((ip&gt;&gt;8)&amp;0xFF),(int)(ip&amp;0xFF));
+			std::cout &lt;&lt; &quot;Bind IP address:                &quot; &lt;&lt; str &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;Local IP addresses:&quot; &lt;&lt; std::endl;
+			for (it = localIPs.begin() ; it != localIPs.end() ; it++)
+			{
+				ip = (*it);
+				sprintf(str,&quot;%d.%d.%d.%d&quot;,(int)((ip&gt;&gt;24)&amp;0xFF),(int)((ip&gt;&gt;16)&amp;0xFF),(int)((ip&gt;&gt;8)&amp;0xFF),(int)(ip&amp;0xFF));
+				std::cout &lt;&lt; &quot;    &quot; &lt;&lt; str &lt;&lt; std::endl;
+			}
+			std::cout &lt;&lt; &quot;Multicast TTL:                  &quot; &lt;&lt; (int)multicastTTL &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;Receive mode:                   &quot;;
+			switch (receivemode)
+			{
+			case RTPTransmitter::AcceptAll:
+				std::cout &lt;&lt; &quot;Accept all&quot;;
+				break;
+			case RTPTransmitter::AcceptSome:
+				std::cout &lt;&lt; &quot;Accept some&quot;;
+				break;
+			case RTPTransmitter::IgnoreSome:
+				std::cout &lt;&lt; &quot;Ignore some&quot;;
+			}
+			std::cout &lt;&lt; std::endl;
+			if (receivemode != RTPTransmitter::AcceptAll)
+			{
+				acceptignoreinfo.GotoFirstElement();
+				while(acceptignoreinfo.HasCurrentElement())
+				{
+					ip = acceptignoreinfo.GetCurrentKey();
+					sprintf(str,&quot;%d.%d.%d.%d&quot;,(int)((ip&gt;&gt;24)&amp;0xFF),(int)((ip&gt;&gt;16)&amp;0xFF),(int)((ip&gt;&gt;8)&amp;0xFF),(int)(ip&amp;0xFF));
+					PortInfo *pinfo = acceptignoreinfo.GetCurrentElement();
+					std::cout &lt;&lt; &quot;    &quot; &lt;&lt; str &lt;&lt; &quot;: &quot;;
+					if (pinfo-&gt;all)
+					{
+						std::cout &lt;&lt; &quot;All ports&quot;;
+						if (!pinfo-&gt;portlist.empty())
+							std::cout &lt;&lt; &quot;, except &quot;;
+					}
+					
+					std::list&lt;u_int16_t&gt;::const_iterator it;
+					
+					for (it = pinfo-&gt;portlist.begin() ; it != pinfo-&gt;portlist.end() ; )
+					{
+						std::cout &lt;&lt; (*it);
+						it++;
+						if (it != pinfo-&gt;portlist.end())
+							std::cout &lt;&lt; &quot;, &quot;;
+					}
+					std::cout &lt;&lt; std::endl;
+				}
+			}
+			
+			std::cout &lt;&lt; &quot;Local host name:                &quot;;
+			if (localhostname == 0)
+				std::cout &lt;&lt; &quot;Not set&quot;;
+			else
+				std::cout &lt;&lt; localhostname;
+			std::cout &lt;&lt; std::endl;
+
+			std::cout &lt;&lt; &quot;List of destinations:           &quot;;
+			destinations.GotoFirstElement();
+			if (destinations.HasCurrentElement())
+			{
+				std::cout &lt;&lt; std::endl;
+				do
+				{
+					std::cout &lt;&lt; &quot;    &quot; &lt;&lt; destinations.GetCurrentElement().GetDestinationString() &lt;&lt; std::endl;
+					destinations.GotoNextElement();
+				} while (destinations.HasCurrentElement());
+			}
+			else
+				std::cout &lt;&lt; &quot;Empty&quot; &lt;&lt; std::endl;
+		
+			std::cout &lt;&lt; &quot;Supports multicasting:          &quot; &lt;&lt; ((supportsmulticasting)?&quot;Yes&quot;:&quot;No&quot;) &lt;&lt; std::endl;
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+			std::cout &lt;&lt; &quot;List of multicast groups:       &quot;;
+			multicastgroups.GotoFirstElement();
+			if (multicastgroups.HasCurrentElement())
+			{
+				std::cout &lt;&lt; std::endl;
+				do
+				{
+					ip = multicastgroups.GetCurrentElement();
+					sprintf(str,&quot;%d.%d.%d.%d&quot;,(int)((ip&gt;&gt;24)&amp;0xFF),(int)((ip&gt;&gt;16)&amp;0xFF),(int)((ip&gt;&gt;8)&amp;0xFF),(int)(ip&amp;0xFF));
+					std::cout &lt;&lt; &quot;    &quot; &lt;&lt; str &lt;&lt; std::endl;
+					multicastgroups.GotoNextElement();
+				} while (multicastgroups.HasCurrentElement());
+			}
+			else
+				std::cout &lt;&lt; &quot;Empty&quot; &lt;&lt; std::endl;
+#endif // RTP_SUPPORT_IPV4MULTICAST
+			
+			std::cout &lt;&lt; &quot;Number of raw packets in queue: &quot; &lt;&lt; rawpacketlist.size() &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;Maximum allowed packet size:    &quot; &lt;&lt; maxpacksize &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;RTP packet count:               &quot; &lt;&lt; rtppackcount &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;RTCP packet count:              &quot; &lt;&lt; rtcppackcount &lt;&lt; std::endl;
+		}
+		
+		MAINMUTEX_UNLOCK
+	}
+}
+#endif // RTPDEBUG
+

Added: konference/src/rtp/jrtplib/rtpudpv4transmitter.h
===================================================================
--- konference/src/rtp/jrtplib/rtpudpv4transmitter.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpudpv4transmitter.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,228 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPUDPV4TRANSMITTER_H
+
+#define RTPUDPV4TRANSMITTER_H
+
+#include &quot;rtpconfig.h&quot;
+#include &quot;rtptransmitter.h&quot;
+#include &quot;rtpipv4destination.h&quot;
+#include &quot;rtphashtable.h&quot;
+#include &quot;rtpkeyhashtable.h&quot;
+#include &lt;list&gt;
+
+#ifdef RTP_SUPPORT_THREAD
+	#include &lt;jmutex.h&gt;
+#endif // RTP_SUPPORT_THREAD
+
+#define RTPUDPV4TRANS_HASHSIZE									8317
+#define RTPUDPV4TRANS_DEFAULTPORTBASE								5000
+
+class RTPUDPv4TransmissionParams : public RTPTransmissionParams
+{
+public:
+	RTPUDPv4TransmissionParams():RTPTransmissionParams(RTPTransmitter::IPv4UDPProto)	{ portbase = RTPUDPV4TRANS_DEFAULTPORTBASE; bindIP = 0; multicastTTL = 1; }
+	void SetBindIP(u_int32_t ip)								{ bindIP = ip; }
+	void SetPortbase(u_int16_t pbase)							{ portbase = pbase; }
+	void SetMulticastTTL(u_int8_t mcastTTL)							{ multicastTTL = mcastTTL; }
+	void SetLocalIPList(std::list&lt;u_int32_t&gt; &amp;iplist)					{ localIPs = iplist; } 
+	void ClearLocalIPList()									{ localIPs.clear(); }
+	u_int32_t GetBindIP() const								{ return bindIP; }
+	u_int16_t GetPortbase() const								{ return portbase; }
+	u_int8_t GetMulticastTTL() const							{ return multicastTTL; }
+	const std::list&lt;u_int32_t&gt; &amp;GetLocalIPList() const					{ return localIPs; }
+private:
+	u_int16_t portbase;
+	u_int32_t bindIP;
+	std::list&lt;u_int32_t&gt; localIPs;
+	u_int8_t multicastTTL;
+};
+
+class RTPUDPv4TransmissionInfo : public RTPTransmissionInfo
+{
+public:
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	RTPUDPv4TransmissionInfo(std::list&lt;u_int32_t&gt; iplist,int rtpsock,int rtcpsock) : RTPTransmissionInfo(RTPTransmitter::IPv4UDPProto) 
+#else
+	RTPUDPv4TransmissionInfo(std::list&lt;u_int32_t&gt; iplist,SOCKET rtpsock,SOCKET rtcpsock) : RTPTransmissionInfo(RTPTransmitter::IPv4UDPProto) 
+#endif  // WIN32
+												{ localIPlist = iplist; rtpsocket = rtpsock; rtcpsocket = rtcpsock; }
+
+	~RTPUDPv4TransmissionInfo()								{ }
+	std::list&lt;u_int32_t&gt; GetLocalIPList() const						{ return localIPlist; }
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	int GetRTPSocket() const								{ return rtpsocket; }
+	int GetRTCPSocket() const								{ return rtcpsocket; }
+#else
+	SOCKET GetRTPSocket() const								{ return rtpsocket; }
+	SOCKET GetRTCPSocket() const								{ return rtcpsocket; }
+#endif // WIN32
+private:
+	std::list&lt;u_int32_t&gt; localIPlist;
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	int rtpsocket,rtcpsocket;
+#else
+	SOCKET rtpsocket,rtcpsocket;
+#endif // WIN32
+};
+	
+#ifdef RTP_SUPPORT_INLINETEMPLATEPARAM
+	inline int RTPUDPv4Trans_GetHashIndex_IPv4Dest(const RTPIPv4Destination &amp;d)				{ return d.GetIP_HBO()%RTPUDPV4TRANS_HASHSIZE; }
+	inline int RTPUDPv4Trans_GetHashIndex_u_int32_t(const u_int32_t &amp;k)					{ return k%RTPUDPV4TRANS_HASHSIZE; }
+#else // No support for inline function as template parameter
+	int RTPUDPv4Trans_GetHashIndex_IPv4Dest(const RTPIPv4Destination &amp;d);
+	int RTPUDPv4Trans_GetHashIndex_u_int32_t(const u_int32_t &amp;k);
+#endif // RTP_SUPPORT_INLINETEMPLATEPARAM
+
+#define RTPUDPV4TRANS_HEADERSIZE						(20+8)
+	
+class RTPUDPv4Transmitter : public RTPTransmitter
+{
+public:
+	RTPUDPv4Transmitter();
+	~RTPUDPv4Transmitter();
+
+	int Init(bool treadsafe);
+	int Create(size_t maxpacksize,const RTPTransmissionParams *transparams);
+	void Destroy();
+	RTPTransmissionInfo *GetTransmissionInfo();
+
+	int GetLocalHostName(u_int8_t *buffer,size_t *bufferlength);
+	bool ComesFromThisTransmitter(const RTPAddress *addr);
+	size_t GetHeaderOverhead()							{ return RTPUDPV4TRANS_HEADERSIZE; }
+	
+	int Poll();
+	int WaitForIncomingData(const RTPTime &amp;delay,bool *dataavailable = 0);
+	int AbortWait();
+	
+	int SendRTPData(const void *data,size_t len);	
+	int SendRTCPData(const void *data,size_t len);
+
+	void ResetPacketCount();
+	u_int32_t GetNumRTPPacketsSent();
+	u_int32_t GetNumRTCPPacketsSent();
+				
+	int AddDestination(const RTPAddress &amp;addr);
+	int DeleteDestination(const RTPAddress &amp;addr);
+	void ClearDestinations();
+
+	bool SupportsMulticasting();
+	int JoinMulticastGroup(const RTPAddress &amp;addr);
+	int LeaveMulticastGroup(const RTPAddress &amp;addr);
+	void LeaveAllMulticastGroups();
+
+	int SetReceiveMode(RTPTransmitter::ReceiveMode m);
+	int AddToIgnoreList(const RTPAddress &amp;addr);
+	int DeleteFromIgnoreList(const RTPAddress &amp;addr);
+	void ClearIgnoreList();
+	int AddToAcceptList(const RTPAddress &amp;addr);
+	int DeleteFromAcceptList(const RTPAddress &amp;addr);
+	void ClearAcceptList();
+	int SetMaximumPacketSize(size_t s);	
+	
+	bool NewDataAvailable();
+	RTPRawPacket *GetNextPacket();
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+private:
+	int CreateLocalIPList();
+	bool GetLocalIPList_Interfaces();
+	void GetLocalIPList_DNS();
+	void AddLoopbackAddress();
+	void FlushPackets();
+	int PollSocket(bool rtp);
+	int ProcessAddAcceptIgnoreEntry(u_int32_t ip,u_int16_t port);
+	int ProcessDeleteAcceptIgnoreEntry(u_int32_t ip,u_int16_t port);
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+	bool SetMulticastTTL(u_int8_t ttl);
+#endif // RTP_SUPPORT_IPV4MULTICAST
+	bool ShouldAcceptData(u_int32_t srcip,u_int16_t srcport);
+	void ClearAcceptIgnoreInfo();
+	
+	bool init;
+	bool created;
+	bool waitingfordata;
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	SOCKET rtpsock,rtcpsock;
+#else // not using winsock
+	int rtpsock,rtcpsock;
+#endif // WIN32
+	u_int32_t bindIP;
+	std::list&lt;u_int32_t&gt; localIPs;
+	u_int16_t portbase;
+	u_int8_t multicastTTL;
+	RTPTransmitter::ReceiveMode receivemode;
+
+	u_int8_t *localhostname;
+	size_t localhostnamelength;
+	
+	RTPHashTable&lt;const RTPIPv4Destination,RTPUDPv4Trans_GetHashIndex_IPv4Dest,RTPUDPV4TRANS_HASHSIZE&gt; destinations;
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+	RTPHashTable&lt;const u_int32_t,RTPUDPv4Trans_GetHashIndex_u_int32_t,RTPUDPV4TRANS_HASHSIZE&gt; multicastgroups;
+#endif // RTP_SUPPORT_IPV4MULTICAST
+	std::list&lt;RTPRawPacket*&gt; rawpacketlist;
+
+	bool supportsmulticasting;
+	size_t maxpacksize;
+
+	class PortInfo
+	{
+	public:
+		PortInfo() { all = false; }
+		
+		bool all;
+		std::list&lt;u_int16_t&gt; portlist;
+	};
+
+	RTPKeyHashTable&lt;const u_int32_t,PortInfo*,RTPUDPv4Trans_GetHashIndex_u_int32_t,RTPUDPV4TRANS_HASHSIZE&gt; acceptignoreinfo;
+
+	// notification descriptors for AbortWait (0 is for reading, 1 for writing)
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	SOCKET abortdesc[2];
+#else
+	int abortdesc[2];
+#endif // WIN32
+	int CreateAbortDescriptors();
+	void DestroyAbortDescriptors();
+	void AbortWaitInternal();
+#ifdef RTP_SUPPORT_THREAD
+	JMutex mainmutex,waitmutex;
+	int threadsafe;
+#endif // RTP_SUPPORT_THREAD
+
+	u_int32_t rtppackcount,rtcppackcount;
+};
+
+#endif // RTPUDPV4TRANSMITTER_H
+

Added: konference/src/rtp/jrtplib/rtpudpv6transmitter.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpudpv6transmitter.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpudpv6transmitter.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,1939 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include &quot;rtpudpv6transmitter.h&quot;
+
+#ifdef RTP_SUPPORT_IPV6
+
+#include &quot;rtprawpacket.h&quot;
+#include &quot;rtpipv6address.h&quot;
+#include &quot;rtptimeutilities.h&quot;
+#include &lt;stdio.h&gt;
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	#define RTPSOCKERR								INVALID_SOCKET
+	#define RTPCLOSE(x)								closesocket(x)
+	#define RTPSOCKLENTYPE								int
+	#define RTPIOCTL								ioctlsocket
+#else // not Win32
+	#include &lt;sys/socket.h&gt;
+	#include &lt;netinet/in.h&gt;
+	#include &lt;arpa/inet.h&gt;
+	#include &lt;sys/ioctl.h&gt;
+	#include &lt;net/if.h&gt;
+	#include &lt;string.h&gt;
+	#include &lt;netdb.h&gt;
+	#include &lt;unistd.h&gt;
+
+	#ifdef RTP_HAVE_SYS_FILIO
+		#include &lt;sys/filio.h&gt;
+	#endif // RTP_HAVE_SYS_FILIO
+	#ifdef RTP_HAVE_SYS_SOCKIO
+		#include &lt;sys/sockio.h&gt;
+	#endif // RTP_HAVE_SYS_SOCKIO
+	#ifdef RTP_SUPPORT_IFADDRS
+		#include &lt;ifaddrs.h&gt;
+	#endif // RTP_SUPPORT_IFADDRS
+
+
+	#define RTPSOCKERR								-1
+	#define RTPCLOSE(x)								close(x)
+
+	#ifdef RTP_SOCKLENTYPE_UINT
+		#define RTPSOCKLENTYPE							unsigned int
+	#else
+		#define RTPSOCKLENTYPE							int
+	#endif // RTP_SOCKLENTYPE_UINT
+
+	#define RTPIOCTL								ioctl
+#endif // WIN32
+
+#include &quot;rtpdebug.h&quot;
+
+#ifndef _WIN32_WCE
+	#define RTPUDPV6TRANS_RTPRECEIVEBUFFER							32768
+	#define RTPUDPV6TRANS_RTCPRECEIVEBUFFER							32768
+	#define RTPUDPV6TRANS_RTPTRANSMITBUFFER							32768
+	#define RTPUDPV6TRANS_RTCPTRANSMITBUFFER						32768
+	#define RTPUDPV6TRANS_MAXPACKSIZE							65535
+	#define RTPUDPV6TRANS_IFREQBUFSIZE							8192
+#else
+	#define RTPUDPV6TRANS_RTPRECEIVEBUFFER							2048
+	#define RTPUDPV6TRANS_RTCPRECEIVEBUFFER							2048
+	#define RTPUDPV6TRANS_RTPTRANSMITBUFFER							2048
+	#define RTPUDPV6TRANS_RTCPTRANSMITBUFFER						2048
+	#define RTPUDPV6TRANS_MAXPACKSIZE							2048
+	#define RTPUDPV6TRANS_IFREQBUFSIZE							2048
+#endif // _WIN32_WCE
+
+#define RTPUDPV6TRANS_IS_MCASTADDR(x)							(x.s6_addr[0] == 0xFF)
+
+#define RTPUDPV6TRANS_MCASTMEMBERSHIP(socket,type,mcastip,status)	{\
+										struct ipv6_mreq mreq;\
+										\
+										mreq.ipv6mr_multiaddr = mcastip;\
+										mreq.ipv6mr_interface = 0;\
+										status = setsockopt(socket,IPPROTO_IPV6,type,(const char *)&amp;mreq,sizeof(struct ipv6_mreq));\
+									}
+#ifndef RTP_SUPPORT_INLINETEMPLATEPARAM
+	int RTPUDPv6Trans_GetHashIndex_IPv6Dest(const RTPIPv6Destination &amp;d)		{ in6_addr ip = d.GetIP(); return ((((u_int32_t)ip.s6_addr[12])&lt;&lt;24)|(((u_int32_t)ip.s6_addr[13])&lt;&lt;16)|(((u_int32_t)ip.s6_addr[14])&lt;&lt;8)|((u_int32_t)ip.s6_addr[15]))%RTPUDPV6TRANS_HASHSIZE; }
+	int RTPUDPv6Trans_GetHashIndex_in6_addr(const in6_addr &amp;ip)			{ return ((((u_int32_t)ip.s6_addr[12])&lt;&lt;24)|(((u_int32_t)ip.s6_addr[13])&lt;&lt;16)|(((u_int32_t)ip.s6_addr[14])&lt;&lt;8)|((u_int32_t)ip.s6_addr[15]))%RTPUDPV6TRANS_HASHSIZE; }
+#endif // !RTP_SUPPORT_INLINETEMPLATEPARAM
+	
+#ifdef RTP_SUPPORT_THREAD
+	#define MAINMUTEX_LOCK 		{ if (threadsafe) mainmutex.Lock(); }
+	#define MAINMUTEX_UNLOCK	{ if (threadsafe) mainmutex.Unlock(); }
+	#define WAITMUTEX_LOCK		{ if (threadsafe) waitmutex.Lock(); }
+	#define WAITMUTEX_UNLOCK	{ if (threadsafe) waitmutex.Unlock(); }
+#else
+	#define MAINMUTEX_LOCK
+	#define MAINMUTEX_UNLOCK
+	#define WAITMUTEX_LOCK
+	#define WAITMUTEX_UNLOCK
+#endif // RTP_SUPPORT_THREAD
+	
+inline bool operator==(const in6_addr &amp;ip1,const in6_addr &amp;ip2)
+{
+	if (memcmp(&amp;ip1,&amp;ip2,sizeof(in6_addr)) == 0)
+		return true;
+	return false;
+}
+
+RTPUDPv6Transmitter::RTPUDPv6Transmitter()
+{
+	created = false;
+	init = false;
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	timeinit.Dummy();
+#endif // WIN32 || _WIN32_WCE
+}
+
+RTPUDPv6Transmitter::~RTPUDPv6Transmitter()
+{
+	Destroy();
+}
+
+int RTPUDPv6Transmitter::Init(bool tsafe)
+{
+	if (init)
+		return ERR_RTP_UDPV6TRANS_ALREADYINIT;
+	
+#ifdef RTP_SUPPORT_THREAD
+	threadsafe = tsafe;
+	if (threadsafe)
+	{
+		int status;
+		
+		status = mainmutex.Init();
+		if (status &lt; 0)
+			return ERR_RTP_UDPV6TRANS_CANTINITMUTEX;
+		status = waitmutex.Init();
+		if (status &lt; 0)
+			return ERR_RTP_UDPV6TRANS_CANTINITMUTEX;
+	}
+#else
+	if (tsafe)
+		return ERR_RTP_NOTHREADSUPPORT;
+#endif // RTP_SUPPORT_THREAD
+
+	init = true;
+	return 0;
+}
+
+int RTPUDPv6Transmitter::Create(size_t maximumpacketsize,const RTPTransmissionParams *transparams)
+{
+	const RTPUDPv6TransmissionParams *params,defaultparams;
+	struct sockaddr_in6 addr;
+	RTPSOCKLENTYPE size;
+	int status;
+
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+
+	if (created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_ALREADYCREATED;
+	}
+	
+	// Obtain transmission parameters
+	
+	if (transparams == 0)
+		params = &defaultparams;
+	else
+	{
+		if (transparams-&gt;GetTransmissionProtocol() != RTPTransmitter::IPv6UDPProto)
+		{
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_UDPV6TRANS_ILLEGALPARAMETERS;
+		}
+		params = (const RTPUDPv6TransmissionParams *)transparams;
+	}
+
+	// Check if portbase is even
+	if (params-&gt;GetPortbase()%2 != 0)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_PORTBASENOTEVEN;
+	}
+
+	// create sockets
+	
+	rtpsock = socket(PF_INET6,SOCK_DGRAM,0);
+	if (rtpsock == RTPSOCKERR)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_CANTCREATESOCKET;
+	}
+	rtcpsock = socket(PF_INET6,SOCK_DGRAM,0);
+	if (rtcpsock == RTPSOCKERR)
+	{
+		RTPCLOSE(rtpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_CANTCREATESOCKET;
+	}
+	
+	// set socket buffer sizes
+	
+	size = RTPUDPV6TRANS_RTPRECEIVEBUFFER;
+	if (setsockopt(rtpsock,SOL_SOCKET,SO_RCVBUF,(const char *)&amp;size,sizeof(int)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_CANTSETRTPRECEIVEBUF;
+	}
+	size = RTPUDPV6TRANS_RTPTRANSMITBUFFER;
+	if (setsockopt(rtpsock,SOL_SOCKET,SO_SNDBUF,(const char *)&amp;size,sizeof(int)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_CANTSETRTPTRANSMITBUF;
+	}
+	size = RTPUDPV6TRANS_RTCPRECEIVEBUFFER;
+	if (setsockopt(rtcpsock,SOL_SOCKET,SO_RCVBUF,(const char *)&amp;size,sizeof(int)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_CANTSETRTCPRECEIVEBUF;
+	}
+	size = RTPUDPV6TRANS_RTCPTRANSMITBUFFER;
+	if (setsockopt(rtcpsock,SOL_SOCKET,SO_SNDBUF,(const char *)&amp;size,sizeof(int)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_CANTSETRTCPTRANSMITBUF;
+	}
+	
+	// bind sockets
+
+	bindIP = params-&gt;GetBindIP();
+	
+	memset(&amp;addr,0,sizeof(struct sockaddr_in6));
+	addr.sin6_family = AF_INET6;
+	addr.sin6_port = htons(params-&gt;GetPortbase());
+	addr.sin6_addr = bindIP;
+	if (bind(rtpsock,(struct sockaddr *)&amp;addr,sizeof(struct sockaddr_in6)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_CANTBINDRTPSOCKET;
+	}
+	memset(&amp;addr,0,sizeof(struct sockaddr_in6));
+	addr.sin6_family = AF_INET6;
+	addr.sin6_port = htons(params-&gt;GetPortbase()+1);
+	addr.sin6_addr = bindIP;
+	if (bind(rtcpsock,(struct sockaddr *)&amp;addr,sizeof(struct sockaddr_in6)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_CANTBINDRTCPSOCKET;
+	}
+
+	// Try to obtain local IP addresses
+
+	localIPs = params-&gt;GetLocalIPList();
+	if (localIPs.empty()) // User did not provide list of local IP addresses, calculate them
+	{
+		int status;
+		
+		if ((status = CreateLocalIPList()) &lt; 0)
+		{
+			RTPCLOSE(rtpsock);
+			RTPCLOSE(rtcpsock);
+			MAINMUTEX_UNLOCK
+			return status;
+		}
+
+#ifdef RTPDEBUG
+		std::cout &lt;&lt; &quot;Found these local IP addresses:&quot; &lt;&lt; std::endl;
+		
+		std::list&lt;in6_addr&gt;::const_iterator it;
+
+		for (it = localIPs.begin() ; it != localIPs.end() ; it++)
+		{
+			RTPIPv6Address a(*it);
+
+			std::cout &lt;&lt; a.GetAddressString() &lt;&lt; std::endl;
+		}
+#endif // RTPDEBUG
+	}
+
+#ifdef RTP_SUPPORT_IPV6MULTICAST
+	if (SetMulticastTTL(params-&gt;GetMulticastTTL()))
+		supportsmulticasting = true;
+	else
+		supportsmulticasting = false;
+#else // no multicast support enabled
+	supportsmulticasting = false;
+#endif // RTP_SUPPORT_IPV6MULTICAST
+
+	if ((status = CreateAbortDescriptors()) &lt; 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return status;
+	}
+	
+	if (maximumpacketsize &gt; RTPUDPV6TRANS_MAXPACKSIZE)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		DestroyAbortDescriptors();
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_SPECIFIEDSIZETOOBIG;
+	}
+	
+	maxpacksize = maximumpacketsize;
+	portbase = params-&gt;GetPortbase();
+	multicastTTL = params-&gt;GetMulticastTTL();
+	receivemode = RTPTransmitter::AcceptAll;
+
+	localhostname = 0;
+	localhostnamelength = 0;
+
+	rtppackcount = 0;
+	rtcppackcount = 0;
+	
+	waitingfordata = false;
+	created = true;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+void RTPUDPv6Transmitter::Destroy()
+{
+	if (!init)
+		return;
+
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK;
+		return;
+	}
+
+	if (localhostname)
+	{
+		delete [] localhostname;
+		localhostname = 0;
+		localhostnamelength = 0;
+	}
+	
+	RTPCLOSE(rtpsock);
+	RTPCLOSE(rtcpsock);
+	destinations.Clear();
+#ifdef RTP_SUPPORT_IPV6MULTICAST
+	multicastgroups.Clear();
+#endif // RTP_SUPPORT_IPV6MULTICAST
+	FlushPackets();
+	ClearAcceptIgnoreInfo();
+	localIPs.clear();
+	created = false;
+	
+	if (waitingfordata)
+	{
+		AbortWaitInternal();
+		DestroyAbortDescriptors();
+		MAINMUTEX_UNLOCK
+		WAITMUTEX_LOCK // to make sure that the WaitForIncomingData function ended
+		WAITMUTEX_UNLOCK
+	}
+	else
+		DestroyAbortDescriptors();
+
+	MAINMUTEX_UNLOCK
+}
+
+RTPTransmissionInfo *RTPUDPv6Transmitter::GetTransmissionInfo()
+{
+	if (!init)
+		return 0;
+
+	MAINMUTEX_LOCK
+	RTPTransmissionInfo *tinf = new RTPUDPv6TransmissionInfo(localIPs,rtpsock,rtcpsock);
+	MAINMUTEX_UNLOCK
+	return tinf;
+}
+
+int RTPUDPv6Transmitter::GetLocalHostName(u_int8_t *buffer,size_t *bufferlength)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+
+	if (localhostname == 0)
+	{
+		if (localIPs.empty())
+		{
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_UDPV6TRANS_NOLOCALIPS;
+		}
+		
+		std::list&lt;in6_addr&gt;::const_iterator it;
+		std::list&lt;std::string&gt; hostnames;
+	
+		for (it = localIPs.begin() ; it != localIPs.end() ; it++)
+		{
+			struct hostent *he;
+			in6_addr ip = (*it);	
+			
+			he = gethostbyaddr((char *)&amp;ip,sizeof(in6_addr),AF_INET6);
+			if (he != 0)
+			{
+				std::string hname = std::string(he-&gt;h_name);
+				hostnames.push_back(hname);
+			}
+		}
+	
+		bool found  = false;
+		
+		if (!hostnames.empty())	// try to select the most appropriate hostname
+		{
+			std::list&lt;std::string&gt;::const_iterator it;
+			
+			for (it = hostnames.begin() ; !found &amp;&amp; it != hostnames.end() ; it++)
+			{
+				if ((*it).find('.') != std::string::npos)
+				{
+					found = true;
+					localhostnamelength = (*it).length();
+					localhostname = new u_int8_t [localhostnamelength+1];
+					if (localhostname == 0)
+					{
+						MAINMUTEX_UNLOCK
+						return ERR_RTP_OUTOFMEM;
+					}
+					memcpy(localhostname,(*it).c_str(),localhostnamelength);
+					localhostname[localhostnamelength] = 0;
+				}
+			}
+		}
+	
+		if (!found) // use an IP address
+		{
+			in6_addr ip;
+			int len;
+			char str[256];
+			u_int16_t ip16[8];
+			int i,j;
+				
+			it = localIPs.begin();
+			ip = (*it);
+			
+			for (i = 0,j = 0 ; j &lt; 8 ; j++,i += 2)
+			{
+				ip16[j] = (((u_int16_t)ip.s6_addr[i])&lt;&lt;8);
+				ip16[j] |= ((u_int16_t)ip.s6_addr[i+1]);
+			}			
+			
+			sprintf(str,&quot;%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X&quot;,(int)ip16[0],(int)ip16[1],(int)ip16[2],(int)ip16[3],(int)ip16[4],(int)ip16[5],(int)ip16[6],(int)ip16[7]);
+			len = strlen(str);
+	
+			localhostnamelength = len;
+			localhostname = new u_int8_t [localhostnamelength+1];
+			if (localhostname == 0)
+			{
+				MAINMUTEX_UNLOCK
+				return ERR_RTP_OUTOFMEM;
+			}
+			memcpy(localhostname,str,localhostnamelength);
+			localhostname[localhostnamelength] = 0;
+		}
+	}
+	
+	if ((*bufferlength) &lt; localhostnamelength)
+	{
+		*bufferlength = localhostnamelength; // tell the application the required size of the buffer
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_TRANS_BUFFERLENGTHTOOSMALL;
+	}
+
+	memcpy(buffer,localhostname,localhostnamelength);
+	*bufferlength = localhostnamelength;
+	
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+bool RTPUDPv6Transmitter::ComesFromThisTransmitter(const RTPAddress *addr)
+{
+	if (!init)
+		return false;
+
+	if (addr == 0)
+		return false;
+	
+	MAINMUTEX_LOCK
+	
+	bool v;
+		
+	if (created &amp;&amp; addr-&gt;GetAddressType() == RTPAddress::IPv6Address)
+	{	
+		const RTPIPv6Address *addr2 = (const RTPIPv6Address *)addr;
+		bool found = false;
+		std::list&lt;in6_addr&gt;::const_iterator it;
+	
+		it = localIPs.begin();
+		while (!found &amp;&amp; it != localIPs.end())
+		{
+			in6_addr itip = *it;
+			in6_addr addrip = addr2-&gt;GetIP();
+			if (memcmp(&amp;addrip,&amp;itip,sizeof(in6_addr)) == 0)
+				found = true;
+			else
+				++it;
+		}
+	
+		if (!found)
+			v = false;
+		else
+		{
+			if (addr2-&gt;GetPort() == portbase) // check for RTP port
+				v = true;
+			else if (addr2-&gt;GetPort() == (portbase+1)) // check for RTCP port
+				v = true;
+			else 
+				v = false;
+		}
+	}
+	else
+		v = false;
+
+	MAINMUTEX_UNLOCK
+	return v;
+}
+
+int RTPUDPv6Transmitter::Poll()
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+
+	int status;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	status = PollSocket(true); // poll RTP socket
+	if (status &gt;= 0)
+		status = PollSocket(false); // poll RTCP socket
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPUDPv6Transmitter::WaitForIncomingData(const RTPTime &amp;delay,bool *dataavailable)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	fd_set fdset;
+	struct timeval tv;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (waitingfordata)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_ALREADYWAITING;
+	}
+	
+	FD_ZERO(&amp;fdset);
+	FD_SET(rtpsock,&amp;fdset);
+	FD_SET(rtcpsock,&amp;fdset);
+	FD_SET(abortdesc[0],&amp;fdset);
+	tv.tv_sec = delay.GetSeconds();
+	tv.tv_usec = delay.GetMicroSeconds();
+	
+	waitingfordata = true;
+	
+	WAITMUTEX_LOCK
+	MAINMUTEX_UNLOCK
+
+	if (select(FD_SETSIZE,&amp;fdset,0,0,&amp;tv) &lt; 0)
+	{
+		MAINMUTEX_LOCK
+		waitingfordata = false;
+		MAINMUTEX_UNLOCK
+		WAITMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_ERRORINSELECT;
+	}
+	
+	MAINMUTEX_LOCK
+	waitingfordata = false;
+	if (!created) // destroy called
+	{
+		MAINMUTEX_UNLOCK;
+		WAITMUTEX_UNLOCK
+		return 0;
+	}
+		
+	// if aborted, read from abort buffer
+	if (FD_ISSET(abortdesc[0],&amp;fdset))
+	{
+#if (defined(WIN32) || defined(_WIN32_WCE))
+		char buf[1];
+		
+		recv(abortdesc[0],buf,1,0);
+#else 
+		unsigned char buf[1];
+
+		read(abortdesc[0],buf,1);
+#endif // WIN32
+	}
+	
+	if (dataavailable != 0)
+	{
+		if (FD_ISSET(rtpsock,&amp;fdset) || FD_ISSET(rtcpsock,&amp;fdset))
+			*dataavailable = true;
+		else
+			*dataavailable = false;
+	}	
+
+	MAINMUTEX_UNLOCK
+	WAITMUTEX_UNLOCK
+	return 0;
+}
+
+int RTPUDPv6Transmitter::AbortWait()
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (!waitingfordata)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTWAITING;
+	}
+
+	AbortWaitInternal();
+	
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+int RTPUDPv6Transmitter::SendRTPData(const void *data,size_t len)	
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	struct sockaddr_in6 saddr;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (len &gt; maxpacksize)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_SPECIFIEDSIZETOOBIG;
+	}
+	
+	memset(&amp;saddr,0,sizeof(struct sockaddr_in6));
+	saddr.sin6_family = AF_INET6;
+	destinations.GotoFirstElement();
+	while (destinations.HasCurrentElement())
+	{
+		saddr.sin6_port = destinations.GetCurrentElement().GetRTPPort_NBO();
+		saddr.sin6_addr = destinations.GetCurrentElement().GetIP();
+		sendto(rtpsock,(const char *)data,len,0,(struct sockaddr *)&amp;saddr,sizeof(struct sockaddr_in6));
+		destinations.GotoNextElement();
+	}
+	
+	rtppackcount++;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+int RTPUDPv6Transmitter::SendRTCPData(const void *data,size_t len)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	struct sockaddr_in6 saddr;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (len &gt; maxpacksize)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_SPECIFIEDSIZETOOBIG;
+	}
+	
+	memset(&amp;saddr,0,sizeof(struct sockaddr_in6));
+	saddr.sin6_family = AF_INET6;
+	destinations.GotoFirstElement();
+	while (destinations.HasCurrentElement())
+	{
+		saddr.sin6_port = destinations.GetCurrentElement().GetRTCPPort_NBO();
+		saddr.sin6_addr = destinations.GetCurrentElement().GetIP();
+		sendto(rtcpsock,(const char *)data,len,0,(struct sockaddr *)&amp;saddr,sizeof(struct sockaddr_in6));
+		destinations.GotoNextElement();
+	}
+	
+	rtcppackcount++;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+void RTPUDPv6Transmitter::ResetPacketCount()
+{
+	if (!init)
+		return;
+
+	MAINMUTEX_LOCK
+	if (created)
+	{
+		rtppackcount = 0;
+		rtcppackcount = 0;	
+	}
+	MAINMUTEX_UNLOCK	
+}
+
+u_int32_t RTPUDPv6Transmitter::GetNumRTPPacketsSent()
+{
+	if (!init)
+		return 0;
+
+	MAINMUTEX_LOCK
+	
+	u_int32_t num;
+
+	if (!created)
+		num = 0;
+	else
+		num = rtppackcount;
+
+	MAINMUTEX_UNLOCK
+
+	return num;
+}
+
+u_int32_t RTPUDPv6Transmitter::GetNumRTCPPacketsSent()
+{
+	if (!init)
+		return 0;
+	
+	MAINMUTEX_LOCK
+	
+	u_int32_t num;
+
+	if (!created)
+		num = 0;
+	else
+		num = rtcppackcount;
+
+	MAINMUTEX_UNLOCK
+
+	return num;
+}
+
+int RTPUDPv6Transmitter::AddDestination(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv6Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	RTPIPv6Address &amp;address = (RTPIPv6Address &amp;)addr;
+	RTPIPv6Destination dest(address.GetIP(),address.GetPort());
+	int status = destinations.AddElement(dest);
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPUDPv6Transmitter::DeleteDestination(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv6Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	RTPIPv6Address &amp;address = (RTPIPv6Address &amp;)addr;	
+	RTPIPv6Destination dest(address.GetIP(),address.GetPort());
+	int status = destinations.DeleteElement(dest);
+	
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPUDPv6Transmitter::ClearDestinations()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created)
+		destinations.Clear();
+	MAINMUTEX_UNLOCK
+}
+
+bool RTPUDPv6Transmitter::SupportsMulticasting()
+{
+	if (!init)
+		return false;
+	
+	MAINMUTEX_LOCK
+	
+	bool v;
+		
+	if (!created)
+		v = false;
+	else
+		v = supportsmulticasting;
+
+	MAINMUTEX_UNLOCK
+	return v;
+}
+
+#ifdef RTP_SUPPORT_IPV6MULTICAST
+
+int RTPUDPv6Transmitter::JoinMulticastGroup(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv6Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	const RTPIPv6Address &amp;address = (const RTPIPv6Address &amp;)addr;
+	in6_addr mcastIP = address.GetIP();
+	
+	if (!RTPUDPV6TRANS_IS_MCASTADDR(mcastIP))
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTAMULTICASTADDRESS;
+	}
+	
+	status = multicastgroups.AddElement(mcastIP);
+	if (status &gt;= 0)
+	{
+		RTPUDPV6TRANS_MCASTMEMBERSHIP(rtpsock,IPV6_JOIN_GROUP,mcastIP,status);
+		if (status != 0)
+		{
+			multicastgroups.DeleteElement(mcastIP);
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_UDPV6TRANS_COULDNTJOINMULTICASTGROUP;
+		}
+		RTPUDPV6TRANS_MCASTMEMBERSHIP(rtcpsock,IPV6_JOIN_GROUP,mcastIP,status);
+		if (status != 0)
+		{
+			RTPUDPV6TRANS_MCASTMEMBERSHIP(rtpsock,IPV6_LEAVE_GROUP,mcastIP,status);
+			multicastgroups.DeleteElement(mcastIP);
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_UDPV6TRANS_COULDNTJOINMULTICASTGROUP;
+		}
+	}
+	MAINMUTEX_UNLOCK	
+	return status;
+}
+
+int RTPUDPv6Transmitter::LeaveMulticastGroup(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv6Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	const RTPIPv6Address &amp;address = (const RTPIPv6Address &amp;)addr;
+	in6_addr mcastIP = address.GetIP();
+	
+	if (!RTPUDPV6TRANS_IS_MCASTADDR(mcastIP))
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTAMULTICASTADDRESS;
+	}
+	
+	status = multicastgroups.DeleteElement(mcastIP);
+	if (status &gt;= 0)
+	{	
+		RTPUDPV6TRANS_MCASTMEMBERSHIP(rtpsock,IPV6_LEAVE_GROUP,mcastIP,status);
+		RTPUDPV6TRANS_MCASTMEMBERSHIP(rtcpsock,IPV6_LEAVE_GROUP,mcastIP,status);
+		status = 0;
+	}
+	
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPUDPv6Transmitter::LeaveAllMulticastGroups()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created)
+	{
+		multicastgroups.GotoFirstElement();
+		while (multicastgroups.HasCurrentElement())
+		{
+			in6_addr mcastIP;
+			int status = 0;
+
+			mcastIP = multicastgroups.GetCurrentElement();
+			RTPUDPV6TRANS_MCASTMEMBERSHIP(rtpsock,IPV6_LEAVE_GROUP,mcastIP,status);
+			RTPUDPV6TRANS_MCASTMEMBERSHIP(rtcpsock,IPV6_LEAVE_GROUP,mcastIP,status);
+			multicastgroups.GotoNextElement();
+		}
+		multicastgroups.Clear();
+	}
+	MAINMUTEX_UNLOCK
+}
+
+#else // no multicast support
+
+int RTPUDPv6Transmitter::JoinMulticastGroup(const RTPAddress &amp;addr)
+{
+	return ERR_RTP_UDPV6TRANS_NOMULTICASTSUPPORT;
+}
+
+int RTPUDPv6Transmitter::LeaveMulticastGroup(const RTPAddress &amp;addr)
+{
+	return ERR_RTP_UDPV6TRANS_NOMULTICASTSUPPORT;
+}
+
+void RTPUDPv6Transmitter::LeaveAllMulticastGroups()
+{
+}
+
+#endif // RTP_SUPPORT_IPV6MULTICAST
+
+int RTPUDPv6Transmitter::SetReceiveMode(RTPTransmitter::ReceiveMode m)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (m != receivemode)
+	{
+		receivemode = m;
+		acceptignoreinfo.Clear();
+	}
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+int RTPUDPv6Transmitter::AddToIgnoreList(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	int status;
+
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv6Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::IgnoreSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv6Address &amp;address = (const RTPIPv6Address &amp;)addr;
+	status = ProcessAddAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+	
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPUDPv6Transmitter::DeleteFromIgnoreList(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv6Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::IgnoreSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv6Address &amp;address = (const RTPIPv6Address &amp;)addr;	
+	status = ProcessDeleteAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPUDPv6Transmitter::ClearIgnoreList()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created &amp;&amp; receivemode == RTPTransmitter::IgnoreSome)
+		ClearAcceptIgnoreInfo();
+	MAINMUTEX_UNLOCK
+}
+
+int RTPUDPv6Transmitter::AddToAcceptList(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv6Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::AcceptSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv6Address &amp;address = (const RTPIPv6Address &amp;)addr;
+	status = ProcessAddAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPUDPv6Transmitter::DeleteFromAcceptList(const RTPAddress &amp;addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv6Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::AcceptSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv6Address &amp;address = (const RTPIPv6Address &amp;)addr;
+	status = ProcessDeleteAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPUDPv6Transmitter::ClearAcceptList()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created &amp;&amp; receivemode == RTPTransmitter::AcceptSome)
+		ClearAcceptIgnoreInfo();
+	MAINMUTEX_UNLOCK
+}
+
+int RTPUDPv6Transmitter::SetMaximumPacketSize(size_t s)	
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (s &gt; RTPUDPV6TRANS_MAXPACKSIZE)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_SPECIFIEDSIZETOOBIG;
+	}
+	maxpacksize = s;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+bool RTPUDPv6Transmitter::NewDataAvailable()
+{
+	if (!init)
+		return false;
+	
+	MAINMUTEX_LOCK
+	
+	bool v;
+		
+	if (!created)
+		v = false;
+	else
+	{
+		if (rawpacketlist.empty())
+			v = false;
+		else
+			v = true;
+	}
+	
+	MAINMUTEX_UNLOCK
+	return v;
+}
+
+RTPRawPacket *RTPUDPv6Transmitter::GetNextPacket()
+{
+	if (!init)
+		return 0;
+	
+	MAINMUTEX_LOCK
+	
+	RTPRawPacket *p;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return 0;
+	}
+	if (rawpacketlist.empty())
+	{
+		MAINMUTEX_UNLOCK
+		return 0;
+	}
+
+	p = *(rawpacketlist.begin());
+	rawpacketlist.pop_front();
+
+	MAINMUTEX_UNLOCK
+	return p;
+}
+
+// Here the private functions start...
+
+
+#ifdef RTP_SUPPORT_IPV6MULTICAST
+bool RTPUDPv6Transmitter::SetMulticastTTL(u_int8_t ttl)
+{
+	int ttl2,status;
+
+	ttl2 = (int)ttl;
+	status = setsockopt(rtpsock,IPPROTO_IPV6,IPV6_MULTICAST_HOPS,(const char *)&amp;ttl2,sizeof(int));
+	if (status != 0)
+		return false;
+	status = setsockopt(rtcpsock,IPPROTO_IPV6,IPV6_MULTICAST_HOPS,(const char *)&amp;ttl2,sizeof(int));
+	if (status != 0)
+		return false;
+	return true;
+}
+#endif // RTP_SUPPORT_IPV6MULTICAST
+
+
+void RTPUDPv6Transmitter::FlushPackets()
+{
+	std::list&lt;RTPRawPacket*&gt;::const_iterator it;
+
+	for (it = rawpacketlist.begin() ; it != rawpacketlist.end() ; ++it)
+		delete (*it);
+	rawpacketlist.clear();
+}
+
+int RTPUDPv6Transmitter::PollSocket(bool rtp)
+{
+	RTPSOCKLENTYPE fromlen;
+	int recvlen;
+	char packetbuffer[RTPUDPV6TRANS_MAXPACKSIZE];
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	SOCKET sock;
+	unsigned long len;
+#else 
+	size_t len;
+	int sock;
+#endif // WIN32
+	struct sockaddr_in6 srcaddr;
+	
+	if (rtp)
+		sock = rtpsock;
+	else
+		sock = rtcpsock;
+	
+	len = 0;
+	RTPIOCTL(sock,FIONREAD,&amp;len);
+	if (len &lt;= 0)
+		return 0;
+
+	while (len &gt; 0)
+	{
+		RTPTime curtime = RTPTime::CurrentTime();
+		fromlen = sizeof(struct sockaddr_in6);
+		recvlen = recvfrom(sock,packetbuffer,(int)len,0,(struct sockaddr *)&amp;srcaddr,&amp;fromlen);
+		if (recvlen &gt; 0)
+		{
+			bool acceptdata;
+
+			// got data, process it
+			if (receivemode == RTPTransmitter::AcceptAll)
+				acceptdata = true;
+			else
+				acceptdata = ShouldAcceptData(srcaddr.sin6_addr,htons(srcaddr.sin6_port));
+			
+			if (acceptdata)
+			{
+				RTPRawPacket *pack;
+				RTPIPv6Address *addr;
+				u_int8_t *datacopy;
+
+				addr = new RTPIPv6Address(srcaddr.sin6_addr,ntohs(srcaddr.sin6_port));
+				if (addr == 0)
+					return ERR_RTP_OUTOFMEM;
+				datacopy = new u_int8_t[recvlen];
+				if (datacopy == 0)
+				{
+					delete addr;
+					return ERR_RTP_OUTOFMEM;
+				}
+				memcpy(datacopy,packetbuffer,recvlen);
+				pack = new RTPRawPacket(datacopy,recvlen,addr,curtime,rtp);
+				if (pack == 0)
+				{
+					delete addr;
+					delete [] datacopy;
+					return ERR_RTP_OUTOFMEM;
+				}
+				rawpacketlist.push_back(pack);	
+			}
+		}
+		len = 0;
+		RTPIOCTL(sock,FIONREAD,&amp;len);
+	}
+	return 0;
+}
+
+int RTPUDPv6Transmitter::ProcessAddAcceptIgnoreEntry(in6_addr ip,u_int16_t port)
+{
+	acceptignoreinfo.GotoElement(ip);
+	if (acceptignoreinfo.HasCurrentElement()) // An entry for this IP address already exists
+	{
+		PortInfo *portinf = acceptignoreinfo.GetCurrentElement();
+		
+		if (port == 0) // select all ports
+		{
+			portinf-&gt;all = true;
+			portinf-&gt;portlist.clear();
+		}
+		else if (!portinf-&gt;all)
+		{
+			std::list&lt;u_int16_t&gt;::const_iterator it,begin,end;
+
+			begin = portinf-&gt;portlist.begin();
+			end = portinf-&gt;portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == port) // already in list
+					return 0;
+			}
+			portinf-&gt;portlist.push_front(port);
+		}
+	}
+	else // got to create an entry for this IP address
+	{
+		PortInfo *portinf;
+		int status;
+		
+		portinf = new PortInfo();
+		if (port == 0) // select all ports
+			portinf-&gt;all = true;
+		else
+			portinf-&gt;portlist.push_front(port);
+		
+		status = acceptignoreinfo.AddElement(ip,portinf);
+		if (status &lt; 0)
+		{
+			delete portinf;
+			return status;
+		}
+	}
+	return 0;
+}
+
+void RTPUDPv6Transmitter::ClearAcceptIgnoreInfo()
+{
+	acceptignoreinfo.GotoFirstElement();
+	while (acceptignoreinfo.HasCurrentElement())
+	{
+		PortInfo *inf;
+
+		inf = acceptignoreinfo.GetCurrentElement();
+		delete inf;
+		acceptignoreinfo.GotoNextElement();
+	}
+	acceptignoreinfo.Clear();
+}
+	
+int RTPUDPv6Transmitter::ProcessDeleteAcceptIgnoreEntry(in6_addr ip,u_int16_t port)
+{
+	acceptignoreinfo.GotoElement(ip);
+	if (!acceptignoreinfo.HasCurrentElement())
+		return ERR_RTP_UDPV6TRANS_NOSUCHENTRY;
+	
+	PortInfo *inf;
+
+	inf = acceptignoreinfo.GetCurrentElement();
+	if (port == 0) // delete all entries
+	{
+		inf-&gt;all = false;
+		inf-&gt;portlist.clear();
+	}
+	else // a specific port was selected
+	{
+		if (inf-&gt;all) // currently, all ports are selected. Add the one to remove to the list
+		{
+			// we have to check if the list doesn't contain the port already
+			std::list&lt;u_int16_t&gt;::const_iterator it,begin,end;
+
+			begin = inf-&gt;portlist.begin();
+			end = inf-&gt;portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == port) // already in list: this means we already deleted the entry
+					return ERR_RTP_UDPV6TRANS_NOSUCHENTRY;
+			}
+			inf-&gt;portlist.push_front(port);
+		}
+		else // check if we can find the port in the list
+		{
+			std::list&lt;u_int16_t&gt;::iterator it,begin,end;
+			
+			begin = inf-&gt;portlist.begin();
+			end = inf-&gt;portlist.end();
+			for (it = begin ; it != end ; ++it)
+			{
+				if (*it == port) // found it!
+				{
+					inf-&gt;portlist.erase(it);
+					return 0;
+				}
+			}
+			// didn't find it
+			return ERR_RTP_UDPV6TRANS_NOSUCHENTRY;			
+		}
+	}
+	return 0;
+}
+
+bool RTPUDPv6Transmitter::ShouldAcceptData(in6_addr srcip,u_int16_t srcport)
+{
+	if (receivemode == RTPTransmitter::AcceptSome)
+	{
+		PortInfo *inf;
+
+		acceptignoreinfo.GotoElement(srcip);
+		if (!acceptignoreinfo.HasCurrentElement())
+			return false;
+		
+		inf = acceptignoreinfo.GetCurrentElement();
+		if (!inf-&gt;all) // only accept the ones in the list
+		{
+			std::list&lt;u_int16_t&gt;::const_iterator it,begin,end;
+
+			begin = inf-&gt;portlist.begin();
+			end = inf-&gt;portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return true;
+			}
+			return false;
+		}
+		else // accept all, except the ones in the list
+		{
+			std::list&lt;u_int16_t&gt;::const_iterator it,begin,end;
+
+			begin = inf-&gt;portlist.begin();
+			end = inf-&gt;portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return false;
+			}
+			return true;
+		}
+	}
+	else // IgnoreSome
+	{
+		PortInfo *inf;
+
+		acceptignoreinfo.GotoElement(srcip);
+		if (!acceptignoreinfo.HasCurrentElement())
+			return true;
+		
+		inf = acceptignoreinfo.GetCurrentElement();
+		if (!inf-&gt;all) // ignore the ports in the list
+		{
+			std::list&lt;u_int16_t&gt;::const_iterator it,begin,end;
+
+			begin = inf-&gt;portlist.begin();
+			end = inf-&gt;portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return false;
+			}
+			return true;
+		}
+		else // ignore all, except the ones in the list
+		{
+			std::list&lt;u_int16_t&gt;::const_iterator it,begin,end;
+
+			begin = inf-&gt;portlist.begin();
+			end = inf-&gt;portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return true;
+			}
+			return false;
+		}
+	}
+	return true;
+}
+
+#if (defined(WIN32) || defined(_WIN32_WCE))
+
+int RTPUDPv6Transmitter::CreateAbortDescriptors()
+{
+	SOCKET listensock;
+	int size;
+	struct sockaddr_in6 addr;
+
+	listensock = socket(PF_INET6,SOCK_STREAM,0);
+	if (listensock == RTPSOCKERR)
+		return ERR_RTP_UDPV6TRANS_CANTCREATEABORTDESCRIPTORS;
+	
+	memset(&amp;addr,0,sizeof(struct sockaddr_in6));
+	addr.sin6_family = AF_INET6;
+	if (bind(listensock,(struct sockaddr *)&amp;addr,sizeof(struct sockaddr_in6)) != 0)
+	{
+		RTPCLOSE(listensock);
+		return ERR_RTP_UDPV6TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&amp;addr,0,sizeof(struct sockaddr_in6));
+	size = sizeof(struct sockaddr_in6);
+	if (getsockname(listensock,(struct sockaddr*)&amp;addr,&amp;size) != 0)
+	{
+		RTPCLOSE(listensock);
+		return ERR_RTP_UDPV6TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	unsigned short connectport = ntohs(addr.sin6_port);
+
+	abortdesc[0] = socket(PF_INET6,SOCK_STREAM,0);
+	if (abortdesc[0] == RTPSOCKERR)
+	{
+		RTPCLOSE(listensock);
+		return ERR_RTP_UDPV6TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&amp;addr,0,sizeof(struct sockaddr_in6));
+	addr.sin6_family = AF_INET6;
+	if (bind(abortdesc[0],(struct sockaddr *)&amp;addr,sizeof(struct sockaddr_in6)) != 0)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_UDPV6TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	if (listen(listensock,1) != 0)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_UDPV6TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&amp;addr,0,sizeof(struct sockaddr_in6));
+	addr.sin6_family = AF_INET6;
+	addr.sin6_addr = in6addr_loopback;
+	addr.sin6_port = htons(connectport);
+	
+	if (connect(abortdesc[0],(struct sockaddr *)&amp;addr,sizeof(struct sockaddr_in6)) != 0)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_UDPV6TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&amp;addr,0,sizeof(struct sockaddr_in6));
+	size = sizeof(struct sockaddr_in6);
+	abortdesc[1] = accept(listensock,(struct sockaddr *)&amp;addr,&amp;size);
+	if (abortdesc[1] == RTPSOCKERR)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_UDPV6TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	// okay, got the connection, close the listening socket
+
+	RTPCLOSE(listensock);
+	return 0;
+}
+
+void RTPUDPv6Transmitter::DestroyAbortDescriptors()
+{
+	RTPCLOSE(abortdesc[0]);
+	RTPCLOSE(abortdesc[1]);
+}
+
+#else // in a non winsock environment we can use pipes
+
+int RTPUDPv6Transmitter::CreateAbortDescriptors()
+{
+	if (pipe(abortdesc) &lt; 0)
+		return ERR_RTP_UDPV6TRANS_CANTCREATEPIPE;
+	return 0;
+}
+
+void RTPUDPv6Transmitter::DestroyAbortDescriptors()
+{
+	close(abortdesc[0]);
+	close(abortdesc[1]);
+}
+
+#endif // WIN32
+
+int RTPUDPv6Transmitter::CreateLocalIPList()
+{
+	 // first try to obtain the list from the network interface info
+
+	if (!GetLocalIPList_Interfaces())
+	{
+		// If this fails, we'll have to depend on DNS info
+		GetLocalIPList_DNS();
+	}
+	AddLoopbackAddress();
+	return 0;
+}
+
+#if (defined(WIN32) || defined(_WIN32_WCE))
+
+bool RTPUDPv6Transmitter::GetLocalIPList_Interfaces()
+{
+	unsigned char buffer[RTPUDPV6TRANS_IFREQBUFSIZE];
+	DWORD outputsize;
+	DWORD numaddresses,i;
+	SOCKET_ADDRESS_LIST *addrlist;
+
+	if (WSAIoctl(rtpsock,SIO_ADDRESS_LIST_QUERY,NULL,0,&amp;buffer,RTPUDPV6TRANS_IFREQBUFSIZE,&amp;outputsize,NULL,NULL))
+		return false;
+	
+	addrlist = (SOCKET_ADDRESS_LIST *)buffer;
+	numaddresses = addrlist-&gt;iAddressCount;
+	for (i = 0 ; i &lt; numaddresses ; i++)
+	{
+		SOCKET_ADDRESS *sockaddr = &amp;(addrlist-&gt;Address[i]);
+		if (sockaddr-&gt;iSockaddrLength == sizeof(struct sockaddr_in6)) // IPv6 address
+		{
+			struct sockaddr_in6 *addr = (struct sockaddr_in6 *)sockaddr-&gt;lpSockaddr;
+
+			localIPs.push_back(addr-&gt;sin6_addr);
+		}
+	}
+
+	if (localIPs.empty())
+		return false;
+	return true;
+}
+
+#else
+
+#ifdef RTP_SUPPORT_IFADDRS
+
+bool RTPUDPv6Transmitter::GetLocalIPList_Interfaces()
+{
+	struct ifaddrs *addrs,*tmp;
+	
+	getifaddrs(&amp;addrs);
+	tmp = addrs;
+	
+	while (tmp != 0)
+	{
+		if (tmp-&gt;ifa_addr-&gt;sa_family == AF_INET6)
+		{
+			struct sockaddr_in6 *inaddr = (struct sockaddr_in6 *)tmp-&gt;ifa_addr;
+			localIPs.push_back(inaddr-&gt;sin6_addr);
+		}
+		tmp = tmp-&gt;ifa_next;
+	}
+	
+	freeifaddrs(addrs);
+	
+	if (localIPs.empty())
+		return false;
+	return true;
+}
+
+#else
+
+bool RTPUDPv6Transmitter::GetLocalIPList_Interfaces()
+{
+	return false;
+}
+
+#endif // RTP_SUPPORT_IFADDRS
+
+#endif // WIN32
+
+void RTPUDPv6Transmitter::GetLocalIPList_DNS()
+{
+	int status;
+	char name[1024];
+
+	gethostname(name,1023);
+	name[1023] = 0;
+
+	struct addrinfo hints;
+	struct addrinfo *res,*tmp;
+	
+	memset(&amp;hints,0,sizeof(struct addrinfo));
+	hints.ai_family = AF_INET6;
+	hints.ai_socktype = 0;
+	hints.ai_protocol = 0;
+
+	if ((status = getaddrinfo(name,0,&amp;hints,&amp;res)) != 0)
+		return;
+
+	tmp = res;
+	while (tmp != 0)
+	{
+		if (tmp-&gt;ai_family == AF_INET6)
+		{
+			struct sockaddr_in6 *addr = (struct sockaddr_in6 *)(tmp-&gt;ai_addr);
+			localIPs.push_back(addr-&gt;sin6_addr);
+		}
+		tmp = tmp-&gt;ai_next;
+	}
+	
+	freeaddrinfo(res);	
+}
+
+
+void RTPUDPv6Transmitter::AbortWaitInternal()
+{
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	send(abortdesc[1],&quot;*&quot;,1,0);
+#else
+	write(abortdesc[1],&quot;*&quot;,1);
+#endif // WIN32
+}
+
+
+void RTPUDPv6Transmitter::AddLoopbackAddress()
+{
+	std::list&lt;in6_addr&gt;::const_iterator it;
+	bool found = false;
+
+	for (it = localIPs.begin() ; !found &amp;&amp; it != localIPs.end() ; it++)
+	{
+		if ((*it) == in6addr_loopback)
+			found = true;
+	}
+
+	if (!found)
+		localIPs.push_back(in6addr_loopback);
+}
+
+#ifdef RTPDEBUG
+void RTPUDPv6Transmitter::Dump()
+{
+	if (!init)
+		std::cout &lt;&lt; &quot;Not initialized&quot; &lt;&lt; std::endl;
+	else
+	{
+		MAINMUTEX_LOCK
+	
+		if (!created)
+			std::cout &lt;&lt; &quot;Not created&quot; &lt;&lt; std::endl;
+		else
+		{
+			char str[1024];
+			in6_addr ip;
+			u_int16_t ip16[8];
+			std::list&lt;in6_addr&gt;::const_iterator it;
+			int i,j;
+			
+			std::cout &lt;&lt; &quot;Portbase:                       &quot; &lt;&lt; portbase &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;RTP socket descriptor:          &quot; &lt;&lt; rtpsock &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;RTCP socket descriptor:         &quot; &lt;&lt; rtcpsock &lt;&lt; std::endl;
+			ip = bindIP;
+			for (i = 0,j = 0 ; j &lt; 8 ; j++,i += 2)	{ ip16[j] = (((u_int16_t)ip.s6_addr[i])&lt;&lt;8); ip16[j] |= ((u_int16_t)ip.s6_addr[i+1]); }
+			sprintf(str,&quot;%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X&quot;,(int)ip16[0],(int)ip16[1],(int)ip16[2],(int)ip16[3],(int)ip16[4],(int)ip16[5],(int)ip16[6],(int)ip16[7]);
+			std::cout &lt;&lt; &quot;Bind IP address:                &quot; &lt;&lt; str &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;Local IP addresses:&quot; &lt;&lt; std::endl;
+			for (it = localIPs.begin() ; it != localIPs.end() ; it++)
+			{
+				ip = (*it);
+				for (i = 0,j = 0 ; j &lt; 8 ; j++,i += 2)	{ ip16[j] = (((u_int16_t)ip.s6_addr[i])&lt;&lt;8); ip16[j] |= ((u_int16_t)ip.s6_addr[i+1]); }
+				sprintf(str,&quot;%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X&quot;,(int)ip16[0],(int)ip16[1],(int)ip16[2],(int)ip16[3],(int)ip16[4],(int)ip16[5],(int)ip16[6],(int)ip16[7]);
+				std::cout &lt;&lt; &quot;    &quot; &lt;&lt; str &lt;&lt; std::endl;
+			}
+			std::cout &lt;&lt; &quot;Multicast TTL:                  &quot; &lt;&lt; (int)multicastTTL &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;Receive mode:                   &quot;;
+			switch (receivemode)
+			{
+			case RTPTransmitter::AcceptAll:
+				std::cout &lt;&lt; &quot;Accept all&quot;;
+				break;
+			case RTPTransmitter::AcceptSome:
+				std::cout &lt;&lt; &quot;Accept some&quot;;
+				break;
+			case RTPTransmitter::IgnoreSome:
+				std::cout &lt;&lt; &quot;Ignore some&quot;;
+			}
+			std::cout &lt;&lt; std::endl;
+			if (receivemode != RTPTransmitter::AcceptAll)
+			{
+				acceptignoreinfo.GotoFirstElement();
+				while(acceptignoreinfo.HasCurrentElement())
+				{
+					ip = acceptignoreinfo.GetCurrentKey();
+					for (i = 0,j = 0 ; j &lt; 8 ; j++,i += 2)	{ ip16[j] = (((u_int16_t)ip.s6_addr[i])&lt;&lt;8); ip16[j] |= ((u_int16_t)ip.s6_addr[i+1]); }
+					sprintf(str,&quot;%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X&quot;,(int)ip16[0],(int)ip16[1],(int)ip16[2],(int)ip16[3],(int)ip16[4],(int)ip16[5],(int)ip16[6],(int)ip16[7]);
+					PortInfo *pinfo = acceptignoreinfo.GetCurrentElement();
+					std::cout &lt;&lt; &quot;    &quot; &lt;&lt; str &lt;&lt; &quot;: &quot;;
+					if (pinfo-&gt;all)
+					{
+						std::cout &lt;&lt; &quot;All ports&quot;;
+						if (!pinfo-&gt;portlist.empty())
+							std::cout &lt;&lt; &quot;, except &quot;;
+					}
+					
+					std::list&lt;u_int16_t&gt;::const_iterator it;
+					
+					for (it = pinfo-&gt;portlist.begin() ; it != pinfo-&gt;portlist.end() ; )
+					{
+						std::cout &lt;&lt; (*it);
+						it++;
+						if (it != pinfo-&gt;portlist.end())
+							std::cout &lt;&lt; &quot;, &quot;;
+					}
+					std::cout &lt;&lt; std::endl;
+				}
+			}
+			
+			std::cout &lt;&lt; &quot;Local host name:                &quot;;
+			if (localhostname == 0)
+				std::cout &lt;&lt; &quot;Not set&quot;;
+			else
+				std::cout &lt;&lt; localhostname;
+			std::cout &lt;&lt; std::endl;
+
+			std::cout &lt;&lt; &quot;List of destinations:           &quot;;
+			destinations.GotoFirstElement();
+			if (destinations.HasCurrentElement())
+			{
+				std::cout &lt;&lt; std::endl;
+				do
+				{
+					std::cout &lt;&lt; &quot;    &quot; &lt;&lt; destinations.GetCurrentElement().GetDestinationString() &lt;&lt; std::endl;
+					destinations.GotoNextElement();
+				} while (destinations.HasCurrentElement());
+			}
+			else
+				std::cout &lt;&lt; &quot;Empty&quot; &lt;&lt; std::endl;
+		
+			std::cout &lt;&lt; &quot;Supports multicasting:          &quot; &lt;&lt; ((supportsmulticasting)?&quot;Yes&quot;:&quot;No&quot;) &lt;&lt; std::endl;
+#ifdef RTP_SUPPORT_IPV6MULTICAST
+			std::cout &lt;&lt; &quot;List of multicast groups:       &quot;;
+			multicastgroups.GotoFirstElement();
+			if (multicastgroups.HasCurrentElement())
+			{
+				std::cout &lt;&lt; std::endl;
+				do
+				{
+					ip = multicastgroups.GetCurrentElement();
+					for (i = 0,j = 0 ; j &lt; 8 ; j++,i += 2)	{ ip16[j] = (((u_int16_t)ip.s6_addr[i])&lt;&lt;8); ip16[j] |= ((u_int16_t)ip.s6_addr[i+1]); }
+					sprintf(str,&quot;%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X&quot;,(int)ip16[0],(int)ip16[1],(int)ip16[2],(int)ip16[3],(int)ip16[4],(int)ip16[5],(int)ip16[6],(int)ip16[7]);
+					std::cout &lt;&lt; &quot;    &quot; &lt;&lt; str &lt;&lt; std::endl;
+					multicastgroups.GotoNextElement();
+				} while (multicastgroups.HasCurrentElement());
+			}
+			else
+				std::cout &lt;&lt; &quot;Empty&quot; &lt;&lt; std::endl;
+#endif // RTP_SUPPORT_IPV6MULTICAST
+			
+			std::cout &lt;&lt; &quot;Number of raw packets in queue: &quot; &lt;&lt; rawpacketlist.size() &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;Maximum allowed packet size:    &quot; &lt;&lt; maxpacksize &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;RTP packet count:               &quot; &lt;&lt; rtppackcount &lt;&lt; std::endl;
+			std::cout &lt;&lt; &quot;RTCP packet count:              &quot; &lt;&lt; rtcppackcount &lt;&lt; std::endl;
+		}
+		
+		MAINMUTEX_UNLOCK
+	}
+
+}
+#endif // RTPDEBUG
+
+#endif // RTP_SUPPORT_IPV6
+

Added: konference/src/rtp/jrtplib/rtpudpv6transmitter.h
===================================================================
--- konference/src/rtp/jrtplib/rtpudpv6transmitter.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpudpv6transmitter.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,237 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: <A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">jori at lumumba.uhasselt.be</A>
+
+  This library was developed at the &quot;Expertisecentrum Digitale Media&quot;
+  (<A HREF="http://www.edm.uhasselt.be">http://www.edm.uhasselt.be</A>), a research center of the Hasselt University
+  (<A HREF="http://www.uhasselt.be">http://www.uhasselt.be</A>). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the &quot;Software&quot;),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPUDPV6TRANSMITTER_H
+
+#define RTPUDPV6TRANSMITTER_H
+
+#include &quot;rtpconfig.h&quot;
+
+#ifdef RTP_SUPPORT_IPV6
+
+#include &quot;rtptransmitter.h&quot;
+#include &quot;rtpipv6destination.h&quot;
+#include &quot;rtphashtable.h&quot;
+#include &quot;rtpkeyhashtable.h&quot;
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include &lt;netinet/in.h&gt;
+#endif // WIN32
+#include &lt;string.h&gt;
+#include &lt;list&gt;
+
+#ifdef RTP_SUPPORT_THREAD
+	#include &lt;jmutex.h&gt;
+#endif // RTP_SUPPORT_THREAD
+
+#define RTPUDPV6TRANS_HASHSIZE									8317
+#define RTPUDPV6TRANS_DEFAULTPORTBASE								5000
+
+class RTPUDPv6TransmissionParams : public RTPTransmissionParams
+{
+public:
+	RTPUDPv6TransmissionParams():RTPTransmissionParams(RTPTransmitter::IPv6UDPProto)	{ portbase = RTPUDPV6TRANS_DEFAULTPORTBASE; for (int i = 0 ; i &lt; 16 ; i++) bindIP.s6_addr[i] = 0; multicastTTL = 1; }
+	void SetBindIP(in6_addr ip)								{ bindIP = ip; }
+	void SetPortbase(u_int16_t pbase)							{ portbase = pbase; }
+	void SetMulticastTTL(u_int8_t mcastTTL)							{ multicastTTL = mcastTTL; }
+	void SetLocalIPList(std::list&lt;in6_addr&gt; &amp;iplist)					{ localIPs = iplist; } 
+	void ClearLocalIPList()									{ localIPs.clear(); }
+	in6_addr GetBindIP() const								{ return bindIP; }
+	u_int16_t GetPortbase() const								{ return portbase; }
+	u_int8_t GetMulticastTTL() const							{ return multicastTTL; }
+	const std::list&lt;in6_addr&gt; &amp;GetLocalIPList() const					{ return localIPs; }
+private:
+	u_int16_t portbase;
+	in6_addr bindIP;
+	std::list&lt;in6_addr&gt; localIPs;
+	u_int8_t multicastTTL;
+};
+
+class RTPUDPv6TransmissionInfo : public RTPTransmissionInfo
+{
+public:
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	RTPUDPv6TransmissionInfo(std::list&lt;in6_addr&gt; iplist,int rtpsock,int rtcpsock) : RTPTransmissionInfo(RTPTransmitter::IPv6UDPProto) 
+#else
+	RTPUDPv6TransmissionInfo(std::list&lt;in6_addr&gt; iplist,SOCKET rtpsock,SOCKET rtcpsock) : RTPTransmissionInfo(RTPTransmitter::IPv6UDPProto) 
+#endif  // WIN32
+												{ localIPlist = iplist; rtpsocket = rtpsock; rtcpsocket = rtcpsock; }
+
+	~RTPUDPv6TransmissionInfo()								{ }
+	std::list&lt;in6_addr&gt; GetLocalIPList() const						{ return localIPlist; }
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	int GetRTPSocket() const								{ return rtpsocket; }
+	int GetRTCPSocket() const								{ return rtcpsocket; }
+#else
+	SOCKET GetRTPSocket() const								{ return rtpsocket; }
+	SOCKET GetRTCPSocket() const								{ return rtcpsocket; }
+#endif // WIN32
+private:
+	std::list&lt;in6_addr&gt; localIPlist;
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	int rtpsocket,rtcpsocket;
+#else
+	SOCKET rtpsocket,rtcpsocket;
+#endif // WIN32
+};
+		
+#ifdef RTP_SUPPORT_INLINETEMPLATEPARAM
+	inline int RTPUDPv6Trans_GetHashIndex_IPv6Dest(const RTPIPv6Destination &amp;d)		{ in6_addr ip = d.GetIP(); return ((((u_int32_t)ip.s6_addr[12])&lt;&lt;24)|(((u_int32_t)ip.s6_addr[13])&lt;&lt;16)|(((u_int32_t)ip.s6_addr[14])&lt;&lt;8)|((u_int32_t)ip.s6_addr[15]))%RTPUDPV6TRANS_HASHSIZE; }
+	inline int RTPUDPv6Trans_GetHashIndex_in6_addr(const in6_addr &amp;ip)			{ return ((((u_int32_t)ip.s6_addr[12])&lt;&lt;24)|(((u_int32_t)ip.s6_addr[13])&lt;&lt;16)|(((u_int32_t)ip.s6_addr[14])&lt;&lt;8)|((u_int32_t)ip.s6_addr[15]))%RTPUDPV6TRANS_HASHSIZE; }
+#else // No support for inline function as template parameter
+	int RTPUDPv6Trans_GetHashIndex_IPv6Dest(const RTPIPv6Destination &amp;d);
+	int RTPUDPv6Trans_GetHashIndex_in6_addr(const in6_addr &amp;ip);
+#endif // RTP_SUPPORT_INLINETEMPLATEPARAM
+
+#define RTPUDPV6TRANS_HEADERSIZE								(40+8)
+	
+class RTPUDPv6Transmitter : public RTPTransmitter
+{
+public:
+	RTPUDPv6Transmitter();
+	~RTPUDPv6Transmitter();
+
+	int Init(bool treadsafe);
+	int Create(size_t maxpacksize,const RTPTransmissionParams *transparams);
+	void Destroy();
+	RTPTransmissionInfo *GetTransmissionInfo();
+
+	int GetLocalHostName(u_int8_t *buffer,size_t *bufferlength);
+	bool ComesFromThisTransmitter(const RTPAddress *addr);
+	size_t GetHeaderOverhead()								{ return RTPUDPV6TRANS_HEADERSIZE; }
+	
+	int Poll();
+	int WaitForIncomingData(const RTPTime &amp;delay,bool *dataavailable = 0);
+	int AbortWait();
+	
+	int SendRTPData(const void *data,size_t len);	
+	int SendRTCPData(const void *data,size_t len);
+
+	void ResetPacketCount();
+	u_int32_t GetNumRTPPacketsSent();
+	u_int32_t GetNumRTCPPacketsSent();
+				
+	int AddDestination(const RTPAddress &amp;addr);
+	int DeleteDestination(const RTPAddress &amp;addr);
+	void ClearDestinations();
+
+	bool SupportsMulticasting();
+	int JoinMulticastGroup(const RTPAddress &amp;addr);
+	int LeaveMulticastGroup(const RTPAddress &amp;addr);
+	void LeaveAllMulticastGroups();
+
+	int SetReceiveMode(RTPTransmitter::ReceiveMode m);
+	int AddToIgnoreList(const RTPAddress &amp;addr);
+	int DeleteFromIgnoreList(const RTPAddress &amp;addr);
+	void ClearIgnoreList();
+	int AddToAcceptList(const RTPAddress &amp;addr);
+	int DeleteFromAcceptList(const RTPAddress &amp;addr);
+	void ClearAcceptList();
+	int SetMaximumPacketSize(size_t s);	
+	
+	bool NewDataAvailable();
+	RTPRawPacket *GetNextPacket();
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+private:
+	int CreateLocalIPList();
+	bool GetLocalIPList_Interfaces();
+	void GetLocalIPList_DNS();
+	void AddLoopbackAddress();
+	void FlushPackets();
+	int PollSocket(bool rtp);
+	int ProcessAddAcceptIgnoreEntry(in6_addr ip,u_int16_t port);
+	int ProcessDeleteAcceptIgnoreEntry(in6_addr ip,u_int16_t port);
+#ifdef RTP_SUPPORT_IPV6MULTICAST
+	bool SetMulticastTTL(u_int8_t ttl);
+#endif // RTP_SUPPORT_IPV6MULTICAST
+	bool ShouldAcceptData(in6_addr srcip,u_int16_t srcport);
+	void ClearAcceptIgnoreInfo();
+	
+	bool init;
+	bool created;
+	bool waitingfordata;
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	SOCKET rtpsock,rtcpsock;
+#else // not using winsock
+	int rtpsock,rtcpsock;
+#endif // WIN32
+	in6_addr bindIP;
+	std::list&lt;in6_addr&gt; localIPs;
+	u_int16_t portbase;
+	u_int8_t multicastTTL;
+	RTPTransmitter::ReceiveMode receivemode;
+
+	u_int8_t *localhostname;
+	size_t localhostnamelength;
+	
+	RTPHashTable&lt;const RTPIPv6Destination,RTPUDPv6Trans_GetHashIndex_IPv6Dest,RTPUDPV6TRANS_HASHSIZE&gt; destinations;
+#ifdef RTP_SUPPORT_IPV6MULTICAST
+	RTPHashTable&lt;const in6_addr,RTPUDPv6Trans_GetHashIndex_in6_addr,RTPUDPV6TRANS_HASHSIZE&gt; multicastgroups;
+#endif // RTP_SUPPORT_IPV6MULTICAST
+	std::list&lt;RTPRawPacket*&gt; rawpacketlist;
+
+	bool supportsmulticasting;
+	size_t maxpacksize;
+
+	class PortInfo
+	{
+	public:
+		PortInfo() { all = false; }
+		
+		bool all;
+		std::list&lt;u_int16_t&gt; portlist;
+	};
+
+	RTPKeyHashTable&lt;const in6_addr,PortInfo*,RTPUDPv6Trans_GetHashIndex_in6_addr,RTPUDPV6TRANS_HASHSIZE&gt; acceptignoreinfo;
+
+	// notification descriptors for AbortWait (0 is for reading, 1 for writing)
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	SOCKET abortdesc[2];
+#else
+	int abortdesc[2];
+#endif // WIN32
+	int CreateAbortDescriptors();
+	void DestroyAbortDescriptors();
+	void AbortWaitInternal();
+#ifdef RTP_SUPPORT_THREAD
+	JMutex mainmutex,waitmutex;
+	int threadsafe;
+#endif // RTP_SUPPORT_THREAD
+
+	u_int32_t rtppackcount,rtcppackcount;
+};
+
+#endif // RTP_SUPPORT_IPV6
+
+#endif // RTPUDPV6TRANSMITTER_H
+

Modified: konference/src/rtp/rtpaudio.cpp
===================================================================
--- konference/src/rtp/rtpaudio.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/rtpaudio.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -31,404 +31,120 @@
 #include &lt;linux/sockios.h&gt;
 #include &quot;config.h&quot;
 
+#include &lt;kdebug.h&gt;
+
+#include &lt;netinet/in.h&gt;
+#include &lt;arpa/inet.h&gt;
+#include &quot;rtppacket.h&quot;
+#include &quot;rtpudpv4transmitter.h&quot;
+#include &quot;rtpipv4address.h&quot;
+#include &quot;rtpsessionparams.h&quot;
+//#include &quot;rtperrors.h&quot;
+
 #include &quot;rtpaudio.h&quot;
 #include &quot;../codecs/g711.h&quot;
 #include &quot;../codecs/gsmcodec.h&quot;
 
-
-rtpAudio::rtpAudio(int localPort, QString remoteIP, int remotePort,
-                   int mediaPay, int dtmfPay, codecBase *codec, audioBase *audioDevice)
-		: rtpBase(remoteIP, localPort, remotePort)
+rtpAudio::rtpAudio(int localPort, QString remoteIP, int remotePort, codecBase *codec, audioBase *audioDevice)
 {
+	m_codec = codec;
 	m_audioDevice = audioDevice;
 
-	txMode = RTP_TX_AUDIO_FROM_MICROPHONE;
-	rxMode = RTP_RX_AUDIO_TO_SPEAKER;
-	//txMode = RTP_TX_AUDIO_SILENCE;
-	//rxMode = RTP_RX_AUDIO_DISCARD;
+	u_int32_t destip = inet_addr(remoteIP.latin1());
+	if (destip == INADDR_NONE)
+		kdDebug() &lt;&lt; &quot;rtpVideo: remoteIP error&quot; &lt;&lt; endl;
+	destip = ntohl(destip);
 
-	m_codec = codec;
 
-	audioPayload = mediaPay;
-	dtmfPayload = dtmfPay;
+	// Now, we'll create a RTP session
+	RTPUDPv4TransmissionParams transparams;
+	RTPSessionParams sessparams;
 
-	// Clear variables within the calling tasks thread that are used by the calling
-	// task to prevent race conditions
-	txBuffer = 0;
-	recBuffer = 0;
-	dtmfIn = &quot;&quot;;
+	// IMPORTANT: The local timestamp unit MUST be set, otherwise
+	//            RTCP Sender Report info will be calculated wrong
+	// In this case, we'll be sending 10 samples each second, so we'll
+	// put the timestamp unit to (1.0/10.0)
+	//8000 Hz
+	sessparams.SetOwnTimestampUnit(1.0/8000.0);
 
-	killRtpThread = false;
+	sessparams.SetAcceptOwnPackets(true);
+	transparams.SetPortbase(localPort);
+	m_status = m_rtpSession.Create(sessparams,&amp;transparams);
+	//checkerror(status);
+
+	RTPIPv4Address addr(destip,remotePort);
+
+	m_status = m_rtpSession.AddDestination(addr);
+	//checkerror(status);
+	micFirstTime = true;
 	start();
 }
 
 rtpAudio::~rtpAudio()
 {
-	killRtpThread = true;
+	m_killThread = true;
 	wait();
 }
 
 void rtpAudio::run()
 {
-	rtpAudioThreadWorker();
-}
-
-
-void rtpAudio::rtpAudioThreadWorker()
-{
-	RTPPACKET RTPpacket;
-	QTime timeNextTx;
-	bool micFirstTime = true;
-
-	rtpInitialise();
-	openSocket();
-	//set this to have no mic
-	//txMode = RTP_TX_AUDIO_SILENCE;
-	kdDebug() &lt;&lt; &quot;rtpAudio::rtpAudioThreadWorker()&quot; &lt;&lt; endl;
-
-	PlayoutDelay = SpkJitter;
-	PlayLen = 0;
-	memset(SilenceBuffer, 0, sizeof(SilenceBuffer));
-	SilenceLen = rxPCMSamplesPerPacket * sizeof(short);
-	rxTimestamp = 0;
-	rxSeqNum = 0;
-	rxFirstFrame = true;
-
-	timeNextTx = (QTime::currentTime()).addMSecs(rxMsPacketSize);
-
-	while(!killRtpThread)
+	m_killThread = false;
+	while(!m_killThread)
 	{
-		// Awake every 10ms to see if we need to rx/tx anything
-		// May need to revisit this; as I'd much prefer it to be event driven
-		// usleep(10000) seems to cause a 20ms sleep whereas usleep(0)
-		// seems to sleep for ~10ms
-		usleep(10000);
+		handleOutgoingPackets();
 
-		// Pull in all received packets
-		StreamInAudio();
-		// Write audio to the speaker, but keep in dejitter buffer as long as possible
-		while (m_audioDevice-&gt;isSpeakerHungry() &amp;&amp;
-		        pJitter-&gt;AnyData() &amp;&amp;
-		        rxMode == RTP_RX_AUDIO_TO_SPEAKER &amp;&amp;
-		        pJitter-&gt;isPacketQueued(rxSeqNum))
+		m_rtpSession.BeginDataAccess();
+		// check incoming packets
+		if (m_rtpSession.GotoFirstSourceWithData())
 		{
-			PlayOutAudio();
-		}
-		// For mic. data, the microphone determines the transmit rate
-		// Mic. needs kicked the first time through
-		while ((txMode == RTP_TX_AUDIO_FROM_MICROPHONE) &amp;&amp;
-		        ((m_audioDevice-&gt;isMicrophoneData()) || micFirstTime))
-		{
-			micFirstTime = false;
-			if (fillPacketfromMic(RTPpacket))
+			do
 			{
-				txTimeStamp += txPCMSamplesPerPacket;
-				initPacket(RTPpacket);
-				sendPacket(RTPpacket);
-			}
-		}
-
-		// For transmitting silence/buffered data we need to use the clock
-		// as timing
-		if (((txMode == RTP_TX_AUDIO_SILENCE) || (txMode == RTP_TX_AUDIO_FROM_BUFFER)) &amp;&amp;
-		        (timeNextTx &lt;= QTime::currentTime()))
-		{
-			timeNextTx = timeNextTx.addMSecs(rxMsPacketSize);
-			switch (txMode)
-			{
-			default:
-			case RTP_TX_AUDIO_SILENCE:           fillPacketwithSilence(RTPpacket); break;
-			case RTP_TX_AUDIO_FROM_BUFFER:       fillPacketfromBuffer(RTPpacket);  break;
-			}
-			txTimeStamp += txPCMSamplesPerPacket;
-			initPacket(RTPpacket);
-			sendPacket(RTPpacket);
-		}
-
-		//here may be a good place to send dtmf-tones...
-		//SendWaitingDtmf();
-	}
-
-	m_audioDevice-&gt;closeDevice();
-	closeSocket();
-	if (pJitter)
-		delete pJitter;
-}
-
-void rtpAudio::rtpInitialise()
-{
-	rxMsPacketSize        = 20;
-	rxPCMSamplesPerPacket = rxMsPacketSize * PCM_SAMPLES_PER_MS;
-	txMsPacketSize        = 20;
-	txPCMSamplesPerPacket = txMsPacketSize*PCM_SAMPLES_PER_MS;
-	SpkJitter             = 5; // Size of the jitter buffer * (rxMsPacketSize/2); so 5=50ms for 20ms packet size
-	txBuffer              = 0;
-	lastDtmfTimestamp     = 0;
-	dtmfIn                = &quot;&quot;;
-	recBuffer             = 0;
-	recBufferLen          = 0;
-	recBufferMaxLen       = 0;
-	rxFirstFrame          = true;
-	//spkLowThreshold       = (rxPCMSamplesPerPacket*sizeof(short));
-	oobError              = false;
-	micMuted              = false;
-
-	spkInBuffer = 0;
-
-	m_audioDevice-&gt;setSpkLowThreshold(rxPCMSamplesPerPacket*sizeof(short));
-
-	pJitter = new Jitter();
-
-	rtpMPT = m_codec-&gt;getPayload();
-	rtpMarker = 0;
-}
-
-void rtpAudio::StreamInAudio()
-{
-	RTPPACKET rtpDump;
-	RTPPACKET *JBuf;
-	bool tryAgain;
-
-	do
-	{
-		tryAgain = false; // We keep going until we empty the socket
-
-		// Get a buffer from the Jitter buffer to put the packet in
-		if ((JBuf = pJitter-&gt;GetJBuffer()) != 0)
-		{
-			//JBuf-&gt;len = rtpSocket-&gt;readBlock((char *)&amp;JBuf-&gt;RtpVPXCC, sizeof(RTPPACKET));
-			JBuf-&gt;len = readPacket((char *)&amp;JBuf-&gt;RtpVPXCC, sizeof(RTPPACKET));
-			if (JBuf-&gt;len &gt; 0)
-			{
-				tryAgain = true;
-				if (PAYLOAD(JBuf) == rtpMPT)
+				RTPPacket *pack;
+				while ((pack = m_rtpSession.GetNextPacket()) != NULL)
 				{
-					JBuf-&gt;RtpSequenceNumber = ntohs(JBuf-&gt;RtpSequenceNumber);
-					JBuf-&gt;RtpTimeStamp = ntohl(JBuf-&gt;RtpTimeStamp);
-					if (rxFirstFrame)
-					{
-						rxFirstFrame = FALSE;
-						rxSeqNum = JBuf-&gt;RtpSequenceNumber;
-					}
-					if (PKLATE(rxSeqNum, JBuf-&gt;RtpSequenceNumber))
-					{
-						kdDebug() &lt;&lt; &quot;Packet arrived too late to play, try increasing jitter buffer\n&quot;;
-						pJitter-&gt;FreeJBuffer(JBuf);
-					}
-					else
-						pJitter-&gt;InsertJBuffer(JBuf);
+					//pack-&gt;Dump();
+					handleIncomingPackets(pack);
+					delete pack;
 				}
-				else if (PAYLOAD(JBuf) == dtmfPayload)
-				{
-					tryAgain = true; // Force us to get another frame since this one is additional
-					HandleRxDTMF(JBuf);
-					if (PKLATE(rxSeqNum, JBuf-&gt;RtpSequenceNumber))
-						pJitter-&gt;FreeJBuffer(JBuf);
-					else
-						pJitter-&gt;InsertDTMF(JBuf); // Do this just so seq-numbers stay intact, it gets discarded later
-				}
-				else
-				{
-					if (PAYLOAD(JBuf) != RTP_PAYLOAD_COMF_NOISE)
-						kdDebug() &lt;&lt; &quot;Received Invalid Payload &quot; &lt;&lt; (int)JBuf-&gt;RtpMPT &lt;&lt; &quot;\n&quot;;
-					else
-						kdDebug() &lt;&lt; &quot;Received Comfort Noise Payload\n&quot;;
-					pJitter-&gt;FreeJBuffer(JBuf);
-				}
 			}
-			else // No received frames, free the buffer
-				pJitter-&gt;FreeJBuffer(JBuf);
+			while (m_rtpSession.GotoNextSourceWithData());
 		}
+		m_rtpSession.EndDataAccess();
 
-		// No free buffers, still get the data from the socket but dump it. Unlikely to recover from this by
-		// ourselves so we really need to discard all queued frames and reset the receiver
-		else
-		{
-			//rtpSocket-&gt;readBlock((char *)&amp;rtpDump.RtpVPXCC, sizeof(RTPPACKET));
-			readPacket((char *)&amp;rtpDump.RtpVPXCC, sizeof(RTPPACKET));
-			if (!oobError)
-			{
-				kdDebug() &lt;&lt; &quot;Dumping received RTP frame, no free buffers; rx-mode &quot; &lt;&lt; rxMode &lt;&lt; &quot;; tx-mode &quot; &lt;&lt; txMode &lt;&lt; endl;
-				pJitter-&gt;Debug();
-				oobError = true;
-			}
-		}
+		msleep(20);
+		m_status = m_rtpSession.Poll();
 	}
-	while (tryAgain);
 
-	// Check size of Jitter buffer, make sure it doesn't grow too big
-	//pJitter-&gt;Debug();
+	m_audioDevice-&gt;closeDevice();
 
 }
 
-
-void rtpAudio::PlayOutAudio()
+void rtpAudio::handleIncomingPackets(RTPPacket *pack)
 {
-	bool tryAgain;
-	int mLen, m, reason;
- 
-	// Implement a playout de-jitter delay
-	if (PlayoutDelay &gt; 0)
-	{
-		PlayoutDelay--;
-		return;
-	}
- 
-	// Now process buffers from the Jitter Buffer
-	do
-	{
-		tryAgain = false;
-		RTPPACKET *JBuf = pJitter-&gt;DequeueJBuffer(rxSeqNum, reason);
-		switch (reason)
-		{
-		case JB_REASON_OK:
-			++rxSeqNum;
-			mLen = JBuf-&gt;len - RTP_HEADER_SIZE;
-			if ((rxMode == RTP_RX_AUDIO_TO_SPEAKER))
-			{
-				PlayLen = m_codec-&gt;Decode(JBuf-&gt;RtpData, spkBuffer[spkInBuffer], mLen, spkPower2);
-				//	kdDebug() &lt;&lt; &quot;spkPower: &quot; &lt;&lt; spkPower2 &lt;&lt; endl;
-				//m = write(speakerFd, (uchar *)spkBuffer[spkInBuffer], PlayLen);
-				m_audioDevice-&gt;playFrame((uchar *)spkBuffer[spkInBuffer], PlayLen);
-			}
-			//TODO why the heck should we want to put received frames in a buffer
-			//TODO and do nothing with them??
-			//else if (rxMode == RTP_RX_AUDIO_TO_BUFFER)
-			//{
-			//	PlayLen = m_codec-&gt;Decode(JBuf-&gt;RtpData, SpkBuffer[spkInBuffer], mLen, spkPower2);
-			//	recordInPacket(SpkBuffer[spkInBuffer], PlayLen);
-			//	cout &lt;&lt; &quot;rxMode == RTP_RX_AUDIO_TO_BUFFER&quot; &lt;&lt; endl;
-			//}
-			//rxTimestamp += mLen;//TODO increasing the timestamp by a length of data??
-			//pJitter-&gt;FreeJBuffer(JBuf);
- 
-// rxMode is RTP_RX_AUDIO_DISCARD
-			else
-{}
-			pJitter-&gt;FreeJBuffer(JBuf);
-				break
-;
-			case JB_REASON_DUPLICATE: // This should not happen; but it does, especially with DTMF frames!
-				if (JBuf != 0)
-					pJitter-&gt;FreeJBuffer(JBuf);
-				tryAgain = true;
-				break;
- 
-			case JB_REASON_DTMF:
-				++rxSeqNum;
-				pJitter-&gt;FreeJBuffer(JBuf);
-				tryAgain = true;
-				break;
- 
-				// This may just be because we are putting frames into the driver too early, but no way to tell
-			case JB_REASON_MISSING:
-				rxSeqNum++;
-				memset(SilenceBuffer, 0, sizeof(SilenceBuffer));
-				SilenceLen = rxPCMSamplesPerPacket * sizeof(short);
-				if ((rxMode == RTP_RX_AUDIO_TO_SPEAKER))
-				{
-					m_audioDevice-&gt;playFrame((uchar *)SilenceBuffer, SilenceLen);
-					//m = write(speakerFd, (uchar *)SilenceBuffer, SilenceLen);
-				}
-				//TODO see above
-				else if (rxMode == RTP_RX_AUDIO_TO_BUFFER)
-				{
-				rxMode = RTP_RX_AUDIO_DISCARD;
-				kdDebug() &lt;&lt; &quot;rxMode == RTP_RX_AUDIO_TO_BUFFER&quot; &lt;&lt; endl;
-				//
-				//	recordInPacket(SilenceBuffer, SilenceLen);
-				}
-				pJitter-&gt;FreeJBuffer(JBuf);
-				break;
- 
-			case JB_REASON_EMPTY: // nothing to do, just hope the driver playout buffer is full (since we can't tell!)
-				break;
-			case JB_REASON_SEQERR:
-			default:
-				//kdDebug() &lt;&lt; &quot;Something funny happened with the seq numbers, should reset them &amp; start again\n&quot;;
-				break;
-			}
-		}
-		while (tryAgain);
- 
-	}
+	short int spkPower2;
+	int PlayLen = m_codec-&gt;Decode((uchar*)pack-&gt;GetPayloadData(), spkBuffer[spkInBuffer], (int)pack-&gt;GetPayloadLength(), spkPower2);
+	m_audioDevice-&gt;playFrame((uchar *)spkBuffer[spkInBuffer], PlayLen);
 
-
-void rtpAudio::HandleRxDTMF(RTPPACKET *RTPpacket)
-{
-	DTMF_RFC2833 *dtmf = (DTMF_RFC2833 *)RTPpacket-&gt;RtpData;
-	RTPpacket-&gt;RtpSequenceNumber = ntohs(RTPpacket-&gt;RtpSequenceNumber);
-	RTPpacket-&gt;RtpTimeStamp = ntohl(RTPpacket-&gt;RtpTimeStamp);
-
-	// Check if it is a NEW or REPEATED DTMF character
-	if (RTPpacket-&gt;RtpTimeStamp != lastDtmfTimestamp)
-	{
-		lastDtmfTimestamp = RTPpacket-&gt;RtpTimeStamp;
-		rtpMutex.lock();
-		dtmfIn.append(DTMF2CHAR(dtmf-&gt;dtmfDigit));
-		kdDebug() &lt;&lt; &quot;Received DTMF digit &quot; &lt;&lt; dtmfIn &lt;&lt; endl;
-		rtpMutex.unlock();
-	}
 }
 
-void rtpAudio::initPacket(RTPPACKET &amp;RTPpacket)
+void rtpAudio::handleOutgoingPackets()
 {
-	RTPpacket.RtpVPXCC = 128;
-	RTPpacket.RtpMPT = rtpMPT | rtpMarker;
-	rtpMarker = 0;
-	//seq-numbers are handled by the base-class
-	//RTPpacket.RtpSequenceNumber = htons(txSequenceNumber);
-
-	RTPpacket.RtpTimeStamp = htonl(txTimeStamp);
-}
-
-void rtpAudio::fillPacketwithSilence(RTPPACKET &amp;RTPpacket)
-{
-	RTPpacket.len = m_codec-&gt;Silence(RTPpacket.RtpData, txMsPacketSize);
-}
-
-bool rtpAudio::fillPacketfromMic(RTPPACKET &amp;RTPpacket)
-{
-	int gain=0;
-	short buffer[MAX_DECOMP_AUDIO_SAMPLES];
-	//	int len = read(microphoneFd, (char *)buffer, txPCMSamplesPerPacket*sizeof(short));
-	int len = m_audioDevice-&gt;recordFrame((char *) buffer, txPCMSamplesPerPacket*sizeof(short));
-
-	if (len != (int)(txPCMSamplesPerPacket*sizeof(short)))
+	while(m_audioDevice-&gt;isMicrophoneData() || micFirstTime)
 	{
-		fillPacketwithSilence(RTPpacket);
-		//kdDebug() &lt;&lt; &quot;aua :&quot; &lt;&lt; len &lt;&lt; endl;
-	}
-	else if (micMuted)
-		fillPacketwithSilence(RTPpacket);
-	else
-	{
-		RTPpacket.len = m_codec-&gt;Encode(buffer, RTPpacket.RtpData, txPCMSamplesPerPacket, spkPower2, gain);
-		//		kdDebug() &lt;&lt; &quot;micPower: &quot; &lt;&lt; spkPower2 &lt;&lt; endl;
-	}
+		micFirstTime = false;
+		int gain=0;
+		short buffer[MAX_DECOMP_AUDIO_SAMPLES];
+		//	int len = read(microphoneFd, (char *)buffer, txPCMSamplesPerPacket*sizeof(short));
+		int len = m_audioDevice-&gt;recordFrame((char *) buffer, 20*8/*txPCMSamplesPerPacket*/*sizeof(short));
+		short int spkPower2;
+		uchar	  RtpData[IP_MAX_MTU-RTP_HEADER_SIZE-UDP_HEADER_SIZE];
 
-	return true;
-}
-
-void rtpAudio::fillPacketfromBuffer(RTPPACKET &amp;RTPpacket)
-{
-	rtpMutex.lock();
-	if (txBuffer == 0)
-	{
-		fillPacketwithSilence(RTPpacket);
-		txMode = RTP_TX_AUDIO_SILENCE;
-		kdDebug() &lt;&lt; &quot;No buffer to playout, changing to playing silence\n&quot;;
-	}
-	else
-	{
-		RTPpacket.len = m_codec-&gt;Encode(txBuffer+txBufferPtr, RTPpacket.RtpData, txPCMSamplesPerPacket, spkPower2, 0);
-		txBufferPtr += txPCMSamplesPerPacket;
-		if (txBufferPtr &gt;= txBufferLen)
+		if (len != (int)(20*8*sizeof(short)))
 		{
-			delete txBuffer;
-			txBuffer = 0;
-			txMode = RTP_TX_AUDIO_SILENCE;
+			//fillPacketwithSilence(RTPpacket);
+			kdDebug() &lt;&lt; &quot;aua :&quot; &lt;&lt; len &lt;&lt; endl;
 		}
+		len = m_codec-&gt;Encode((short*)&amp;buffer, (uchar*)&amp;RtpData, 20*8/*txPCMSamplesPerPacket*/, spkPower2, gain);
+		m_status = m_rtpSession.SendPacket((uchar*)&amp;RtpData,len,m_codec-&gt;getPayload(),true/*marker*/,160);
 	}
-	rtpMutex.unlock();
 }

Modified: konference/src/rtp/rtpaudio.h
===================================================================
--- konference/src/rtp/rtpaudio.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/rtpaudio.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -17,17 +17,12 @@
  *   Free Software Foundation, Inc.,                                       *
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
- 
+
 #ifndef RTPAUDIO_H_
 #define RTPAUDIO_H_
 
-#include &lt;qsocketdevice.h&gt;
-#include &lt;qtimer.h&gt;
-#include &lt;qptrlist.h&gt;
 #include &lt;qthread.h&gt;
-#include &lt;qdatetime.h&gt;
 
-
 #define IP_MAX_MTU                1500     // Max size of rxed RTP packet
 #define IP_MTU                    1290     // Max size of txed RTP packet. Standard MTU is 1500, leave some room for IPSec etc
 #define TX_USER_STREAM_SIZE       4096
@@ -44,107 +39,34 @@
 #define NUM_SPK_BUFFERS		16
 #define SPK_BUFFER_SIZE		MIC_BUFFER_SIZE // Need to keep these the same (see RTPPACKET)
 
-typedef struct
-{
-	uchar  dtmfDigit;
-	uchar  dtmfERVolume;
-	short dtmfDuration;
-}
-DTMF_RFC2833;
+#define IP_MTU                    1290     // Max size of txed RTP packet. Standard MTU is 1500, leave some room for IPSec etc
+#define IP_MAX_MTU                1500     // Max size of rxed RTP packet
+#define RTP_HEADER_SIZE           12
+#define UDP_HEADER_SIZE           28
 
-
-// Values for RTP Payload Type
-#define RTP_PAYLOAD_MARKER_BIT	0x80
-#define PAYLOAD(r)              (((r)-&gt;RtpMPT) &amp; (~RTP_PAYLOAD_MARKER_BIT))
-#define RTP_DTMF_EBIT           0x80
-#define RTP_DTMF_VOLUMEMASK     0x3F
-#define JITTERQ_SIZE	          512
-#define PKLATE(c,r)             (((r)&lt;(c)) &amp;&amp; (((c)-(r))&lt;32000))    // check if rxed seq-number is less than current but handle wrap
-
-#define DTMF_STAR 10
-#define DTMF_HASH 11
-#define DTMF2CHAR(d) ((d)&gt;DTMF_HASH ? '?' : ((d)==DTMF_STAR ? '*' : ((d) == DTMF_HASH ? '#' : ((d)+'0'))))
-#define CHAR2DTMF(c) ((c)=='#' ? DTMF_HASH : ((c)=='*' ? DTMF_STAR : ((c)-'0')))
-
-
 #include &quot;../codecs/codecbase.h&quot;
 #include &quot;../audio/audiobase.h&quot;
 
-#include &quot;jitter.h&quot;
+#include &quot;rtpsession.h&quot;
 
-#include &quot;rtpbase.h&quot;
-
-/**
- * @brief Class that handles transmission/receiption of audio
- */
-class rtpAudio : public rtpBase, QThread
+class rtpAudio : public QThread
 {
-
 public:
-	rtpAudio(int localPort, QString remoteIP, int remotePort, int mediaPay, int dtmfPay, codecBase *codec, audioBase *audioDevice);
+	rtpAudio(int localPort, QString remoteIP, int remotePort, codecBase *codec, audioBase *audioDevice);
 	~rtpAudio();
 	virtual void run();
 
 private:
-	void rtpAudioThreadWorker();
-	void rtpInitialise();
-	void StreamInAudio();
-	void PlayOutAudio();
-	void HandleRxDTMF(RTPPACKET *RTPpacket);
-	void SendWaitingDtmf();
-	void initPacket(RTPPACKET &amp;RTPpacket);
-	void fillPacketwithSilence(RTPPACKET &amp;RTPpacket);
-	bool fillPacketfromMic(RTPPACKET &amp;RTPpacket);
-	void fillPacketfromBuffer(RTPPACKET &amp;RTPpacket);
-
-
+	void handleIncomingPackets(RTPPacket *pack);
+	void handleOutgoingPackets();
+	bool micFirstTime;
+	audioBase *m_audioDevice;
+	codecBase   *m_codec;
+	bool m_killThread;
+	int m_status;
+	RTPSession m_rtpSession;
 	short spkBuffer[1][SPK_BUFFER_SIZE];
 	int spkInBuffer;
-
-	codecBase   *m_codec;
-	Jitter *pJitter;
-	int rxMsPacketSize;
-	int txMsPacketSize;
-	int rxPCMSamplesPerPacket;
-	int txPCMSamplesPerPacket;
-	int SpkJitter;
-
-	ulong rxTimestamp;
-	ushort rxSeqNum;
-	bool rxFirstFrame;
-	unsigned long txTimeStamp;
-
-	int PlayoutDelay;
-	short SilenceBuffer[MAX_DECOMP_AUDIO_SAMPLES];
-	int PlayLen;
-	int SilenceLen;
-	uchar rtpMPT;
-	uchar rtpMarker;
-	rtpTxMode txMode;
-	rtpRxMode rxMode;
-
-	bool oobError;
-	bool killRtpThread;
-	short *txBuffer;
-	int txBufferLen, txBufferPtr;
-	ulong lastDtmfTimestamp;
-	QString dtmfIn;
-	short *recBuffer;
-	int recBufferLen, recBufferMaxLen;
-
-	///this may be set to 'true' anytime to transmit silence instead of mic-data (speech)
-	bool micMuted;
-
-	int audioPayload,dtmfPayload;
-	
-	audioBase *m_audioDevice;
-	
-	//this is used by the encode/decode functions of the codecs and stores the power-lvl in this frame
-	//used for statistics/powermeter
-	short spkPower2;
 };
 
-
-
-
 #endif

Modified: konference/src/rtp/rtpbase.h
===================================================================
--- konference/src/rtp/rtpbase.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/rtpbase.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -32,6 +32,7 @@
 #define RTP_PAYLOAD_G711A		0x08
 #define RTP_PAYLOAD_COMF_NOISE	0x0D
 #define RTP_PAYLOAD_GSM			0x03
+#define RTP_PAYLOAD_SPEEX		0x61
 #define PAYLOAD(r)				(((r)-&gt;RtpMPT) &amp; (~RTP_PAYLOAD_MARKER_BIT))
 
 #include &quot;jitter.h&quot;

Modified: konference/src/rtp/rtpvideo.cpp
===================================================================
--- konference/src/rtp/rtpvideo.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/rtpvideo.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -18,380 +18,230 @@
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
 
+#include &lt;qapplication.h&gt;//for ::postEvent()
+
+#include &lt;kdebug.h&gt;
+
 #include &lt;netinet/in.h&gt;
+#include &lt;arpa/inet.h&gt;
+#include &quot;rtppacket.h&quot;
+#include &quot;rtpudpv4transmitter.h&quot;
+#include &quot;rtpipv4address.h&quot;
+#include &quot;rtpsessionparams.h&quot;
+//#include &quot;rtperrors.h&quot;
 
 #include &quot;rtpvideo.h&quot;
 
-
-rtpVideo::rtpVideo(QObject *parent, int localPort, QString remoteIP, int remotePort, int mediaPay, rtpTxMode txm, rtpRxMode rxm)
-		: rtpBase(remoteIP, localPort, remotePort)
+rtpVideo::rtpVideo(QObject *parent, int localPort, QString remoteIP, int remotePort, int payloadType, float fps)
 {
+	m_payloadType = payloadType;
 	m_parent = parent;
-	txMode = txm;
-	rxMode = rxm;
 
-	videoPayload = mediaPay;
+	m_videoBuffer.w = m_videoBuffer.h = m_videoBuffer.len = 0;
 
-	//create 10 videobuffers
-	for(int i=0; i&lt;=9; i++)
-		FreeVideoBufferQ.append(new VIDEOBUFFER);
+	u_int32_t destip = inet_addr(remoteIP.latin1());
+	if (destip == INADDR_NONE)
+		kdDebug() &lt;&lt; &quot;rtpVideo: remoteIP error&quot; &lt;&lt; endl;
+	destip = ntohl(destip);
 
-	videoToTx = 0;
-	pJitter = new Jitter();
-	killRtpThread = false;
-	start();
-}
+	// Now, we'll create a RTP session
+	RTPUDPv4TransmissionParams transparams;
+	RTPSessionParams sessparams;
 
+	// IMPORTANT: The local timestamp unit MUST be set, otherwise
+	//            RTCP Sender Report info will be calculated wrong
+	// In this case, we'll be sending 10 samples each second, so we'll
+	// put the timestamp unit to (1.0/10.0)
+	sessparams.SetOwnTimestampUnit(1.0/fps);
 
-rtpVideo::~rtpVideo()
-{
-	killRtpThread = true;
-	wait();
-	destroyVideoBuffers();
-}
+	sessparams.SetAcceptOwnPackets(true);
+	transparams.SetPortbase(localPort);
+	m_status = m_rtpSession.Create(sessparams,&amp;transparams);
+	//checkerror(status);
 
-void rtpVideo::initialise()
-{
-	rtpMPT = videoPayload;
+	RTPIPv4Address addr(destip,remotePort);
 
-	rxFirstFrame          = true;
+	m_status = m_rtpSession.AddDestination(addr);
+	//checkerror(status);
 
-	rtpMarker = 0;
+	start();
 }
 
-VIDEOBUFFER *rtpVideo::getRxedVideo()
+rtpVideo::~rtpVideo()
 {
-	rtpMutex.lock();
-	VIDEOBUFFER *b=rxedVideoFrames.take(0);
-	rtpMutex.unlock();
-	return b;
+	m_killThread = true;
+	wait();
+	m_rtpSession.Destroy();
 }
 
-VIDEOBUFFER *rtpVideo::getVideoBuffer(int len)
+void rtpVideo::run()
 {
-	if ((len==0) || (len &lt;= MAX_VIDEO_LEN)) // len parameter, is passed, should be checked against buffer sizes
+	m_killThread = false;
+	while(!m_killThread)
 	{
-		VIDEOBUFFER *buf;
-		rtpMutex.lock();
-		buf = FreeVideoBufferQ.take(0);
-		rtpMutex.unlock();
-		return buf;
+		handleOutgoingPackets();
+
+		m_rtpSession.BeginDataAccess();
+		// check incoming packets
+		if (m_rtpSession.GotoFirstSourceWithData())
+		{
+			do
+			{
+				RTPPacket *pack;
+				while ((pack = m_rtpSession.GetNextPacket()) != NULL)
+				{
+					//pack-&gt;Dump();
+					handleIncomingPackets(pack);
+					delete pack;
+				}
+			}
+			while (m_rtpSession.GotoNextSourceWithData());
+		}
+		m_rtpSession.EndDataAccess();
+
+		msleep(50);
+		m_status = m_rtpSession.Poll();
 	}
-	kdDebug() &lt;&lt; &quot;Received video picture size &quot; &lt;&lt; len &lt;&lt; &quot; too big for preallocated buffer size &quot; &lt;&lt; MAX_VIDEO_LEN &lt;&lt; endl;
-	return 0;
+	//m_rtpSession.Destroy();
 }
 
-bool rtpVideo::queueVideo(VIDEOBUFFER *vb)
+void rtpVideo::getReceivedFrame(VIDEOBUFFER *videobuffer)
 {
-	bool res=false;
-	rtpMutex.lock();
-	if (videoToTx==0)
-	{
-		videoToTx=vb;
-//		if (eventCond)
-//			eventCond-&gt;wakeAll();
-		res=true;
-	}
-	rtpMutex.unlock();
-	return res;
+	m_rtpMutex.lock();
+	videobuffer-&gt;w = m_videoBuffer2.w;
+	videobuffer-&gt;h = m_videoBuffer2.h;
+	videobuffer-&gt;len = m_videoBuffer2.len;
+	memcpy(videobuffer-&gt;video, &amp;m_videoBuffer2.video, m_videoBuffer2.len);
+	m_rtpMutex.unlock();
 }
 
-// Packetisation as per RFC 2190 Mode A
-void rtpVideo::transmitQueuedVideo()
-{
-	// TODO
-	// Currently we only allow one video frame outstanding between the app and the RTP stack. This should be
-	// ok as its only meant to produce 10-30 frames / second, and we should consume much quicker
-	rtpMutex.lock();
-	VIDEOBUFFER *queuedVideo = videoToTx;
-	rtpMutex.unlock();
-
-	if (queuedVideo)
+void rtpVideo::checkFrameSize(RTPPacket *pack)
+{//if we dont know the size of this frame yet, check it.
+	if (m_videoBuffer.w == 0 || m_videoBuffer.h == 0)
 	{
-		RTPPACKET videoPacket;
-		uchar *v = queuedVideo-&gt;video;
-		int queuedLen = queuedVideo-&gt;len;
-
-		txTimeStamp += 25000; // TODO --- fix this, this is a guessed-at value
-
-		videoPacket.RtpVPXCC = 128;
-		videoPacket.RtpMPT = videoPayload;
-		videoPacket.RtpTimeStamp = htonl(txTimeStamp);
-		videoPacket.RtpSourceID = 0x666;
-		H263_RFC2190_HDR *h263Hdr = (H263_RFC2190_HDR *)videoPacket.RtpData;
-		switch (queuedVideo-&gt;w)
+		H263_RFC2190_HDR *h263Hdr = (H263_RFC2190_HDR *)pack-&gt;GetPayloadData();
+		switch (H263HDR_GETSZ(h263Hdr-&gt;h263hdr))
 		{
-		case 704: h263Hdr-&gt;h263hdr = H263HDR(H263_SRC_4CIF); break;
+		case H263_SRC_4CIF:  m_videoBuffer.w = 704; m_videoBuffer.h = 576; break;
 		default:
-		case 352: h263Hdr-&gt;h263hdr = H263HDR(H263_SRC_CIF); break;
-		case 176: h263Hdr-&gt;h263hdr = H263HDR(H263_SRC_QCIF); break;
-		case 128: h263Hdr-&gt;h263hdr = H263HDR(H263_SRC_SQCIF); break;
+		case H263_SRC_CIF:   m_videoBuffer.w = 352; m_videoBuffer.h = 288; break;
+		case H263_SRC_QCIF:  m_videoBuffer.w = 176; m_videoBuffer.h = 144; break;
+		case H263_SRC_SQCIF: m_videoBuffer.w = 128; m_videoBuffer.h = 96;  break;
 		}
-
-		while (queuedLen &gt; 0)
-		{
-			uint pkLen = queuedLen;
-			if (pkLen &gt; H263SPACE)
-				pkLen = H263SPACE;
-
-			videoPacket.len = pkLen+sizeof(H263_RFC2190_HDR);
-			memcpy(videoPacket.RtpData+sizeof(H263_RFC2190_HDR), v, pkLen);
-			v += pkLen;
-			queuedLen -= pkLen;
-
-			//we have reached the last packet for this frame, so mark it
-			if (queuedLen == 0)
-				videoPacket.RtpMPT |= RTP_PAYLOAD_MARKER_BIT;  // Last packet has Marker bit set as per RFC 2190
-
-			sendPacket(videoPacket);
-			
-		}
-		freeVideoBuffer(queuedVideo);
+		//kdDebug() &lt;&lt; &quot;received new h263-size of:&quot; &lt;&lt; m_videoBuffer.w &lt;&lt; &quot;x&quot; &lt;&lt; m_videoBuffer.h &lt;&lt; endl;
 	}
-	videoToTx = 0;
 }
 
-void rtpVideo::destroyVideoBuffers()
+void rtpVideo::handleOutgoingPackets()
 {
-	VIDEOBUFFER *buf = FreeVideoBufferQ.first();
-	while (buf)
+	if(transmitBuffer.isEmpty())
 	{
-		FreeVideoBufferQ.remove();
-		delete buf;
-		buf = FreeVideoBufferQ.current();
+		//kdDebug() &lt;&lt; &quot;buffer empty&quot; &lt;&lt; endl;
+		return;
 	}
-}
+	VIDEOBUFFER *queuedVideo;
 
-void rtpVideo::freeVideoBuffer(VIDEOBUFFER *vb)
-{
-	rtpMutex.lock();
-	FreeVideoBufferQ.append(vb);
-	rtpMutex.unlock();
-}
+	queuedVideo = transmitBuffer.first();
+	transmitBuffer.removeFirst();
 
-void rtpVideo::run()
-{
-	initialise();
-	openSocket();
-	
-	while(!killRtpThread)
-	{
-		// wait for the rtpSocket to have some data
-		//eventCond-&gt;wait();
-		
-		if (killRtpThread)
-			break;
-		
-		//TODO dirty hack... (prevents blocking)
-		if(bytesAvailable() &gt; 40)
-		{
-			StreamInVideo();
-		}
-		
-		transmitQueuedVideo();
-		msleep(20);
-	}
 
-	if (videoToTx)
+	uchar RtpData[MAX_PAYLOAD_LENGTH];
+	uchar *v = queuedVideo-&gt;video;
+	int queuedLen = queuedVideo-&gt;len;
+
+	H263_RFC2190_HDR *h263Hdr = (H263_RFC2190_HDR *)&RtpData;
+	switch (queuedVideo-&gt;w)
 	{
-		freeVideoBuffer(videoToTx);
-		videoToTx = 0;
+	case 704: h263Hdr-&gt;h263hdr = H263HDR(H263_SRC_4CIF); break;
+	default:
+	case 352: h263Hdr-&gt;h263hdr = H263HDR(H263_SRC_CIF); break;
+	case 176: h263Hdr-&gt;h263hdr = H263HDR(H263_SRC_QCIF); break;
+	case 128: h263Hdr-&gt;h263hdr = H263HDR(H263_SRC_SQCIF); break;
 	}
 
-	VIDEOBUFFER *buf;
-	while ((buf = rxedVideoFrames.take(0)) != 0)
+	while (queuedLen &gt; 0)
 	{
-		freeVideoBuffer(buf);
-	}
+		uint pkLen = queuedLen;
+		if (pkLen &gt; H263SPACE)
+			pkLen = H263SPACE;
 
-	closeSocket();
-	if (pJitter)
-		delete pJitter;
-}
+		memcpy((char*)&amp;RtpData+sizeof(H263_RFC2190_HDR), v, pkLen);
+		v += pkLen;
+		queuedLen -= pkLen;
 
-int rtpVideo::appendVideoPacket(VIDEOBUFFER *picture, int curLen, RTPPACKET *JBuf, int mLen)
-{
-	if ((curLen + mLen) &lt;= (int)sizeof(picture-&gt;video))
-	{
-		H263_RFC2190_HDR *h263Hdr = (H263_RFC2190_HDR *)JBuf-&gt;RtpData;
-		int bitOffset = H263HDR_GETSBIT(h263Hdr-&gt;h263hdr);
-		if ((bitOffset == 0) || (curLen == 0))
-		{
-			memcpy(&amp;picture-&gt;video[curLen], JBuf-&gt;RtpData+sizeof(H263_RFC2190_HDR), mLen);
-			curLen += mLen;
-		}
+		//we have reached the last packet for this frame, so mark it
+		if (queuedLen == 0)
+			m_status = m_rtpSession.SendPacket((char*)&amp;RtpData,pkLen+sizeof(H263_RFC2190_HDR),m_payloadType,true/*marker*/,25000);
 		else
-		{
-			uchar mask = (0xFF &gt;&gt; bitOffset) &lt;&lt; bitOffset;
-			picture-&gt;video[curLen-1] &amp;= mask; // Keep most sig bits from last frame
-			picture-&gt;video[curLen-1] |= (*(JBuf-&gt;RtpData+sizeof(H263_RFC2190_HDR)) &amp; (~mask));
-			memcpy(&amp;picture-&gt;video[curLen], JBuf-&gt;RtpData+sizeof(H263_RFC2190_HDR)+1, mLen-1);
-			curLen += mLen-1;
-		}
+			m_status = m_rtpSession.SendPacket((char*)&amp;RtpData,pkLen+sizeof(H263_RFC2190_HDR),m_payloadType,false/*marker*/,0);
 	}
-	return curLen;
 }
 
-void rtpVideo::StreamInVideo()
+void rtpVideo::queueVideoForTransmission(VIDEOBUFFER *videobuffer)
 {
-	RTPPACKET *JBuf;
-	int mLen, reason;
-	//TODO nice typo :D
-	bool MarketBitSet = false;
+	if(transmitBuffer.count() &gt; 3)
+		return;
 
-	// Get a buffer from the Jitter buffer to put the packet in
-	while ( (JBuf = pJitter-&gt;GetJBuffer()) != 0 &amp;&amp;
-	( (JBuf-&gt;len = readPacket( (char *)&amp;JBuf-&gt;RtpVPXCC, sizeof(RTPPACKET) ) ) &gt; 0))
-	{
-		if (PAYLOAD(JBuf) == rtpMPT)
-		{
-			if (JBuf-&gt;RtpMPT &amp; RTP_PAYLOAD_MARKER_BIT)
-				MarketBitSet = true;
+	VIDEOBUFFER *vb = new VIDEOBUFFER;
+	vb-&gt;w = videobuffer-&gt;w;
+	vb-&gt;h = videobuffer-&gt;h;
+	vb-&gt;len = videobuffer-&gt;len;
+	memcpy(vb-&gt;video, videobuffer-&gt;video, vb-&gt;len);
+	m_rtpMutex.lock();
+	transmitBuffer.append(vb);
+	m_rtpMutex.unlock();
+}
 
-			JBuf-&gt;RtpSequenceNumber = ntohs(JBuf-&gt;RtpSequenceNumber);
-			JBuf-&gt;RtpTimeStamp = ntohl(JBuf-&gt;RtpTimeStamp);
-			if (rxFirstFrame)
-			{
-				rxFirstFrame = FALSE;
-				videoFrameFirstSeqNum = rxSeqNum = JBuf-&gt;RtpSequenceNumber;
-			}
-			if (JBuf-&gt;RtpSequenceNumber &lt; videoFrameFirstSeqNum)
-			{
-				kdDebug() &lt;&lt; &quot;Packet arrived too late to play, try increasing jitter buffer&quot; &lt;&lt; endl;
-				pJitter-&gt;FreeJBuffer(JBuf);
-			}
-			else
-				pJitter-&gt;InsertJBuffer(JBuf);
-		}
-		else
-		{
-			kdDebug() &lt;&lt; &quot;Received Invalid Payload &quot; &lt;&lt; (int)JBuf-&gt;RtpMPT &lt;&lt; endl;
-			pJitter-&gt;FreeJBuffer(JBuf);
-		}
+void rtpVideo::handleIncomingPackets(RTPPacket *pack)
+{
+	if(pack-&gt;GetPayloadType() != m_payloadType)
+	{
+		kdDebug() &lt;&lt; &quot;Received invalid payloadType&quot; &lt;&lt; endl;
+		pack-&gt;Dump();
+		return;
 	}
 
-	if (JBuf == 0)
-		kdDebug() &lt;&lt; &quot;No free buffers, aborting network read&quot; &lt;&lt; endl;
+	//get the framesize for this frame... shouldnt chagne though
+	checkFrameSize(pack);
 
-	// Got a buffer but no received frames, free the buffer
-	else if (JBuf-&gt;len &lt;= 0)
-		pJitter-&gt;FreeJBuffer(JBuf);
+	//this is the length of the actual h263-data without headers
+	h263_data_length = pack-&gt;GetPayloadLength() - sizeof(H263_RFC2190_HDR);
 
-	// Currently, whilst we buffer frames until the final one, we use receipt of the final frame
-	// to cause processing of all the received buffers. So any mis-orderering will cause problems!
-	// This should hopefully be flagged by the &quot;VIDEOPKLATE&quot; check above so we will know to fix it!
-	if (MarketBitSet)
+	//handle last packet for this frame
+	if(pack-&gt;HasMarker())
 	{
-		// Check if we have all packets in the sequence up until the marker
-		int vidLen = pJitter-&gt;GotAllBufsInFrame(rxSeqNum, sizeof(H263_RFC2190_HDR));
-		if (vidLen == 0)
+		//kdDebug() &lt;&lt; &quot;Got last packet for this frame&quot; &lt;&lt; endl;
+		memcpy(&amp;m_videoBuffer.video[m_videoBuffer.len], (uchar*)pack-&gt;GetPayloadData()+sizeof(H263_RFC2190_HDR),h263_data_length);
+		m_videoBuffer.len += h263_data_length;
+
+		m_rtpMutex.lock();
+		m_videoBuffer2 = m_videoBuffer;
+		m_rtpMutex.unlock();
+
+		//since we have all packets for this frame, tell our parent about it.
+		if (m_parent)
+			QApplication::postEvent(m_parent, new rtpVideoEvent(rtpVideoEvent::newFrame));
+
+		//reset variables
+		m_videoBuffer.w = m_videoBuffer.h = m_videoBuffer.len = 0;
+	}
+	else//if no marker was set it can be the first packet of a frame or a packet from the middle
+	{
+		// Concatenate received IP packets into a picture buffer, checking we have all we parts
+		H263_RFC2190_HDR *h263Hdr = (H263_RFC2190_HDR *)pack-&gt;GetPayloadData();
+		h263_data_offset = H263HDR_GETSBIT(h263Hdr-&gt;h263hdr);
+		if(h263_data_offset == 0 || m_videoBuffer.len == 0)
 		{
-			kdDebug() &lt;&lt; &quot;RTP Dropping video frame: Lost Packet&quot; &lt;&lt; endl;
-			rxSeqNum = pJitter-&gt;DumpAllJBuffers(true) + 1;
+			memcpy(&amp;m_videoBuffer.video[m_videoBuffer.len], (uchar*)pack-&gt;GetPayloadData()+sizeof(H263_RFC2190_HDR),h263_data_length);
+			m_videoBuffer.len += h263_data_length;
 		}
 		else
 		{
-			VIDEOBUFFER *picture = getVideoBuffer(vidLen);
-			if (picture)
-			{
-				int pictureIndex = 0;
-				bool markerSetOnLastPacket = false;
-				picture-&gt;w = picture-&gt;h = 0;
-
-				// Concatenate received IP packets into a picture buffer, checking we have all we parts
-				while ((JBuf = pJitter-&gt;DequeueJBuffer(rxSeqNum, reason)) != 0)
-				{
-					++rxSeqNum;
-					mLen = JBuf-&gt;len - RTP_HEADER_SIZE - sizeof(H263_RFC2190_HDR);
-					rxTimestamp += mLen;
-					pictureIndex = appendVideoPacket(picture, pictureIndex, JBuf, mLen);
-					if (JBuf-&gt;RtpMPT &amp; RTP_PAYLOAD_MARKER_BIT)
-					{
-						markerSetOnLastPacket = true;
-					}
-					if (picture-&gt;w == 0)
-					{
-						H263_RFC2190_HDR *h263Hdr = (H263_RFC2190_HDR *)JBuf-&gt;RtpData;
-						switch (H263HDR_GETSZ(h263Hdr-&gt;h263hdr))
-						{
-						case H263_SRC_4CIF:  picture-&gt;w = 704; picture-&gt;h = 576; break;
-						default:
-						case H263_SRC_CIF:   picture-&gt;w = 352; picture-&gt;h = 288; break;
-						case H263_SRC_QCIF:  picture-&gt;w = 176; picture-&gt;h = 144; break;
-						case H263_SRC_SQCIF: picture-&gt;w = 128; picture-&gt;h = 96;  break;
-						}
-					}
-					pJitter-&gt;FreeJBuffer(JBuf);
-				}
-
-				// Check rxed frame was not too big
-				if (pictureIndex &gt; (int)sizeof(picture-&gt;video))
-				{
-					kdDebug() &lt;&lt; &quot;Received video frame size &quot; &lt;&lt; pictureIndex &lt;&lt; &quot;; too big for buffer&quot; &lt;&lt; endl;
-					freeVideoBuffer(picture);
-					picture = 0;
-				}
-
-				// Now pass the received picture up to the higher layer. If the last packet has the marker bit set
-				// then we have received a full pictures worth of packets.
-				else if (markerSetOnLastPacket)
-				{
-					picture-&gt;len = pictureIndex;
-
-					// Pass received picture to app
-					rtpMutex.lock();
-					if (rxedVideoFrames.count() &lt; 3)    // Limit no of buffes tied up queueing to app
-					{
-						rxedVideoFrames.append(picture);
-						rtpMutex.unlock();
-					}
-					else
-					{
-						rtpMutex.unlock();
-						freeVideoBuffer(picture);
-						kdDebug() &lt;&lt; &quot;Discarding frame, app consuming too slowly&quot; &lt;&lt; endl;
-					}
-					if (m_parent)
-						QApplication::postEvent(m_parent, new rtpVideoEvent(rtpVideoEvent::newFrame));
-					picture = 0;
-				}
-				else
-				{
-					// We didn't get the whole frame, so dump all buffered packets
-					kdDebug() &lt;&lt; &quot;RTP Dropping video frame: &quot;;
-					switch (reason)
-					{
-					case JB_REASON_DUPLICATE:
-						kdDebug() &lt;&lt; &quot;Duplicate&quot; &lt;&lt; endl;
-						break;
-					case JB_REASON_DTMF:
-						break;
-						kdDebug() &lt;&lt; &quot;DTMF&quot; &lt;&lt; endl;
-					case JB_REASON_MISSING:
-						kdDebug() &lt;&lt; &quot;Missed Packets&quot; &lt;&lt; endl;
-						break;
-					case JB_REASON_EMPTY:
-						kdDebug() &lt;&lt; &quot;Empty&quot; &lt;&lt; endl;
-						break;
-					case JB_REASON_SEQERR:
-						kdDebug() &lt;&lt; &quot;Sequence Error&quot; &lt;&lt; endl;
-						break;
-					default:
-						kdDebug() &lt;&lt; &quot;Unknown&quot; &lt;&lt; endl;
-						break;
-					}
-					rxSeqNum = pJitter-&gt;DumpAllJBuffers(true) + 1;
-					freeVideoBuffer(picture);
-					picture = 0;
-				}
-			}
-			else
-			{
-				kdDebug() &lt;&lt; &quot;No buffers for video frame, dropping&quot; &lt;&lt; endl;
-				rxSeqNum = pJitter-&gt;DumpAllJBuffers(true) + 1;
-			}
+			uchar mask = (0xFF &gt;&gt; h263_data_offset) &lt;&lt; h263_data_offset;
+			m_videoBuffer.video[m_videoBuffer.len-1] &amp;= mask; // Keep most sig bits from last frame
+			m_videoBuffer.video[m_videoBuffer.len-1] |= (*(pack-&gt;GetPayloadData()+sizeof(H263_RFC2190_HDR)) &amp; (~mask));
+			memcpy(&amp;m_videoBuffer.video[m_videoBuffer.len], pack-&gt;GetPayloadData()+sizeof(H263_RFC2190_HDR)+1, h263_data_length-1);
+			m_videoBuffer.len += h263_data_length-1;
 		}
-		videoFrameFirstSeqNum = rxSeqNum;
 	}
 }
-

Modified: konference/src/rtp/rtpvideo.h
===================================================================
--- konference/src/rtp/rtpvideo.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/rtpvideo.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -22,19 +22,26 @@
 
 #include &lt;qptrlist.h&gt;
 #include &lt;qevent.h&gt;
+#include &lt;qthread.h&gt;
 
-#include &quot;rtpbase.h&quot;
+#include &quot;rtpsession.h&quot;
 
+#define IP_MTU                    1290     // Max size of txed RTP packet. Standard MTU is 1500, leave some room for IPSec etc
+#define IP_MAX_MTU                1500     // Max size of rxed RTP packet
+#define RTP_HEADER_SIZE           12
+#define UDP_HEADER_SIZE           28
+
 typedef struct
 {
 	ulong h263hdr;
 }
 H263_RFC2190_HDR;
 
+
 #define H263HDR(s)              ((s)&lt;&lt;13)
 #define H263HDR_GETSZ(h)        (((h)&gt;&gt;13) &amp; 0x7)
 #define H263HDR_GETSBIT(h)      (((h)&gt;&gt;3) &amp; 0x7)
-#define H263HDR_GETEBIT(h)      ((h) &amp; 0x7)
+//#define H263HDR_GETEBIT(h)      ((h) &amp; 0x7)
 
 #define H263_SRC_SQCIF          1
 #define H263_SRC_QCIF           2
@@ -43,7 +50,8 @@
 #define H263_SRC_16CIF          5
 
 
-#define H263SPACE               (IP_MTU-RTP_HEADER_SIZE-UDP_HEADER_SIZE-sizeof(H263_RFC2190_HDR))
+#define H263SPACE          (IP_MTU-RTP_HEADER_SIZE-UDP_HEADER_SIZE-sizeof(H263_RFC2190_HDR))
+#define MAX_PAYLOAD_LENGTH (IP_MTU-RTP_HEADER_SIZE-UDP_HEADER_SIZE)
 
 #define MAX_VIDEO_LEN 256000
 
@@ -58,54 +66,53 @@
 class rtpVideoEvent : public QCustomEvent
 {
 public:
-    enum type { newFrame = (QEvent::User + 300)};
-    rtpVideoEvent(type t) : QCustomEvent(t) {}
+	enum type{newFrame};
+	rtpVideoEvent(type t) : QCustomEvent(t) {};
 };
 
 /**
<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">- at author</A> Malte B&#246;hme
-*/
-class rtpVideo : public rtpBase, QThread
+ * class that handles video-rtp hgandling/transmission.
+ * This class also handles (de-)packetization for h263 frames.
+ * currently only h263 is supported.
+ * when a new frame is received,rtpVideoEvent::newFrame is postet
+ * to the parent object. get a received frame through getReceivedFrame()
+ * queueVideoForTransmission() enqueues frames for transmission.
+ *
+ * @author Malte B&#246;hme
+ */
+class rtpVideo : public QThread
 {
 public:
-	rtpVideo(QObject *parent, int localPort, QString remoteIP, int remotePort, int mediaPay, rtpTxMode txm, rtpRxMode rxm);
-	VIDEOBUFFER *getRxedVideo();
-	VIDEOBUFFER *getVideoBuffer(int len=0);
-	bool queueVideo(VIDEOBUFFER *vb);
-	void freeVideoBuffer(VIDEOBUFFER *vb);
-	void destroyVideoBuffers();
-	void transmitQueuedVideo();
-	void initialise();
+	rtpVideo(QObject *parent, int localPort, QString remoteIP, int remotePort, int payloadType, float fps);
 	~rtpVideo();
 	void run();
-	void StreamInVideo();
-	int  appendVideoPacket(VIDEOBUFFER *picture, int curLen, RTPPACKET *JBuf, int mLen);
+	void stop(){m_killThread = true;};
+	/**
+	 * Writes the new frame to videobuffer
+	 * the data is memcpy'ed to the videobuffer.
+	 */
+	void getReceivedFrame(VIDEOBUFFER *videobuffer);
+	/**
+	 * Enqueues a videobuffer for transmission
+	 * the data is memcpy'ed from the videobuffer.
+	 */
+	void queueVideoForTransmission(VIDEOBUFFER *videobuffer);
+private:
+	void handleIncomingPackets(RTPPacket *pack);
+	void handleOutgoingPackets();
 
-protected:
+	void checkFrameSize(RTPPacket *pack);
+	int m_status;//used for jrtplib-error-checks
+	int h263_data_length;//lenght of actual h263-data in the rtp packet (excluding rtp and h263 headers)
+	int h263_data_offset;
+	RTPSession m_rtpSession;
+	bool m_killThread;
+	int m_payloadType;
+	VIDEOBUFFER m_videoBuffer;
+	VIDEOBUFFER m_videoBuffer2;
+	QPtrList&lt;VIDEOBUFFER&gt; transmitBuffer;
 	QObject *m_parent;
-	
-	Jitter *pJitter;
-
-	int videoPayload;
-	QPtrList&lt;VIDEOBUFFER&gt; FreeVideoBufferQ;
-	QPtrList&lt;VIDEOBUFFER&gt; rxedVideoFrames;
-	VIDEOBUFFER *videoToTx;
-	int videoFrameFirstSeqNum;
-
-	rtpTxMode txMode;
-	rtpRxMode rxMode;
-
-	unsigned long txTimeStamp;
-	
-	unsigned long rxTimestamp;
-	unsigned short rxSeqNum;
-
-	bool rxFirstFrame;
-
-	bool killRtpThread;
-
-	uchar rtpMarker;
-	uchar rtpMPT;
+	QMutex m_rtpMutex;
 };
 
 #endif

Modified: konference/src/sip/sipfsm.cpp
===================================================================
--- konference/src/sip/sipfsm.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/sip/sipfsm.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -35,39 +35,495 @@
 #ifndef WIN32
 #include &lt;sys/ioctl.h&gt;
 #include &lt;unistd.h&gt;
+//#include &lt;pthread.h&gt;
 #include &lt;netdb.h&gt;
 #include &lt;netinet/in.h&gt;
 #include &lt;net/if.h&gt;
-
+//#include &lt;linux/sockios.h&gt;
+//#include &lt;linux/videodev.h&gt;
+//#include &lt;mythtv/mythcontext.h&gt;
 #include &quot;config.h&quot;
 #endif
 
+//#ifdef WIN32
+//#include &lt;winsock2.h&gt;
+//#include &quot;gcontext.h&quot;
+//#endif
+
 using namespace std;
 
 #include &quot;sipfsm.h&quot;
 #include &quot;sipsdp.h&quot;
 #include &quot;sipxpidf.h&quot;
-#include &quot;sipthread.h&quot;
-#include &quot;sipfsmbase.h&quot;
-#include &quot;sipcall.h&quot;
 
 // Static variables for the debug file used
+QFile *debugFile;
+QTextStream *debugStream;
+QObject *eventWindow;
+QStringList EventQ;
+QStringList NotifyQ;
+QMutex EventQLock;
+QString localIp;
+QString natIp;
 
+
+
 /**********************************************************************
+SipContainer
+ 
+This is a container class that runs the SIP protocol stack within a 
+separate thread and controls communication with it. This is done
+such that the SIP protocol stack can run in the background regardless
+of which Myth frontend has focus.
+ 
+**********************************************************************/
+
+SipContainer::SipContainer(int listenPort)
+{
+	killSipThread = false;
+	CallState = -1;
+	eventWindow = 0;
+
+	sipThread = new SipThread(this);
+	sipThread-&gt;start();
+}
+
+SipContainer::~SipContainer()
+{
+	killSipThread = true;
+	sipThread-&gt;wait();
+	delete sipThread;
+}
+
+void SipContainer::PlaceNewCall(QString Mode, QString uri, QString name, bool disableNat)
+{
+	EventQLock.lock();
+	EventQ.append(&quot;PLACECALL&quot;);
+	EventQ.append(Mode);
+	EventQ.append(uri);
+	EventQ.append(name);
+	EventQ.append(disableNat ? &quot;DisableNAT&quot; : &quot;EnableNAT&quot;);
+	EventQLock.unlock();
+}
+
+void SipContainer::AnswerRingingCall(QString Mode, bool disableNat)
+{
+	EventQLock.lock();
+	EventQ.append(&quot;ANSWERCALL&quot;);
+	EventQ.append(Mode);
+	EventQ.append(disableNat ? &quot;DisableNAT&quot; : &quot;EnableNAT&quot;);
+	EventQLock.unlock();
+}
+
+void SipContainer::HangupCall()
+{
+	EventQLock.lock();
+	EventQ.append(&quot;HANGUPCALL&quot;);
+	EventQLock.unlock();
+}
+
+void SipContainer::UiOpened(QObject *callingApp)
+{
+	EventQLock.lock();
+	eventWindow = callingApp;
+	EventQ.append(&quot;UIOPENED&quot;);
+	EventQLock.unlock();
+}
+
+void SipContainer::UiClosed()
+{
+	EventQLock.lock();
+	eventWindow = 0;
+	EventQ.append(&quot;UICLOSED&quot;);
+	EventQLock.unlock();
+}
+
+void SipContainer::UiWatch(QStrList uriList)
+{
+	QStrListIterator it(uriList);
+
+	EventQLock.lock();
+	EventQ.append(&quot;UIWATCH&quot;);
+	for (; it.current(); ++it)
+		EventQ.append(it.current());
+	EventQ.append(&quot;&quot;);
+	EventQLock.unlock();
+}
+
+void SipContainer::UiWatch(QString uri)
+{
+	EventQLock.lock();
+	EventQ.append(&quot;UIWATCH&quot;);
+	EventQ.append(uri);
+	EventQ.append(&quot;&quot;);
+	EventQLock.unlock();
+}
+
+void SipContainer::UiStopWatchAll()
+{
+	EventQLock.lock();
+	EventQ.append(&quot;UISTOPWATCHALL&quot;);
+	EventQLock.unlock();
+}
+
+QString SipContainer::UiSendIMMessage(QString DestUrl, QString CallId, QString Msg)
+{
+	SipCallId sipCallId;
+
+	if (CallId.length() == 0)
+	{
+		sipCallId.Generate(localIp);
+		CallId = sipCallId.string();
+	}
+
+	EventQLock.lock();
+	EventQ.append(&quot;SENDIM&quot;);
+	EventQ.append(DestUrl);
+	EventQ.append(CallId);
+	EventQ.append(Msg);
+	EventQLock.unlock();
+	return CallId;
+}
+
+
+int SipContainer::GetSipState()
+{
+	int tempState;
+	EventQLock.lock();
+	tempState = CallState;
+	EventQLock.unlock();
+	return tempState;
+}
+
+bool SipContainer::GetNotification(QString &amp;type, QString &amp;url, QString &amp;param1, QString &amp;param2)
+{
+	bool notifyFlag = false;
+	EventQLock.lock();
+
+	if (!NotifyQ.empty())
+	{
+		QStringList::Iterator it;
+		notifyFlag = true;
+		it = NotifyQ.begin();
+		type = *it;
+		it = NotifyQ.remove(it);
+		url = *it;
+		it = NotifyQ.remove(it);
+		param1 = *it;
+		it = NotifyQ.remove(it);
+		param2 = *it;
+		NotifyQ.remove(it);
+	}
+
+	EventQLock.unlock();
+	return notifyFlag;
+}
+
+void SipContainer::GetRegistrationStatus(bool &amp;Registered, QString &amp;RegisteredTo, QString &amp;RegisteredAs)
+{
+	EventQLock.lock();
+	Registered = regStatus;
+	RegisteredTo = regTo;
+	RegisteredAs = regAs;
+	EventQLock.unlock();
+}
+
+void SipContainer::GetIncomingCaller(QString &amp;u, QString &amp;d, QString &amp;l, bool &amp;a)
+{
+	EventQLock.lock();
+	u = callerUser;
+	d = callerName;
+	l = callerUrl;
+	a = inAudioOnly;
+	EventQLock.unlock();
+}
+
+void SipContainer::GetSipSDPDetails(QString &amp;ip, int &amp;aport, int &amp;audPay, QString &amp;audCodec, int &amp;dtmfPay, int &amp;vport, int &amp;vidPay, QString &amp;vidCodec, QString &amp;vidRes)
+{
+	EventQLock.lock();
+	ip = remoteIp;
+	aport = remoteAudioPort;
+	vport = remoteVideoPort;
+	audPay = audioPayload;
+	audCodec = audioCodec;
+	dtmfPay = dtmfPayload;
+	vidPay = videoPayload;
+	vidCodec = videoCodec;
+	vidRes = videoRes;
+	EventQLock.unlock();
+}
+
+QString SipContainer::getLocalIpAddress()
+{
+	return localIp;
+}
+
+QString SipContainer::getNatIpAddress()
+{
+	return natIp;
+}
+
+
+/**********************************************************************
+SipThread
+ 
+The main SIP thread that polls for events and handles communication
+with the user via the SipContainer class
+**********************************************************************/
+
+void SipThread::run()
+{
+	SipThreadWorker();
+}
+
+void SipThread::SipThreadWorker()
+{
+	FrontEndActive = false;
+	rnaTimer = -1;
+	// Open a file for writing debug info into
+	char *homeDir = getenv(&quot;HOME&quot;);
+	QString debugFileName = QString(homeDir) + &quot;/.mythtv/MythPhone/siplog.txt&quot;;
+	debugFile = new QFile(debugFileName);
+	if (debugFile-&gt;open(IO_WriteOnly))
+		debugStream = new QTextStream (debugFile);
+
+	SipFsm *sipFsm = new SipFsm();
+
+	if (sipFsm-&gt;SocketOpenedOk())
+	{
+		while(!sipContainer-&gt;killThread())
+		{
+			int OldCallState = CallState;
+
+			// This blocks for timeout or data in Linux
+			CheckNetworkEvents(sipFsm);
+			CheckUIEvents(sipFsm);
+			CheckRegistrationStatus(sipFsm); // Probably don't need to do this every 1/2 sec but this is a fallout of a non event-driven arch.
+			sipFsm-&gt;HandleTimerExpiries();
+			ChangePrimaryCallState(sipFsm, sipFsm-&gt;getPrimaryCallState());
+
+			// A Ring No Answer timer runs to send calls to voicemail after x seconds
+			if ((CallState == SIP_ICONNECTING) &amp;&amp; (rnaTimer != -1))
+			{
+				if (--rnaTimer &lt; 0)
+				{
+					rnaTimer = -1;
+					//vxmlCallActive = true;
+					sipFsm-&gt;Answer(true, &quot;&quot;, false);
+				}
+			}
+
+			ChangePrimaryCallState(sipFsm, sipFsm-&gt;getPrimaryCallState());
+
+			EventQLock.lock();
+			if ((OldCallState != CallState) &amp;&amp; (eventWindow))
+				QApplication::postEvent(eventWindow, new SipEvent(SipEvent::SipStateChange));
+			EventQLock.unlock();
+		}
+	}
+
+	delete sipFsm;
+	if (debugStream)
+		delete debugStream;
+	if (debugFile)
+	{
+		debugFile-&gt;close();
+		delete debugFile;
+	}
+}
+
+void SipThread::CheckUIEvents(SipFsm *sipFsm)
+{
+	QString event;
+	QStringList::Iterator it;
+
+	// Check why we awoke
+	event = &quot;&quot;;
+	EventQLock.lock();
+	if (!EventQ.empty())
+	{
+		it = EventQ.begin();
+		event = *it;
+		EventQ.remove(it);
+	}
+	EventQLock.unlock();
+
+	if (event == &quot;PLACECALL&quot;)
+	{
+		EventQLock.lock();
+		it = EventQ.begin();
+		QString Mode = *it;
+		it = EventQ.remove(it);
+		QString Uri = *it;
+		it = EventQ.remove(it);
+		QString Name = *it;
+		it = EventQ.remove(it);
+		QString UseNat = *it;
+		EventQ.remove(it);
+		EventQLock.unlock();
+		sipFsm-&gt;NewCall(Mode == &quot;AUDIOONLY&quot; ? true : false, Uri, Name, Mode, UseNat == &quot;DisableNAT&quot; ? true : false);
+	}
+	else if (event == &quot;ANSWERCALL&quot;)
+	{
+		EventQLock.lock();
+		it = EventQ.begin();
+		QString Mode = *it;
+		it = EventQ.remove(it);
+		QString UseNat = *it;
+		EventQ.remove(it);
+		EventQLock.unlock();
+		sipFsm-&gt;Answer(Mode == &quot;AUDIOONLY&quot; ? true : false, Mode, UseNat == &quot;DisableNAT&quot; ? true : false);
+	}
+	else if (event == &quot;HANGUPCALL&quot;)
+		sipFsm-&gt;HangUp();
+	else if (event == &quot;UIOPENED&quot;)
+	{
+		sipFsm-&gt;StatusChanged(&quot;OPEN&quot;);
+		FrontEndActive = true;
+	}
+	else if (event == &quot;UICLOSED&quot;)
+	{
+		sipFsm-&gt;StatusChanged(&quot;CLOSED&quot;);
+		FrontEndActive = false;
+	}
+	else if (event == &quot;UIWATCH&quot;)
+	{
+		QString uri;
+		do
+		{
+			EventQLock.lock();
+			it = EventQ.begin();
+			uri = *it;
+			EventQ.remove(it);
+			EventQLock.unlock();
+			if (uri.length() &gt; 0)
+				sipFsm-&gt;CreateWatcherFsm(uri);
+		}
+		while (uri.length() &gt; 0);
+	}
+	else if (event == &quot;UISTOPWATCHALL&quot;)
+		sipFsm-&gt;StopWatchers();
+	else if (event == &quot;SENDIM&quot;)
+	{
+		EventQLock.lock();
+		it = EventQ.begin();
+		QString DestUrl = *it;
+		it = EventQ.remove(it);
+		QString CallId = *it;
+		it = EventQ.remove(it);
+		QString imMsg = *it;
+		EventQ.remove(it);
+		EventQLock.unlock();
+		sipFsm-&gt;SendIM(DestUrl, CallId, imMsg);
+	}
+
+	ChangePrimaryCallState(sipFsm, sipFsm-&gt;getPrimaryCallState());
+}
+
+void SipThread::CheckRegistrationStatus(SipFsm *sipFsm)
+{
+	sipContainer-&gt;notifyRegistrationStatus(sipFsm-&gt;isRegistered(), sipFsm-&gt;registeredTo(),
+	                                       sipFsm-&gt;registeredAs());
+}
+
+void SipThread::CheckNetworkEvents(SipFsm *sipFsm)
+{
+	// Check for incoming SIP messages
+	sipFsm-&gt;CheckRxEvent();
+
+	// We only handle state changes in the &quot;primary&quot; call; we ignore additional calls which are
+	// currently just rejected with busy
+	ChangePrimaryCallState(sipFsm, sipFsm-&gt;getPrimaryCallState());
+}
+
+
+void SipThread::ChangePrimaryCallState(SipFsm *sipFsm, int NewState)
+{
+	int OldState = CallState;
+	CallState = NewState;
+	sipContainer-&gt;notifyCallState(CallState);
+
+	if (OldState != CallState)
+	{
+		if (CallState == SIP_IDLE)
+		{
+			callerUser = &quot;&quot;;
+			callerName = &quot;&quot;;
+			callerUrl = &quot;&quot;;
+			inAudioOnly = true;
+			sipContainer-&gt;notifyCallerDetails(callerUser, callerName, callerUrl, inAudioOnly);
+			remoteIp = &quot;0.0.0.0&quot;;
+			remoteAudioPort = -1;
+			remoteVideoPort = -1;
+			audioPayload = -1;
+			dtmfPayload = -1;
+			videoPayload = -1;
+			audioCodec = &quot;&quot;;
+			videoCodec = &quot;&quot;;
+			videoRes = &quot;&quot;;
+			sipContainer-&gt;notifySDPDetails(remoteIp, remoteAudioPort, audioPayload, audioCodec, dtmfPayload, remoteVideoPort, videoPayload, videoCodec, videoRes);
+		}
+
+		if (CallState == SIP_ICONNECTING)
+		{
+			// new incoming call; get the caller info
+			EventQLock.lock();
+			SipCall *call = sipFsm-&gt;MatchCall(sipFsm-&gt;getPrimaryCall());
+			if (call != 0)
+			{
+				call-&gt;GetIncomingCaller(callerUser, callerName, callerUrl, inAudioOnly);
+				sipContainer-&gt;notifyCallerDetails(callerUser, callerName, callerUrl, inAudioOnly);
+			}
+			EventQLock.unlock();
+
+			rnaTimer = 10;//TODO atoi((const char *)gContext-&gt;GetSetting(&quot;TimeToAnswer&quot;)) * SIP_POLL_PERIOD;
+		}
+		else
+			rnaTimer = -1;
+
+
+		if (CallState == SIP_CONNECTED)
+		{
+			// connected call; get the SDP info
+			EventQLock.lock();
+			SipCall *call = sipFsm-&gt;MatchCall(sipFsm-&gt;getPrimaryCall());
+			if (call != 0)
+			{
+				call-&gt;GetSdpDetails(remoteIp, remoteAudioPort, audioPayload, audioCodec, dtmfPayload, remoteVideoPort, videoPayload, videoCodec, videoRes);
+				sipContainer-&gt;notifySDPDetails(remoteIp, remoteAudioPort, audioPayload, audioCodec, dtmfPayload, remoteVideoPort, videoPayload, videoCodec, videoRes);
+
+			}
+			EventQLock.unlock();
+
+		}
+
+		//TODO sipstack should not have to know anything about the gui!!!
+		if ((CallState == SIP_ICONNECTING) &amp;&amp; (FrontEndActive == false))
+		{
+			// No application running to tell of the incoming call
+			// Either alert via on-screen popup or send to voicemail
+			//			SipNotify *notify = new SipNotify();
+			//			notify-&gt;Display(callerName, callerUrl);
+			//			delete notify;
+		}
+	}
+}
+
+
+/**********************************************************************
 SipFsm
  
 This class forms the container class for the SIP FSM, and creates call
 instances which handle actual events.
 **********************************************************************/
 
-SipFsm::SipFsm(SipContainer *container, QWidget *parent, const char *name)
+SipFsm::SipFsm(QWidget *parent, const char *name)
 		: QWidget( parent, name )
 {
 	callCount = 0;
 	primaryCall = -1;
 	PresenceStatus = &quot;CLOSED&quot;;
-	m_sipContainer = container;
-	
+
 	sipSocket = 0;
 	localPort = 5060;//TODO atoi((const char *)gContext-&gt;GetSetting(&quot;SipLocalPort&quot;));
 
@@ -75,7 +531,7 @@
 	natIp = DetermineNatAddress();
 	if (natIp.length() == 0)
 		natIp = localIp;
-//	SipFsm::Debug(SipDebugEvent::SipDebugEv, QString(&quot;SIP listening on IP Address &quot;) + localIp + &quot;:&quot; + QString::number(localPort) + &quot; NAT address &quot; + natIp + &quot;\n\n&quot;);
+	SipFsm::Debug(SipDebugEvent::SipDebugEv, QString(&quot;SIP listening on IP Address &quot;) + localIp + &quot;:&quot; + QString::number(localPort) + &quot; NAT address &quot; + natIp + &quot;\n\n&quot;);
 	cout &lt;&lt; &quot;SIP listening on IP Address &quot; &lt;&lt; localIp &lt;&lt; &quot;:&quot; &lt;&lt; localPort &lt;&lt; &quot; NAT address &quot; &lt;&lt; natIp &lt;&lt; endl;
 
 	// Create the timer list
@@ -85,13 +541,17 @@
 	sipRegistrar = new SipRegistrar(this, &quot;maldn&quot;, localIp, localPort);
 
 	// if Proxy Registration is configured ...
-	bool RegisterWithProxy = true;//TODO gContext-&gt;GetNumSetting(&quot;SipRegisterWithProxy&quot;,1);
+	bool RegisterWithProxy = false;//TODO gContext-&gt;GetNumSetting(&quot;SipRegisterWithProxy&quot;,1);
 	sipRegistration = 0;
 	if (RegisterWithProxy)
 	{
 		QString ProxyDNS = &quot;sipgate.de&quot;;//TODO gContext-&gt;GetSetting(&quot;SipProxyName&quot;);
 		QString ProxyUsername = &quot;8925303&quot;;//TODO gContext-&gt;GetSetting(&quot;SipProxyAuthName&quot;);
-		QString ProxyPassword = &quot;wonttellyou :-)&quot;;//TODO gContext-&gt;GetSetting(&quot;SipProxyAuthPassword&quot;);
+		QString ProxyPassword = &quot;DKTYHV&quot;;//TODO gContext-&gt;GetSetting(&quot;SipProxyAuthPassword&quot;);
+		//QString ProxyDNS = &quot;fwd.pulver.com&quot;;//TODO gContext-&gt;GetSetting(&quot;SipProxyName&quot;);
+		//QString ProxyUsername = &quot;603123&quot;;//TODO gContext-&gt;GetSetting(&quot;SipProxyAuthName&quot;);
+		//QString ProxyPassword = &quot;loppy&quot;;//TODO gContext-&gt;GetSetting(&quot;SipProxyAuthPassword&quot;);
+		
 		if ((ProxyDNS.length() &gt; 0) &amp;&amp; (ProxyUsername.length() &gt; 0) &amp;&amp; (ProxyPassword.length() &gt; 0))
 		{
 			sipRegistration = new SipRegistration(this, natIp, localPort, ProxyUsername, ProxyPassword, ProxyDNS, 5060);
@@ -113,6 +573,17 @@
 	CloseSocket();
 }
 
+void SipFsm::Debug(SipDebugEvent::Type t, QString dbg)
+{
+#ifdef WIN32
+	if (eventWindow)
+		QApplication::postEvent(eventWindow, new SipDebugEvent(t, dbg));
+#else
+	if ((debugStream) &amp;&amp; ((t == SipDebugEvent::SipTraceRxEv) || (t == SipDebugEvent::SipTraceTxEv)))
+		*debugStream &lt;&lt; dbg;
+#endif
+}
+
 QString SipFsm::OpenSocket(int Port)
 {
 	sipSocket = new QSocketDevice (QSocketDevice::Datagram);
@@ -156,8 +627,8 @@
 QString SipFsm::DetermineNatAddress()
 {
 	QString natIP = &quot;&quot;;
-	QString NatTraversalMethodStr = &quot;None&quot;;//TODO gContext-&gt;GetSetting(&quot;NatTraversalMethod&quot;);
-
+	//QString NatTraversalMethodStr = &quot;Web Server&quot;;//TODO gContext-&gt;GetSetting(&quot;NatTraversalMethod&quot;);
+	QString NatTraversalMethodStr = &quot;Manual&quot;;
 	if (NatTraversalMethodStr == &quot;Manual&quot;)
 	{
 		//TODO natIP = gContext-&gt;GetSetting(&quot;NatIpAddress&quot;);
@@ -241,7 +712,7 @@
 	{
 		QHostAddress dest;
 		dest.setAddress(destIP);
-		//SipFsm::Debug(SipDebugEvent::SipTraceTxEv, QDateTime::currentDateTime().toString() + &quot; Sent to &quot; + destIP + &quot;:&quot; + QString::number(destPort) + &quot;...\n&quot; + Msg + &quot;\n&quot;);
+		SipFsm::Debug(SipDebugEvent::SipTraceTxEv, QDateTime::currentDateTime().toString() + &quot; Sent to &quot; + destIP + &quot;:&quot; + QString::number(destPort) + &quot;...\n&quot; + Msg + &quot;\n&quot;);
 		sipSocket-&gt;writeBlock((const char *)Msg, Msg.length(), dest, destPort);
 	}
 	else
@@ -257,7 +728,7 @@
 		if (len &gt; 0)
 		{
 			rxMsg[len] = 0;
-			//SipFsm::Debug(SipDebugEvent::SipTraceRxEv, QDateTime::currentDateTime().toString() + &quot; Received: Len &quot; + QString::number(len) + &quot;\n&quot; + rxMsg + &quot;\n&quot;);
+			SipFsm::Debug(SipDebugEvent::SipTraceRxEv, QDateTime::currentDateTime().toString() + &quot; Received: Len &quot; + QString::number(len) + &quot;\n&quot; + rxMsg + &quot;\n&quot;);
 			sipMsg.decode(rxMsg);
 			return true;
 		}
@@ -400,14 +871,17 @@
 
 void SipFsm::SetNotification(QString type, QString uri, QString param1, QString param2)
 {
-	m_sipContainer-&gt;getEventQueueMutex()-&gt;lock();
-		m_sipContainer-&gt;getNotifyQueue()-&gt;append(type);
-		m_sipContainer-&gt;getNotifyQueue()-&gt;append(uri);
-		m_sipContainer-&gt;getNotifyQueue()-&gt;append(param1);
-		m_sipContainer-&gt;getNotifyQueue()-&gt;append(param2);
+	EventQLock.lock();
+	if (eventWindow) // Is there someone listening?
+	{
+		NotifyQ.append(type);
+		NotifyQ.append(uri);
+		NotifyQ.append(param1);
+		NotifyQ.append(param2);
 
-		QApplication::postEvent(m_sipContainer-&gt;getParent(), new SipEvent(SipEvent::SipNotification));
-	m_sipContainer-&gt;getEventQueueMutex()-&gt;unlock();
+		QApplication::postEvent(eventWindow, new SipEvent(SipEvent::SipNotification));
+	}
+	EventQLock.unlock();
 }
 
 
@@ -455,7 +929,7 @@
 	SipFsmBase *it;
 	for (it=FsmList.first(); it; it=FsmList.next())
 		if ((it-&gt;type() == &quot;CALL&quot;) &amp;&amp; (it-&gt;getCallRef() == cr))
-			return (dynamic_cast&lt;SipCall *&gt;(it));//TODO
+			return (dynamic_cast&lt;SipCall *&gt;(it));
 	return 0;
 }
 
@@ -588,7 +1062,900 @@
 			it-&gt;FSM(SIP_PRESENCE_CHANGE, 0, newStatus);
 }
 
+
+
+
 /**********************************************************************
+SipFsmBase
+ 
+A base class for FSM which defines a set of default procedures that are
+used by the derived classes.
+**********************************************************************/
+
+SipFsmBase::SipFsmBase(SipFsm *p)
+{
+	parent = p;
+	remoteUrl = 0;
+	toUrl = 0;
+	contactUrl = 0;
+	recRouteUrl = 0;
+	remoteTag = &quot;&quot;;
+	remoteEpid = &quot;&quot;;
+	rxedTo = &quot;&quot;;
+	rxedFrom = &quot;&quot;;
+	MyUrl = 0;
+	MyContactUrl = 0;
+	sentAuthenticated = false;
+}
+
+SipFsmBase::~SipFsmBase()
+{
+	if (remoteUrl != 0)
+		delete remoteUrl;
+	if (toUrl != 0)
+		delete toUrl;
+	if (contactUrl != 0)
+		delete contactUrl;
+	if (recRouteUrl != 0)
+		delete recRouteUrl;
+	if (MyUrl != 0)
+		delete MyUrl;
+	if (MyContactUrl != 0)
+		delete MyContactUrl;
+
+	remoteUrl = 0;
+	toUrl = 0;
+	contactUrl = 0;
+	recRouteUrl = 0;
+	MyUrl = 0;
+	MyContactUrl = 0;
+}
+
+bool SipFsmBase::Retransmit(bool force)
+{
+	if (force || (t1 &lt; 8000))
+	{
+		t1 *= 2;
+		if ((retx.length() &gt; 0) &amp;&amp; (retxIp.length() &gt; 0))
+		{
+			parent-&gt;Transmit(retx, retxIp, retxPort);
+			return true;
+		}
+	}
+	return false;
+}
+
+void SipFsmBase::ParseSipMsg(int Event, SipMsg *sipMsg)
+{
+	// Pull out Remote TAG
+	remoteTag = (SIP_CMD(Event)) ? sipMsg-&gt;getFromTag() : sipMsg-&gt;getToTag();
+	remoteEpid = (SIP_CMD(Event)) ? sipMsg-&gt;getFromEpid() : QString(&quot;&quot;);
+
+	// Pull out VIA, To and From information from CMDs to send back in Status
+	if (SIP_CMD(Event))
+	{
+		rxedTo   = sipMsg-&gt;getCompleteTo();
+		rxedFrom = sipMsg-&gt;getCompleteFrom();
+		RecRoute = sipMsg-&gt;getCompleteRR();
+		Via      = sipMsg-&gt;getCompleteVia();
+		CallId   = *(sipMsg-&gt;getCallId());
+		viaIp    = sipMsg-&gt;getViaIp();
+		viaPort  = sipMsg-&gt;getViaPort();
+		if (remoteUrl == 0)
+			remoteUrl = new SipUrl(sipMsg-&gt;getFromUrl());
+		if (toUrl == 0)
+			toUrl = new SipUrl(sipMsg-&gt;getToUrl());
+	}
+
+	// Pull out Contact info
+	SipUrl *s;
+	if ((s = sipMsg-&gt;getContactUrl()) != 0)
+	{
+		if (contactUrl)
+			delete contactUrl;
+		contactUrl = new SipUrl(s);
+	}
+
+	// Pull out Record Route info
+	if ((s = sipMsg-&gt;getRecRouteUrl()) != 0)
+	{
+		if (recRouteUrl)
+			delete recRouteUrl;
+		recRouteUrl = new SipUrl(s);
+	}
+}
+
+void SipFsmBase::BuildSendStatus(int Code, QString Method, int statusCseq, int Option, int statusExpires, QString sdp)
+{
+	if (remoteUrl == 0)
+	{
+		cerr &lt;&lt; &quot;URL variables not setup\n&quot;;
+		return;
+	}
+
+	SipMsg Status(Method);
+	Status.addStatusLine(Code);
+	if (RecRoute.length() &gt; 0)
+		Status.addRRCopy(RecRoute);
+	if (Via.length() &gt; 0)
+		Status.addViaCopy(Via);
+	Status.addFromCopy(rxedFrom);
+	Status.addToCopy(rxedTo);
+	Status.addCallId(&amp;CallId);
+	Status.addCSeq(statusCseq);
+	if ((Option &amp; SIP_OPT_EXPIRES) &amp;&amp; (statusExpires &gt;= 0))
+		Status.addExpires(statusExpires);
+
+	if (Option &amp; SIP_OPT_ALLOW) // Add my Contact URL to the message
+		Status.addAllow();
+	if (Option &amp; SIP_OPT_CONTACT) // Add my Contact URL to the message
+		Status.addContact(*MyContactUrl);
+	if (Option &amp; SIP_OPT_SDP) // Add an SDP to the message
+		Status.addContent(&quot;application/sdp&quot;, sdp);
+	else
+		Status.addNullContent();
+
+	// Send STATUS messages to the VIA address
+	parent-&gt;Transmit(Status.string(), retxIp = viaIp, retxPort = viaPort);
+
+	if (((Code &gt;= 200) &amp;&amp; (Code &lt;= 299)) &amp;&amp; (Method == &quot;INVITE&quot;))
+	{
+		retx = Status.string();
+		t1 = 500;
+		(parent-&gt;Timer())-&gt;Start(this, t1, SIP_RETX);
+	}
+}
+
+
+void SipFsmBase::DebugFsm(int event, int old_state, int new_state)
+{
+	SipFsm::Debug(SipDebugEvent::SipDebugEv, &quot;SIP FSM: Event &quot; + EventtoString(event) + &quot; : &quot;
+	              + StatetoString(old_state) + &quot; -&gt; &quot; + StatetoString(new_state) + &quot;\n&quot;);
+}
+
+
+QString SipFsmBase::EventtoString(int Event)
+{
+	switch (Event)
+	{
+	case SIP_OUTCALL:             return &quot;OUTCALL&quot;;
+	case SIP_REGISTER:            return &quot;REGISTER&quot;;
+	case SIP_INVITE:              return &quot;INVITE&quot;;
+	case SIP_INVITESTATUS_3456xx: return &quot;INVST-3456xx&quot;;
+	case SIP_INVITESTATUS_2xx:    return &quot;INVSTAT-2xx&quot;;
+	case SIP_INVITESTATUS_1xx:    return &quot;INVSTAT-1xx&quot;;
+	case SIP_ANSWER:              return &quot;ANSWER&quot;;
+	case SIP_ACK:                 return &quot;ACK&quot;;
+	case SIP_BYE:                 return &quot;BYE&quot;;
+	case SIP_CANCEL:              return &quot;CANCEL&quot;;
+	case SIP_HANGUP:              return &quot;HANGUP&quot;;
+	case SIP_BYESTATUS:           return &quot;BYESTATUS&quot;;
+	case SIP_CANCELSTATUS:        return &quot;CANCSTATUS&quot;;
+	case SIP_RETX:                return &quot;RETX&quot;;
+	case SIP_REGISTRAR_TEXP:      return &quot;REGITRAR_T&quot;;
+	case SIP_REGSTATUS:           return &quot;REG_STATUS&quot;;
+	case SIP_REG_TREGEXP:         return &quot;REG_TEXP&quot;;
+	case SIP_SUBSCRIBE:           return &quot;SUBSCRIBE&quot;;
+	case SIP_SUBSTATUS:           return &quot;SUB_STATUS&quot;;
+	case SIP_NOTIFY:              return &quot;NOTIFY&quot;;
+	case SIP_NOTSTATUS:           return &quot;NOT_STATUS&quot;;
+	case SIP_PRESENCE_CHANGE:     return &quot;PRESENCE_CHNG&quot;;
+	case SIP_SUBSCRIBE_EXPIRE:    return &quot;SUB_EXPIRE&quot;;
+	case SIP_WATCH:               return &quot;WATCH&quot;;
+	case SIP_STOPWATCH:           return &quot;STOPWATCH&quot;;
+	case SIP_MESSAGE:             return &quot;MESSAGE&quot;;
+	case SIP_MESSAGESTATUS:       return &quot;MESSAGESTATUS&quot;;
+	case SIP_INFO:                return &quot;INFO&quot;;
+	case SIP_INFOSTATUS:          return &quot;INFOSTATUS&quot;;
+	case SIP_IM_TIMEOUT:          return &quot;IM_TIMEOUT&quot;;
+	case SIP_USER_MESSAGE:        return &quot;USER_IM&quot;;
+	case SIP_KICKWATCH:           return &quot;KICKWATCH&quot;;
+	default:
+		break;
+	}
+	return &quot;Unknown-Event&quot;;
+}
+
+
+QString SipFsmBase::StatetoString(int S)
+{
+	switch (S)
+	{
+	case SIP_IDLE:              return &quot;IDLE&quot;;
+	case SIP_OCONNECTING1:      return &quot;OCONNECT1&quot;;
+	case SIP_OCONNECTING2:      return &quot;OCONNECT2&quot;;
+	case SIP_ICONNECTING:       return &quot;ICONNECT&quot;;
+	case SIP_CONNECTED:         return &quot;CONNECTED&quot;;
+	case SIP_DISCONNECTING:     return &quot;DISCONNECT &quot;;
+	case SIP_CONNECTED_VXML:    return &quot;CONNECT-VXML&quot;;  // A false state! Only used to indicate to frontend
+	case SIP_SUB_SUBSCRIBED:    return &quot;SUB_SUBSCRIBED&quot;;
+	case SIP_WATCH_TRYING:      return &quot;WTCH_TRYING&quot;;
+	case SIP_WATCH_ACTIVE:      return &quot;WTCH_ACTIVE&quot;;
+	case SIP_WATCH_STOPPING:    return &quot;WTCH_STOPPING&quot;;
+	case SIP_WATCH_HOLDOFF:     return &quot;WTCH_HOLDDOFF&quot;;
+	case SIP_IM_ACTIVE:         return &quot;IM_ACTIVE&quot;;
+
+	default:
+		break;
+	}
+	return &quot;Unknown-State&quot;;
+}
+
+
+
+
+
+
+/**********************************************************************
+SipCall
+ 
+This class handles a per call instance of the FSM
+**********************************************************************/
+
+SipCall::SipCall(QString localIp, QString natIp, int localPort, int n, SipFsm *par) : SipFsmBase(par)
+{
+	callRef = n;
+	sipLocalIP = localIp;
+	sipNatIP = natIp;
+	sipLocalPort = localPort;
+	initialise();
+}
+
+SipCall::~SipCall()
+{}
+
+
+void SipCall::initialise()
+{
+	// Initialise Local Parameters.  We get info from the database on every new
+	// call in case it has been changed
+	myDisplayName = &quot;maldn&quot;;//TODO gContext-&gt;GetSetting(&quot;MySipName&quot;);
+	sipUsername = &quot;Konference&quot;;//gContext-&gt;GetSetting(&quot;MySipUser&quot;);  -- Note; this is really not needed &amp; is too much config
+
+	// Get other params - done on a per call basis so config changes take effect immediately
+	sipAudioRtpPort = 21232;//TODO atoi((const char *)gContext-&gt;GetSetting(&quot;AudioLocalPort&quot;));
+	sipVideoRtpPort = 21234;//TODO atoi((const char *)gContext-&gt;GetSetting(&quot;VideoLocalPort&quot;));
+
+	sipRtpPacketisation = 20;
+	State = SIP_IDLE;
+	remoteAudioPort = 0;
+	remoteVideoPort = 0;
+	remoteIp = &quot;&quot;;
+	audioPayloadIdx = -1;
+	videoPayload = -1;
+	dtmfPayload = -1;
+	remoteIp = &quot;&quot;;
+	allowVideo = true;
+	disableNat = false;
+	rxVideoResolution = &quot;CIF&quot;;
+	txVideoResolution = &quot;CIF&quot;;
+	viaRegProxy = 0;
+
+	MyUrl = 0;
+	MyContactUrl = 0;
+
+	// Read the codec priority list from the database into an array
+	CodecList[0].Payload = 0;
+	CodecList[0].Encoding = &quot;PCMU&quot;;
+	int n=0;
+	QString CodecListString = &quot;G.711u;G.711a;GSM&quot;;//TODO gContext-&gt;GetSetting(&quot;CodecPriorityList&quot;);
+	while ((CodecListString.length() &gt; 0) &amp;&amp; (n &lt; MAX_AUDIO_CODECS-1))
+	{
+		int sep = CodecListString.find(';');
+		QString CodecStr = CodecListString;
+		if (sep != -1)
+			CodecStr = CodecListString.left(sep);
+		if (CodecStr == &quot;G.711u&quot;)
+		{
+			CodecList[n].Payload = 0;
+			CodecList[n++].Encoding = &quot;PCMU&quot;;
+		}
+		else if (CodecStr == &quot;G.711a&quot;)
+		{
+			CodecList[n].Payload = 8;
+			CodecList[n++].Encoding = &quot;PCMA&quot;;
+		}
+		else if (CodecStr == &quot;GSM&quot;)
+		{
+			CodecList[n].Payload = 3;
+			CodecList[n++].Encoding = &quot;GSM&quot;;
+		}
+		else
+			cout &lt;&lt; &quot;Unknown codec &quot; &lt;&lt; CodecStr &lt;&lt; &quot; in Codec Priority List\n&quot;;
+		if (sep != -1)
+		{
+			QString tempStr = CodecListString.mid(sep+1);
+			CodecListString = tempStr;
+		}
+		else
+			break;
+	}
+	CodecList[n].Payload = -1;
+}
+
+
+int SipCall::FSM(int Event, SipMsg *sipMsg, void *Value)
+{
+	(void)Value;
+	int oldState = State;
+
+	// Parse SIP messages for general relevant data
+	if (sipMsg != 0)
+		ParseSipMsg(Event, sipMsg);
+
+	if (State == SIP_IDLE) // Setup local variables on first event
+	{
+		//if (UseNat(remoteUrl-&gt;getHostIp()))
+		//	sipLocalIP = sipNatIP;
+		MyContactUrl = new SipUrl(myDisplayName, sipUsername, sipLocalIP, sipLocalPort);
+		if (viaRegProxy == 0)
+			MyUrl = new SipUrl(myDisplayName, sipUsername, sipLocalIP, sipLocalPort);
+		else
+			MyUrl = new SipUrl(myDisplayName, viaRegProxy-&gt;registeredAs(), viaRegProxy-&gt;registeredTo(), viaRegProxy-&gt;registeredPort());
+	}
+
+	switch(Event | State)
+	{
+	case SIP_IDLE_BYE:
+		BuildSendStatus(481, &quot;BYE&quot;, sipMsg-&gt;getCSeqValue()); //481 Call/Transaction does not exist
+		State = SIP_IDLE;
+		break;
+	case SIP_IDLE_INVITESTATUS_1xx:
+	case SIP_IDLE_INVITESTATUS_2xx:
+	case SIP_IDLE_INVITESTATUS_3456:
+		// Check if we are being a proxy
+		if (sipMsg-&gt;getViaIp() == sipLocalIP)
+		{
+			ForwardMessage(sipMsg);
+			State = SIP_IDLE;
+		}
+		break;
+	case SIP_IDLE_OUTCALL:
+		cseq = 1;
+		remoteUrl = new SipUrl(DestinationUri, &quot;&quot;);
+		if ((remoteUrl-&gt;getHostIp()).length() == 0)
+		{
+			cout &lt;&lt; &quot;SIP: Tried to call &quot; &lt;&lt; DestinationUri &lt;&lt; &quot; but can't get destination IP address\n&quot;;
+			State = SIP_IDLE;
+			break;
+		}
+
+#ifdef SIPREGISTRAR
+		// If the domain matches the local registrar, see if user is registered
+		if ((remoteUrl-&gt;getHost() == &quot;volkaerts&quot;) &amp;&amp;
+		        (!(parent-&gt;getRegistrar())-&gt;getRegisteredContact(remoteUrl)))
+		{
+			cout &lt;&lt; DestinationUri &lt;&lt; &quot; is not registered here\n&quot;;
+			break;
+		}
+#endif
+		BuildSendInvite(0);
+		State = SIP_OCONNECTING1;
+		break;
+	case SIP_IDLE_INVITE:
+		cseq = sipMsg-&gt;getCSeqValue();
+#ifdef SIPREGISTRAR
+		if ((toUrl-&gt;getUser() == sipUsername)) &amp;&amp; (toUrl-&gt;getHost() ==  &quot;Volkaerts&quot;))
+#endif
+		{
+			if (parent-&gt;numCalls() &gt; 1)     // Check there are no active calls, and give busy if there is
+			{
+				BuildSendStatus(486, &quot;INVITE&quot;, sipMsg-&gt;getCSeqValue()); //486 Busy Here
+				State = SIP_DISCONNECTING;
+			}
+			else
+			{
+				GetSDPInfo(sipMsg);
+				if (audioPayloadIdx != -1) // INVITE had a codec we support; proces
+				{
+					AlertUser(sipMsg);
+					BuildSendStatus(100, &quot;INVITE&quot;, sipMsg-&gt;getCSeqValue(), SIP_OPT_CONTACT); //100 Trying
+					BuildSendStatus(180, &quot;INVITE&quot;, sipMsg-&gt;getCSeqValue(), SIP_OPT_CONTACT); //180 Ringing
+					State = SIP_ICONNECTING;
+				}
+				else
+				{
+					BuildSendStatus(488, &quot;INVITE&quot;, sipMsg-&gt;getCSeqValue()); //488 Not Acceptable Here
+					State = SIP_DISCONNECTING;
+				}
+			}
+		}
+
+#ifdef SIPREGISTRAR
+		// Not for me, see if it is for a registered UA
+		else if ((toUrl-&gt;getHost() == &quot;volkaerts&quot;) &amp;&amp; ((parent-&gt;getRegistrar())-&gt;getRegisteredContact(toUrl)))
+		{
+			ForwardMessage(sipMsg);
+			State = SIP_IDLE;
+		}
+
+		// Not for me and not for anyone registered here
+		else
+		{
+			BuildSendStatus(404, &quot;INVITE&quot;, sipMsg-&gt;getCSeqValue()); //404 Not Found
+			State = SIP_DISCONNECTING;
+		}
+#endif
+		break;
+	case SIP_OCONNECTING1_INVITESTATUS_1xx:
+			(parent-&gt;Timer())-&gt;Stop(this, SIP_RETX);
+			parent-&gt;SetNotification(&quot;CALLSTATUS&quot;, &quot;&quot;, QString::number(sipMsg-&gt;getStatusCode()), sipMsg-&gt;getReasonPhrase());
+			State = SIP_OCONNECTING2;
+			break;
+		case SIP_OCONNECTING1_INVITESTATUS_3456:
+				(parent-&gt;Timer())-&gt;Stop(this, SIP_RETX);
+				parent-&gt;SetNotification(&quot;CALLSTATUS&quot;, &quot;&quot;, QString::number(sipMsg-&gt;getStatusCode()), sipMsg-&gt;getReasonPhrase());
+				// Fall through
+			case SIP_OCONNECTING2_INVITESTATUS_3456:
+					if (((sipMsg-&gt;getStatusCode() == 407) || (sipMsg-&gt;getStatusCode() == 401)) &amp;&amp;
+						        (viaRegProxy != 0) &amp;&amp; (viaRegProxy-&gt;isRegistered())) // Authentication Required
+					{
+						if (!sentAuthenticated) // This avoids loops where we are not authenticating properly
+						{
+							BuildSendAck();
+							BuildSendInvite(sipMsg);
+							State = SIP_OCONNECTING1;
+						}
+					}
+					else
+					{
+						BuildSendAck();
+						State = SIP_IDLE;
+					}
+		break;
+	case SIP_OCONNECTING1_INVITESTATUS_2xx:
+			(parent-&gt;Timer())-&gt;Stop(this, SIP_RETX);
+			// Fall through
+		case SIP_OCONNECTING2_INVITESTATUS_2xx:
+				GetSDPInfo(sipMsg);
+				if (audioPayloadIdx != -1) // INVITE had a codec we support; proces
+			{
+				BuildSendAck();
+					State = SIP_CONNECTED;
+				}
+				else
+				{
+					cerr &lt;&lt; &quot;2xx STATUS did not contain a valid Audio codec\n&quot;;
+					BuildSendAck();  // What is the right thing to do here?
+					BuildSendBye(0);
+					State = SIP_DISCONNECTING;
+				}
+		break;
+	case SIP_OCONNECTING1_INVITE:
+			// This is usually because we sent the INVITE to ourselves, &amp; when we receive it matches the call-id for this call leg
+			(parent-&gt;Timer())-&gt;Stop(this, SIP_RETX);
+			BuildSendCancel(0);
+			State = SIP_DISCONNECTING;
+			break;
+		case SIP_OCONNECTING1_HANGUP:
+				(parent-&gt;Timer())-&gt;Stop(this, SIP_RETX);
+				BuildSendCancel(0);
+				State = SIP_IDLE;
+				break;
+			case SIP_OCONNECTING1_RETX:
+					if (Retransmit(false))
+						(parent-&gt;Timer())-&gt;Start(this, t1, SIP_RETX);
+						else
+							State = SIP_IDLE;
+							break;
+						case SIP_OCONNECTING2_HANGUP:
+								BuildSendCancel(0);
+								State = SIP_DISCONNECTING;
+								break;
+							case SIP_ICONNECTING_INVITE:
+									BuildSendStatus(180, &quot;INVITE&quot;, sipMsg-&gt;getCSeqValue(), SIP_OPT_CONTACT); // Retxed INVITE, resend 180 Ringing
+									break;
+								case SIP_ICONNECTING_ANSWER:
+										BuildSendStatus(200, &quot;INVITE&quot;, cseq, SIP_OPT_SDP | SIP_OPT_CONTACT, -1, BuildSdpResponse());
+										State = SIP_CONNECTED;
+										break;
+									case SIP_ICONNECTING_CANCEL:
+											BuildSendStatus(200, &quot;CANCEL&quot;, sipMsg-&gt;getCSeqValue()); //200 Ok
+											State = SIP_IDLE;
+											break;
+										case SIP_CONNECTED_ACK:
+												(parent-&gt;Timer())-&gt;Stop(this, SIP_RETX); // Stop resending 200 OKs
+												break;
+											case SIP_CONNECTED_INVITESTATUS_2xx:
+													Retransmit(true); // Resend our ACK
+													break;
+												case SIP_CONNECTED_RETX:
+														if (Retransmit(false))
+															(parent-&gt;Timer())-&gt;Start(this, t1, SIP_RETX);
+															else
+																State = SIP_IDLE;
+																break;
+															case SIP_CONNECTED_BYE:
+																	(parent-&gt;Timer())-&gt;Stop(this, SIP_RETX);
+																	if (sipMsg-&gt;getCSeqValue() &gt; cseq)
+																	{
+																		cseq = sipMsg-&gt;getCSeqValue();
+																		BuildSendStatus(200, &quot;BYE&quot;, cseq); //200 Ok
+																		State = SIP_IDLE;
+																	}
+																	else
+																		BuildSendStatus(400, &quot;BYE&quot;, sipMsg-&gt;getCSeqValue()); //400 Bad Request
+																		break;
+																	case SIP_CONNECTED_HANGUP:
+																			BuildSendBye(0);
+																			State = SIP_DISCONNECTING;
+																			break;
+																		case SIP_DISCONNECTING_ACK:
+																				(parent-&gt;Timer())-&gt;Stop(this, SIP_RETX);
+																				State = SIP_IDLE;
+																				break;
+																			case SIP_DISCONNECTING_RETX:
+																					if (Retransmit(false))
+																						(parent-&gt;Timer())-&gt;Start(this, t1, SIP_RETX);
+																						else
+																							State = SIP_IDLE;
+																							break;
+																						case SIP_DISCONNECTING_CANCEL:
+																								(parent-&gt;Timer())-&gt;Stop(this, SIP_RETX);
+																								BuildSendStatus(200, &quot;CANCEL&quot;, sipMsg-&gt;getCSeqValue()); //200 Ok
+																								State = SIP_IDLE;
+																								break;
+																							case SIP_DISCONNECTING_BYESTATUS:
+																									(parent-&gt;Timer())-&gt;Stop(this, SIP_RETX);
+																									if (((sipMsg-&gt;getStatusCode() == 407) || (sipMsg-&gt;getStatusCode() == 401)) &amp;&amp;
+																										        (viaRegProxy != 0) &amp;&amp; (viaRegProxy-&gt;isRegistered())) // Authentication Required
+																									{
+																										if (!sentAuthenticated)
+																											BuildSendBye(sipMsg);
+																									}
+																									else
+																										State = SIP_IDLE;
+																										break;
+																									case SIP_DISCONNECTING_CANCELSTATUS:
+																											(parent-&gt;Timer())-&gt;Stop(this, SIP_RETX);
+																											if (((sipMsg-&gt;getStatusCode() == 407) || (sipMsg-&gt;getStatusCode() == 401)) &amp;&amp;
+																												        (viaRegProxy != 0) &amp;&amp; (viaRegProxy-&gt;isRegistered())) // Authentication Required
+																											{
+																												if (!sentAuthenticated)
+																													BuildSendCancel(sipMsg);
+																											}
+																											else
+																												State = SIP_IDLE;
+																												break;
+																											case SIP_DISCONNECTING_BYE:
+																													(parent-&gt;Timer())-&gt;Stop(this, SIP_RETX);
+																													BuildSendStatus(200, &quot;BYE&quot;, sipMsg-&gt;getCSeqValue()); //200 Ok
+																													State = SIP_IDLE;
+																													break;
+
+																													// Events ignored in states
+																												case SIP_OCONNECTING2_INVITESTATUS_1xx:
+																														parent-&gt;SetNotification(&quot;CALLSTATUS&quot;, &quot;&quot;, QString::number(sipMsg-&gt;getStatusCode()), sipMsg-&gt;getReasonPhrase());
+																														break;
+
+																														// Everything else is an error, just flag it for now
+																													default:
+																															SipFsm::Debug(SipDebugEvent::SipErrorEv, &quot;SIP CALL FSM Error; received &quot; + EventtoString(Event) + &quot; in state &quot; + StatetoString(State) + &quot;\n\n&quot;);
+																															break;
+																														}
+
+	DebugFsm(Event, oldState, State);
+	return State;
+}
+
+bool SipCall::UseNat(QString destIPAddress)
+{
+	(void)destIPAddress;
+	// User to check subnets but this was a flawed concept; now checks a configuration item per-remote user
+	return !disableNat;
+}
+
+
+void SipCall::BuildSendInvite(SipMsg *authMsg)
+{
+	if (authMsg == 0)
+		CallId.Generate(sipLocalIP);
+
+	SipMsg Invite(&quot;INVITE&quot;);
+	Invite.addRequestLine(*remoteUrl);
+	Invite.addVia(sipLocalIP, sipLocalPort);
+	Invite.addFrom(*MyUrl, &quot;ae1d8a43cf3f4d8a8f4f0e1004&quot;, &quot;3622b728e3&quot;);
+	Invite.addTo(*remoteUrl);
+	Invite.addCallId(&amp;CallId);
+	Invite.addCSeq(++cseq);
+	Invite.addUserAgent();
+
+	if (authMsg)
+	{
+		if (authMsg-&gt;getAuthMethod() == &quot;Digest&quot;)
+			Invite.addAuthorization(authMsg-&gt;getAuthMethod(), viaRegProxy-&gt;registeredAs(), viaRegProxy-&gt;registeredPasswd(), authMsg-&gt;getAuthRealm(), authMsg-&gt;getAuthNonce(), remoteUrl-&gt;formatReqLineUrl(), authMsg-&gt;getStatusCode() == 407);
+		else
+			cout &lt;&lt; &quot;SIP: Unknown Auth Type: &quot; &lt;&lt; authMsg-&gt;getAuthMethod() &lt;&lt; endl;
+		sentAuthenticated = true;
+	}
+	else
+		sentAuthenticated = false;
+
+	//Invite.addAllow();
+	Invite.addContact(*MyContactUrl);
+	addSdpToInvite(Invite, allowVideo);
+
+	parent-&gt;Transmit(Invite.string(), retxIp = remoteUrl-&gt;getHostIp(), retxPort = remoteUrl-&gt;getPort());
+	retx = Invite.string();
+	t1 = 500;
+	(parent-&gt;Timer())-&gt;Start(this, t1, SIP_RETX);
+}
+
+
+
+void SipCall::ForwardMessage(SipMsg *msg)
+{
+	QString toIp;
+	int toPort;
+
+	if (msg-&gt;getMethod() != &quot;STATUS&quot;)
+	{
+		msg-&gt;insertVia(sipLocalIP, sipLocalPort);
+		toIp = toUrl-&gt;getHostIp();
+		toPort = toUrl-&gt;getPort();
+	}
+	else
+	{
+		msg-&gt;removeVia();
+		toIp = msg-&gt;getViaIp();
+		toPort = msg-&gt;getViaPort();
+	}
+	parent-&gt;Transmit(msg-&gt;string(), toIp, toPort);
+}
+
+
+
+void SipCall::BuildSendAck()
+{
+	if ((MyUrl == 0) || (remoteUrl == 0))
+	{
+		cerr &lt;&lt; &quot;URL variables not setup\n&quot;;
+		return;
+	}
+
+	SipMsg Ack(&quot;ACK&quot;);
+	Ack.addRequestLine(*remoteUrl);
+	Ack.addVia(sipLocalIP, sipLocalPort);
+	Ack.addFrom(*MyUrl, &quot;ae1d8a43cf3f4d8a8f4f0e1004&quot;, &quot;3622b728e3&quot;);
+	Ack.addTo(*remoteUrl, remoteTag);
+	Ack.addCallId(&amp;CallId);
+	Ack.addCSeq(cseq);
+	Ack.addUserAgent();
+	Ack.addNullContent();
+
+	// Even if we have a contact URL in one of the response messages; we still send the ACK to
+	// the same place we sent the INVITE to
+	parent-&gt;Transmit(Ack.string(), retxIp = remoteUrl-&gt;getHostIp(), retxPort = remoteUrl-&gt;getPort());
+	retx = Ack.string();
+}
+
+
+void SipCall::BuildSendCancel(SipMsg *authMsg)
+{
+	if ((MyUrl == 0) || (remoteUrl == 0))
+	{
+		cerr &lt;&lt; &quot;URL variables not setup\n&quot;;
+		return;
+	}
+
+	SipMsg Cancel(&quot;CANCEL&quot;);
+	Cancel.addRequestLine(*remoteUrl);
+	Cancel.addVia(sipLocalIP, sipLocalPort);
+	Cancel.addTo(*remoteUrl, remoteTag);
+	Cancel.addFrom(*MyUrl);
+	Cancel.addCallId(&amp;CallId);
+	Cancel.addCSeq(cseq);
+	Cancel.addUserAgent();
+
+	if (authMsg)
+	{
+		if (authMsg-&gt;getAuthMethod() == &quot;Digest&quot;)
+			Cancel.addAuthorization(authMsg-&gt;getAuthMethod(), viaRegProxy-&gt;registeredAs(), viaRegProxy-&gt;registeredPasswd(), authMsg-&gt;getAuthRealm(), authMsg-&gt;getAuthNonce(), remoteUrl-&gt;formatReqLineUrl(), authMsg-&gt;getStatusCode() == 407);
+		else
+			cout &lt;&lt; &quot;SIP: Unknown Auth Type: &quot; &lt;&lt; authMsg-&gt;getAuthMethod() &lt;&lt; endl;
+		sentAuthenticated = true;
+	}
+	else
+		sentAuthenticated = false;
+
+	Cancel.addNullContent();
+
+	// Send new transactions to (a) record route, (b) contact URL or (c) configured URL
+	if (recRouteUrl)
+		parent-&gt;Transmit(Cancel.string(), retxIp = recRouteUrl-&gt;getHostIp(), retxPort = recRouteUrl-&gt;getPort());
+	else if (contactUrl)
+		parent-&gt;Transmit(Cancel.string(), retxIp = contactUrl-&gt;getHostIp(), retxPort = contactUrl-&gt;getPort());
+	else
+		parent-&gt;Transmit(Cancel.string(), retxIp = remoteUrl-&gt;getHostIp(), retxPort = remoteUrl-&gt;getPort());
+	retx = Cancel.string();
+	t1 = 500;
+	(parent-&gt;Timer())-&gt;Start(this, t1, SIP_RETX);
+}
+
+
+void SipCall::BuildSendBye(SipMsg *authMsg)
+{
+	if (remoteUrl == 0)
+	{
+		cerr &lt;&lt; &quot;URL variables not setup\n&quot;;
+		return;
+	}
+
+	SipMsg Bye(&quot;BYE&quot;);
+	Bye.addRequestLine(*remoteUrl);
+	Bye.addVia(sipLocalIP, sipLocalPort);
+	if (rxedFrom.length() &gt; 0)
+	{
+		Bye.addFromCopy(rxedFrom);
+		Bye.addToCopy(rxedTo);
+	}
+	else
+	{
+		Bye.addFrom(*MyUrl);
+		Bye.addTo(*remoteUrl, remoteTag);
+	}
+	Bye.addCallId(&amp;CallId);
+	Bye.addCSeq(++cseq);
+	Bye.addUserAgent();
+
+	if (authMsg)
+	{
+		if (authMsg-&gt;getAuthMethod() == &quot;Digest&quot;)
+			Bye.addAuthorization(authMsg-&gt;getAuthMethod(), viaRegProxy-&gt;registeredAs(), viaRegProxy-&gt;registeredPasswd(), authMsg-&gt;getAuthRealm(), authMsg-&gt;getAuthNonce(), remoteUrl-&gt;formatReqLineUrl(), authMsg-&gt;getStatusCode() == 407);
+		else
+			cout &lt;&lt; &quot;SIP: Unknown Auth Type: &quot; &lt;&lt; authMsg-&gt;getAuthMethod() &lt;&lt; endl;
+		sentAuthenticated = true;
+	}
+	else
+		sentAuthenticated = false;
+
+	Bye.addNullContent();
+
+	// Send new transactions to (a) record route, (b) contact URL or (c) configured URL
+	if (recRouteUrl)
+		parent-&gt;Transmit(Bye.string(), retxIp = recRouteUrl-&gt;getHostIp(), retxPort = recRouteUrl-&gt;getPort());
+	else if (contactUrl)
+		parent-&gt;Transmit(Bye.string(), retxIp = contactUrl-&gt;getHostIp(), retxPort = contactUrl-&gt;getPort());
+	else
+		parent-&gt;Transmit(Bye.string(), retxIp = remoteUrl-&gt;getHostIp(), retxPort = remoteUrl-&gt;getPort());
+	retx = Bye.string();
+	t1 = 500;
+	(parent-&gt;Timer())-&gt;Start(this, t1, SIP_RETX);
+}
+
+void SipCall::AlertUser(SipMsg *rxMsg)
+{
+	// A new incoming call has been received, tell someone!
+	// Actually we just pull out the important bits here &amp; on the
+	// next call to poll the stack the State will have changed to
+	// alert the user
+	if (rxMsg != 0)
+	{
+		SipUrl *from = rxMsg-&gt;getFromUrl();
+
+		if (from)
+		{
+			CallersUserid = from-&gt;getUser();
+			if ((viaRegProxy) &amp;&amp; (viaRegProxy-&gt;registeredTo() == from-&gt;getHost()))
+				CallerUrl = from-&gt;getUser();
+			else
+			{
+				CallerUrl = from-&gt;getUser() + &quot;@&quot; + from-&gt;getHost();
+				if (from-&gt;getPort() != 5060)
+					CallerUrl += &quot;:&quot; + QString::number(from-&gt;getPort());
+			}
+			CallersDisplayName = from-&gt;getDisplay();
+		}
+		else
+			cerr &lt;&lt; &quot;What no from in INVITE?  It is invalid then.\n&quot;;
+	}
+	else
+		cerr &lt;&lt; &quot;What no INVITE?  How did we get here then?\n&quot;;
+}
+
+void SipCall::GetSDPInfo(SipMsg *sipMsg)
+{
+	audioPayloadIdx = -1;
+	videoPayload = -1;
+	dtmfPayload = -1;
+	remoteAudioPort = 0;
+	remoteVideoPort = 0;
+	rxVideoResolution = &quot;AUDIOONLY&quot;;
+
+	SipSdp *Sdp = sipMsg-&gt;getSdp();
+	if (Sdp != 0)
+	{
+		remoteIp = Sdp-&gt;getMediaIP();
+		remoteAudioPort = Sdp-&gt;getAudioPort();
+		remoteVideoPort = Sdp-&gt;getVideoPort();
+
+		// See if there is an audio codec we support
+		QPtrList&lt;sdpCodec&gt; *audioCodecs = Sdp-&gt;getAudioCodecList();
+		sdpCodec *c;
+		if (audioCodecs)
+		{
+			for (int n=0; (n&lt;MAX_AUDIO_CODECS) &amp;&amp; (CodecList[n].Payload != -1) &amp;&amp;
+			        (audioPayloadIdx == -1); n++)
+			{
+				for (c=audioCodecs-&gt;first(); c; c=audioCodecs-&gt;next())
+				{
+					if (CodecList[n].Payload == c-&gt;intValue())
+						audioPayloadIdx = n;
+
+					// Note - no checking for dynamic payloads implemented yet --- need to match
+					// by text if .Payload == -1
+				}
+			}
+
+			// Also check for DTMF
+			for (c=audioCodecs-&gt;first(); c; c=audioCodecs-&gt;next())
+			{
+				if (c-&gt;strValue() == &quot;telephone-event/8000&quot;)
+					dtmfPayload = c-&gt;intValue();
+			}
+		}
+
+		// See if there is a video codec we support
+		QPtrList&lt;sdpCodec&gt; *videoCodecs = Sdp-&gt;getVideoCodecList();
+		if (videoCodecs)
+		{
+			for (c=videoCodecs-&gt;first(); c; c=videoCodecs-&gt;next())
+			{
+				if ((c-&gt;intValue() == 34) &amp;&amp; (c-&gt;strValue() == &quot;H263/90000&quot;))
+				{
+					videoPayload = c-&gt;intValue();
+					rxVideoResolution = (c-&gt;fmtValue()).section('=', 0, 0);
+					break;
+				}
+			}
+		}
+
+		SipFsm::Debug(SipDebugEvent::SipDebugEv, &quot;SDP contains IP &quot; + remoteIp + &quot; A-Port &quot; + QString::number(remoteAudioPort) + &quot; V-Port &quot; + QString::number(remoteVideoPort) + &quot; Audio Codec:&quot; + QString::number(audioPayloadIdx) + &quot; Video Codec:&quot; + QString::number(videoPayload) + &quot; Format:&quot; + rxVideoResolution + &quot; DTMF: &quot; + QString::number(dtmfPayload) + &quot;\n\n&quot;);
+	}
+	else
+		SipFsm::Debug(SipDebugEvent::SipDebugEv, &quot;SIP: No SDP in message\n&quot;);
+}
+
+
+
+void SipCall::addSdpToInvite(SipMsg&amp; msg, bool advertiseVideo)
+{
+	SipSdp sdp(sipLocalIP, sipAudioRtpPort, advertiseVideo ? sipVideoRtpPort : 0);
+
+	for (int n=0; (n&lt;MAX_AUDIO_CODECS) &amp;&amp; (CodecList[n].Payload != -1); n++)
+		sdp.addAudioCodec(CodecList[n].Payload, CodecList[n].Encoding + &quot;/8000&quot;);
+
+	// Signal support for DTMF
+	sdp.addAudioCodec(101, &quot;telephone-event/8000&quot;, &quot;0-11&quot;);
+
+	if (advertiseVideo)
+		sdp.addVideoCodec(34, &quot;H263/90000&quot;, txVideoResolution +&quot;=2&quot;);
+	sdp.encode();
+	msg.addContent(&quot;application/sdp&quot;, sdp.string());
+}
+
+
+QString SipCall::BuildSdpResponse()
+{
+	SipSdp sdp(sipLocalIP, sipAudioRtpPort, (videoPayload != -1) ? sipVideoRtpPort : 0);
+
+	sdp.addAudioCodec(CodecList[audioPayloadIdx].Payload, CodecList[audioPayloadIdx].Encoding + &quot;/8000&quot;);
+
+	// Signal support for DTMF
+	if (dtmfPayload != -1)
+		sdp.addAudioCodec(dtmfPayload, &quot;telephone-event/8000&quot;, &quot;0-11&quot;);
+
+	if (videoPayload != -1)
+		sdp.addVideoCodec(34, &quot;H263/90000&quot;, txVideoResolution +&quot;=2&quot;);
+
+	sdp.encode();
+	return sdp.string();
+}
+
+
+
+
+/**********************************************************************
 SipRegistrar
  
 A simple registrar class used mainly for testing purposes. Allows
@@ -760,7 +2127,155 @@
 	parent-&gt;Transmit(Status.string(), rIp, rPort);
 }
 
+
 /**********************************************************************
+SipRegistration
+ 
+This class is used to register with a SIP Proxy.
+**********************************************************************/
+
+SipRegistration::SipRegistration(SipFsm *par, QString localIp, int localPort, QString Username, QString Password, QString ProxyName, int ProxyPort) : SipFsmBase(par)
+{
+	sipLocalIp = localIp;
+	sipLocalPort = localPort;
+	ProxyUrl = new SipUrl(&quot;&quot;, &quot;&quot;, ProxyName, ProxyPort);
+	MyUrl = new SipUrl(&quot;&quot;, Username, ProxyName, ProxyPort);
+	MyContactUrl = new SipUrl(&quot;&quot;, Username, sipLocalIp, sipLocalPort);
+	MyPassword = Password;
+	cseq = 1;
+	CallId.Generate(sipLocalIp);
+
+	SendRegister();
+	State = SIP_REG_TRYING;
+	regRetryCount = REG_RETRY_MAXCOUNT;
+	Expires = 3600;
+	(parent-&gt;Timer())-&gt;Start(this, REG_RETRY_TIMER, SIP_RETX);
+}
+
+SipRegistration::~SipRegistration()
+{
+	if (ProxyUrl)
+		delete ProxyUrl;
+	if (MyUrl)
+		delete MyUrl;
+	if (MyContactUrl)
+		delete MyContactUrl;
+	ProxyUrl = MyUrl = MyContactUrl = 0;
+	(parent-&gt;Timer())-&gt;StopAll(this);
+}
+
+int SipRegistration::FSM(int Event, SipMsg *sipMsg, void *Value)
+{
+	(void)Value;
+	switch (Event | State)
+	{
+	case SIP_REG_TRYING_STATUS:
+		(parent-&gt;Timer())-&gt;Stop(this, SIP_RETX);
+		switch (sipMsg-&gt;getStatusCode())
+		{
+		case 200:
+			if (sipMsg-&gt;getExpires() &gt; 0)
+				Expires = sipMsg-&gt;getExpires();
+			cout &lt;&lt; &quot;SIP Registered to &quot; &lt;&lt; ProxyUrl-&gt;getHost() &lt;&lt; &quot; for &quot; &lt;&lt; Expires &lt;&lt; &quot;s&quot; &lt;&lt; endl;
+			State = SIP_REG_REGISTERED;
+			(parent-&gt;Timer())-&gt;Start(this, (Expires-30)*1000, SIP_REG_TREGEXP); // Assume 30secs max to reregister
+			break;
+		case 401:
+		case 407:
+			SendRegister(sipMsg);
+			regRetryCount = REG_RETRY_MAXCOUNT;
+			State = SIP_REG_CHALLENGED;
+			(parent-&gt;Timer())-&gt;Start(this, REG_RETRY_TIMER, SIP_RETX);
+			break;
+		default:
+			if (sipMsg-&gt;getStatusCode() != 100)
+			{
+				cout &lt;&lt; &quot;SIP Registration failed; Reason &quot; &lt;&lt; sipMsg-&gt;getStatusCode() &lt;&lt; &quot; &quot; &lt;&lt; sipMsg-&gt;getReasonPhrase() &lt;&lt; endl;
+				State = SIP_REG_FAILED;
+				(parent-&gt;Timer())-&gt;Start(this, REG_FAIL_RETRY_TIMER, SIP_RETX); // Try again in 3 minutes
+			}
+			break;
+		}
+		break;
+
+	case SIP_REG_CHALL_STATUS:
+		(parent-&gt;Timer())-&gt;Stop(this, SIP_RETX);
+		switch (sipMsg-&gt;getStatusCode())
+		{
+		case 200:
+			if (sipMsg-&gt;getExpires() &gt; 0)
+				Expires = sipMsg-&gt;getExpires();
+			cout &lt;&lt; &quot;SIP Registered to &quot; &lt;&lt; ProxyUrl-&gt;getHost() &lt;&lt; &quot; for &quot; &lt;&lt; Expires &lt;&lt; &quot;s&quot; &lt;&lt; endl;
+			State = SIP_REG_REGISTERED;
+			(parent-&gt;Timer())-&gt;Start(this, (Expires-30)*1000, SIP_REG_TREGEXP); // Assume 30secs max to reregister
+			break;
+		default:
+			if (sipMsg-&gt;getStatusCode() != 100)
+			{
+				cout &lt;&lt; &quot;SIP Registration failed; Reason &quot; &lt;&lt; sipMsg-&gt;getStatusCode() &lt;&lt; &quot; &quot; &lt;&lt; sipMsg-&gt;getReasonPhrase() &lt;&lt; endl;
+				State = SIP_REG_FAILED;
+				(parent-&gt;Timer())-&gt;Start(this, REG_FAIL_RETRY_TIMER, SIP_RETX); // Try again in 3 minutes
+			}
+			break;
+		}
+		break;
+
+	case SIP_REG_REGISTERED_TREGEXP:
+		regRetryCount = REG_RETRY_MAXCOUNT+1;
+	case SIP_REG_TRYING_RETX:
+	case SIP_REG_CHALL_RETX:
+	case SIP_REG_FAILED_RETX:
+		if (--regRetryCount &gt; 0)
+		{
+			State = SIP_REG_TRYING;
+			SendRegister();
+			(parent-&gt;Timer())-&gt;Start(this, REG_RETRY_TIMER, SIP_RETX); // Retry every 10 seconds
+		}
+		else
+		{
+			State = SIP_REG_FAILED;
+			cout &lt;&lt; &quot;SIP Registration failed; no Response from Server. Are you behind a firewall?\n&quot;;
+		}
+		break;
+
+	default:
+		cerr &lt;&lt; &quot;SIP Registration: Unknown Event &quot; &lt;&lt; EventtoString(Event) &lt;&lt; &quot;, State &quot; &lt;&lt; State &lt;&lt; endl;
+		break;
+	}
+	return 0;
+}
+
+void SipRegistration::SendRegister(SipMsg *authMsg)
+{
+	SipMsg Register(&quot;REGISTER&quot;);
+	Register.addRequestLine(*ProxyUrl);
+	Register.addVia(sipLocalIp, sipLocalPort);
+	Register.addFrom(*MyUrl);
+	Register.addTo(*MyUrl);
+	Register.addCallId(&amp;CallId);
+	Register.addCSeq(++cseq);
+
+	if (authMsg &amp;&amp; (authMsg-&gt;getAuthMethod() == &quot;Digest&quot;))
+	{
+		Register.addAuthorization(authMsg-&gt;getAuthMethod(), MyUrl-&gt;getUser(), MyPassword,
+		                          authMsg-&gt;getAuthRealm(), authMsg-&gt;getAuthNonce(),
+		                          ProxyUrl-&gt;formatReqLineUrl(), authMsg-&gt;getStatusCode() == 407);
+		sentAuthenticated = true;
+	}
+	else
+		sentAuthenticated = false;
+
+	Register.addUserAgent();
+	Register.addExpires(Expires=3600);
+	Register.addContact(*MyContactUrl);
+	Register.addNullContent();
+
+	parent-&gt;Transmit(Register.string(), ProxyUrl-&gt;getHostIp(), ProxyUrl-&gt;getPort());
+}
+
+
+
+/**********************************************************************
 SipSubscriber
  
 FSM to handle clients subscribed to our presence status.
@@ -857,11 +2372,11 @@
 		break;
 
 	default:
-//		SipFsm::Debug(SipDebugEvent::SipErrorEv, &quot;SIP Subscriber FSM Error; received &quot; + EventtoString(Event) + &quot; in state &quot; + StatetoString(State) + &quot;\n\n&quot;);
+		SipFsm::Debug(SipDebugEvent::SipErrorEv, &quot;SIP Subscriber FSM Error; received &quot; + EventtoString(Event) + &quot; in state &quot; + StatetoString(State) + &quot;\n\n&quot;);
 		break;
 	}
 
-//	DebugFsm(Event, OldState, State);
+	DebugFsm(Event, OldState, State);
 	return State;
 }
 
@@ -1094,11 +2609,11 @@
 		break;
 
 	default:
-//		SipFsm::Debug(SipDebugEvent::SipErrorEv, &quot;SIP Watcher FSM Error; received &quot; + EventtoString(Event) + &quot; in state &quot; + StatetoString(State) + &quot;\n\n&quot;);
+		SipFsm::Debug(SipDebugEvent::SipErrorEv, &quot;SIP Watcher FSM Error; received &quot; + EventtoString(Event) + &quot; in state &quot; + StatetoString(State) + &quot;\n\n&quot;);
 		break;
 	}
 
-//	DebugFsm(Event, OldState, State);
+	DebugFsm(Event, OldState, State);
 	return State;
 }
 
@@ -1251,11 +2766,11 @@
 		break;
 
 	default:
-//		SipFsm::Debug(SipDebugEvent::SipErrorEv, &quot;SIP IM FSM Error; received &quot; + EventtoString(Event) + &quot; in state &quot; + StatetoString(State) + &quot;\n\n&quot;);
+		SipFsm::Debug(SipDebugEvent::SipErrorEv, &quot;SIP IM FSM Error; received &quot; + EventtoString(Event) + &quot; in state &quot; + StatetoString(State) + &quot;\n\n&quot;);
 		break;
 	}
 
-//	DebugFsm(Event, OldState, State);
+	DebugFsm(Event, OldState, State);
 	return State;
 }
 

Modified: konference/src/sip/sipmsg.cpp
===================================================================
--- konference/src/sip/sipmsg.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/sip/sipmsg.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -422,7 +422,7 @@
 
 		QString thisParamNoWs = thisParam.stripWhiteSpace();
 		QString ParamName  = thisParamNoWs.section('=', 0, 0);
-		QString ParamValue = thisParamNoWs.section('=', 1, 1);
+		QString ParamValue = thisParamNoWs.section('=', 1);
 		QString ParamValueNoQuotes = (ParamValue.startsWith(&quot;\&quot;&quot;)) ? ParamValue.section('\&quot;', 1, 1) : ParamValue;
 
 		if (ParamName == &quot;realm&quot;)

Modified: konference/src/sip/sipurl.h
===================================================================
--- konference/src/sip/sipurl.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/sip/sipurl.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -22,9 +22,6 @@
 
 #include &lt;qstring.h&gt;
 
-/**
<A HREF="https://lists.berlios.de/mailman/listinfo/konference-commits">- at author</A> Malte B&#246;hme
-*/
 class SipUrl
 {
 public:


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000008.html">[Konference-commits] r77 - konference/src/rtp/jrtplib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11">[ date ]</a>
              <a href="thread.html#11">[ thread ]</a>
              <a href="subject.html#11">[ subject ]</a>
              <a href="author.html#11">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/konference-commits">More information about the Konference-commits
mailing list</a><br>
</body></html>
