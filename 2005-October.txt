From maldn at berlios.de  Fri Oct 28 11:33:45 2005
From: maldn at berlios.de (Malte Böhme at BerliOS)
Date: Fri, 28 Oct 2005 11:33:45 +0200
Subject: [Konference-commits] r77 - konference/src/rtp/jrtplib
Message-ID: <200510280933.j9S9XjT0001565@sheep.berlios.de>

Author: maldn
Date: 2005-10-28 11:33:44 +0200 (Fri, 28 Oct 2005)
New Revision: 77

Removed:
   konference/src/rtp/jrtplib/.deps/
Log:
removed .dep




From maldn at berlios.de  Fri Oct 28 11:33:16 2005
From: maldn at berlios.de (Malte Böhme at BerliOS)
Date: Fri, 28 Oct 2005 11:33:16 +0200
Subject: [Konference-commits] r76 - in konference/src: . codecs rtp rtp/jrtplib rtp/jrtplib/.deps sip
Message-ID: <200510280933.j9S9XGks001525@sheep.berlios.de>

Author: maldn
Date: 2005-10-28 11:33:02 +0200 (Fri, 28 Oct 2005)
New Revision: 76

Added:
   konference/src/rtp/jrtplib/
   konference/src/rtp/jrtplib/.deps/
   konference/src/rtp/jrtplib/.deps/rtcpapppacket.Plo
   konference/src/rtp/jrtplib/.deps/rtcpbyepacket.Plo
   konference/src/rtp/jrtplib/.deps/rtcpcompoundpacket.Plo
   konference/src/rtp/jrtplib/.deps/rtcpcompoundpacketbuilder.Plo
   konference/src/rtp/jrtplib/.deps/rtcppacket.Plo
   konference/src/rtp/jrtplib/.deps/rtcppacketbuilder.Plo
   konference/src/rtp/jrtplib/.deps/rtcprrpacket.Plo
   konference/src/rtp/jrtplib/.deps/rtcpscheduler.Plo
   konference/src/rtp/jrtplib/.deps/rtcpsdesinfo.Plo
   konference/src/rtp/jrtplib/.deps/rtcpsdespacket.Plo
   konference/src/rtp/jrtplib/.deps/rtcpsrpacket.Plo
   konference/src/rtp/jrtplib/.deps/rtpcollisionlist.Plo
   konference/src/rtp/jrtplib/.deps/rtpdebug.Plo
   konference/src/rtp/jrtplib/.deps/rtperrors.Plo
   konference/src/rtp/jrtplib/.deps/rtpgsttransmitter.Plo
   konference/src/rtp/jrtplib/.deps/rtpinternalsourcedata.Plo
   konference/src/rtp/jrtplib/.deps/rtpipv4address.Plo
   konference/src/rtp/jrtplib/.deps/rtpipv6address.Plo
   konference/src/rtp/jrtplib/.deps/rtplibraryversion.Plo
   konference/src/rtp/jrtplib/.deps/rtppacket.Plo
   konference/src/rtp/jrtplib/.deps/rtppacketbuilder.Plo
   konference/src/rtp/jrtplib/.deps/rtppollthread.Plo
   konference/src/rtp/jrtplib/.deps/rtprandom.Plo
   konference/src/rtp/jrtplib/.deps/rtpsession.Plo
   konference/src/rtp/jrtplib/.deps/rtpsessionparams.Plo
   konference/src/rtp/jrtplib/.deps/rtpsessionsources.Plo
   konference/src/rtp/jrtplib/.deps/rtpsourcedata.Plo
   konference/src/rtp/jrtplib/.deps/rtpsources.Plo
   konference/src/rtp/jrtplib/.deps/rtptimeutilities.Plo
   konference/src/rtp/jrtplib/.deps/rtpudpv4transmitter.Plo
   konference/src/rtp/jrtplib/.deps/rtpudpv6transmitter.Plo
   konference/src/rtp/jrtplib/Makefile.am
   konference/src/rtp/jrtplib/rtcpapppacket.cpp
   konference/src/rtp/jrtplib/rtcpapppacket.h
   konference/src/rtp/jrtplib/rtcpbyepacket.cpp
   konference/src/rtp/jrtplib/rtcpbyepacket.h
   konference/src/rtp/jrtplib/rtcpcompoundpacket.cpp
   konference/src/rtp/jrtplib/rtcpcompoundpacket.h
   konference/src/rtp/jrtplib/rtcpcompoundpacketbuilder.cpp
   konference/src/rtp/jrtplib/rtcpcompoundpacketbuilder.h
   konference/src/rtp/jrtplib/rtcppacket.cpp
   konference/src/rtp/jrtplib/rtcppacket.h
   konference/src/rtp/jrtplib/rtcppacketbuilder.cpp
   konference/src/rtp/jrtplib/rtcppacketbuilder.h
   konference/src/rtp/jrtplib/rtcprrpacket.cpp
   konference/src/rtp/jrtplib/rtcprrpacket.h
   konference/src/rtp/jrtplib/rtcpscheduler.cpp
   konference/src/rtp/jrtplib/rtcpscheduler.h
   konference/src/rtp/jrtplib/rtcpsdesinfo.cpp
   konference/src/rtp/jrtplib/rtcpsdesinfo.h
   konference/src/rtp/jrtplib/rtcpsdespacket.cpp
   konference/src/rtp/jrtplib/rtcpsdespacket.h
   konference/src/rtp/jrtplib/rtcpsrpacket.cpp
   konference/src/rtp/jrtplib/rtcpsrpacket.h
   konference/src/rtp/jrtplib/rtcpunknownpacket.h
   konference/src/rtp/jrtplib/rtpaddress.h
   konference/src/rtp/jrtplib/rtpcollisionlist.cpp
   konference/src/rtp/jrtplib/rtpcollisionlist.h
   konference/src/rtp/jrtplib/rtpconfig.h
   konference/src/rtp/jrtplib/rtpconfig_unix.h
   konference/src/rtp/jrtplib/rtpconfig_unix.h.in
   konference/src/rtp/jrtplib/rtpconfig_win.h
   konference/src/rtp/jrtplib/rtpdebug.cpp
   konference/src/rtp/jrtplib/rtpdebug.h
   konference/src/rtp/jrtplib/rtpdefines.h
   konference/src/rtp/jrtplib/rtperrors.cpp
   konference/src/rtp/jrtplib/rtperrors.h
   konference/src/rtp/jrtplib/rtpgsttransmitter.cpp
   konference/src/rtp/jrtplib/rtpgsttransmitter.h
   konference/src/rtp/jrtplib/rtphashtable.h
   konference/src/rtp/jrtplib/rtpinternalsourcedata.cpp
   konference/src/rtp/jrtplib/rtpinternalsourcedata.h
   konference/src/rtp/jrtplib/rtpipv4address.cpp
   konference/src/rtp/jrtplib/rtpipv4address.h
   konference/src/rtp/jrtplib/rtpipv4destination.h
   konference/src/rtp/jrtplib/rtpipv6address.cpp
   konference/src/rtp/jrtplib/rtpipv6address.h
   konference/src/rtp/jrtplib/rtpipv6destination.h
   konference/src/rtp/jrtplib/rtpkeyhashtable.h
   konference/src/rtp/jrtplib/rtplibraryversion.cpp
   konference/src/rtp/jrtplib/rtplibraryversion.h
   konference/src/rtp/jrtplib/rtppacket.cpp
   konference/src/rtp/jrtplib/rtppacket.h
   konference/src/rtp/jrtplib/rtppacketbuilder.cpp
   konference/src/rtp/jrtplib/rtppacketbuilder.h
   konference/src/rtp/jrtplib/rtppollthread.cpp
   konference/src/rtp/jrtplib/rtppollthread.h
   konference/src/rtp/jrtplib/rtprandom.cpp
   konference/src/rtp/jrtplib/rtprandom.h
   konference/src/rtp/jrtplib/rtprawpacket.h
   konference/src/rtp/jrtplib/rtpsession.cpp
   konference/src/rtp/jrtplib/rtpsession.h
   konference/src/rtp/jrtplib/rtpsessionparams.cpp
   konference/src/rtp/jrtplib/rtpsessionparams.h
   konference/src/rtp/jrtplib/rtpsessionsources.cpp
   konference/src/rtp/jrtplib/rtpsessionsources.h
   konference/src/rtp/jrtplib/rtpsourcedata.cpp
   konference/src/rtp/jrtplib/rtpsourcedata.h
   konference/src/rtp/jrtplib/rtpsources.cpp
   konference/src/rtp/jrtplib/rtpsources.h
   konference/src/rtp/jrtplib/rtpstructs.h
   konference/src/rtp/jrtplib/rtptimeutilities.cpp
   konference/src/rtp/jrtplib/rtptimeutilities.h
   konference/src/rtp/jrtplib/rtptransmitter.h
   konference/src/rtp/jrtplib/rtptypes.h
   konference/src/rtp/jrtplib/rtptypes_unix.h
   konference/src/rtp/jrtplib/rtptypes_win.h
   konference/src/rtp/jrtplib/rtpudpv4transmitter.cpp
   konference/src/rtp/jrtplib/rtpudpv4transmitter.h
   konference/src/rtp/jrtplib/rtpudpv6transmitter.cpp
   konference/src/rtp/jrtplib/rtpudpv6transmitter.h
Modified:
   konference/src/Makefile.am
   konference/src/codecs/Makefile.am
   konference/src/codecs/codecbase.h
   konference/src/codecs/speexcodec.cpp
   konference/src/codecs/speexcodec.h
   konference/src/konference_part.cpp
   konference/src/konference_part.h
   konference/src/rtp/Makefile.am
   konference/src/rtp/jitter.cpp
   konference/src/rtp/jitter.h
   konference/src/rtp/rtpaudio.cpp
   konference/src/rtp/rtpaudio.h
   konference/src/rtp/rtpbase.h
   konference/src/rtp/rtpvideo.cpp
   konference/src/rtp/rtpvideo.h
   konference/src/sip/sipfsm.cpp
   konference/src/sip/sipmsg.cpp
   konference/src/sip/sipurl.h
Log:
_big_ patch...
biggest changes: replaced rtp-subsystem with jrtplib and added 
speex-codec


Modified: konference/src/Makefile.am
===================================================================
--- konference/src/Makefile.am	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/Makefile.am	2005-10-28 09:33:02 UTC (rev 76)
@@ -1,6 +1,6 @@
 # set the include path for X, qt and KDE
 INCLUDES = -I$(top_srcdir)/src/dialogs -I$(top_srcdir)/src/dialogs/config \
-	-I$(top_srcdir)/src/dialogs/wizard $(all_includes)
+	-I$(top_srcdir)/src/dialogs/wizard -I$(top_srcdir)/src/rtp/jrtplib $(all_includes)
 
 # these are the headers for your project
 noinst_HEADERS = konference.h konference_part.h videowidget.h konferenceui.h \

Modified: konference/src/codecs/Makefile.am
===================================================================
--- konference/src/codecs/Makefile.am	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/codecs/Makefile.am	2005-10-28 09:33:02 UTC (rev 76)
@@ -7,4 +7,4 @@
 	gsmcodec.cpp speexcodec.cpp
 SUBDIRS = gsm
 
-libcodecs_la_LIBADD = $(top_builddir)/src/codecs/gsm/libgsm.la
+libcodecs_la_LIBADD = $(top_builddir)/src/codecs/gsm/libgsm.la -lspeex

Modified: konference/src/codecs/codecbase.h
===================================================================
--- konference/src/codecs/codecbase.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/codecs/codecbase.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -30,12 +30,12 @@
 class codecBase
 {
 public:
-    codecBase();
+	codecBase();
 	virtual ~codecBase();
-    virtual int Decode(uchar *In, short *out, int Len, short &maxPower)=0;
-    virtual int Encode(short *In, uchar *out, int Samples, short &maxPower, int gain)=0;
-    virtual int Silence(uchar *out, int ms)=0;
-    virtual QString getCodecName()=0;
+	virtual int Decode(uchar *In, short *out, int Len, short &maxPower)=0;
+	virtual int Encode(short *In, uchar *out, int Samples, short &maxPower, int gain)=0;
+	virtual int Silence(uchar *out, int ms)=0;
+	virtual QString getCodecName()=0;
 	virtual int getPayload()=0;
 };
 

Modified: konference/src/codecs/speexcodec.cpp
===================================================================
--- konference/src/codecs/speexcodec.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/codecs/speexcodec.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -17,16 +17,88 @@
  *   Free Software Foundation, Inc.,                                       *
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
+
+#include <iostream>
+using namespace std;
+
 #include "speexcodec.h"
 
-speexCodec::speexCodec()
- : codecBase()
+speexCodec::speexCodec(): codecBase()
 {
+	//encoder
+	speex_bits_init(&m_encSpeexBits);
+	m_encState = speex_encoder_init(&speex_nb_mode);
+	speex_encoder_ctl(m_encState,SPEEX_GET_FRAME_SIZE,&m_encFrameSize);
+	int tmp=15;
+	speex_encoder_ctl(m_encState, SPEEX_SET_QUALITY, &tmp);
+	cout << "FRAMESIZE encoder:" << m_encFrameSize << endl;
+
+	//decoder
+	speex_bits_init(&m_decSpeexBits);
+	m_decState = speex_decoder_init(&speex_nb_mode);
+	speex_decoder_ctl(m_decState, SPEEX_GET_FRAME_SIZE, &m_decFrameSize);
+	//There is also a parameter that can be set for the decoder: whether or not to use a perceptual post-filter. This can be set by:
+	//speex_decoder_ctl(dec_state, SPEEX_SET_ENH, &enh);
+	//where enh is an int that with value 0 to have the post-filter disabled and 1 to have it enabled.
+	cout << "FRAMESIZE decoder:" << m_decFrameSize << endl;
 }
 
-
 speexCodec::~speexCodec()
 {
+	speex_bits_destroy(&m_encSpeexBits);
+	speex_encoder_destroy(m_encState);
+
+	speex_bits_destroy(&m_decSpeexBits);
+	speex_decoder_destroy(m_decState);
 }
 
+int speexCodec::Encode(short *In, unsigned char *Out, int Samples, short &maxPower, int gain)
+{
+//memcpy(faketmp,In,160);
 
+	int MAX_NB_BYTES = 2000;//nb = number (of) bytes
+	float in_float[160];//should be 160 framesize
+	int i;
+	for (i=0;i<m_encFrameSize;i++)
+	{
+		in_float[i]=In[i];
+	}
+	char out_bits[MAX_NB_BYTES];
+	int len=0;
+	speex_bits_reset(&m_encSpeexBits);
+	speex_encode(m_encState, in_float, &m_encSpeexBits);
+	len = speex_bits_write(&m_encSpeexBits, out_bits, MAX_NB_BYTES);
+	memcpy(Out,out_bits,len);
+	
+	
+	return len;
+}
+
+int speexCodec::Decode(unsigned char *In, short *Out, int Len, short &maxPower)
+{
+	float out_float[160];//should be 160 framesize
+
+	char in_bits[160];
+	memcpy(in_bits, In,Len);
+	speex_bits_read_from(&m_decSpeexBits, in_bits, Len);
+	speex_decode(m_decState, &m_decSpeexBits, out_float);
+
+	int i;
+	for (i=0;i<m_encFrameSize;i++)
+	{
+		Out[i]=out_float[i];
+	}
+	//memcpy(Out,faketmp,160);
+	return m_decFrameSize*sizeof(short);
+}
+
+int speexCodec::Silence(uchar *out, int ms)
+{
+	if (ms != 20)
+		cout << "SPEEX: Silence unsupported length " << ms << endl;
+
+	//short pcmSilence[160];
+	//memset(pcmSilence, 0, 160*sizeof(short));
+	//gsm_encode(gsmEncData, pcmSilence, out);
+	return 0;//TODO
+}

Modified: konference/src/codecs/speexcodec.h
===================================================================
--- konference/src/codecs/speexcodec.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/codecs/speexcodec.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -20,7 +20,7 @@
 #ifndef SPEEXCODEC_H
 #define SPEEXCODEC_H
 
-//#include <speex.h>
+#include <speex/speex.h>
 
 #include "codecbase.h"
 
@@ -30,10 +30,27 @@
 class speexCodec : public codecBase
 {
 public:
-    speexCodec();
+	speexCodec();
 
-    ~speexCodec();
+	~speexCodec();
+	//reimplemented from base-class
+	QString getCodecName(){return "speex";};
+	int getPayload(){return 0x61;};
+	int Decode(uchar *In, short *out, int Len, short &maxPower);
+	int Encode(short *In, uchar *out, int Samples, short &maxPower, int gain);
+	int Silence(uchar *out, int ms);
 
+private:
+	//encoder
+	SpeexBits m_encSpeexBits;
+	void *m_encState;
+	int m_encFrameSize;
+
+	//decoder
+	SpeexBits m_decSpeexBits;
+	void *m_decState;
+	int m_decFrameSize;
+	//short faketmp[320];
 };
 
 #endif

Modified: konference/src/konference_part.cpp
===================================================================
--- konference/src/konference_part.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/konference_part.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -47,6 +47,7 @@
 #include "codecs/codecbase.h"
 #include "codecs/gsmcodec.h"
 #include "codecs/g711.h"
+#include "codecs/speexcodec.h"
 #include "codecs/h263.h"
 #include "sip/sipcontainer.h"
 #include "audio/oss.h"
@@ -55,6 +56,11 @@
 #include "konferenceui.h"
 #include "dialogs/wizard/wizard.h"
 
+#define RTP_PAYLOAD_G711U		0x00
+#define RTP_PAYLOAD_G711A		0x08
+#define RTP_PAYLOAD_COMF_NOISE	0x0D
+#define RTP_PAYLOAD_GSM			0x03
+#define RTP_PAYLOAD_SPEEX		0x61
 
 KonferencePart::KonferencePart( QWidget *parentWidget, const char *widgetName,
                                 QObject *parent, const char *name )
@@ -216,6 +222,8 @@
 				}
 			default:
 				kdDebug() << "		DEFAULT:" << NotifyParam2 << endl;
+				kdDebug() << "		DEFAULT:" << NotifyParam1 << endl;
+				kdDebug() << "		DEFAULT:" << NotifyUrl << endl;
 				break;
 			}
 		}
@@ -338,6 +346,11 @@
 		m_audioCodec = new g711ulaw();
 	}
 
+	//speex-testing
+	kdDebug() << "using speex codec" << endl;
+	audioPayload = RTP_PAYLOAD_SPEEX;
+	m_audioCodec = new speexCodec();
+
 	if(KonferenceSettings::audioPlugin() == KonferenceSettings::EnumAudioPlugin::OSS)
 	{
 		kdDebug() << "using OSS driver" << endl;
@@ -358,10 +371,12 @@
 		m_audioDevice->openDevice("plughw:0,0");
 	}
 
+	//m_rtpAudio = new rtpAudio(KonferenceSettings::localAudioPort(), remoteIP,
+	//                          remoteAudioPort, audioPayload, dtmfPayload,
+	//                          m_audioCodec, m_audioDevice);
 	m_rtpAudio = new rtpAudio(KonferenceSettings::localAudioPort(), remoteIP,
-	                          remoteAudioPort, audioPayload, dtmfPayload,
-	                          m_audioCodec, m_audioDevice);
-
+	                          remoteAudioPort,  m_audioCodec, m_audioDevice);
+	 
 	//kdDebug() << "dtmfpayload: " << dtmfPayload << endl;
 }
 
@@ -408,8 +423,7 @@
 
 	h263->H263StartEncoder(m_webcam->width(), m_webcam->height(), 5);
 	h263->H263StartDecoder(w, h);
-	m_rtpVideo = new rtpVideo (this, KonferenceSettings::localVideoPort(), remoteIP,
-	                           remoteVideoPort, videoPayload,RTP_TX_VIDEO, RTP_RX_VIDEO);
+	m_rtpVideo = new rtpVideo(this,KonferenceSettings::localVideoPort(), remoteIP,remoteVideoPort, videoPayload,5.0);
 }
 
 void KonferencePart::stopVideoRTP()
@@ -418,32 +432,23 @@
 
 	h263->H263StopEncoder();
 	h263->H263StopDecoder();
-	if(m_rtpVideo)
-		delete m_rtpVideo;
-	m_rtpVideo = 0;
+	m_rtpVideo->stop();
+	delete m_rtpVideo;
 }
 
 void KonferencePart::ProcessRxVideoFrame()
 {
-	VIDEOBUFFER *v;
+	VIDEOBUFFER v;
+	m_rtpVideo->getReceivedFrame(&v);
 
-	//kdDebug() << "KonferencePart::ProcessRxVideoFrame()" << endl;
-
-	//TODO always true, isnt it?
-	if (m_rtpVideo && (v = m_rtpVideo->getRxedVideo()))
+	//kdDebug() << "====> v.h=" << v.h << " v.w=" << v.w << "v.len=" << v.len << endl;
+	uchar *decRgbFrame = h263->H263DecodeFrame(v.video, v.len, rxRgbBuffer, sizeof(rxRgbBuffer));
+	if (decRgbFrame)
 	{
-		//kdDebug() << "rtpVideo && (v = rtpVideo->getRxedVideo())" << endl;
-
-		uchar *decRgbFrame = h263->H263DecodeFrame(v->video, v->len, rxRgbBuffer, sizeof(rxRgbBuffer));
-		if (decRgbFrame)
-		{
-			//kdDebug() << "if (decRgbFrame)" << endl;
-
-			QImage rxImage(rxRgbBuffer, v->w, v->h, 32, (QRgb *)0, 0, QImage::LittleEndian);
-			KonferenceNewImageEvent* ce = new KonferenceNewImageEvent( rxImage, KonferenceNewImageEvent::REMOTE );
-			QApplication::postEvent( m_widget, ce );  // Qt will delete the event when done-
-		}
-		m_rtpVideo->freeVideoBuffer(v);
+		//kdDebug() << "if (decRgbFrame)" << endl;
+		QImage rxImage(rxRgbBuffer, v.w, v.h, 32, (QRgb *)0, 0, QImage::LittleEndian);
+		KonferenceNewImageEvent* ce = new KonferenceNewImageEvent( rxImage, KonferenceNewImageEvent::REMOTE );
+		QApplication::postEvent( m_widget, ce );  // Qt will delete the event when done-
 	}
 }
 
@@ -452,7 +457,7 @@
 	uchar *yuvFrame = m_webcam->GetVideoFrame(m_txWebcamClient);
 
 	int encLen=0;
-	if (yuvFrame != 0 && m_rtpVideo)
+	if ((yuvFrame != 0)/* && m_rtpVideo2*/)
 	{
 		//TODO find better fix for odd quickcam resolutions
 		int txWidth = m_webcam->width();//176;
@@ -472,27 +477,28 @@
 		else
 		{
 
-			VIDEOBUFFER *vb = m_rtpVideo->getVideoBuffer(0);
-			if (vb)
+			VIDEOBUFFER *vb = new VIDEOBUFFER;// = m_rtpVideo->getVideoBuffer(0);
+			//if (vb)
+			//{
+			if (encLen > (int)sizeof(vb->video))
 			{
-				if (encLen > (int)sizeof(vb->video))
-				{
-					kdDebug()  << "SIP: Encoded H.263 frame size is " << encLen << "; too big for buffer\n";
-					m_rtpVideo->freeVideoBuffer(vb);
-				}
-				else
-				{
-					memcpy(vb->video, encFrame, encLen); // Optimisation to get rid of this copy may be possible, check H.263 stack
-					vb->len = encLen;
-					vb->w = m_webcam->width();//176;
-					vb->h = m_webcam->height();//144;
-					if (!m_rtpVideo->queueVideo(vb))
-					{
-						kdDebug()  << "KonferencePart::TransmitLocalWebcamImage(): Could not queue RTP Video frame for transmission\n";
-						m_rtpVideo->freeVideoBuffer(vb);
-					}
-				}
+				kdDebug()  << "Encoded H.263 frame size is " << encLen << "; too big for buffer\n";
+				//m_rtpVideo->freeVideoBuffer(vb);
 			}
+			else
+			{
+				memcpy(vb->video, encFrame, encLen); // Optimisation to get rid of this copy may be possible, check H.263 stack
+				vb->len = encLen;
+				vb->w = m_webcam->width();//176;
+				vb->h = m_webcam->height();//144;
+				m_rtpVideo->queueVideoForTransmission(vb);
+				//if (!m_rtpVideo->queueVideo(vb))
+				//{
+				//	kdDebug()  << "KonferencePart::TransmitLocalWebcamImage(): Could not queue RTP Video frame for transmission\n";
+				//m_rtpVideo->freeVideoBuffer(vb);
+				//}
+			}
+			//}
 		}
 		m_webcam->FreeVideoBuffer(m_txWebcamClient, yuvFrame);
 	}
@@ -594,8 +600,8 @@
 void KonferencePart::connectClicked()
 {//TODO enabling buttons needs fix
 	//TODO Mode not used?
-	kdDebug() << "moooh" << endl;
-	sipStack->PlaceNewCall("CIF", m_location->currentText(), "", 1);
+	//kdDebug() << "moooh" << endl;
+	sipStack->PlaceNewCall("QCIF", m_location->currentText(), "mooh", 1);
 	m_cancelAction->setEnabled(true);
 	m_connectAction->setEnabled(false);
 	addToHistory(KURL(m_location->currentText()));

Modified: konference/src/konference_part.h
===================================================================
--- konference/src/konference_part.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/konference_part.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -43,7 +43,7 @@
 class KonferenceUI;
 class KonferenceWizard;
 #include "dcopiface.h"
-
+#include "rtp/rtpvideo.h"
 /**
  * This is a "Part".  It that does all the real work in a KPart
  * application.
@@ -78,7 +78,7 @@
 	*/
 	virtual void call(const QString &ip);
 	//dcop stuff ends here
-	
+
 protected:
 	/**
 	 * This must be implemented by each part
@@ -92,7 +92,7 @@
 	void showConfigDialog();
 
 	void showWizard();
-	
+
 	/**
 	 * Reloads the configuration
 	 */
@@ -150,7 +150,7 @@
 	 * Our wizard
 	 */
 	KonferenceWizard *m_wizard;
-	
+
 	/**
 	 * This handles the grabbing from our cam. if there is a new frame our part get an event.
 	 */
@@ -177,7 +177,6 @@
 
 	rtpVideo *m_rtpVideo;
 	rtpAudio *m_rtpAudio;
-
 	wcClient *m_localWebcamClient;
 	wcClient *m_txWebcamClient;
 

Modified: konference/src/rtp/Makefile.am
===================================================================
--- konference/src/rtp/Makefile.am	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/Makefile.am	2005-10-28 09:33:02 UTC (rev 76)
@@ -1,7 +1,12 @@
-INCLUDES = -I$(top_srcdir)/src/dialogs -I$(top_srcdir)/src/dialogs/config \
-	-I$(top_srcdir)/src/dialogs/wizard -I$(top_srcdir)/src/rtp -I$(top_srcdir)/src/codecs $(all_includes)
+INCLUDES = -I$(top_srcdir)/src/codecs -I$(top_srcdir)/src/dialogs \
+	-I$(top_srcdir)/src/dialogs/config -I$(top_srcdir)/src/dialogs/wizard -I$(top_srcdir)/src/rtp \
+	-I$(top_srcdir)/src/rtp/jrtplib $(all_includes)
 METASOURCES = AUTO
 librtp_la_LDFLAGS = $(all_libraries)
 noinst_LTLIBRARIES = librtp.la
-noinst_HEADERS = jitter.h
-librtp_la_SOURCES = jitter.cpp rtpbase.cpp rtpvideo.cpp rtpaudio.cpp
+
+librtp_la_SOURCES = rtpvideo.cpp rtpaudio.cpp
+
+SUBDIRS = jrtplib
+librtp_la_LIBADD = $(top_builddir)/src/rtp/jrtplib/libjrtp.la
+AM_CXXFLAGS = -DRTPDEBUG

Modified: konference/src/rtp/jitter.cpp
===================================================================
--- konference/src/rtp/jitter.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jitter.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -98,15 +98,15 @@
 	}
 }
 
-
+/*
 int Jitter::compareItems(QPtrCollection::Item s1, QPtrCollection::Item s2)
 {
 	RTPPACKET *r1 = (RTPPACKET *)s1;
 	RTPPACKET *r2 = (RTPPACKET *)s2;
 	return (r1->RtpSequenceNumber - r2->RtpSequenceNumber);
 }
+*/
 
-
 RTPPACKET *Jitter::DequeueJBuffer(ushort seqNum, int &reason)
 {
 	RTPPACKET *head = first();

Modified: konference/src/rtp/jitter.h
===================================================================
--- konference/src/rtp/jitter.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jitter.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -38,7 +38,6 @@
 #define JB_REASON_DTMF        4   // Buffer which matches seq-number contained DTMF
 #define JB_REASON_DUPLICATE   5   // Got the same sequence number twice
 
-
 typedef struct RTPPACKET
 {
   int     len;                       // Not part of the RTP frame itself
@@ -64,7 +63,7 @@
     void		InsertJBuffer(RTPPACKET *Buffer);
     RTPPACKET *DequeueJBuffer(ushort seqNum, int &reason);  
     int     DumpAllJBuffers(bool StopAtMarkerBit);
-    virtual int compareItems(QPtrCollection::Item s1, QPtrCollection::Item s2);
+   // virtual int compareItems(QPtrCollection::Item s1, QPtrCollection::Item s2);
     int AnyData() { return count(); };
     bool isPacketQueued(ushort Seq);
     int GotAllBufsInFrame(ushort seq, int offset);

Added: konference/src/rtp/jrtplib/.deps/rtcpapppacket.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcpapppacket.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcpapppacket.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtcpbyepacket.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcpbyepacket.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcpbyepacket.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtcpcompoundpacket.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcpcompoundpacket.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcpcompoundpacket.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtcpcompoundpacketbuilder.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcpcompoundpacketbuilder.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcpcompoundpacketbuilder.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtcppacket.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcppacket.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcppacket.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtcppacketbuilder.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcppacketbuilder.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcppacketbuilder.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtcprrpacket.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcprrpacket.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcprrpacket.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtcpscheduler.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcpscheduler.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcpscheduler.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtcpsdesinfo.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcpsdesinfo.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcpsdesinfo.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtcpsdespacket.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcpsdespacket.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcpsdespacket.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtcpsrpacket.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtcpsrpacket.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtcpsrpacket.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpcollisionlist.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpcollisionlist.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpcollisionlist.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpdebug.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpdebug.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpdebug.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtperrors.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtperrors.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtperrors.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpgsttransmitter.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpgsttransmitter.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpgsttransmitter.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpinternalsourcedata.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpinternalsourcedata.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpinternalsourcedata.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpipv4address.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpipv4address.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpipv4address.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpipv6address.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpipv6address.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpipv6address.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtplibraryversion.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtplibraryversion.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtplibraryversion.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtppacket.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtppacket.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtppacket.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtppacketbuilder.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtppacketbuilder.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtppacketbuilder.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtppollthread.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtppollthread.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtppollthread.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtprandom.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtprandom.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtprandom.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpsession.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpsession.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpsession.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpsessionparams.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpsessionparams.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpsessionparams.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpsessionsources.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpsessionsources.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpsessionsources.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpsourcedata.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpsourcedata.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpsourcedata.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpsources.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpsources.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpsources.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtptimeutilities.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtptimeutilities.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtptimeutilities.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpudpv4transmitter.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpudpv4transmitter.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpudpv4transmitter.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/.deps/rtpudpv6transmitter.Plo
===================================================================
--- konference/src/rtp/jrtplib/.deps/rtpudpv6transmitter.Plo	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/.deps/rtpudpv6transmitter.Plo	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+# dummy

Added: konference/src/rtp/jrtplib/Makefile.am
===================================================================
--- konference/src/rtp/jrtplib/Makefile.am	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/Makefile.am	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,35 @@
+noinst_LTLIBRARIES = libjrtp.la
+libjrtp_la_SOURCES = rtpdebug.cpp rtpsession.cpp rtpconfig_win.h \
+		     rtperrors.cpp rtpudpv4transmitter.cpp \
+		     rtcpsdesinfo.cpp rtppollthread.cpp rtppacket.cpp \
+		     rtppacketbuilder.cpp rtpsessionparams.cpp \
+		     rtpsources.cpp rtpinternalsourcedata.cpp \
+		     rtpsourcedata.cpp rtpipv4address.cpp \
+		     rtcpcompoundpacket.cpp \
+		     rtcpapppacket.cpp rtcpbyepacket.cpp \
+		     rtcprrpacket.cpp rtcpsdespacket.cpp \
+		     rtcpsrpacket.cpp rtplibraryversion.cpp \
+		     rtcppacket.cpp rtcpcompoundpacketbuilder.cpp \
+		     rtprandom.cpp rtcpscheduler.cpp \
+		     rtcppacketbuilder.cpp rtpsessionsources.cpp \
+		     rtpcollisionlist.cpp rtpipv6address.cpp \
+		     rtpudpv6transmitter.cpp rtptimeutilities.cpp \
+		     rtpgsttransmitter.cpp
+
+noinst_HEADERS = rtcpapppacket.h rtcpbyepacket.h rtcpcompoundpacket.h \
+			 rtcpcompoundpacketbuilder.h rtcppacket.h rtcppacketbuilder.h \
+			 rtcprrpacket.h rtcpscheduler.h rtcpsdesinfo.h rtcpsdespacket.h \
+			 rtcpsrpacket.h rtcpunknownpacket.h rtpaddress.h rtpconfig.h \
+			 rtpconfig_win.h rtpdebug.h rtpdefines.h rtperrors.h rtphashtable.h \
+			 rtpconfig_unix.h rtpinternalsourcedata.h rtpipv4address.h \
+			 rtpipv4destination.h rtpkeyhashtable.h rtplibraryversion.h rtppacket.h \
+			 rtppacketbuilder.h rtppollthread.h rtprandom.h rtprawpacket.h \
+			 rtpsession.h rtpsessionparams.h rtpsourcedata.h rtpsources.h \
+			 rtpstructs.h rtptimeutilities.h rtptransmitter.h \
+			 rtptypes_win.h rtpudpv4transmitter.h rtpsessionsources.h \
+			 rtpcollisionlist.h rtpipv6address.h rtpipv6destination.h \
+			 rtpudpv6transmitter.h rtptypes.h rtptypes_unix.h \
+			 rtpgsttransmitter.h
+EXTRA_DIST = rtpconfig_unix.h.in
+
+AM_CXXFLAGS = -DRTPDEBUG

Added: konference/src/rtp/jrtplib/rtcpapppacket.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcpapppacket.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpapppacket.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,87 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtcpapppacket.h"
+#ifdef RTPDEBUG
+	#include <iostream>
+	#include <string>
+#endif // RTPDEBUG
+
+#include "rtpdebug.h"
+
+RTCPAPPPacket::RTCPAPPPacket(u_int8_t *data,size_t datalength)
+	: RTCPPacket(APP,data,datalength)
+{
+	knownformat = false;
+	
+	RTCPCommonHeader *hdr;
+	size_t len = datalength;
+	
+	hdr = (RTCPCommonHeader *)data;
+	if (hdr->padding)
+	{
+		u_int8_t padcount = data[datalength-1];
+		if ((padcount & 0x03) != 0) // not a multiple of four! (see rfc 3550 p 37)
+			return;
+		if (((size_t)padcount) >= len)
+			return;
+		len -= (size_t)padcount;
+	}
+	
+	if (len < (sizeof(RTCPCommonHeader)+sizeof(u_int32_t)*2))
+		return;
+	len -= (sizeof(RTCPCommonHeader)+sizeof(u_int32_t)*2);
+	appdatalen = len;
+	knownformat = true;
+}
+
+#ifdef RTPDEBUG
+void RTCPAPPPacket::Dump()
+{
+	RTCPPacket::Dump();
+	if (!IsKnownFormat())
+	{
+		std::cout << "    Unknown format!" << std::endl;
+	}
+	else
+	{
+		std::cout << "    SSRC:   " << GetSSRC() << std::endl;
+		
+		char str[5];
+		memcpy(str,GetName(),4);
+		str[4] = 0;
+		std::cout << "    Name:   " << std::string(str).c_str() << std::endl;
+		std::cout << "    Length: " << GetAPPDataLength() << std::endl;
+	}
+}
+#endif // RTPDEBUG
+

Added: konference/src/rtp/jrtplib/rtcpapppacket.h
===================================================================
--- konference/src/rtp/jrtplib/rtcpapppacket.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpapppacket.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,106 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPAPPPACKET_H
+
+#define RTCPAPPPACKET_H
+
+#include "rtpconfig.h"
+#include "rtcppacket.h"
+#include "rtpstructs.h"
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include <netinet/in.h>
+#endif // WIN32 
+
+class RTCPCompoundPacket;
+
+class RTCPAPPPacket : public RTCPPacket
+{
+public:
+	RTCPAPPPacket(u_int8_t *data,size_t datalen);
+	~RTCPAPPPacket()							{ }
+
+	u_int8_t GetSubType() const;
+	u_int32_t GetSSRC() const;
+	u_int8_t *GetName(); // Note that the name always consists of 4 octets and is not null-terminated
+	u_int8_t *GetAPPData();
+	size_t GetAPPDataLength() const;
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG	
+private:
+	size_t appdatalen;
+};
+
+inline u_int8_t RTCPAPPPacket::GetSubType() const
+{
+	if (!knownformat)
+		return 0;
+	RTCPCommonHeader *hdr = (RTCPCommonHeader *)data;
+	return hdr->count;
+}
+
+inline u_int32_t RTCPAPPPacket::GetSSRC() const
+{
+	if (!knownformat)
+		return 0;
+
+	u_int32_t *ssrc = (u_int32_t *)(data+sizeof(RTCPCommonHeader));
+	return ntohl(*ssrc);	
+}
+
+inline u_int8_t *RTCPAPPPacket::GetName()
+{
+	if (!knownformat)
+		return 0;
+
+	return (data+sizeof(RTCPCommonHeader)+sizeof(u_int32_t));	
+}
+
+inline u_int8_t *RTCPAPPPacket::GetAPPData()
+{
+	if (!knownformat)
+		return 0;
+	if (appdatalen == 0)
+		return 0;
+	return (data+sizeof(RTCPCommonHeader)+sizeof(u_int32_t)*2);
+}
+
+inline size_t RTCPAPPPacket::GetAPPDataLength() const
+{
+	if (!knownformat)
+		return 0;
+	return appdatalen;
+}
+
+#endif // RTCPAPPPACKET_H
+

Added: konference/src/rtp/jrtplib/rtcpbyepacket.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcpbyepacket.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpbyepacket.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,98 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtcpbyepacket.h"
+#ifdef RTPDEBUG
+	#include <iostream>
+#endif // RTPDEBUG
+
+#include "rtpdebug.h"
+
+RTCPBYEPacket::RTCPBYEPacket(u_int8_t *data,size_t datalength)
+	: RTCPPacket(BYE,data,datalength)
+{
+	knownformat = false;
+	reasonoffset = 0;	
+	
+	RTCPCommonHeader *hdr;
+	size_t len = datalength;
+	
+	hdr = (RTCPCommonHeader *)data;
+	if (hdr->padding)
+	{
+		u_int8_t padcount = data[datalength-1];
+		if ((padcount & 0x03) != 0) // not a multiple of four! (see rfc 3550 p 37)
+			return;
+		if (((size_t)padcount) >= len)
+			return;
+		len -= (size_t)padcount;
+	}
+	
+	size_t ssrclen = ((size_t)(hdr->count))*sizeof(u_int32_t) + sizeof(RTCPCommonHeader);
+	if (ssrclen > len)
+		return;
+	if (ssrclen < len) // there's probably a reason for leaving
+	{
+		u_int8_t *reasonlength = (data+ssrclen);
+		size_t reaslen = (size_t)(*reasonlength);
+		if (reaslen > (len-ssrclen-1))
+			return;
+		reasonoffset = ssrclen;
+	}
+	knownformat = true;
+}
+
+#ifdef RTPDEBUG
+void RTCPBYEPacket::Dump()
+{
+	RTCPPacket::Dump();
+	if (!IsKnownFormat())
+	{
+		std::cout << "    Unknown format" << std::endl;
+		return;	
+	}
+
+	int num = GetSSRCCount();
+	int i;
+
+	for (i = 0 ; i < num ; i++)
+		std::cout << "    SSRC: " << GetSSRC(i) << std::endl;
+	if (HasReasonForLeaving())
+	{
+		char str[1024];
+		memcpy(str,GetReasonData(),GetReasonLength());
+		str[GetReasonLength()] = 0;
+		std::cout << "    Reason: " << str << std::endl;
+	}
+}
+#endif // RTPDEBUG
+

Added: konference/src/rtp/jrtplib/rtcpbyepacket.h
===================================================================
--- konference/src/rtp/jrtplib/rtcpbyepacket.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpbyepacket.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,114 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPBYEPACKET_H
+
+#define RTCPBYEPACKET_H
+
+#include "rtpconfig.h"
+#include "rtcppacket.h"
+#include "rtpstructs.h"
+#if ! (defined(WIN32) || defined (_WIN32_WCE))
+	#include <netinet/in.h>
+#endif // WIN32
+
+class RTCPCompoundPacket;
+
+class RTCPBYEPacket : public RTCPPacket
+{
+public:
+	RTCPBYEPacket(u_int8_t *data,size_t datalen);
+	~RTCPBYEPacket()							{ }
+	
+	int GetSSRCCount() const;
+	u_int32_t GetSSRC(int index) const; // note: no check is performed to see if index is valid!
+	bool HasReasonForLeaving() const;
+	size_t GetReasonLength() const;
+	u_int8_t *GetReasonData();
+
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+private:
+	size_t reasonoffset;
+};
+		      
+inline int RTCPBYEPacket::GetSSRCCount() const
+{
+	if (!knownformat)
+		return 0;
+
+	RTCPCommonHeader *hdr = (RTCPCommonHeader *)data;
+	return (int)(hdr->count);
+}
+
+inline u_int32_t RTCPBYEPacket::GetSSRC(int index) const
+{
+	if (!knownformat)
+		return 0;
+	u_int32_t *ssrc = (u_int32_t *)(data+sizeof(RTCPCommonHeader)+sizeof(u_int32_t)*index);
+	return ntohl(*ssrc);
+}
+
+inline bool RTCPBYEPacket::HasReasonForLeaving() const
+{
+	if (!knownformat)
+		return false;
+	if (reasonoffset == 0)
+		return false;
+	return true;
+}
+
+inline size_t RTCPBYEPacket::GetReasonLength() const
+{
+	if (!knownformat)
+		return 0;
+	if (reasonoffset == 0)
+		return 0;
+	u_int8_t *reasonlen = (data+reasonoffset);
+	return (size_t)(*reasonlen);
+}
+
+inline u_int8_t *RTCPBYEPacket::GetReasonData()
+{
+	if (!knownformat)
+		return 0;
+	if (reasonoffset == 0)
+		return 0;
+	u_int8_t *reasonlen = (data+reasonoffset);
+	if ((*reasonlen) == 0)
+		return 0;
+	return (data+reasonoffset+1);	
+}
+
+#endif // RTCPBYEPACKET_H
+

Added: konference/src/rtp/jrtplib/rtcpcompoundpacket.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcpcompoundpacket.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpcompoundpacket.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,208 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtcpcompoundpacket.h"
+#include "rtprawpacket.h"
+#include "rtperrors.h"
+#include "rtpstructs.h"
+#include "rtpdefines.h"
+#include "rtcpsrpacket.h"
+#include "rtcprrpacket.h"
+#include "rtcpsdespacket.h"
+#include "rtcpbyepacket.h"
+#include "rtcpapppacket.h"
+#include "rtcpunknownpacket.h"
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include <netinet/in.h>
+#endif // WIN32
+
+#include "rtpdebug.h"
+
+RTCPCompoundPacket::RTCPCompoundPacket(RTPRawPacket &rawpack)
+{
+	compoundpacket = 0;
+	compoundpacketlength = 0;
+	error = 0;
+	
+	if (rawpack.IsRTP())
+	{
+		error = ERR_RTP_RTCPCOMPOUND_INVALIDPACKET;
+		return;
+	}
+
+	u_int8_t *data = rawpack.GetData();
+	size_t datalen = rawpack.GetDataLength();
+	bool first;
+	
+	if (datalen < sizeof(RTCPCommonHeader))
+	{
+		error = ERR_RTP_RTCPCOMPOUND_INVALIDPACKET;
+		return;
+	}
+
+	first = true;
+	
+	do
+	{
+		RTCPCommonHeader *rtcphdr;
+		size_t length;
+		
+		rtcphdr = (RTCPCommonHeader *)data;
+		if (rtcphdr->version != RTP_VERSION) // check version
+		{
+			ClearPacketList();
+			error = ERR_RTP_RTCPCOMPOUND_INVALIDPACKET;
+			return;
+		}
+		if (first)
+		{
+			// Check if first packet is SR or RR
+			
+			first = false;
+			if ( ! (rtcphdr->packettype == RTP_RTCPTYPE_SR || rtcphdr->packettype == RTP_RTCPTYPE_RR))
+			{
+				ClearPacketList();
+				error = ERR_RTP_RTCPCOMPOUND_INVALIDPACKET;
+				return;
+			}
+		}
+		
+		length = (size_t)ntohs(rtcphdr->length);
+		length++;
+		length *= sizeof(u_int32_t);
+
+		if (length > datalen) // invalid length field
+		{
+			ClearPacketList();
+			error = ERR_RTP_RTCPCOMPOUND_INVALIDPACKET;
+			return;
+		}
+		
+		if (rtcphdr->padding)
+		{
+			// check if it's the last packet
+			if (length != datalen)
+			{
+				ClearPacketList();
+				error = ERR_RTP_RTCPCOMPOUND_INVALIDPACKET;
+				return; // not last packet
+			}
+		}
+
+		RTCPPacket *p;
+		
+		switch (rtcphdr->packettype)
+		{
+		case RTP_RTCPTYPE_SR:
+			p = new RTCPSRPacket(data,length);
+			break;
+		case RTP_RTCPTYPE_RR:
+			p = new RTCPRRPacket(data,length);
+			break;
+		case RTP_RTCPTYPE_SDES:
+			p = new RTCPSDESPacket(data,length);
+			break;
+		case RTP_RTCPTYPE_BYE:
+			p = new RTCPBYEPacket(data,length);
+			break;
+		case RTP_RTCPTYPE_APP:
+			p = new RTCPAPPPacket(data,length);
+			break;
+		default:
+			p = new RTCPUnknownPacket(data,length);
+		}
+
+		if (p == 0)
+		{
+			ClearPacketList();
+			error = ERR_RTP_OUTOFMEM;
+			return;
+		}
+
+		rtcppacklist.push_back(p);
+		
+		datalen -= length;
+		data += length;
+	} while (datalen >= (size_t)sizeof(RTCPCommonHeader));
+
+	if (datalen != 0) // some remaining bytes
+	{
+		ClearPacketList();
+		error = ERR_RTP_RTCPCOMPOUND_INVALIDPACKET;
+		return;
+	}
+
+	compoundpacket = rawpack.GetData();
+	compoundpacketlength = rawpack.GetDataLength();
+
+	rawpack.ZeroData();
+	
+	rtcppackit = rtcppacklist.begin();
+}
+
+RTCPCompoundPacket::RTCPCompoundPacket()
+{
+	compoundpacket = 0;
+	compoundpacketlength = 0;
+	error = 0;
+}
+
+RTCPCompoundPacket::~RTCPCompoundPacket()
+{
+	ClearPacketList();
+	if (compoundpacket)
+		delete [] compoundpacket;
+}
+
+void RTCPCompoundPacket::ClearPacketList()
+{
+	std::list<RTCPPacket *>::const_iterator it;
+
+	for (it = rtcppacklist.begin() ; it != rtcppacklist.end() ; it++)
+		delete *it;
+
+	rtcppacklist.clear();
+	rtcppackit = rtcppacklist.begin();
+}
+
+#ifdef RTPDEBUG
+void RTCPCompoundPacket::Dump()
+{
+	std::list<RTCPPacket *>::const_iterator it;
+	for (it = rtcppacklist.begin() ; it != rtcppacklist.end() ; it++)
+	{
+		RTCPPacket *p = *it;
+
+		p->Dump();
+	}
+}
+#endif // RTPDEBUG

Added: konference/src/rtp/jrtplib/rtcpcompoundpacket.h
===================================================================
--- konference/src/rtp/jrtplib/rtcpcompoundpacket.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpcompoundpacket.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,79 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+
+#ifndef RTCPCOMPOUNDPACKET_H
+
+#define RTCPCOMPOUNDPACKET_H
+
+#include "rtpconfig.h"
+#include "rtptypes.h"
+#include <list>
+
+class RTPRawPacket;
+class RTCPPacket;
+
+class RTCPCompoundPacket
+{
+public:
+	RTCPCompoundPacket(RTPRawPacket &rawpack);
+protected:
+	RTCPCompoundPacket(); // this is for the compoundpacket builder
+public:
+	virtual ~RTCPCompoundPacket();
+	int GetCreationError()								{ return error; }
+
+	u_int8_t *GetCompoundPacketData()						{ return compoundpacket; }
+	size_t GetCompoundPacketLength()						{ return compoundpacketlength; }
+
+	void GotoFirstPacket()								{ rtcppackit = rtcppacklist.begin(); }
+
+	// Note: the individual RTCPPackets may NOT be deleted!
+	RTCPPacket *GetNextPacket()							{ if (rtcppackit == rtcppacklist.end()) return 0; RTCPPacket *p = *rtcppackit; rtcppackit++; return p; }
+
+#ifdef RTPDEBUG
+	void Dump();	
+#endif // RTPDEBUG
+protected:
+	void ClearPacketList();
+	
+	int error;
+
+	u_int8_t *compoundpacket;
+	size_t compoundpacketlength;
+	
+	std::list<RTCPPacket *> rtcppacklist;
+	std::list<RTCPPacket *>::const_iterator rtcppackit;
+};
+
+#endif // RTCPCOMPOUNDPACKET_H
+

Added: konference/src/rtp/jrtplib/rtcpcompoundpacketbuilder.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcpcompoundpacketbuilder.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpcompoundpacketbuilder.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,672 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtcpcompoundpacketbuilder.h"
+#include "rtcpsrpacket.h"
+#include "rtcprrpacket.h"
+#include "rtcpsdespacket.h"
+#include "rtcpbyepacket.h"
+#include "rtcpapppacket.h"
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include <netinet/in.h>
+#endif // WIN32
+
+#include "rtpdebug.h"
+
+RTCPCompoundPacketBuilder::RTCPCompoundPacketBuilder()
+{
+	byesize = 0;
+	appsize = 0;
+	maximumpacketsize = 0;
+	buffer = 0;
+	external = false;
+	arebuilding = false;
+}
+
+RTCPCompoundPacketBuilder::~RTCPCompoundPacketBuilder()
+{
+	if (external)
+		compoundpacket = 0; // make sure RTCPCompoundPacket doesn't delete the external buffer
+	ClearBuildBuffers();
+}
+
+void RTCPCompoundPacketBuilder::ClearBuildBuffers()
+{
+	report.Clear();
+	sdes.Clear();
+
+	std::list<Buffer>::const_iterator it;
+	for (it = byepackets.begin() ; it != byepackets.end() ; it++)
+		if ((*it).packetdata)
+			delete [] (*it).packetdata;
+	
+	for (it = apppackets.begin() ; it != apppackets.end() ; it++)
+		if ((*it).packetdata)
+			delete [] (*it).packetdata;
+
+	byepackets.clear();
+	apppackets.clear();
+	byesize = 0;
+	appsize = 0;
+}
+
+int RTCPCompoundPacketBuilder::InitBuild(size_t maxpacketsize)
+{
+	if (arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYBUILDING;
+	if (compoundpacket)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYBUILT;
+
+	if (maxpacketsize < RTP_MINPACKETSIZE)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_MAXPACKETSIZETOOSMALL;
+	
+	maximumpacketsize = maxpacketsize;
+	buffer = 0;
+	external = false;
+	byesize = 0;
+	appsize = 0;
+	
+	arebuilding = true;
+	return 0;
+}
+
+int RTCPCompoundPacketBuilder::InitBuild(void *externalbuffer,size_t buffersize)
+{
+	if (arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYBUILDING;
+	if (compoundpacket)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYBUILT;
+
+	if (buffersize < RTP_MINPACKETSIZE)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_BUFFERSIZETOOSMALL;
+
+	maximumpacketsize = buffersize;
+	buffer = (u_int8_t *)externalbuffer;
+	external = true;
+	byesize = 0;
+	appsize = 0;
+
+	arebuilding = true;
+	return 0;
+}
+
+int RTCPCompoundPacketBuilder::StartSenderReport(u_int32_t senderssrc,const RTPNTPTime &ntptimestamp,u_int32_t rtptimestamp,
+                                                 u_int32_t packetcount,u_int32_t octetcount)
+{
+	if (!arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING;
+
+	if (report.headerlength != 0)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYGOTREPORT;
+
+	size_t totalsize = byesize+appsize+sdes.NeededBytes();
+	size_t sizeleft = maximumpacketsize-totalsize;
+	size_t neededsize = sizeof(RTCPCommonHeader)+sizeof(u_int32_t)+sizeof(RTCPSenderReport);
+	
+	if (neededsize > sizeleft)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT;
+	
+	// fill in some things
+
+	report.headerlength = sizeof(u_int32_t)+sizeof(RTCPSenderReport);
+	report.isSR = true;	
+	
+	u_int32_t *ssrc = (u_int32_t *)report.headerdata;
+	*ssrc = htonl(senderssrc);
+
+	RTCPSenderReport *sr = (RTCPSenderReport *)(report.headerdata + sizeof(u_int32_t));
+	sr->ntptime_msw = htonl(ntptimestamp.GetMSW());
+	sr->ntptime_lsw = htonl(ntptimestamp.GetLSW());
+	sr->rtptimestamp = htonl(rtptimestamp);
+	sr->packetcount = htonl(packetcount);
+	sr->octetcount = htonl(octetcount);
+
+	return 0;
+}
+
+int RTCPCompoundPacketBuilder::StartReceiverReport(u_int32_t senderssrc)
+{
+	if (!arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING;
+	if (report.headerlength != 0)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYGOTREPORT;
+
+	size_t totalsize = byesize+appsize+sdes.NeededBytes();
+	size_t sizeleft = maximumpacketsize-totalsize;
+	size_t neededsize = sizeof(RTCPCommonHeader)+sizeof(u_int32_t);
+	
+	if (neededsize > sizeleft)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT;
+	
+	// fill in some things
+
+	report.headerlength = sizeof(u_int32_t);
+	report.isSR = false;
+	
+	u_int32_t *ssrc = (u_int32_t *)report.headerdata;
+	*ssrc = htonl(senderssrc);
+
+	return 0;
+}
+
+int RTCPCompoundPacketBuilder::AddReportBlock(u_int32_t ssrc,u_int8_t fractionlost,int32_t packetslost,u_int32_t exthighestseq,
+	                                      u_int32_t jitter,u_int32_t lsr,u_int32_t dlsr)
+{
+	if (!arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING;
+	if (report.headerlength == 0)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_REPORTNOTSTARTED;
+
+	size_t totalothersize = byesize+appsize+sdes.NeededBytes();
+	size_t reportsizewithextrablock = report.NeededBytesWithExtraReportBlock();
+	
+	if ((totalothersize+reportsizewithextrablock) > maximumpacketsize)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT;
+
+	u_int8_t *buf = new u_int8_t[sizeof(RTCPReceiverReport)];
+	if (buf == 0)
+		return ERR_RTP_OUTOFMEM;
+	
+	RTCPReceiverReport *rr = (RTCPReceiverReport *)buf;
+	u_int32_t *packlost = (u_int32_t *)&packetslost;
+	u_int32_t packlost2 = (*packlost);
+		
+	rr->ssrc = htonl(ssrc);
+	rr->fractionlost = fractionlost;
+	rr->packetslost[2] = (u_int8_t)(packlost2&0xFF);
+	rr->packetslost[1] = (u_int8_t)((packlost2>>8)&0xFF);
+	rr->packetslost[0] = (u_int8_t)((packlost2>>16)&0xFF);
+	rr->exthighseqnr = htonl(exthighestseq);
+	rr->jitter = htonl(jitter);
+	rr->lsr = htonl(lsr);
+	rr->dlsr = htonl(dlsr);
+
+	report.reportblocks.push_back(Buffer(buf,sizeof(RTCPReceiverReport)));
+	return 0;
+}
+
+int RTCPCompoundPacketBuilder::AddSDESSource(u_int32_t ssrc)
+{
+	if (!arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING;
+
+	size_t totalotherbytes = byesize+appsize+report.NeededBytes();
+	size_t sdessizewithextrasource = sdes.NeededBytesWithExtraSource();
+
+	if ((totalotherbytes + sdessizewithextrasource) > maximumpacketsize)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT;
+
+	int status;
+
+	if ((status = sdes.AddSSRC(ssrc)) < 0)
+		return status;
+	return 0;
+}
+
+int RTCPCompoundPacketBuilder::AddSDESNormalItem(RTCPSDESPacket::ItemType t,const void *itemdata,u_int8_t itemlength)
+{
+	if (!arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING;
+	if (sdes.sdessources.empty())
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOCURRENTSOURCE;
+
+	u_int8_t itemid;
+	
+	switch(t)
+	{
+	case RTCPSDESPacket::CNAME:
+		itemid = RTCP_SDES_ID_CNAME;
+		break;
+	case RTCPSDESPacket::NAME:
+		itemid = RTCP_SDES_ID_NAME;
+		break;
+	case RTCPSDESPacket::EMAIL:
+		itemid = RTCP_SDES_ID_EMAIL;
+		break;
+	case RTCPSDESPacket::PHONE:
+		itemid = RTCP_SDES_ID_PHONE;
+		break;
+	case RTCPSDESPacket::LOC:
+		itemid = RTCP_SDES_ID_LOCATION;
+		break;
+	case RTCPSDESPacket::TOOL:
+		itemid = RTCP_SDES_ID_TOOL;
+		break;
+	case RTCPSDESPacket::NOTE:
+		itemid = RTCP_SDES_ID_NOTE;
+		break;
+	default:
+		return ERR_RTP_RTCPCOMPPACKBUILDER_INVALIDITEMTYPE;
+	}
+
+	size_t totalotherbytes = byesize+appsize+report.NeededBytes();
+	size_t sdessizewithextraitem = sdes.NeededBytesWithExtraItem(itemlength);
+
+	if ((sdessizewithextraitem+totalotherbytes) > maximumpacketsize)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT;
+
+	u_int8_t *buf;
+	size_t len;
+
+	buf = new u_int8_t[sizeof(RTCPSDESHeader)+(size_t)itemlength];
+	if (buf == 0)
+		return ERR_RTP_OUTOFMEM;
+	len = sizeof(RTCPSDESHeader)+(size_t)itemlength;
+
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(buf);
+
+	sdeshdr->id = itemid;
+	sdeshdr->length = itemlength;
+	if (itemlength != 0)
+		memcpy((buf + sizeof(RTCPSDESHeader)),itemdata,(size_t)itemlength);
+
+	sdes.AddItem(buf,len);
+	return 0;
+}
+
+#ifdef RTP_SUPPORT_SDESPRIV
+int RTCPCompoundPacketBuilder::AddSDESPrivateItem(const void *prefixdata,u_int8_t prefixlength,const void *valuedata,
+                                                  u_int8_t valuelength)
+{
+	if (!arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING;
+	if (sdes.sdessources.empty())
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOCURRENTSOURCE;
+
+	size_t itemlength = ((size_t)prefixlength)+1+((size_t)valuelength);
+	if (itemlength > 255)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_TOTALITEMLENGTHTOOBIG;
+	
+	size_t totalotherbytes = byesize+appsize+report.NeededBytes();
+	size_t sdessizewithextraitem = sdes.NeededBytesWithExtraItem(itemlength);
+
+	if ((sdessizewithextraitem+totalotherbytes) > maximumpacketsize)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT;
+
+	u_int8_t *buf;
+	size_t len;
+
+	buf = new u_int8_t[sizeof(RTCPSDESHeader)+itemlength];
+	if (buf == 0)
+		return ERR_RTP_OUTOFMEM;
+	len = sizeof(RTCPSDESHeader)+(size_t)itemlength;
+
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(buf);
+
+	sdeshdr->id = RTCP_SDES_ID_PRIVATE;
+	sdeshdr->length = itemlength;
+	
+	buf[sizeof(RTCPSDESHeader)] = prefixlength;
+	if (prefixlength != 0)
+		memcpy((buf+sizeof(RTCPSDESHeader)+1),prefixdata,(size_t)prefixlength);
+	if (valuelength != 0)
+		memcpy((buf+sizeof(RTCPSDESHeader)+1+(size_t)prefixlength),valuedata,(size_t)valuelength);
+
+	sdes.AddItem(buf,len);
+	return 0;
+}
+#endif // RTP_SUPPORT_SDESPRIV
+
+int RTCPCompoundPacketBuilder::AddBYEPacket(u_int32_t *ssrcs,u_int8_t numssrcs,const void *reasondata,u_int8_t reasonlength)
+{
+	if (!arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING;
+
+	if (numssrcs > 31)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_TOOMANYSSRCS;
+	
+	size_t packsize = sizeof(RTCPCommonHeader)+sizeof(u_int32_t)*((size_t)numssrcs);
+	size_t zerobytes = 0;
+	
+	if (reasonlength > 0)
+	{
+		packsize += 1; // 1 byte for the length;
+		packsize += (size_t)reasonlength;
+
+		size_t r = (packsize&0x03);
+		if (r != 0)
+		{
+			zerobytes = 4-r;
+			packsize += zerobytes;
+		}
+	}
+
+	size_t totalotherbytes = appsize+byesize+sdes.NeededBytes()+report.NeededBytes();
+
+	if ((totalotherbytes + packsize) > maximumpacketsize)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT;
+
+	u_int8_t *buf;
+	size_t numwords;
+	
+	buf = new u_int8_t[packsize];
+	if (buf == 0)
+		return ERR_RTP_OUTOFMEM;
+
+	RTCPCommonHeader *hdr = (RTCPCommonHeader *)buf;
+
+	hdr->version = 2;
+	hdr->padding = 0;
+	hdr->count = numssrcs;
+	
+	numwords = packsize/sizeof(u_int32_t);
+	hdr->length = htons((u_int16_t)(numwords-1));
+	hdr->packettype = RTP_RTCPTYPE_BYE;
+	
+	u_int32_t *sources = (u_int32_t *)(buf+sizeof(RTCPCommonHeader));
+	u_int8_t srcindex;
+	
+	for (srcindex = 0 ; srcindex < numssrcs ; srcindex++)
+		sources[srcindex] = htonl(ssrcs[srcindex]);
+
+	if (reasonlength != 0)
+	{
+		size_t offset = sizeof(RTCPCommonHeader)+((size_t)numssrcs)*sizeof(u_int32_t);
+
+		buf[offset] = reasonlength;
+		memcpy((buf+offset+1),reasondata,(size_t)reasonlength);
+		for (size_t i = 0 ; i < zerobytes ; i++)
+			buf[packsize-1-i] = 0;
+	}
+
+	byepackets.push_back(Buffer(buf,packsize));
+	byesize += packsize;
+	
+	return 0;
+}
+
+int RTCPCompoundPacketBuilder::AddAPPPacket(u_int8_t subtype,u_int32_t ssrc,const u_int8_t name[4],const void *appdata,size_t appdatalen)
+{
+	if (!arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING;
+	if (subtype > 31)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_ILLEGALSUBTYPE;
+	if ((appdatalen%4) != 0)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_ILLEGALAPPDATALENGTH;
+
+	size_t appdatawords = appdatalen/4;
+
+	if ((appdatawords+2) > 65535)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_APPDATALENTOOBIG;
+	
+	size_t packsize = sizeof(RTCPCommonHeader)+sizeof(u_int32_t)*2+appdatalen;
+	size_t totalotherbytes = appsize+byesize+sdes.NeededBytes()+report.NeededBytes();
+
+	if ((totalotherbytes + packsize) > maximumpacketsize)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT;
+
+	u_int8_t *buf;
+	
+	buf = new u_int8_t[packsize];
+	if (buf == 0)
+		return ERR_RTP_OUTOFMEM;
+
+	RTCPCommonHeader *hdr = (RTCPCommonHeader *)buf;
+
+	hdr->version = 2;
+	hdr->padding = 0;
+	hdr->count = subtype;
+	
+	hdr->length = htons((u_int16_t)(appdatawords+2));
+	hdr->packettype = RTP_RTCPTYPE_APP;
+	
+	u_int32_t *source = (u_int32_t *)(buf+sizeof(RTCPCommonHeader));
+	*source = htonl(ssrc);
+
+	buf[sizeof(RTCPCommonHeader)+sizeof(u_int32_t)+0] = name[0];
+	buf[sizeof(RTCPCommonHeader)+sizeof(u_int32_t)+1] = name[1];
+	buf[sizeof(RTCPCommonHeader)+sizeof(u_int32_t)+2] = name[2];
+	buf[sizeof(RTCPCommonHeader)+sizeof(u_int32_t)+3] = name[3];
+
+	if (appdatalen > 0)
+		memcpy((buf+sizeof(RTCPCommonHeader)+sizeof(u_int32_t)*2),appdata,appdatalen);
+
+	apppackets.push_back(Buffer(buf,packsize));
+	appsize += packsize;
+	
+	return 0;
+}
+
+int RTCPCompoundPacketBuilder::EndBuild()
+{
+	if (!arebuilding)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING;
+	if (report.headerlength == 0)
+		return ERR_RTP_RTCPCOMPPACKBUILDER_NOREPORTPRESENT;
+	
+	u_int8_t *buf;
+	size_t len;
+	
+	len = appsize+byesize+report.NeededBytes()+sdes.NeededBytes();
+	
+	if (!external)
+	{
+		buf = new u_int8_t[len];
+		if (buf == 0)
+			return ERR_RTP_OUTOFMEM;
+	}
+	else
+		buf = buffer;
+	
+	u_int8_t *curbuf = buf;
+	RTCPPacket *p;
+
+	// first, we'll add all report info
+	
+	{
+		bool firstpacket = true;
+		bool done = false;
+		std::list<Buffer>::const_iterator it = report.reportblocks.begin();
+		do
+		{
+			RTCPCommonHeader *hdr = (RTCPCommonHeader *)curbuf;
+			size_t offset;
+			
+			hdr->version = 2;
+			hdr->padding = 0;
+
+			if (firstpacket && report.isSR)
+			{
+				hdr->packettype = RTP_RTCPTYPE_SR;
+				memcpy((curbuf+sizeof(RTCPCommonHeader)),report.headerdata,report.headerlength);
+				offset = sizeof(RTCPCommonHeader)+report.headerlength;
+			}
+			else
+			{
+				hdr->packettype = RTP_RTCPTYPE_RR;
+				memcpy((curbuf+sizeof(RTCPCommonHeader)),report.headerdata,sizeof(u_int32_t));
+				offset = sizeof(RTCPCommonHeader)+sizeof(u_int32_t);
+			}
+			firstpacket = false;
+			
+			u_int8_t count = 0;
+
+			while (it != report.reportblocks.end() && count < 31)
+			{
+				memcpy(curbuf+offset,(*it).packetdata,(*it).packetlength);
+				offset += (*it).packetlength;
+				count++;
+				it++;
+			}
+
+			size_t numwords = offset/sizeof(u_int32_t);
+
+			hdr->length = htons((u_int16_t)(numwords-1));
+			hdr->count = count;
+
+			// add entry in parent's list
+			if (hdr->packettype == RTP_RTCPTYPE_SR)
+				p = new RTCPSRPacket(curbuf,offset);
+			else
+				p = new RTCPRRPacket(curbuf,offset);
+			if (p == 0)
+			{
+				if (!external)
+					delete [] buf;
+				ClearPacketList();
+				return ERR_RTP_OUTOFMEM;
+			}
+			rtcppacklist.push_back(p);
+
+			curbuf += offset;
+			if (it == report.reportblocks.end())
+				done = true;
+		} while (!done);
+	}
+		
+	// then, we'll add the sdes info
+
+	if (!sdes.sdessources.empty())
+	{
+		bool done = false;
+		std::list<SDESSource *>::const_iterator sourceit = sdes.sdessources.begin();
+		
+		do
+		{
+			RTCPCommonHeader *hdr = (RTCPCommonHeader *)curbuf;
+			size_t offset = sizeof(RTCPCommonHeader);
+			
+			hdr->version = 2;
+			hdr->padding = 0;
+			hdr->packettype = RTP_RTCPTYPE_SDES;
+
+			u_int8_t sourcecount = 0;
+			
+			while (sourceit != sdes.sdessources.end() && sourcecount < 31)
+			{
+				u_int32_t *ssrc = (u_int32_t *)(curbuf+offset);
+				*ssrc = htonl((*sourceit)->ssrc);
+				offset += sizeof(u_int32_t);
+				
+				std::list<Buffer>::const_iterator itemit,itemend;
+
+				itemit = (*sourceit)->items.begin();
+				itemend = (*sourceit)->items.end();
+				while (itemit != itemend)
+				{
+					memcpy(curbuf+offset,(*itemit).packetdata,(*itemit).packetlength);
+					offset += (*itemit).packetlength;
+					itemit++;
+				}
+
+				curbuf[offset] = 0; // end of item list;
+				offset++;
+
+				size_t r = offset&0x03;
+				if (r != 0) // align to 32 bit boundary
+				{
+					size_t num = 4-r;
+					size_t i;
+
+					for (i = 0 ; i < num ; i++)
+						curbuf[offset+i] = 0;
+					offset += num;
+				}
+				
+				sourceit++;
+				sourcecount++;
+			}
+
+			size_t numwords = offset/4;
+			
+			hdr->count = sourcecount;
+			hdr->length = htons((u_int16_t)(numwords-1));
+
+			p = new RTCPSDESPacket(curbuf,offset);
+			if (p == 0)
+			{
+				if (!external)
+					delete [] buf;
+				ClearPacketList();
+				return ERR_RTP_OUTOFMEM;
+			}
+			rtcppacklist.push_back(p);
+			
+			curbuf += offset;
+			if (sourceit == sdes.sdessources.end())
+				done = true;
+		} while (!done);
+	}
+	
+	// adding the app data
+	
+	{
+		std::list<Buffer>::const_iterator it;
+
+		for (it = apppackets.begin() ; it != apppackets.end() ; it++)
+		{
+			memcpy(curbuf,(*it).packetdata,(*it).packetlength);
+			
+			p = new RTCPAPPPacket(curbuf,(*it).packetlength);
+			if (p == 0)
+			{
+				if (!external)
+					delete [] buf;
+				ClearPacketList();
+				return ERR_RTP_OUTOFMEM;
+			}
+			rtcppacklist.push_back(p);
+	
+			curbuf += (*it).packetlength;
+		}
+	}
+	
+	// adding bye packets
+	
+	{
+		std::list<Buffer>::const_iterator it;
+
+		for (it = byepackets.begin() ; it != byepackets.end() ; it++)
+		{
+			memcpy(curbuf,(*it).packetdata,(*it).packetlength);
+			
+			p = new RTCPBYEPacket(curbuf,(*it).packetlength);
+			if (p == 0)
+			{
+				if (!external)
+					delete [] buf;
+				ClearPacketList();
+				return ERR_RTP_OUTOFMEM;
+			}
+			rtcppacklist.push_back(p);
+	
+			curbuf += (*it).packetlength;
+		}
+	}
+	
+	compoundpacket = buf;
+	compoundpacketlength = len;
+	arebuilding = false;
+	ClearBuildBuffers();
+	return 0;
+}
+

Added: konference/src/rtp/jrtplib/rtcpcompoundpacketbuilder.h
===================================================================
--- konference/src/rtp/jrtplib/rtcpcompoundpacketbuilder.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpcompoundpacketbuilder.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,317 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPCOMPOUNDPACKETBUILDER_H
+
+#define RTCPCOMPOUNDPACKETBUILDER_H
+
+#include "rtpconfig.h"
+#include "rtcpcompoundpacket.h"
+#include "rtptimeutilities.h"
+#include "rtcpsdespacket.h"
+#include "rtperrors.h"
+#include <list>
+
+class RTCPCompoundPacketBuilder : public RTCPCompoundPacket
+{
+public:
+	RTCPCompoundPacketBuilder();
+	~RTCPCompoundPacketBuilder();
+
+	int InitBuild(size_t maxpacketsize);
+	int InitBuild(void *externalbuffer,size_t buffersize);
+	
+	int StartSenderReport(u_int32_t senderssrc,const RTPNTPTime &ntptimestamp,u_int32_t rtptimestamp,
+	                    u_int32_t packetcount,u_int32_t octetcount);
+	int StartReceiverReport(u_int32_t senderssrc);
+	int AddReportBlock(u_int32_t ssrc,u_int8_t fractionlost,int32_t packetslost,u_int32_t exthighestseq,
+	                   u_int32_t jitter,u_int32_t lsr,u_int32_t dlsr);
+	
+	int AddSDESSource(u_int32_t ssrc);
+	int AddSDESNormalItem(RTCPSDESPacket::ItemType t,const void *itemdata,u_int8_t itemlength);
+#ifdef RTP_SUPPORT_SDESPRIV
+	int AddSDESPrivateItem(const void *prefixdata,u_int8_t prefixlength,const void *valuedata,
+	                       u_int8_t valuelength);
+#endif // RTP_SUPPORT_SDESPRIV
+
+	int AddBYEPacket(u_int32_t *ssrcs,u_int8_t numssrcs,const void *reasondata,u_int8_t reasonlength);
+
+	// note: appdatalen must be a multiple of 4 (32 bits) !
+	int AddAPPPacket(u_int8_t subtype,u_int32_t ssrc,const u_int8_t name[4],const void *appdata,size_t appdatalen);
+
+	int EndBuild();
+private:
+	class Buffer
+	{
+	public:
+		Buffer():packetdata(0),packetlength(0) { }
+		Buffer(u_int8_t *data,size_t len):packetdata(data),packetlength(len) { }			
+		
+		u_int8_t *packetdata;
+		size_t packetlength;
+	};
+
+	class Report
+	{
+	public:
+		Report() { headerdata = (u_int8_t *)headerdata32; isSR = false; headerlength = 0; }
+		~Report() { Clear(); }
+
+		void Clear()
+		{
+			std::list<Buffer>::const_iterator it; 
+			for (it = reportblocks.begin() ; it != reportblocks.end() ; it++) 
+				if ((*it).packetdata) 
+					delete [] (*it).packetdata; 
+			reportblocks.clear();
+			isSR = false;
+			headerlength = 0;
+		}
+
+		size_t NeededBytes() 
+		{ 
+			size_t x,n,d,r; 
+			n = reportblocks.size(); 
+			if (n == 0)
+			{
+				if (headerlength == 0)
+					return 0;
+				x = sizeof(RTCPCommonHeader)+headerlength;
+			}
+			else
+			{
+				x = n*sizeof(RTCPReceiverReport);
+				d = n/31; // max 31 reportblocks per report
+				r = n%31;
+				if (r != 0)
+					d++;
+				x += d*(sizeof(RTCPCommonHeader)+sizeof(u_int32_t)); /* header and SSRC */
+				if (isSR)
+					x += sizeof(RTCPSenderReport);
+			}
+			return x;
+		}			
+
+		size_t NeededBytesWithExtraReportBlock()
+		{
+			size_t x,n,d,r; 
+			n = reportblocks.size() + 1; // +1 for the extra block
+			x = n*sizeof(RTCPReceiverReport);
+			d = n/31; // max 31 reportblocks per report
+			r = n%31;
+			if (r != 0)
+				d++;
+			x += d*(sizeof(RTCPCommonHeader)+sizeof(u_int32_t)); /* header and SSRC */
+			if (isSR)
+				x += sizeof(RTCPSenderReport);
+			return x;
+		}
+		
+		bool isSR;
+
+		u_int8_t *headerdata;
+		u_int32_t headerdata32[(sizeof(u_int32_t)+sizeof(RTCPSenderReport))/sizeof(u_int32_t)]; // either for ssrc and sender info or just ssrc
+		size_t headerlength;
+		std::list<Buffer> reportblocks;
+	};
+
+	class SDESSource
+	{
+	public:
+		SDESSource(u_int32_t s) : ssrc(s),totalitemsize(0) { }
+		~SDESSource()
+		{
+			std::list<Buffer>::const_iterator it;
+			for (it = items.begin() ; it != items.end() ; it++)
+				if ((*it).packetdata)
+					delete [] (*it).packetdata;
+			items.clear();
+		}
+
+		size_t NeededBytes()
+		{
+			size_t x,r;
+			x = totalitemsize + 1; // +1 for the 0 byte which terminates the item list
+			r = x%sizeof(u_int32_t);
+			if (r != 0)
+				x += (sizeof(u_int32_t)-r); // make sure it ends on a 32 bit boundary
+			x += sizeof(u_int32_t); // for ssrc
+			return x;
+		}
+
+		size_t NeededBytesWithExtraItem(u_int8_t itemdatalength)
+		{
+			size_t x,r;
+			x = totalitemsize + sizeof(RTCPSDESHeader) + (size_t)itemdatalength + 1;
+			r = x%sizeof(u_int32_t);
+			if (r != 0)
+				x += (sizeof(u_int32_t)-r); // make sure it ends on a 32 bit boundary
+			x += sizeof(u_int32_t); // for ssrc
+			return x;
+		}
+		
+		void AddItem(u_int8_t *buf,size_t len)
+		{
+			Buffer b(buf,len);
+			totalitemsize += len;
+			items.push_back(b);	
+		}
+		
+		u_int32_t ssrc;
+		std::list<Buffer> items;
+	private:
+		size_t totalitemsize;
+	};
+	
+	class SDES
+	{
+	public:
+		SDES() { sdesit = sdessources.end(); }
+		~SDES() { Clear(); }
+
+		void Clear()
+		{
+			std::list<SDESSource *>::const_iterator it;
+
+			for (it = sdessources.begin() ; it != sdessources.end() ; it++)
+				delete (*it);
+			sdessources.clear();
+		}
+
+		int AddSSRC(u_int32_t ssrc)
+		{
+			SDESSource *s = new SDESSource(ssrc);
+			if (s == 0)
+				return ERR_RTP_OUTOFMEM;
+			sdessources.push_back(s);
+			sdesit = sdessources.end();
+			sdesit--;
+			return 0;
+		}
+
+		int AddItem(u_int8_t *buf,size_t len)
+		{
+			if (sdessources.empty())
+				return ERR_RTP_RTCPCOMPPACKBUILDER_NOCURRENTSOURCE;
+			(*sdesit)->AddItem(buf,len);
+			return 0;
+		}
+
+		size_t NeededBytes()
+		{
+			std::list<SDESSource *>::const_iterator it;
+			size_t x = 0;
+			size_t n,d,r;
+			
+			if (sdessources.empty())
+				return 0;
+			
+			for (it = sdessources.begin() ; it != sdessources.end() ; it++)
+				x += (*it)->NeededBytes();
+			n = sdessources.size();
+			d = n/31;
+			r = n%31;
+			if (r != 0)
+				d++;
+			x += d*sizeof(RTCPCommonHeader);
+			return x;
+		}
+		
+		size_t NeededBytesWithExtraItem(u_int8_t itemdatalength)
+		{
+			std::list<SDESSource *>::const_iterator it;
+			size_t x = 0;
+			size_t n,d,r;
+			
+			if (sdessources.empty())
+				return 0;
+			
+			for (it = sdessources.begin() ; it != sdesit ; it++)
+				x += (*it)->NeededBytes();
+			x += (*sdesit)->NeededBytesWithExtraItem(itemdatalength);
+			n = sdessources.size();
+			d = n/31;
+			r = n%31;
+			if (r != 0)
+				d++;
+			x += d*sizeof(RTCPCommonHeader);
+			return x;
+		}
+
+		size_t NeededBytesWithExtraSource()
+		{
+			std::list<SDESSource *>::const_iterator it;
+			size_t x = 0;
+			size_t n,d,r;
+			
+			if (sdessources.empty())
+				return 0;
+			
+			for (it = sdessources.begin() ; it != sdessources.end() ; it++)
+				x += (*it)->NeededBytes();
+			
+			// for the extra source we'll need at least 8 bytes (ssrc and four 0 bytes)
+			x += sizeof(u_int32_t)*2;
+			
+			n = sdessources.size() + 1; // also, the number of sources will increase
+			d = n/31;
+			r = n%31;
+			if (r != 0)
+				d++;
+			x += d*sizeof(RTCPCommonHeader);
+			return x;
+		}
+		
+		std::list<SDESSource *> sdessources;
+	private:
+		std::list<SDESSource *>::const_iterator sdesit;
+	};
+
+	size_t maximumpacketsize;
+	u_int8_t *buffer;
+	bool external;
+	bool arebuilding;
+	
+	Report report;
+	SDES sdes;
+
+	std::list<Buffer> byepackets;
+	size_t byesize;
+	
+	std::list<Buffer> apppackets;
+	size_t appsize;
+	
+	void ClearBuildBuffers();
+};
+
+#endif // RTCPCOMPOUNDPACKETBUILDER_H
+

Added: konference/src/rtp/jrtplib/rtcppacket.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcppacket.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcppacket.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,71 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtcppacket.h"
+#ifdef RTPDEBUG
+	#include <iostream>
+#endif // RTPDEBUG
+
+#include "rtpdebug.h"
+
+#ifdef RTPDEBUG
+
+void RTCPPacket::Dump()
+{
+	switch(packettype)
+	{
+	case SR:
+		std::cout << "RTCP Sender Report      ";
+		break;
+	case RR:
+		std::cout << "RTCP Receiver Report    ";
+		break;
+	case SDES:
+		std::cout << "RTCP Source Description ";
+		break;
+	case APP:
+		std::cout << "RTCP APP Packet         ";
+		break;
+	case BYE:
+		std::cout << "RTCP Bye Packet         ";
+		break;
+	case Unknown:
+		std::cout << "Unknown RTCP Packet     ";
+		break;
+	default:
+		std::cout << "ERROR: Invalid packet type!" << std::endl;		
+	}
+	std::cout << "Length: " << datalen;
+	std::cout << std::endl;
+}
+
+#endif // RTPDEBUG

Added: konference/src/rtp/jrtplib/rtcppacket.h
===================================================================
--- konference/src/rtp/jrtplib/rtcppacket.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcppacket.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,69 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPPACKET_H
+
+#define RTCPPACKET_H
+
+#include "rtpconfig.h"
+#include "rtptypes.h"
+
+class RTCPCompoundPacket;
+
+class RTCPPacket 
+{
+public:
+	enum PacketType { SR,RR,SDES,BYE,APP,Unknown };
+protected:
+	RTCPPacket(PacketType t,u_int8_t *d,size_t dlen) : data(d),datalen(dlen),packettype(t) { knownformat = false; }
+public:
+	virtual ~RTCPPacket()								{ }	
+
+	bool IsKnownFormat() const							{ return knownformat; }
+	
+	PacketType GetPacketType() const						{ return packettype; }
+	u_int8_t *GetPacketData()							{ return data; }
+	size_t GetPacketLength() const							{ return datalen; }
+
+#ifdef RTPDEBUG
+	virtual void Dump();
+#endif // RTPDEBUG
+protected:
+	u_int8_t *data;
+	size_t datalen;
+	bool knownformat;
+private:
+	const PacketType packettype;
+};
+
+#endif // RTCPPACKET_H
+

Added: konference/src/rtp/jrtplib/rtcppacketbuilder.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcppacketbuilder.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcppacketbuilder.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,733 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtcppacketbuilder.h"
+#include "rtpsources.h"
+#include "rtppacketbuilder.h"
+#include "rtcpscheduler.h"
+#include "rtpsourcedata.h"
+#include "rtcpcompoundpacketbuilder.h"
+
+#include "rtpdebug.h"
+
+RTCPPacketBuilder::RTCPPacketBuilder(RTPSources &s,RTPPacketBuilder &pb)
+	: sources(s),rtppacketbuilder(pb),prevbuildtime(0,0)
+{
+	init = false;
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	timeinit.Dummy();
+#endif // WIN32 || _WIN32_WCE
+}
+
+RTCPPacketBuilder::~RTCPPacketBuilder()
+{
+	Destroy();
+}
+
+int RTCPPacketBuilder::Init(size_t maxpacksize,double tsunit,const void *cname,size_t cnamelen)
+{
+	if (init)
+		return ERR_RTP_RTCPPACKETBUILDER_ALREADYINIT;
+	if (maxpacksize < RTP_MINPACKETSIZE)
+		return ERR_RTP_RTCPPACKETBUILDER_ILLEGALMAXPACKSIZE;
+	if (tsunit < 0.0)
+		return ERR_RTP_RTCPPACKETBUILDER_ILLEGALTIMESTAMPUNIT;
+
+	if (cnamelen>255)
+		cnamelen = 255;
+	
+	maxpacketsize = maxpacksize;
+	timestampunit = tsunit;
+	
+	int status;
+	
+	if ((status = ownsdesinfo.SetCNAME((const u_int8_t *)cname,cnamelen)) < 0)
+		return status;
+	
+	ClearAllSourceFlags();
+	
+	interval_name = -1;
+	interval_email = -1;
+	interval_location = -1;
+	interval_phone = -1;
+	interval_tool = -1;
+	interval_note = -1;
+
+	sdesbuildcount = 0;
+
+	firstpacket = true;
+	processingsdes = false;
+	init = true;
+	return 0;
+}
+
+void RTCPPacketBuilder::Destroy()
+{
+	if (!init)
+		return;
+	ownsdesinfo.Clear();
+	init = false;
+}
+
+int RTCPPacketBuilder::BuildNextPacket(RTCPCompoundPacket **pack)
+{
+	if (!init)
+		return ERR_RTP_RTCPPACKETBUILDER_NOTINIT;
+
+	RTCPCompoundPacketBuilder *rtcpcomppack;
+	int status;
+	bool sender = false;
+	RTPSourceData *srcdat;
+	
+	*pack = 0;
+	
+	rtcpcomppack = new RTCPCompoundPacketBuilder();
+	if (rtcpcomppack == 0)
+		return ERR_RTP_OUTOFMEM;
+	
+	if ((status = rtcpcomppack->InitBuild(maxpacketsize)) < 0)
+	{
+		delete rtcpcomppack;
+		return status;
+	}
+	
+	if ((srcdat = sources.GetOwnSourceInfo()) != 0)
+	{
+		if (srcdat->IsSender())
+			sender = true;
+	}
+	
+	u_int32_t ssrc = rtppacketbuilder.GetSSRC();
+	RTPTime curtime = RTPTime::CurrentTime();
+
+	if (sender)
+	{
+		RTPTime rtppacktime = rtppacketbuilder.GetPacketTime();
+		u_int32_t rtppacktimestamp = rtppacketbuilder.GetPacketTimestamp();
+		u_int32_t packcount = rtppacketbuilder.GetPacketCount();
+		u_int32_t octetcount = rtppacketbuilder.GetPayloadOctetCount();
+		RTPTime diff = curtime;
+		diff -= rtppacktime;
+		
+		u_int32_t tsdiff = (u_int32_t)((diff.GetDouble()/timestampunit)+0.5);
+		u_int32_t rtptimestamp = rtppacktimestamp+tsdiff;
+		RTPNTPTime ntptimestamp = curtime.GetNTPTime();
+
+		if ((status = rtcpcomppack->StartSenderReport(ssrc,ntptimestamp,rtptimestamp,packcount,octetcount)) < 0)
+		{
+			delete rtcpcomppack;
+			if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+				return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+			return status;
+		}
+	}
+	else
+	{
+		if ((status = rtcpcomppack->StartReceiverReport(ssrc)) < 0)
+		{
+			delete rtcpcomppack;
+			if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+				return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+			return status;
+		}
+	}
+
+	u_int8_t *owncname;
+	size_t owncnamelen;
+
+	owncname = ownsdesinfo.GetCNAME(&owncnamelen);
+
+	if ((status = rtcpcomppack->AddSDESSource(ssrc)) < 0)
+	{
+		delete rtcpcomppack;
+		if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+			return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+		return status;
+	}
+	if ((status = rtcpcomppack->AddSDESNormalItem(RTCPSDESPacket::CNAME,owncname,owncnamelen)) < 0)
+	{
+		delete rtcpcomppack;
+		if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+			return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+		return status;
+	}
+
+	if (!processingsdes)
+	{
+		int added,skipped;
+		bool full,atendoflist;
+
+		if ((status = FillInReportBlocks(rtcpcomppack,curtime,sources.GetTotalCount(),&full,&added,&skipped,&atendoflist)) < 0)
+		{
+			delete rtcpcomppack;
+			return status;
+		}
+		
+		if (full && added == 0)
+		{
+			delete rtcpcomppack;
+			return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+		}
+	
+		if (!full)
+		{
+			processingsdes = true;
+			sdesbuildcount++;
+			
+			ClearAllSourceFlags();
+	
+			doname = false;
+			doemail = false;
+			doloc = false;
+			dophone = false;
+			dotool = false;
+			donote = false;
+			if (interval_name > 0 && ((sdesbuildcount%interval_name) == 0)) doname = true;
+			if (interval_email > 0 && ((sdesbuildcount%interval_email) == 0)) doemail = true;
+			if (interval_location > 0 && ((sdesbuildcount%interval_location) == 0)) doloc = true;
+			if (interval_phone > 0 && ((sdesbuildcount%interval_phone) == 0)) dophone = true;
+			if (interval_tool > 0 && ((sdesbuildcount%interval_tool) == 0)) dotool = true;
+			if (interval_note > 0 && ((sdesbuildcount%interval_note) == 0)) donote = true;
+			
+			bool processedall;
+			int itemcount;
+			
+			if ((status = FillInSDES(rtcpcomppack,&full,&processedall,&itemcount)) < 0)
+			{
+				delete rtcpcomppack;
+				return status;
+			}
+
+			if (processedall)
+			{
+				processingsdes = false;
+				ClearAllSDESFlags();
+				if (!full && skipped > 0) 
+				{
+					// if the packet isn't full and we skipped some
+				        // sources that we already got in a previous packet,
+					// we can add some of them now
+					
+					bool atendoflist;
+					 
+					if ((status = FillInReportBlocks(rtcpcomppack,curtime,skipped,&full,&added,&skipped,&atendoflist)) < 0)
+					{
+						delete rtcpcomppack;
+						return status;
+					}
+				}
+			}
+		}
+	}
+	else // previous sdes processing wasn't finished
+	{
+		bool processedall;
+		int itemcount;
+		bool full;
+			
+		if ((status = FillInSDES(rtcpcomppack,&full,&processedall,&itemcount)) < 0)
+		{
+			delete rtcpcomppack;
+			return status;
+		}
+
+		if (itemcount == 0) // Big problem: packet size is too small to let any progress happen
+		{
+			delete rtcpcomppack;
+			return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+		}
+
+		if (processedall)
+		{
+			processingsdes = false;
+			ClearAllSDESFlags();
+			if (!full) 
+			{
+				// if the packet isn't full and we skipped some
+				// we can add some report blocks
+				
+				int added,skipped;
+				bool atendoflist;
+
+				if ((status = FillInReportBlocks(rtcpcomppack,curtime,sources.GetTotalCount(),&full,&added,&skipped,&atendoflist)) < 0)
+				{
+					delete rtcpcomppack;
+					return status;
+				}
+				if (atendoflist) // filled in all possible sources
+					ClearAllSourceFlags();
+			}
+		}
+	}
+		
+	if ((status = rtcpcomppack->EndBuild()) < 0)
+	{
+		delete rtcpcomppack;
+		return status;
+	}
+
+	*pack = rtcpcomppack;
+	firstpacket = false;
+	prevbuildtime = curtime;
+	return 0;
+}
+
+void RTCPPacketBuilder::ClearAllSourceFlags()
+{
+	if (sources.GotoFirstSource())
+	{
+		do
+		{
+			RTPSourceData *srcdat = sources.GetCurrentSourceInfo();
+			srcdat->SetProcessedInRTCP(false);
+		} while (sources.GotoNextSource());
+	}
+}
+
+int RTCPPacketBuilder::FillInReportBlocks(RTCPCompoundPacketBuilder *rtcpcomppack,const RTPTime &curtime,int maxcount,bool *full,int *added,int *skipped,bool *atendoflist)
+{
+	RTPSourceData *srcdat;
+	int addedcount = 0;
+	int skippedcount = 0;
+	bool done = false;
+	bool filled = false;
+	bool atend = false;
+	int status;
+
+	if (sources.GotoFirstSource())
+	{
+		do
+		{
+			bool shouldprocess = false;
+			
+			srcdat = sources.GetCurrentSourceInfo();
+			if (!srcdat->IsOwnSSRC()) // don't send to ourselves
+			{
+				if (!srcdat->IsCSRC()) // p 35: no reports should go to CSRCs
+				{
+					if (srcdat->INF_HasSentData()) // if this isn't true, INF_GetLastRTPPacketTime() won't make any sense
+					{
+						if (firstpacket)
+							shouldprocess = true;
+						else
+						{
+							// p 35: only if rtp packets were received since the last RTP packet, a report block
+							// should be added
+							
+							RTPTime lastrtptime = srcdat->INF_GetLastRTPPacketTime();
+							
+							if (lastrtptime > prevbuildtime)
+								shouldprocess = true;
+						}
+					}
+				}
+			}
+
+			if (shouldprocess)
+			{
+				if (srcdat->IsProcessedInRTCP()) // already covered this one
+				{
+					skippedcount++;
+				}
+				else
+				{
+					u_int32_t rr_ssrc = srcdat->GetSSRC();
+					u_int32_t num = srcdat->INF_GetNumPacketsReceivedInInterval();
+					u_int32_t prevseq = srcdat->INF_GetSavedExtendedSequenceNumber();
+					u_int32_t curseq = srcdat->INF_GetExtendedHighestSequenceNumber();
+					u_int32_t expected = curseq-prevseq;
+					u_int8_t fraclost;
+					
+					if (expected < num) // got duplicates
+						fraclost = 0;
+					else
+					{
+						double lost = (double)(expected-num);
+						double frac = lost/((double)expected);
+						fraclost = (u_int8_t)(frac*256.0);
+					}
+
+					expected = curseq-srcdat->INF_GetBaseSequenceNumber();
+					num = srcdat->INF_GetNumPacketsReceived();
+
+					u_int32_t diff = expected-num;
+					int32_t *packlost = (int32_t *)&diff;
+					
+					u_int32_t jitter = srcdat->INF_GetJitter();
+					u_int32_t lsr;
+					u_int32_t dlsr; 	
+
+					if (!srcdat->SR_HasInfo())
+					{
+						lsr = 0;
+						dlsr = 0;
+					}
+					else
+					{
+						RTPNTPTime srtime = srcdat->SR_GetNTPTimestamp();
+						u_int32_t m = (srtime.GetMSW()&0xFFFF);
+						u_int32_t l = ((srtime.GetLSW()>>16)&0xFFFF);
+						lsr = ((m<<16)|l);
+
+						RTPTime diff = curtime;
+						diff -= srcdat->SR_GetReceiveTime();
+						double diff2 = diff.GetDouble();
+						diff2 *= 65536.0;
+						dlsr = (u_int32_t)diff2;
+					}
+
+					status = rtcpcomppack->AddReportBlock(rr_ssrc,fraclost,*packlost,curseq,jitter,lsr,dlsr);
+					if (status < 0)
+					{
+						if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+						{
+							done = true;
+							filled = true;
+						}
+						else
+							return status;
+					}
+					else
+					{
+						addedcount++;
+						if (addedcount >= maxcount)
+						{
+							done = true;
+							if (!sources.GotoNextSource())
+								atend = true;
+						}
+						srcdat->INF_StartNewInterval();
+						srcdat->SetProcessedInRTCP(true);
+					}
+				}
+			}
+
+			if (!done)
+			{
+				if (!sources.GotoNextSource())
+				{
+					atend = true;
+					done = true;
+				}
+			}
+
+		} while (!done);
+	}
+	
+	*added = addedcount;
+	*skipped = skippedcount;
+	*full = filled;
+	
+	if (!atend) // search for available sources
+	{
+		bool shouldprocess = false;
+		
+		do
+		{	
+			srcdat = sources.GetCurrentSourceInfo();
+			if (!srcdat->IsOwnSSRC()) // don't send to ourselves
+			{
+				if (!srcdat->IsCSRC()) // p 35: no reports should go to CSRCs
+				{
+					if (srcdat->INF_HasSentData()) // if this isn't true, INF_GetLastRTPPacketTime() won't make any sense
+					{
+						if (firstpacket)
+							shouldprocess = true;
+						else
+						{
+							// p 35: only if rtp packets were received since the last RTP packet, a report block
+							// should be added
+							
+							RTPTime lastrtptime = srcdat->INF_GetLastRTPPacketTime();
+							
+							if (lastrtptime > prevbuildtime)
+								shouldprocess = true;
+						}
+					}
+				}
+			}
+			
+			if (shouldprocess)
+			{
+				if (srcdat->IsProcessedInRTCP())
+					shouldprocess = false;
+			}
+
+			if (!shouldprocess)
+			{
+				if (!sources.GotoNextSource())
+					atend = true;
+			}
+	
+		} while (!atend && !shouldprocess);
+	}	
+
+	*atendoflist = atend;
+	return 0;	
+}
+
+int RTCPPacketBuilder::FillInSDES(RTCPCompoundPacketBuilder *rtcpcomppack,bool *full,bool *processedall,int *added)
+{
+	int status;
+	u_int8_t *data;
+	size_t datalen;
+	
+	*full = false;
+	*processedall = false;
+	*added = 0;
+
+	// We don't need to add a SSRC for our own data, this is still set
+	// from adding the CNAME
+	if (doname)
+	{
+		if (!ownsdesinfo.ProcessedName())
+		{
+			data = ownsdesinfo.GetName(&datalen);
+			if ((status = rtcpcomppack->AddSDESNormalItem(RTCPSDESPacket::NAME,data,datalen)) < 0)
+			{
+				if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+				{
+					*full = true;
+					return 0;
+				}
+			}
+			(*added)++;
+			ownsdesinfo.SetProcessedName(true);
+		}
+	}
+	if (doemail)
+	{
+		if (!ownsdesinfo.ProcessedEMail())
+		{
+			data = ownsdesinfo.GetEMail(&datalen);
+			if ((status = rtcpcomppack->AddSDESNormalItem(RTCPSDESPacket::EMAIL,data,datalen)) < 0)
+			{
+				if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+				{
+					*full = true;
+					return 0;
+				}
+			}
+			(*added)++;
+			ownsdesinfo.SetProcessedEMail(true);
+		}
+	}
+	if (doloc)
+	{
+		if (!ownsdesinfo.ProcessedLocation())
+		{
+			data = ownsdesinfo.GetLocation(&datalen);
+			if ((status = rtcpcomppack->AddSDESNormalItem(RTCPSDESPacket::LOC,data,datalen)) < 0)
+			{
+				if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+				{
+					*full = true;
+					return 0;
+				}
+			}
+			(*added)++;
+			ownsdesinfo.SetProcessedLocation(true);
+		}
+	}
+	if (dophone)
+	{
+		if (!ownsdesinfo.ProcessedPhone())
+		{
+			data = ownsdesinfo.GetPhone(&datalen);
+			if ((status = rtcpcomppack->AddSDESNormalItem(RTCPSDESPacket::PHONE,data,datalen)) < 0)
+			{
+				if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+				{
+					*full = true;
+					return 0;
+				}
+			}
+			(*added)++;
+			ownsdesinfo.SetProcessedPhone(true);
+		}
+	}
+	if (dotool)
+	{
+		if (!ownsdesinfo.ProcessedTool())
+		{
+			data = ownsdesinfo.GetTool(&datalen);
+			if ((status = rtcpcomppack->AddSDESNormalItem(RTCPSDESPacket::TOOL,data,datalen)) < 0)
+			{
+				if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+				{
+					*full = true;
+					return 0;
+				}
+			}
+			(*added)++;
+			ownsdesinfo.SetProcessedTool(true);
+		}
+	}
+	if (donote)
+	{
+		if (!ownsdesinfo.ProcessedNote())
+		{
+			data = ownsdesinfo.GetNote(&datalen);
+			if ((status = rtcpcomppack->AddSDESNormalItem(RTCPSDESPacket::NOTE,data,datalen)) < 0)
+			{
+				if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+				{
+					*full = true;
+					return 0;
+				}
+			}
+			(*added)++;
+			ownsdesinfo.SetProcessedNote(true);
+		}
+	}
+
+	*processedall = true;
+	return 0;
+}
+
+void RTCPPacketBuilder::ClearAllSDESFlags()
+{
+	ownsdesinfo.ClearFlags();
+}
+	
+int RTCPPacketBuilder::BuildBYEPacket(RTCPCompoundPacket **pack,const void *reason,size_t reasonlength,bool useSRifpossible)
+{
+	if (!init)
+		return ERR_RTP_RTCPPACKETBUILDER_NOTINIT;
+
+	RTCPCompoundPacketBuilder *rtcpcomppack;
+	int status;
+	
+	if (reasonlength > 255)
+		reasonlength = 255;
+	
+	*pack = 0;
+	
+	rtcpcomppack = new RTCPCompoundPacketBuilder();
+	if (rtcpcomppack == 0)
+		return ERR_RTP_OUTOFMEM;
+	
+	if ((status = rtcpcomppack->InitBuild(maxpacketsize)) < 0)
+	{
+		delete rtcpcomppack;
+		return status;
+	}
+	
+	u_int32_t ssrc = rtppacketbuilder.GetSSRC();
+	bool useSR = false;
+	
+	if (useSRifpossible)
+	{
+		RTPSourceData *srcdat;
+		
+		if ((srcdat = sources.GetOwnSourceInfo()) != 0)
+		{
+			if (srcdat->IsSender())
+				useSR = true;
+		}
+	}
+			
+	if (useSR)
+	{
+		RTPTime curtime = RTPTime::CurrentTime();
+		RTPTime rtppacktime = rtppacketbuilder.GetPacketTime();
+		u_int32_t rtppacktimestamp = rtppacketbuilder.GetPacketTimestamp();
+		u_int32_t packcount = rtppacketbuilder.GetPacketCount();
+		u_int32_t octetcount = rtppacketbuilder.GetPayloadOctetCount();
+		RTPTime diff = curtime;
+		diff -= rtppacktime;
+		
+		u_int32_t tsdiff = (u_int32_t)((diff.GetDouble()/timestampunit)+0.5);
+		u_int32_t rtptimestamp = rtppacktimestamp+tsdiff;
+		RTPNTPTime ntptimestamp = curtime.GetNTPTime();
+
+		if ((status = rtcpcomppack->StartSenderReport(ssrc,ntptimestamp,rtptimestamp,packcount,octetcount)) < 0)
+		{
+			delete rtcpcomppack;
+			if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+				return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+			return status;
+		}
+	}
+	else
+	{
+		if ((status = rtcpcomppack->StartReceiverReport(ssrc)) < 0)
+		{
+			delete rtcpcomppack;
+			if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+				return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+			return status;
+		}
+	}
+
+	u_int8_t *owncname;
+	size_t owncnamelen;
+
+	owncname = ownsdesinfo.GetCNAME(&owncnamelen);
+
+	if ((status = rtcpcomppack->AddSDESSource(ssrc)) < 0)
+	{
+		delete rtcpcomppack;
+		if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+			return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+		return status;
+	}
+	if ((status = rtcpcomppack->AddSDESNormalItem(RTCPSDESPacket::CNAME,owncname,owncnamelen)) < 0)
+	{
+		delete rtcpcomppack;
+		if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+			return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+		return status;
+	}
+
+	u_int32_t ssrcs[1];
+
+	ssrcs[0] = ssrc;
+	
+	if ((status = rtcpcomppack->AddBYEPacket(ssrcs,1,(const u_int8_t *)reason,reasonlength)) < 0)
+	{
+		delete rtcpcomppack;
+		if (status == ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT)
+			return ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON;
+		return status;
+	}
+	
+	if ((status = rtcpcomppack->EndBuild()) < 0)
+	{
+		delete rtcpcomppack;
+		return status;
+	}
+
+	*pack = rtcpcomppack;
+	return 0;
+}
+

Added: konference/src/rtp/jrtplib/rtcppacketbuilder.h
===================================================================
--- konference/src/rtp/jrtplib/rtcppacketbuilder.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcppacketbuilder.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,122 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPPACKETBUILDER_H
+
+#define RTCPPACKETBUILDER_H
+
+#include "rtpconfig.h"
+#include "rtptypes.h"
+#include "rtperrors.h"
+#include "rtcpsdesinfo.h"
+#include "rtptimeutilities.h"
+
+class RTPSources;
+class RTPPacketBuilder;
+class RTCPScheduler;
+class RTCPCompoundPacket;
+class RTCPCompoundPacketBuilder;
+
+class RTCPPacketBuilder
+{
+public:
+	RTCPPacketBuilder(RTPSources &sources,RTPPacketBuilder &rtppackbuilder);
+	~RTCPPacketBuilder();
+
+	int Init(size_t maxpacksize,double timestampunit,const void *cname,size_t cnamelen);
+	void Destroy();
+
+	int SetTimestampUnit(double tsunit)						{ if (!init) return ERR_RTP_RTCPPACKETBUILDER_NOTINIT; if (tsunit < 0) return ERR_RTP_RTCPPACKETBUILDER_ILLEGALTIMESTAMPUNIT; timestampunit = tsunit; return 0; }
+	int SetMaximumPacketSize(size_t maxpacksize)					{ if (!init) return ERR_RTP_RTCPPACKETBUILDER_NOTINIT; if (maxpacksize < RTP_MINPACKETSIZE) return ERR_RTP_RTCPPACKETBUILDER_ILLEGALMAXPACKSIZE; maxpacketsize = maxpacksize; return 0; }
+	
+	int BuildNextPacket(RTCPCompoundPacket **pack);
+	int BuildBYEPacket(RTCPCompoundPacket **pack,const void *reason,size_t reasonlength,bool useSRifpossible = true);
+
+	void SetNameInterval(int count)							{ if (!init) return; interval_name = count; }
+	void SetEMailInterval(int count)						{ if (!init) return; interval_email = count; }
+	void SetLocationInterval(int count)						{ if (!init) return; interval_location = count; }
+	void SetPhoneInterval(int count)						{ if (!init) return; interval_phone = count; }
+	void SetToolInterval(int count)							{ if (!init) return; interval_tool = count; }
+	void SetNoteInterval(int count)							{ if (!init) return; interval_note = count; }
+	int SetLocalName(const void *s,size_t len)					{ if (!init) return ERR_RTP_RTCPPACKETBUILDER_NOTINIT; return ownsdesinfo.SetName((const u_int8_t *)s,len); }
+	int SetLocalEMail(const void *s,size_t len)					{ if (!init) return ERR_RTP_RTCPPACKETBUILDER_NOTINIT; return ownsdesinfo.SetEMail((const u_int8_t *)s,len); }
+	int SetLocalLocation(const void *s,size_t len)					{ if (!init) return ERR_RTP_RTCPPACKETBUILDER_NOTINIT; return ownsdesinfo.SetLocation((const u_int8_t *)s,len); }
+	int SetLocalPhone(const void *s,size_t len)					{ if (!init) return ERR_RTP_RTCPPACKETBUILDER_NOTINIT; return ownsdesinfo.SetPhone((const u_int8_t *)s,len); }
+	int SetLocalTool(const void *s,size_t len)					{ if (!init) return ERR_RTP_RTCPPACKETBUILDER_NOTINIT; return ownsdesinfo.SetTool((const u_int8_t *)s,len); }
+	int SetLocalNote(const void *s,size_t len)					{ if (!init) return ERR_RTP_RTCPPACKETBUILDER_NOTINIT; return ownsdesinfo.SetNote((const u_int8_t *)s,len); }
+private:
+	void ClearAllSourceFlags();
+	int FillInReportBlocks(RTCPCompoundPacketBuilder *pack,const RTPTime &curtime,int maxcount,bool *full,int *added,int *skipped,bool *atendoflist);
+	int FillInSDES(RTCPCompoundPacketBuilder *pack,bool *full,bool *processedall,int *added);
+	void ClearAllSDESFlags();
+	
+	RTPSources &sources;
+	RTPPacketBuilder &rtppacketbuilder;
+	
+	bool init;
+	size_t maxpacketsize;
+	double timestampunit;
+	bool firstpacket;
+	RTPTime prevbuildtime;
+
+	class RTCPSDESInfoInternal : public RTCPSDESInfo
+	{
+	public:
+		RTCPSDESInfoInternal() 			{ ClearFlags(); }
+		void ClearFlags()			{ pname = false; pemail = false; plocation = false; pphone = false; ptool = false; pnote = false; }
+		bool ProcessedName() const 		{ return pname; }
+		bool ProcessedEMail() const		{ return pemail; }
+		bool ProcessedLocation() const		{ return plocation; }
+		bool ProcessedPhone() const		{ return pphone; }
+		bool ProcessedTool() const		{ return ptool; }
+		bool ProcessedNote() const		{ return pnote; }
+		void SetProcessedName(bool v)		{ pname = v; }
+		void SetProcessedEMail(bool v)		{ pemail = v; }
+		void SetProcessedLocation(bool v)	{ plocation  = v; }
+		void SetProcessedPhone(bool v)		{ pphone = v; }
+		void SetProcessedTool(bool v)		{ ptool = v; }
+		void SetProcessedNote(bool v)		{ pnote = v; }
+	private:
+		bool pname,pemail,plocation,pphone,ptool,pnote;
+	};
+	
+	RTCPSDESInfoInternal ownsdesinfo;
+	int interval_name,interval_email,interval_location;
+	int interval_phone,interval_tool,interval_note;
+	bool doname,doemail,doloc,dophone,dotool,donote;
+	bool processingsdes;
+
+	int sdesbuildcount;
+};
+
+#endif // RTCPPACKETBUILDER_H
+

Added: konference/src/rtp/jrtplib/rtcprrpacket.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcprrpacket.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcprrpacket.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,94 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtcprrpacket.h"
+#ifdef RTPDEBUG
+	#include <iostream>
+#endif // RTPDEBUG
+
+#include "rtpdebug.h"
+
+RTCPRRPacket::RTCPRRPacket(u_int8_t *data,size_t datalength)
+	: RTCPPacket(RR,data,datalength)
+{
+	knownformat = false;
+	
+	RTCPCommonHeader *hdr;
+	size_t len = datalength;
+	size_t expectedlength;
+	
+	hdr = (RTCPCommonHeader *)data;
+	if (hdr->padding)
+	{
+		u_int8_t padcount = data[datalength-1];
+		if ((padcount & 0x03) != 0) // not a multiple of four! (see rfc 3550 p 37)
+			return;
+		if (((size_t)padcount) >= len)
+			return;
+		len -= (size_t)padcount;
+	}
+
+	expectedlength = sizeof(RTCPCommonHeader)+sizeof(u_int32_t);
+	expectedlength += sizeof(RTCPReceiverReport)*((int)hdr->count);
+
+	if (expectedlength != len)
+		return;
+	
+	knownformat = true;
+}
+
+#ifdef RTPDEBUG
+void RTCPRRPacket::Dump()
+{
+	RTCPPacket::Dump();
+	if (!IsKnownFormat())
+		std::cout << "    Unknown format" << std::endl;
+	else
+	{
+		int num = GetReceptionReportCount();
+		int i;
+
+		std::cout << "    SSRC of sender:     " << GetSenderSSRC() << std::endl;
+		for (i = 0 ; i < num ; i++)
+		{
+			std::cout << "    Report block " << i << std::endl;
+			std::cout << "        SSRC:           " << GetSSRC(i) << std::endl;
+			std::cout << "        Fraction lost:  " << (u_int32_t)GetFractionLost(i) << std::endl;
+			std::cout << "        Packets lost:   " << GetLostPacketCount(i) << std::endl;
+			std::cout << "        Seq. nr.:       " << GetExtendedHighestSequenceNumber(i) << std::endl;
+			std::cout << "        Jitter:         " << GetJitter(i) << std::endl;
+			std::cout << "        LSR:            " << GetLSR(i) << std::endl;
+			std::cout << "        DLSR:           " << GetDLSR(i) << std::endl;
+		}
+	}	
+}
+#endif // RTPDEBUG

Added: konference/src/rtp/jrtplib/rtcprrpacket.h
===================================================================
--- konference/src/rtp/jrtplib/rtcprrpacket.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcprrpacket.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,158 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPRRPACKET_H
+
+#define RTCPRRPACKET_H
+
+#include "rtpconfig.h"
+#include "rtcppacket.h"
+#include "rtpstructs.h"
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include <netinet/in.h>
+#endif // WIN32
+
+class RTCPCompoundPacket;
+
+class RTCPRRPacket : public RTCPPacket
+{
+public:
+	RTCPRRPacket(u_int8_t *data,size_t datalen);
+	~RTCPRRPacket()								{ }
+	
+	// Sender info
+	
+	u_int32_t GetSenderSSRC() const;
+	
+	// Reportblocks
+
+	int GetReceptionReportCount() const;
+	// Note: the validity of index is NOT checked!
+	u_int32_t GetSSRC(int index) const;
+	u_int8_t GetFractionLost(int index) const;
+	int32_t GetLostPacketCount(int index) const;
+	u_int32_t GetExtendedHighestSequenceNumber(int index) const;
+	u_int32_t GetJitter(int index) const;
+	u_int32_t GetLSR(int index) const;
+	u_int32_t GetDLSR(int index) const;
+
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+private:
+	RTCPReceiverReport *GotoReport(int index) const;
+};
+
+inline u_int32_t RTCPRRPacket::GetSenderSSRC() const
+{
+	if (!knownformat)
+		return 0;
+	
+	u_int32_t *ssrcptr = (u_int32_t *)(data+sizeof(RTCPCommonHeader));
+	return ntohl(*ssrcptr);
+}
+inline int RTCPRRPacket::GetReceptionReportCount() const
+{
+	if (!knownformat)
+		return 0;
+	RTCPCommonHeader *hdr = (RTCPCommonHeader *)data;
+	return ((int)hdr->count);
+}
+
+inline RTCPReceiverReport *RTCPRRPacket::GotoReport(int index) const
+{
+	RTCPReceiverReport *r = (RTCPReceiverReport *)(data+sizeof(RTCPCommonHeader)+sizeof(u_int32_t)+index*sizeof(RTCPReceiverReport));
+	return r;
+}
+
+inline u_int32_t RTCPRRPacket::GetSSRC(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return ntohl(r->ssrc);
+}
+
+inline u_int8_t RTCPRRPacket::GetFractionLost(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return r->fractionlost;
+}
+
+inline int32_t RTCPRRPacket::GetLostPacketCount(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	u_int32_t count = ((u_int32_t)r->packetslost[2])|(((u_int32_t)r->packetslost[1])<<8)|(((u_int32_t)r->packetslost[0])<<16);
+	if ((count&0x00800000) != 0) // test for negative number
+		count |= 0xFF000000;
+	int32_t *count2 = (int32_t *)(&count);
+	return (*count2);
+}
+
+inline u_int32_t RTCPRRPacket::GetExtendedHighestSequenceNumber(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return ntohl(r->exthighseqnr);
+}
+
+inline u_int32_t RTCPRRPacket::GetJitter(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return ntohl(r->jitter);
+}
+
+inline u_int32_t RTCPRRPacket::GetLSR(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return ntohl(r->lsr);
+}
+
+inline u_int32_t RTCPRRPacket::GetDLSR(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return ntohl(r->dlsr);
+}
+
+#endif // RTCPRRPACKET_H
+

Added: konference/src/rtp/jrtplib/rtcpscheduler.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcpscheduler.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpscheduler.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,381 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtcpscheduler.h"
+#include "rtpsources.h"
+#include "rtpdefines.h"
+#include "rtcppacket.h"
+#include "rtppacket.h"
+#include "rtcpcompoundpacket.h"
+#include "rtpsourcedata.h"
+
+#include "rtpdebug.h"
+
+#define RTCPSCHED_MININTERVAL						1.0
+
+RTCPSchedulerParams::RTCPSchedulerParams() : mininterval(RTCP_DEFAULTMININTERVAL)
+{
+	bandwidth = 1000; // TODO What is a good value here? 
+	senderfraction = RTCP_DEFAULTSENDERFRACTION;
+	usehalfatstartup = RTCP_DEFAULTHALFATSTARTUP;
+	immediatebye = RTCP_DEFAULTIMMEDIATEBYE;
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	timeinit.Dummy();
+#endif // WIN32 || _WIN32_WCE
+}
+
+RTCPSchedulerParams::~RTCPSchedulerParams()
+{
+}
+
+int RTCPSchedulerParams::SetRTCPBandwidth(double bw)
+{
+	if (bw < 0.0)
+		return ERR_RTP_SCHEDPARAMS_INVALIDBANDWIDTH;
+	bandwidth = bw;
+	return 0;
+}
+
+int RTCPSchedulerParams::SetSenderBandwidthFraction(double fraction)
+{
+	if (fraction < 0.0 || fraction > 1.0)
+		return ERR_RTP_SCHEDPARAMS_BADFRACTION;
+	senderfraction = fraction;
+	return 0;
+}
+
+int RTCPSchedulerParams::SetMinimumTransmissionInterval(const RTPTime &t)
+{
+	double t2 = t.GetDouble();
+
+	if (t2 < RTCPSCHED_MININTERVAL)
+		return ERR_RTP_SCHEDPARAMS_BADMINIMUMINTERVAL;
+
+	mininterval = t;
+	return 0;
+}
+
+RTCPScheduler::RTCPScheduler(RTPSources &s) : sources(s),nextrtcptime(0,0),prevrtcptime(0,0)
+{
+	Reset();
+}
+
+RTCPScheduler::~RTCPScheduler()
+{
+}
+
+void RTCPScheduler::Reset()
+{
+	headeroverhead = 0; // user has to set this to an appropriate value
+	hassentrtcp = false;
+	firstcall = true;
+	avgrtcppacksize = 1000; // TODO: what is a good value for this?
+	byescheduled = false;
+	sendbyenow = false;
+}
+
+void RTCPScheduler::AnalyseIncoming(RTCPCompoundPacket &rtcpcomppack)
+{
+	bool isbye = false;
+	RTCPPacket *p;
+	
+	rtcpcomppack.GotoFirstPacket();
+	while (!isbye && ((p = rtcpcomppack.GetNextPacket()) != 0))
+	{
+		if (p->GetPacketType() == RTCPPacket::BYE)
+			isbye = true;
+	}
+	
+	if (!isbye)
+	{
+		size_t packsize = headeroverhead+rtcpcomppack.GetCompoundPacketLength();
+		avgrtcppacksize = (size_t)((1.0/16.0)*((double)packsize)+(15.0/16.0)*((double)avgrtcppacksize));
+	}
+	else
+	{
+		if (byescheduled)
+		{
+			size_t packsize = headeroverhead+rtcpcomppack.GetCompoundPacketLength();
+			avgbyepacketsize = (size_t)((1.0/16.0)*((double)packsize)+(15.0/16.0)*((double)avgbyepacketsize));
+			byemembers++;
+		}
+	}
+}
+
+void RTCPScheduler::AnalyseOutgoing(RTCPCompoundPacket &rtcpcomppack)
+{
+	bool isbye = false;
+	RTCPPacket *p;
+	
+	rtcpcomppack.GotoFirstPacket();
+	while (!isbye && ((p = rtcpcomppack.GetNextPacket()) != 0))
+	{
+		if (p->GetPacketType() == RTCPPacket::BYE)
+			isbye = true;
+	}
+	
+	if (!isbye)
+	{
+		size_t packsize = headeroverhead+rtcpcomppack.GetCompoundPacketLength();
+		avgrtcppacksize = (size_t)((1.0/16.0)*((double)packsize)+(15.0/16.0)*((double)avgrtcppacksize));
+	}
+
+	hassentrtcp = true;
+}
+
+RTPTime RTCPScheduler::GetTransmissionDelay()
+{
+	if (firstcall)
+	{
+		firstcall = false;
+		prevrtcptime = RTPTime::CurrentTime();
+		pmembers = sources.GetActiveMemberCount();
+		CalculateNextRTCPTime();
+	}
+	
+	RTPTime curtime = RTPTime::CurrentTime();
+
+	if (curtime > nextrtcptime) // packet should be sent
+		return RTPTime(0,0);
+
+	RTPTime diff = nextrtcptime;
+	diff -= curtime;
+	
+	return diff;
+}
+
+bool RTCPScheduler::IsTime()
+{
+	if (firstcall)
+	{
+		firstcall = false;
+		prevrtcptime = RTPTime::CurrentTime();
+		pmembers = sources.GetActiveMemberCount();
+		CalculateNextRTCPTime();
+		return false;
+	}
+
+	RTPTime currenttime = RTPTime::CurrentTime();
+
+	if (currenttime < nextrtcptime) // timer has not yet expired
+		return false;
+
+	RTPTime checktime(0,0);
+	
+	if (!byescheduled)
+	{
+		bool aresender = false;
+		RTPSourceData *srcdat;
+		
+		if ((srcdat = sources.GetOwnSourceInfo()) != 0)
+			aresender = srcdat->IsSender();
+		
+		checktime = CalculateTransmissionInterval(aresender);
+	}
+	else
+		checktime = CalculateBYETransmissionInterval();
+	
+	checktime += prevrtcptime;
+	
+	if (checktime <= currenttime) // Okay
+	{
+		byescheduled = false;
+		prevrtcptime = currenttime;
+		pmembers = sources.GetActiveMemberCount();
+		CalculateNextRTCPTime();
+		return true;
+	}
+	
+	nextrtcptime = checktime;
+	pmembers = sources.GetActiveMemberCount();
+	
+	return false;
+}
+
+void RTCPScheduler::CalculateNextRTCPTime()
+{
+	bool aresender = false;
+	RTPSourceData *srcdat;
+	
+	if ((srcdat = sources.GetOwnSourceInfo()) != 0)
+		aresender = srcdat->IsSender();
+	
+	nextrtcptime = RTPTime::CurrentTime();	
+	nextrtcptime += CalculateTransmissionInterval(aresender);
+}
+
+RTPTime RTCPScheduler::CalculateDeterministicInterval(bool sender /* = false */)
+{
+	int numsenders = sources.GetSenderCount();
+	int numtotal = sources.GetActiveMemberCount();
+
+	// Try to avoid division by zero:
+	if (numtotal == 0)
+		numtotal++;
+
+	double sfraction = ((double)numsenders)/((double)numtotal);
+	double C,n;
+
+	if (sfraction <= schedparams.GetSenderBandwidthFraction())
+	{
+		if (sender)
+		{
+			C = ((double)avgrtcppacksize)/(schedparams.GetSenderBandwidthFraction()*schedparams.GetRTCPBandwidth());
+			n = (double)numsenders;
+		}
+		else
+		{
+			C = ((double)avgrtcppacksize)/((1.0-schedparams.GetSenderBandwidthFraction())*schedparams.GetRTCPBandwidth());
+			n = (double)(numtotal-numsenders);
+		}
+	}
+	else
+	{
+		C = ((double)avgrtcppacksize)/schedparams.GetRTCPBandwidth();
+		n = (double)numtotal;
+	}
+	
+	RTPTime Tmin = schedparams.GetMinimumTransmissionInterval();
+	double tmin = Tmin.GetDouble();
+	
+	if (!hassentrtcp && schedparams.GetUseHalfAtStartup())
+		tmin /= 2.0;
+
+	double ntimesC = n*C;
+	double Td = (tmin>ntimesC)?tmin:ntimesC;
+
+	return RTPTime(Td);
+}
+
+RTPTime RTCPScheduler::CalculateTransmissionInterval(bool sender)
+{
+	RTPTime Td = CalculateDeterministicInterval(sender);
+	double td,mul,T;
+
+	td = Td.GetDouble();
+	mul = rtprand.GetRandomDouble()+0.5; // gives random value between 0.5 and 1.5
+	T = (td*mul)/1.21828; // see RFC 3550 p 30
+
+	return RTPTime(T);
+}
+
+void RTCPScheduler::PerformReverseReconsideration()
+{
+	if (firstcall)
+		return;
+	
+	double diff1,diff2;
+	int members = sources.GetActiveMemberCount();
+	
+	RTPTime tc = RTPTime::CurrentTime();
+	RTPTime tn_min_tc = nextrtcptime;
+	tn_min_tc -= tc;
+	RTPTime tc_min_tp = tc;
+	tc_min_tp -= prevrtcptime;
+	
+	if (pmembers == 0) // avoid division by zero
+		pmembers++;
+	
+	diff1 = (((double)members)/((double)pmembers))*tn_min_tc.GetDouble();
+	diff2 = (((double)members)/((double)pmembers))*tc_min_tp.GetDouble();
+
+	nextrtcptime = tc;
+	prevrtcptime = tc;
+	nextrtcptime += RTPTime(diff1);
+	prevrtcptime -= RTPTime(diff2);
+	
+	pmembers = members;
+}
+
+void RTCPScheduler::ScheduleBYEPacket(size_t packetsize)
+{
+	if (byescheduled)
+		return;
+	
+	if (firstcall)
+	{
+		firstcall = false;
+		pmembers = sources.GetActiveMemberCount();
+	}
+
+	byescheduled = true;
+	avgbyepacketsize = packetsize+headeroverhead;
+
+	// For now, we will always use the BYE backoff algorithm as described in rfc 3550 p 33
+	
+	byemembers = 1;
+	pbyemembers = 1;
+
+	if (schedparams.GetRequestImmediateBYE() && sources.GetActiveMemberCount() < 50) // p 34 (top)
+		sendbyenow = true;
+	else
+		sendbyenow = false;
+	
+	prevrtcptime = RTPTime::CurrentTime();
+	nextrtcptime = prevrtcptime;
+	nextrtcptime += CalculateBYETransmissionInterval();
+}
+
+void RTCPScheduler::ActiveMemberDecrease()
+{
+	if (sources.GetActiveMemberCount() < pmembers)
+		PerformReverseReconsideration();
+}
+
+RTPTime RTCPScheduler::CalculateBYETransmissionInterval()
+{
+	if (!byescheduled)
+		return RTPTime(0,0);
+	
+	if (sendbyenow)
+		return RTPTime(0,0);
+	
+	double C,n;
+
+	C = ((double)avgbyepacketsize)/((1.0-schedparams.GetSenderBandwidthFraction())*schedparams.GetRTCPBandwidth());
+	n = (double)byemembers;
+	
+	RTPTime Tmin = schedparams.GetMinimumTransmissionInterval();
+	double tmin = Tmin.GetDouble();
+	
+	if (schedparams.GetUseHalfAtStartup())
+		tmin /= 2.0;
+
+	double ntimesC = n*C;
+	double Td = (tmin>ntimesC)?tmin:ntimesC;
+
+	double mul = rtprand.GetRandomDouble()+0.5; // gives random value between 0.5 and 1.5
+	double T = (Td*mul)/1.21828; // see RFC 3550 p 30
+	
+	return RTPTime(T);
+}
+

Added: konference/src/rtp/jrtplib/rtcpscheduler.h
===================================================================
--- konference/src/rtp/jrtplib/rtcpscheduler.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpscheduler.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,122 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPSCHEDULER_H
+
+#define RTCPSCHEDULER_H
+
+#include "rtpconfig.h"
+#include "rtptimeutilities.h"
+#include "rtprandom.h"
+
+class RTCPCompoundPacket;
+class RTPPacket;
+class RTPSources;
+
+class RTCPSchedulerParams
+{
+public:
+	RTCPSchedulerParams();
+	~RTCPSchedulerParams();
+	int SetRTCPBandwidth(double bw); // bandwidth is in bytes per second
+	double GetRTCPBandwidth() const							{ return bandwidth; }
+	int SetSenderBandwidthFraction(double fraction);
+	double GetSenderBandwidthFraction() const					{ return senderfraction; }
+	int SetMinimumTransmissionInterval(const RTPTime &t);
+	RTPTime GetMinimumTransmissionInterval() const					{ return mininterval; }
+	void SetUseHalfAtStartup(bool usehalf)						{ usehalfatstartup = usehalf; }
+	bool GetUseHalfAtStartup() const						{ return usehalfatstartup; }
+	void SetRequestImmediateBYE(bool v)						{ immediatebye = v; }
+	bool GetRequestImmediateBYE() const						{ return immediatebye; }	
+private:
+	double bandwidth;
+	double senderfraction;
+	RTPTime mininterval;
+	bool usehalfatstartup;
+	bool immediatebye;
+};
+
+class RTCPScheduler
+{
+public:
+	RTCPScheduler(RTPSources &sources);
+	~RTCPScheduler();
+	void Reset();
+
+	void SetParameters(const RTCPSchedulerParams &params)						{ schedparams = params; }
+	RTCPSchedulerParams GetParameters() const							{ return schedparams; }
+
+	void SetHeaderOverhead(size_t numbytes)								{ headeroverhead = numbytes; }
+	size_t GetHeaderOverhead() const								{ return headeroverhead; }
+
+	void AnalyseIncoming(RTCPCompoundPacket &rtcpcomppack);
+	void AnalyseOutgoing(RTCPCompoundPacket &rtcpcomppack);
+
+	// is to be called when a source times out or when a bye packet was received
+	void ActiveMemberDecrease();
+	void ScheduleBYEPacket(size_t packetsize);
+
+	RTPTime GetTransmissionDelay();
+	
+	// Returns true is it is time to send a packet and then recalculates the next rtcp time
+	// So, if the function would be called immediately after it returned true, it would then
+	// return false
+	bool IsTime();
+
+	RTPTime CalculateDeterministicInterval(bool sender = false);
+private:
+	void CalculateNextRTCPTime();
+	void PerformReverseReconsideration();
+	RTPTime CalculateBYETransmissionInterval();
+	RTPTime CalculateTransmissionInterval(bool sender);
+	
+	RTPSources &sources;
+	RTCPSchedulerParams schedparams;
+	size_t headeroverhead;
+	size_t avgrtcppacksize;
+	bool hassentrtcp;
+	bool firstcall;
+	RTPTime nextrtcptime;
+	RTPTime prevrtcptime;
+	int pmembers;
+
+	// for BYE packet scheduling
+	bool byescheduled;
+	int byemembers,pbyemembers;
+	size_t avgbyepacketsize;
+	bool sendbyenow;
+
+	RTPRandom rtprand;
+};
+
+#endif // RTCPSCHEDULER_H
+

Added: konference/src/rtp/jrtplib/rtcpsdesinfo.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcpsdesinfo.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpsdesinfo.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,177 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtcpsdesinfo.h"
+
+#include "rtpdebug.h"
+
+void RTCPSDESInfo::Clear()
+{
+#ifdef RTP_SUPPORT_SDESPRIV
+	std::list<SDESPrivateItem *>::const_iterator it;
+
+	for (it = privitems.begin() ; it != privitems.end() ; ++it)
+		delete *it;
+	privitems.clear();
+#endif // RTP_SUPPORT_SDESPRIV
+}
+
+#ifdef RTP_SUPPORT_SDESPRIV
+int RTCPSDESInfo::SetPrivateValue(const u_int8_t *prefix,size_t prefixlen,const u_int8_t *value,size_t valuelen)
+{
+	std::list<SDESPrivateItem *>::const_iterator it;
+	bool found;
+	
+	found = false;
+	it = privitems.begin();
+	while (!found && it != privitems.end())
+	{
+		u_int8_t *p;
+		size_t l;
+		
+		p = (*it)->GetPrefix(&l);
+		if (l == prefixlen)
+		{
+			if (l <= 0)
+				found = true;
+			else if (memcmp(prefix,p,l) == 0)
+				found = true;
+			else
+				++it;
+		}
+		else
+			++it;
+	}
+	
+	SDESPrivateItem *item;
+	
+	if (found) // replace the value for this entry
+		item = *it;
+	else // no entry for this prefix found... add it
+	{
+		if (privitems.size() >= RTP_MAXPRIVITEMS) // too many items present, just ignore it
+			return ERR_RTP_SDES_MAXPRIVITEMS;
+		
+		int status;
+		
+		item = new SDESPrivateItem();
+		if (item == 0)
+			return ERR_RTP_OUTOFMEM;
+		if ((status = item->SetPrefix(prefix,prefixlen)) < 0)
+		{
+			delete item;
+			return status;
+		}
+		privitems.push_front(item);
+	}
+	return item->SetInfo(value,valuelen);
+}
+
+int RTCPSDESInfo::DeletePrivatePrefix(const u_int8_t *prefix,size_t prefixlen)
+{
+	std::list<SDESPrivateItem *>::iterator it;
+	bool found;
+	
+	found = false;
+	it = privitems.begin();
+	while (!found && it != privitems.end())
+	{
+		u_int8_t *p;
+		size_t l;
+		
+		p = (*it)->GetPrefix(&l);
+		if (l == prefixlen)
+		{
+			if (l <= 0)
+				found = true;
+			else if (memcmp(prefix,p,l) == 0)
+				found = true;
+			else
+				++it;
+		}
+		else
+			++it;
+	}
+	if (!found)
+		return ERR_RTP_SDES_PREFIXNOTFOUND;
+	
+	delete (*it);
+	privitems.erase(it);
+	return 0;
+}
+
+void RTCPSDESInfo::GotoFirstPrivateValue()
+{
+	curitem = privitems.begin();
+}
+
+bool RTCPSDESInfo::GetNextPrivateValue(u_int8_t **prefix,size_t *prefixlen,u_int8_t **value,size_t *valuelen)
+{
+	if (curitem == privitems.end())
+		return false;
+	*prefix = (*curitem)->GetPrefix(prefixlen);
+	*value = (*curitem)->GetInfo(valuelen);
+	++curitem;
+	return true;
+}
+
+bool RTCPSDESInfo::GetPrivateValue(const u_int8_t *prefix,size_t prefixlen,u_int8_t **value,size_t *valuelen) const
+{
+	std::list<SDESPrivateItem *>::const_iterator it;
+	bool found;
+	
+	found = false;
+	it = privitems.begin();
+	while (!found && it != privitems.end())
+	{
+		u_int8_t *p;
+		size_t l;
+		
+		p = (*it)->GetPrefix(&l);
+		if (l == prefixlen)
+		{
+			if (l <= 0)
+				found = true;
+			else if (memcmp(prefix,p,l) == 0)
+				found = true;
+			else
+				++it;
+		}
+		else
+			++it;
+	}
+	if (found)
+		*value = (*it)->GetInfo(valuelen);
+	return found;
+}
+#endif // RTP_SUPPORT_SDESPRIV
+

Added: konference/src/rtp/jrtplib/rtcpsdesinfo.h
===================================================================
--- konference/src/rtp/jrtplib/rtcpsdesinfo.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpsdesinfo.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,138 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPSDESINFO_H
+
+#define RTCPSDESINFO_H
+
+#include "rtpconfig.h"
+#include "rtperrors.h"
+#include "rtpdefines.h"
+#include "rtptypes.h"
+#include <string.h>
+#include <list>
+
+class RTCPSDESInfo
+{
+public:
+	RTCPSDESInfo()								{ }
+	virtual ~RTCPSDESInfo()							{ Clear(); }
+	void Clear();
+
+	int SetCNAME(const u_int8_t *s,size_t l)				{ return SetNonPrivateItem(RTCP_SDES_ID_CNAME-1,s,l); }
+	int SetName(const u_int8_t *s,size_t l)					{ return SetNonPrivateItem(RTCP_SDES_ID_NAME-1,s,l); }
+	int SetEMail(const u_int8_t *s,size_t l)				{ return SetNonPrivateItem(RTCP_SDES_ID_EMAIL-1,s,l); }
+	int SetPhone(const u_int8_t *s,size_t l)				{ return SetNonPrivateItem(RTCP_SDES_ID_PHONE-1,s,l); }
+	int SetLocation(const u_int8_t *s,size_t l)				{ return SetNonPrivateItem(RTCP_SDES_ID_LOCATION-1,s,l); }
+	int SetTool(const u_int8_t *s,size_t l)					{ return SetNonPrivateItem(RTCP_SDES_ID_TOOL-1,s,l); }
+	int SetNote(const u_int8_t *s,size_t l)					{ return SetNonPrivateItem(RTCP_SDES_ID_NOTE-1,s,l); }
+
+#ifdef RTP_SUPPORT_SDESPRIV
+	int SetPrivateValue(const u_int8_t *prefix,size_t prefixlen,const u_int8_t *value,size_t valuelen);
+	int DeletePrivatePrefix(const u_int8_t *s,size_t len);
+#endif // RTP_SUPPORT_SDESPRIV
+	
+	u_int8_t *GetCNAME(size_t *len) const					{ return GetNonPrivateItem(RTCP_SDES_ID_CNAME-1,len); }
+	u_int8_t *GetName(size_t *len) const					{ return GetNonPrivateItem(RTCP_SDES_ID_NAME-1,len); }
+	u_int8_t *GetEMail(size_t *len) const					{ return GetNonPrivateItem(RTCP_SDES_ID_EMAIL-1,len); }
+	u_int8_t *GetPhone(size_t *len) const					{ return GetNonPrivateItem(RTCP_SDES_ID_PHONE-1,len); }
+	u_int8_t *GetLocation(size_t *len) const				{ return GetNonPrivateItem(RTCP_SDES_ID_LOCATION-1,len); }
+	u_int8_t *GetTool(size_t *len) const					{ return GetNonPrivateItem(RTCP_SDES_ID_TOOL-1,len); }
+	u_int8_t *GetNote(size_t *len) const 					{ return GetNonPrivateItem(RTCP_SDES_ID_NOTE-1,len); }
+
+#ifdef RTP_SUPPORT_SDESPRIV
+	void GotoFirstPrivateValue();
+	bool GetNextPrivateValue(u_int8_t **prefix,size_t *prefixlen,u_int8_t **value,size_t *valuelen);
+	bool GetPrivateValue(const u_int8_t *prefix,size_t prefixlen,u_int8_t **value,size_t *valuelen) const;
+#endif // RTP_SUPPORT_SDESPRIV
+private:
+	int SetNonPrivateItem(int itemno,const u_int8_t *s,size_t l)		{ if (l > RTCP_SDES_MAXITEMLENGTH) return ERR_RTP_SDES_LENGTHTOOBIG; return nonprivateitems[itemno].SetInfo(s,l); }
+	u_int8_t *GetNonPrivateItem(int itemno,size_t *len) const		{ return nonprivateitems[itemno].GetInfo(len); }
+
+	class SDESItem
+	{
+	public:
+		SDESItem() 							{ str = 0; length = 0; }
+		~SDESItem() 							{ if (str) delete [] str; }
+		u_int8_t *GetInfo(size_t *len) const				{ *len = length; return str; }
+		int SetInfo(const u_int8_t *s,size_t len)			{ return SetString(&str,&length,s,len); }
+	protected:
+		static int SetString(u_int8_t **dest,size_t *destlen,const u_int8_t *s,size_t len)
+		{
+			if (len <= 0)
+			{
+				if (*dest)
+					delete [] (*dest);
+				*dest = 0;
+				*destlen = 0;
+			}
+			else
+			{
+				len = (len>RTCP_SDES_MAXITEMLENGTH)?RTCP_SDES_MAXITEMLENGTH:len;
+				u_int8_t *str2 = new u_int8_t[len];
+				if (str2 == 0)
+					return ERR_RTP_OUTOFMEM;
+				memcpy(str2,s,len);
+				*destlen = len;
+				if (*dest)
+					delete [] (*dest);
+				*dest = str2;
+			}
+			return 0;
+		}
+	private:
+		u_int8_t *str;
+		size_t length;
+	};
+
+	SDESItem nonprivateitems[RTCP_SDES_NUMITEMS_NONPRIVATE];
+
+#ifdef RTP_SUPPORT_SDESPRIV
+	class SDESPrivateItem : public SDESItem
+	{
+	public:
+		SDESPrivateItem()						{ prefixlen = 0; prefix = 0; }
+		~SDESPrivateItem()						{ if (prefix) delete [] prefix; }
+		u_int8_t *GetPrefix(size_t *len) const				{ *len = prefixlen; return prefix; }
+		int SetPrefix(const u_int8_t *s,size_t len)			{ return SetString(&prefix,&prefixlen,s,len); }
+	private:
+		u_int8_t *prefix;
+		size_t prefixlen;
+	};
+
+	std::list<SDESPrivateItem *> privitems;
+	std::list<SDESPrivateItem *>::const_iterator curitem;
+#endif // RTP_SUPPORT_SDESPRIV
+};
+
+#endif // RTCPSDESINFO_H
+

Added: konference/src/rtp/jrtplib/rtcpsdespacket.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcpsdespacket.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpsdespacket.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,230 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtcpsdespacket.h"
+#ifdef RTPDEBUG
+	#include <iostream>
+#endif // RTPDEBUG
+
+#include "rtpdebug.h"
+
+RTCPSDESPacket::RTCPSDESPacket(u_int8_t *data,size_t datalength)
+	: RTCPPacket(SDES,data,datalength)
+{
+	knownformat = false;
+	currentchunk = 0;
+	itemoffset = 0;
+	curchunknum = 0;
+		
+	RTCPCommonHeader *hdr = (RTCPCommonHeader *)data;
+	size_t len = datalength;
+	
+	if (hdr->padding)
+	{
+		u_int8_t padcount = data[datalength-1];
+		if ((padcount & 0x03) != 0) // not a multiple of four! (see rfc 3550 p 37)
+			return;
+		if (((size_t)padcount) >= len)
+			return;
+		len -= (size_t)padcount;
+	}
+	
+	if (hdr->count == 0)
+	{
+		if (len != sizeof(RTCPCommonHeader))
+			return;
+	}
+	else
+	{
+		int ssrccount = (int)(hdr->count);
+		u_int8_t *chunk;
+		int chunkoffset;
+		
+		if (len < sizeof(RTCPCommonHeader))
+			return;
+		
+		len -= sizeof(RTCPCommonHeader);
+		chunk = data+sizeof(RTCPCommonHeader);
+		
+		while ((ssrccount > 0) && (len > 0))
+		{
+			chunkoffset = 0;
+			
+			if (len < (sizeof(u_int32_t)*2)) // chunk must contain at least a SSRC identifier
+				return;                  // and a (possibly empty) item
+			
+			len -= sizeof(u_int32_t);
+			chunkoffset = sizeof(u_int32_t);
+
+			bool done = false;
+			while (!done)
+			{
+				if (len < 1) // at least a zero byte (end of item list) should be there
+					return;
+				
+				RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(chunk+chunkoffset);
+				if (sdeshdr->id == 0) // end of item list
+				{
+					len--;
+					chunkoffset++;
+
+					size_t r = (chunkoffset&0x03);
+					if (r != 0)
+					{
+						size_t addoffset = 4-r;
+					
+						if (addoffset > len)
+							return;
+						len -= addoffset;
+						chunkoffset += addoffset;
+					}
+					done = true;
+				}
+				else
+				{
+					if (len < sizeof(RTCPSDESHeader))
+						return;
+					
+					len -= sizeof(RTCPSDESHeader);
+					chunkoffset += sizeof(RTCPSDESHeader);
+					
+					size_t itemlen = (size_t)(sdeshdr->length);
+					if (itemlen > len)
+						return;
+					
+					len -= itemlen;
+					chunkoffset += itemlen;
+				}		
+			}
+			
+			ssrccount--;
+			chunk += chunkoffset;
+		}
+
+		// check for remaining bytes
+		if (len > 0)
+			return;
+		if (ssrccount > 0)
+			return;
+	}
+
+	knownformat = true;
+}
+
+#ifdef RTPDEBUG
+void RTCPSDESPacket::Dump()
+{
+	RTCPPacket::Dump();
+	if (!IsKnownFormat())
+	{
+		std::cout << "    Unknown format" << std::endl;
+		return;
+	}
+	if (!GotoFirstChunk())
+	{
+		std::cout << "    No chunks present" << std::endl;
+		return;
+	}
+	
+	do
+	{
+		std::cout << "    SDES Chunk for SSRC:    " << GetChunkSSRC() << std::endl;
+		if (!GotoFirstItem())
+			std::cout << "        No items found" << std::endl; 
+		else
+		{
+			do
+			{
+				std::cout << "        ";
+				switch (GetItemType())
+				{
+				case None:
+					std::cout << "None    ";
+					break;
+				case CNAME:
+					std::cout << "CNAME   ";
+					break;
+				case NAME:
+					std::cout << "NAME    ";
+					break;
+				case EMAIL:
+					std::cout << "EMAIL   ";
+					break;
+				case PHONE:
+					std::cout << "PHONE   ";
+					break;
+				case LOC:
+					std::cout << "LOC     ";
+					break;
+				case TOOL:
+					std::cout << "TOOL    ";
+					break;
+				case NOTE:
+					std::cout << "NOTE    ";
+					break;
+				case PRIV:
+					std::cout << "PRIV    ";
+					break;
+				case Unknown:
+				default:
+					std::cout << "Unknown ";
+				}
+				
+				std::cout << "Length: " << GetItemLength() << std::endl;
+
+				if (GetItemType() != PRIV)
+				{
+					char str[1024];
+					memcpy(str,GetItemData(),GetItemLength());
+					str[GetItemLength()] = 0;
+					std::cout << "                Value:  " << str << std::endl;
+				}
+#ifdef RTP_SUPPORT_SDESPRIV
+				else // PRIV item
+				{
+					char str[1024];
+					memcpy(str,GetPRIVPrefixData(),GetPRIVPrefixLength());
+					str[GetPRIVPrefixLength()] = 0;
+					std::cout << "                Prefix: " << str << std::endl;
+					std::cout << "                Length: " << GetPRIVPrefixLength() << std::endl;
+					memcpy(str,GetPRIVValueData(),GetPRIVValueLength());
+					str[GetPRIVValueLength()] = 0;
+					std::cout << "                Value:  " << str << std::endl;
+					std::cout << "                Length: " << GetPRIVValueLength() << std::endl;
+				}
+#endif // RTP_SUPPORT_SDESPRIV
+			} while (GotoNextItem());
+		}
+	} while (GotoNextChunk());
+}
+#endif // RTPDEBUG
+

Added: konference/src/rtp/jrtplib/rtcpsdespacket.h
===================================================================
--- konference/src/rtp/jrtplib/rtcpsdespacket.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpsdespacket.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,314 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPSDESPACKET_H
+
+#define RTCPSDESPACKET_H
+
+#include "rtpconfig.h"
+#include "rtcppacket.h"
+#include "rtpstructs.h"
+#include "rtpdefines.h"
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include <netinet/in.h>
+#endif // WIN32
+
+class RTCPCompoundPacket;
+
+class RTCPSDESPacket : public RTCPPacket
+{
+public:
+	enum ItemType { None,CNAME,NAME,EMAIL,PHONE,LOC,TOOL,NOTE,PRIV,Unknown };
+	
+	RTCPSDESPacket(u_int8_t *data,size_t datalen);
+	~RTCPSDESPacket()							{ }
+
+	int GetChunkCount() const;
+	
+	bool GotoFirstChunk();
+	bool GotoNextChunk();
+
+	u_int32_t GetChunkSSRC() const;
+	bool GotoFirstItem();
+	bool GotoNextItem();
+
+	ItemType GetItemType() const;
+	size_t GetItemLength() const;
+	u_int8_t *GetItemData();
+
+#ifdef RTP_SUPPORT_SDESPRIV
+	size_t GetPRIVPrefixLength() const;
+	u_int8_t *GetPRIVPrefixData();
+	size_t GetPRIVValueLength() const;
+	u_int8_t *GetPRIVValueData();
+#endif // RTP_SUPPORT_SDESPRIV
+
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+private:
+	u_int8_t *currentchunk;
+	int curchunknum;
+	size_t itemoffset;
+};
+
+inline int RTCPSDESPacket::GetChunkCount() const
+{
+	if (!knownformat)
+		return 0;
+	RTCPCommonHeader *hdr = (RTCPCommonHeader *)data;
+	return ((int)hdr->count);
+}
+
+inline bool RTCPSDESPacket::GotoFirstChunk()
+{
+	if (GetChunkCount() == 0)
+	{
+		currentchunk = 0;
+		return false;
+	}
+	currentchunk = data+sizeof(RTCPCommonHeader);
+	curchunknum = 1;
+	itemoffset = sizeof(u_int32_t);
+	return true;
+}
+
+inline bool RTCPSDESPacket::GotoNextChunk()
+{
+	if (!knownformat)
+		return false;
+	if (currentchunk == 0)
+		return false;
+	if (curchunknum == GetChunkCount())
+		return false;
+	
+	size_t offset = sizeof(u_int32_t);
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(currentchunk+sizeof(u_int32_t));
+	
+	while (sdeshdr->id != 0)
+	{
+		offset += sizeof(RTCPSDESHeader);
+		offset += (size_t)(sdeshdr->length);
+		sdeshdr = (RTCPSDESHeader *)(currentchunk+offset);
+	}
+	offset++; // for the zero byte
+	if ((offset&0x03) != 0)
+		offset += (4-(offset&0x03));
+	currentchunk += offset;
+	curchunknum++;
+	itemoffset = sizeof(u_int32_t);
+	return true;
+}
+
+inline u_int32_t RTCPSDESPacket::GetChunkSSRC() const
+{
+	if (!knownformat)
+		return 0;
+	if (currentchunk == 0)
+		return 0;
+	u_int32_t *ssrc = (u_int32_t *)currentchunk;
+	return ntohl(*ssrc);
+}
+
+inline bool RTCPSDESPacket::GotoFirstItem()
+{
+	if (!knownformat)
+		return false;
+	if (currentchunk == 0)
+		return false;
+	itemoffset = sizeof(u_int32_t);
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(currentchunk+itemoffset);
+	if (sdeshdr->id == 0)
+		return false;
+	return true;
+}
+
+inline bool RTCPSDESPacket::GotoNextItem()
+{
+	if (!knownformat)
+		return false;
+	if (currentchunk == 0)
+		return false;
+	
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(currentchunk+itemoffset);
+	if (sdeshdr->id == 0)
+		return false;
+	
+	size_t offset = itemoffset;
+	offset += sizeof(RTCPSDESHeader);
+	offset += (size_t)(sdeshdr->length);
+	sdeshdr = (RTCPSDESHeader *)(currentchunk+offset);
+	if (sdeshdr->id == 0)
+		return false;
+	itemoffset = offset;
+	return true;
+}
+
+inline RTCPSDESPacket::ItemType RTCPSDESPacket::GetItemType() const
+{
+	if (!knownformat)
+		return None;
+	if (currentchunk == 0)
+		return None;
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(currentchunk+itemoffset);
+	switch (sdeshdr->id)
+	{
+	case 0:
+		return None;
+	case RTCP_SDES_ID_CNAME:
+		return CNAME;
+	case RTCP_SDES_ID_NAME:
+		return NAME;
+	case RTCP_SDES_ID_EMAIL:
+		return EMAIL;
+	case RTCP_SDES_ID_PHONE:
+		return PHONE;
+	case RTCP_SDES_ID_LOCATION:
+		return LOC;
+	case RTCP_SDES_ID_TOOL:
+		return TOOL;
+	case RTCP_SDES_ID_NOTE:
+		return NOTE;
+	case RTCP_SDES_ID_PRIVATE:
+		return PRIV;
+	default:
+		return Unknown;
+	}
+	return Unknown;
+}
+
+inline size_t RTCPSDESPacket::GetItemLength() const
+{
+	if (!knownformat)
+		return None;
+	if (currentchunk == 0)
+		return None;
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(currentchunk+itemoffset);
+	if (sdeshdr->id == 0)
+		return 0;
+	return (size_t)(sdeshdr->length);
+}
+
+inline u_int8_t *RTCPSDESPacket::GetItemData()
+{
+	if (!knownformat)
+		return 0;
+	if (currentchunk == 0)
+		return 0;
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(currentchunk+itemoffset);
+	if (sdeshdr->id == 0)
+		return 0;
+	return (currentchunk+itemoffset+sizeof(RTCPSDESHeader));
+}
+
+#ifdef RTP_SUPPORT_SDESPRIV
+inline size_t RTCPSDESPacket::GetPRIVPrefixLength() const
+{
+	if (!knownformat)
+		return 0;
+	if (currentchunk == 0)
+		return 0;
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(currentchunk+itemoffset);
+	if (sdeshdr->id != RTCP_SDES_ID_PRIVATE)
+		return 0;
+	if (sdeshdr->length == 0)
+		return 0;
+	u_int8_t *preflen = currentchunk+itemoffset+sizeof(RTCPSDESHeader);
+	size_t prefixlength = (size_t)(*preflen);
+	if (prefixlength > (size_t)((sdeshdr->length)-1))
+		return 0;
+	return prefixlength;
+}
+
+inline u_int8_t *RTCPSDESPacket::GetPRIVPrefixData()
+{
+	if (!knownformat)
+		return 0;
+	if (currentchunk == 0)
+		return 0;
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(currentchunk+itemoffset);
+	if (sdeshdr->id != RTCP_SDES_ID_PRIVATE)
+		return 0;
+	if (sdeshdr->length == 0)
+		return 0;
+	u_int8_t *preflen = currentchunk+itemoffset+sizeof(RTCPSDESHeader);
+	size_t prefixlength = (size_t)(*preflen);
+	if (prefixlength > (size_t)((sdeshdr->length)-1))
+		return 0;
+	if (prefixlength == 0)
+		return 0;
+	return (currentchunk+itemoffset+sizeof(RTCPSDESHeader)+1);
+}
+
+inline size_t RTCPSDESPacket::GetPRIVValueLength() const
+{
+	if (!knownformat)
+		return 0;
+	if (currentchunk == 0)
+		return 0;
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(currentchunk+itemoffset);
+	if (sdeshdr->id != RTCP_SDES_ID_PRIVATE)
+		return 0;
+	if (sdeshdr->length == 0)
+		return 0;
+	u_int8_t *preflen = currentchunk+itemoffset+sizeof(RTCPSDESHeader);
+	size_t prefixlength = (size_t)(*preflen);
+	if (prefixlength > (size_t)((sdeshdr->length)-1))
+		return 0;
+	return ((size_t)(sdeshdr->length))-prefixlength-1;
+}
+
+inline u_int8_t *RTCPSDESPacket::GetPRIVValueData()
+{
+	if (!knownformat)
+		return 0;
+	if (currentchunk == 0)
+		return 0;
+	RTCPSDESHeader *sdeshdr = (RTCPSDESHeader *)(currentchunk+itemoffset);
+	if (sdeshdr->id != RTCP_SDES_ID_PRIVATE)
+		return 0;
+	if (sdeshdr->length == 0)
+		return 0;
+	u_int8_t *preflen = currentchunk+itemoffset+sizeof(RTCPSDESHeader);
+	size_t prefixlength = (size_t)(*preflen);
+	if (prefixlength > (size_t)((sdeshdr->length)-1))
+		return 0;
+	size_t valuelen = ((size_t)(sdeshdr->length))-prefixlength-1;
+	if (valuelen == 0)
+		return 0;
+	return (currentchunk+itemoffset+sizeof(RTCPSDESHeader)+1+prefixlength);
+}
+
+#endif // RTP_SUPPORT_SDESPRIV
+
+#endif // RTCPSDESPACKET_H
+

Added: konference/src/rtp/jrtplib/rtcpsrpacket.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtcpsrpacket.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpsrpacket.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,101 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtcpsrpacket.h"
+#ifdef RTPDEBUG
+	#include <iostream>
+#endif // RTPDEBUG
+
+#include "rtpdebug.h"
+
+RTCPSRPacket::RTCPSRPacket(u_int8_t *data,size_t datalength)
+	: RTCPPacket(SR,data,datalength)
+{
+	knownformat = false;
+	
+	RTCPCommonHeader *hdr;
+	size_t len = datalength;
+	size_t expectedlength;
+	
+	hdr = (RTCPCommonHeader *)data;
+	if (hdr->padding)
+	{
+		u_int8_t padcount = data[datalength-1];
+		if ((padcount & 0x03) != 0) // not a multiple of four! (see rfc 3550 p 37)
+			return;
+		if (((size_t)padcount) >= len)
+			return;
+		len -= (size_t)padcount;
+	}
+
+	expectedlength = sizeof(RTCPCommonHeader)+sizeof(u_int32_t)+sizeof(RTCPSenderReport);
+	expectedlength += sizeof(RTCPReceiverReport)*((int)hdr->count);
+
+	if (expectedlength != len)
+		return;
+	
+	knownformat = true;
+}
+
+#ifdef RTPDEBUG
+void RTCPSRPacket::Dump()
+{
+	RTCPPacket::Dump();
+	if (!IsKnownFormat())
+		std::cout << "    Unknown format" << std::endl;
+	else
+	{
+		int num = GetReceptionReportCount();
+		int i;
+		RTPNTPTime t = GetNTPTimestamp();
+
+		std::cout << "    SSRC of sender:     " << GetSenderSSRC() << std::endl;
+		std::cout << "    Sender info:" << std::endl;
+		std::cout << "        NTP timestamp:  " << t.GetMSW() << ":" << t.GetLSW() << std::endl;
+		std::cout << "        RTP timestamp:  " << GetRTPTimestamp() << std::endl;
+		std::cout << "        Packet count:   " << GetSenderPacketCount() << std::endl;
+		std::cout << "        Octet count:    " << GetSenderOctetCount() << std::endl;
+		for (i = 0 ; i < num ; i++)
+		{
+			std::cout << "    Report block " << i << std::endl;
+			std::cout << "        SSRC:           " << GetSSRC(i) << std::endl;
+			std::cout << "        Fraction lost:  " << (u_int32_t)GetFractionLost(i) << std::endl;
+			std::cout << "        Packets lost:   " << GetLostPacketCount(i) << std::endl;
+			std::cout << "        Seq. nr.:       " << GetExtendedHighestSequenceNumber(i) << std::endl;
+			std::cout << "        Jitter:         " << GetJitter(i) << std::endl;
+			std::cout << "        LSR:            " << GetLSR(i) << std::endl;
+			std::cout << "        DLSR:           " << GetDLSR(i) << std::endl;
+		}
+	}	
+}
+#endif // RTPDEBUG
+

Added: konference/src/rtp/jrtplib/rtcpsrpacket.h
===================================================================
--- konference/src/rtp/jrtplib/rtcpsrpacket.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpsrpacket.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,197 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPSRPACKET_H
+
+#define RTCPSRPACKET_H
+
+#include "rtpconfig.h"
+#include "rtcppacket.h"
+#include "rtptimeutilities.h"
+#include "rtpstructs.h"
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include <netinet/in.h>
+#endif // WIN32
+
+class RTCPCompoundPacket;
+
+class RTCPSRPacket : public RTCPPacket
+{
+public:
+	RTCPSRPacket(u_int8_t *data,size_t datalength);
+	~RTCPSRPacket()								{ }
+
+	// Sender info
+	
+	u_int32_t GetSenderSSRC() const;
+	RTPNTPTime GetNTPTimestamp() const;
+	u_int32_t GetRTPTimestamp() const;
+	u_int32_t GetSenderPacketCount() const;
+	u_int32_t GetSenderOctetCount() const;
+
+	// Reportblocks
+	
+	int GetReceptionReportCount() const;
+	// Note: the validity of index is NOT checked!
+	u_int32_t GetSSRC(int index) const;
+	u_int8_t GetFractionLost(int index) const;
+	int32_t GetLostPacketCount(int index) const;
+	u_int32_t GetExtendedHighestSequenceNumber(int index) const;
+	u_int32_t GetJitter(int index) const;
+	u_int32_t GetLSR(int index) const;
+	u_int32_t GetDLSR(int index) const;
+
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+private:
+	RTCPReceiverReport *GotoReport(int index) const;
+};
+
+inline u_int32_t RTCPSRPacket::GetSenderSSRC() const
+{
+	if (!knownformat)
+		return 0;
+	
+	u_int32_t *ssrcptr = (u_int32_t *)(data+sizeof(RTCPCommonHeader));
+	return ntohl(*ssrcptr);
+}
+
+inline RTPNTPTime RTCPSRPacket::GetNTPTimestamp() const
+{
+	if (!knownformat)
+		return RTPNTPTime(0,0);
+
+	RTCPSenderReport *sr = (RTCPSenderReport *)(data+sizeof(RTCPCommonHeader)+sizeof(u_int32_t));
+	return RTPNTPTime(ntohl(sr->ntptime_msw),ntohl(sr->ntptime_lsw));
+}
+
+inline u_int32_t RTCPSRPacket::GetRTPTimestamp() const
+{
+	if (!knownformat)
+		return 0;
+	RTCPSenderReport *sr = (RTCPSenderReport *)(data+sizeof(RTCPCommonHeader)+sizeof(u_int32_t));
+	return ntohl(sr->rtptimestamp);
+}
+
+inline u_int32_t RTCPSRPacket::GetSenderPacketCount() const
+{
+	if (!knownformat)
+		return 0;
+	RTCPSenderReport *sr = (RTCPSenderReport *)(data+sizeof(RTCPCommonHeader)+sizeof(u_int32_t));
+	return ntohl(sr->packetcount);
+}
+	
+inline u_int32_t RTCPSRPacket::GetSenderOctetCount() const
+{
+	if (!knownformat)
+		return 0;
+	RTCPSenderReport *sr = (RTCPSenderReport *)(data+sizeof(RTCPCommonHeader)+sizeof(u_int32_t));
+	return ntohl(sr->octetcount);
+}
+
+inline int RTCPSRPacket::GetReceptionReportCount() const
+{
+	if (!knownformat)
+		return 0;
+	RTCPCommonHeader *hdr = (RTCPCommonHeader *)data;
+	return ((int)hdr->count);
+}
+
+inline RTCPReceiverReport *RTCPSRPacket::GotoReport(int index) const
+{
+	RTCPReceiverReport *r = (RTCPReceiverReport *)(data+sizeof(RTCPCommonHeader)+sizeof(u_int32_t)+sizeof(RTCPSenderReport)+index*sizeof(RTCPReceiverReport));
+	return r;
+}
+
+inline u_int32_t RTCPSRPacket::GetSSRC(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return ntohl(r->ssrc);
+}
+
+inline u_int8_t RTCPSRPacket::GetFractionLost(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return r->fractionlost;
+}
+
+inline int32_t RTCPSRPacket::GetLostPacketCount(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	u_int32_t count = ((u_int32_t)r->packetslost[2])|(((u_int32_t)r->packetslost[1])<<8)|(((u_int32_t)r->packetslost[0])<<16);
+	if ((count&0x00800000) != 0) // test for negative number
+		count |= 0xFF000000;
+	int32_t *count2 = (int32_t *)(&count);
+	return (*count2);
+}
+
+inline u_int32_t RTCPSRPacket::GetExtendedHighestSequenceNumber(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return ntohl(r->exthighseqnr);
+}
+
+inline u_int32_t RTCPSRPacket::GetJitter(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return ntohl(r->jitter);
+}
+
+inline u_int32_t RTCPSRPacket::GetLSR(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return ntohl(r->lsr);
+}
+
+inline u_int32_t RTCPSRPacket::GetDLSR(int index) const
+{
+	if (!knownformat)
+		return 0;
+	RTCPReceiverReport *r = GotoReport(index);
+	return ntohl(r->dlsr);
+}
+
+#endif // RTCPSRPACKET_H
+

Added: konference/src/rtp/jrtplib/rtcpunknownpacket.h
===================================================================
--- konference/src/rtp/jrtplib/rtcpunknownpacket.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtcpunknownpacket.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,55 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTCPUNKNOWNPACKET_H
+
+#define RTCPUNKNOWNPACKET_H
+
+#include "rtpconfig.h"
+#include "rtcppacket.h"
+
+class RTCPCompoundPacket;
+
+class RTCPUnknownPacket : public RTCPPacket
+{
+public:
+	RTCPUnknownPacket(u_int8_t *data,size_t datalen) :
+		RTCPPacket(Unknown,data,datalen)                                         
+	{
+	       // Since we don't expect a format, we'll trivially put knownformat = true
+	       knownformat = true;	
+	}
+        ~RTCPUnknownPacket()                                                                    { }
+};
+
+#endif // RTCPUNKNOWNPACKET_H
+

Added: konference/src/rtp/jrtplib/rtpaddress.h
===================================================================
--- konference/src/rtp/jrtplib/rtpaddress.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpaddress.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,64 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPADDRESS_H
+
+#define RTPADDRESS_H
+
+#include "rtpconfig.h"
+#include <string>
+
+class RTPAddress
+{
+public:
+	enum AddressType { IPv4Address, IPv6Address, UserDefinedAddress }; 
+	AddressType GetAddressType() const				{ return addresstype; }
+
+	virtual RTPAddress *CreateCopy() const = 0;
+
+	// note: these functions should be able to handle a NULL argument
+	virtual bool IsSameAddress(const RTPAddress *addr) const = 0;
+	virtual bool IsFromSameHost(const RTPAddress *addr) const  = 0;
+
+#ifdef RTPDEBUG
+	virtual std::string GetAddressString() const = 0;
+#endif // RTPDEBUG
+	
+	virtual ~RTPAddress()						{ }
+protected:
+	RTPAddress(const AddressType t) : addresstype(t) { } // only allow subclasses to be created
+private:
+	const AddressType addresstype;
+};
+
+#endif // RTPADDRESS_H
+

Added: konference/src/rtp/jrtplib/rtpcollisionlist.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpcollisionlist.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpcollisionlist.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,124 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtpcollisionlist.h"
+#include "rtperrors.h"
+#ifdef RTPDEBUG
+	#include <iostream>
+#endif // RTPDEBUG
+
+#include "rtpdebug.h"
+
+RTPCollisionList::RTPCollisionList()
+{
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	timeinit.Dummy();
+#endif // WIN32 || _WIN32_WCE
+}
+
+void RTPCollisionList::Clear()
+{
+	std::list<AddressAndTime>::iterator it;
+	
+	for (it = addresslist.begin() ; it != addresslist.end() ; it++)
+		delete (*it).addr;
+	addresslist.clear();
+}
+
+int RTPCollisionList::UpdateAddress(const RTPAddress *addr,const RTPTime &receivetime,bool *created)
+{
+	if (addr == 0)
+		return ERR_RTP_COLLISIONLIST_BADADDRESS;
+	
+	std::list<AddressAndTime>::iterator it;
+	
+	for (it = addresslist.begin() ; it != addresslist.end() ; it++)
+	{
+		if (((*it).addr)->IsSameAddress(addr))
+		{
+			(*it).recvtime = receivetime;
+			*created = false;
+			return 0;
+		}
+	}
+
+	RTPAddress *newaddr = addr->CreateCopy();
+	if (newaddr == 0)
+		return ERR_RTP_OUTOFMEM;
+	
+	addresslist.push_back(AddressAndTime(newaddr,receivetime));
+	*created = true;
+	return 0;
+}
+
+bool RTPCollisionList::HasAddress(const RTPAddress *addr) const
+{
+	std::list<AddressAndTime>::const_iterator it;
+	
+	for (it = addresslist.begin() ; it != addresslist.end() ; it++)
+	{
+		if (((*it).addr)->IsSameAddress(addr))
+			return true;
+	}
+
+	return false;	
+}
+
+void RTPCollisionList::Timeout(const RTPTime &currenttime,const RTPTime &timeoutdelay)
+{
+	std::list<AddressAndTime>::iterator it;
+	RTPTime checktime = currenttime;
+	checktime -= timeoutdelay;
+	
+	it = addresslist.begin();
+	while(it != addresslist.end())
+	{
+		if ((*it).recvtime < checktime) // timeout
+		{
+			delete (*it).addr;
+			it = addresslist.erase(it);	
+		}
+		else
+			it++;
+	}
+}
+
+#ifdef RTPDEBUG
+void RTPCollisionList::Dump()
+{
+	std::list<AddressAndTime>::const_iterator it;
+	
+	for (it = addresslist.begin() ; it != addresslist.end() ; it++)
+		std::cout << "Address: " << ((*it).addr)->GetAddressString() << "\tTime: " << (*it).recvtime.GetSeconds() << std::endl;
+}
+#endif // RTPDEBUG
+

Added: konference/src/rtp/jrtplib/rtpcollisionlist.h
===================================================================
--- konference/src/rtp/jrtplib/rtpcollisionlist.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpcollisionlist.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,70 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPCOLLISIONLIST_H
+
+#define RTPCOLLISIONLIST_H
+
+#include "rtpconfig.h"
+#include "rtpaddress.h"
+#include "rtptimeutilities.h"
+#include <list>
+
+class RTPAddress;
+
+class RTPCollisionList
+{
+public:
+	RTPCollisionList();
+	~RTPCollisionList()								{ Clear(); }
+	void Clear();
+	int UpdateAddress(const RTPAddress *addr,const RTPTime &receivetime,bool *created);
+	bool HasAddress(const RTPAddress *addr) const;
+	void Timeout(const RTPTime &currenttime,const RTPTime &timeoutdelay);
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+private:
+	class AddressAndTime
+	{
+	public:
+		AddressAndTime(RTPAddress *a,const RTPTime &t) : addr(a),recvtime(t) { }
+
+		RTPAddress *addr;
+		RTPTime recvtime;
+	};
+
+	std::list<AddressAndTime> addresslist;
+};
+
+#endif // RTPCOLLISIONLIST_H
+

Added: konference/src/rtp/jrtplib/rtpconfig.h
===================================================================
--- konference/src/rtp/jrtplib/rtpconfig.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpconfig.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,45 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPCONFIG_H
+
+#define RTPCONFIG_H
+
+#if (defined(WIN32) || defined(_WIN32_WCE))
+#include "rtpconfig_win.h"
+#else
+#include "rtpconfig_unix.h"
+#endif // WIN32
+
+// #define RTPDEBUG
+
+#endif // RTPCONFIG_H

Added: konference/src/rtp/jrtplib/rtpconfig_unix.h
===================================================================
--- konference/src/rtp/jrtplib/rtpconfig_unix.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpconfig_unix.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,72 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPCONFIG_UNIX_H
+
+#define RTPCONFIG_UNIX_H
+
+// Don't have <sys/filio.h>
+
+// Don't have <sys/sockio.h>
+
+// Little endian system
+
+#define RTP_SOCKLENTYPE_UINT
+
+// No sa_len member in struct sockaddr
+
+#define RTP_SUPPORT_IPV4MULTICAST
+
+// No support for jthread
+
+#define RTP_SUPPORT_SDESPRIV
+
+#define RTP_SUPPORT_INLINETEMPLATEPARAM
+
+#define RTP_SUPPORT_PROBATION
+
+#define RTP_SUPPORT_GNUDRAND
+
+// Not using rand_r
+
+#define RTP_SUPPORT_GETLOGINR
+
+// No IPv6 support
+
+// No IPv6 multicasting support
+
+#define RTP_SUPPORT_IFADDRS
+
+// No GStreamer support
+
+#endif // RTPCONFIG_UNIX_H
+

Added: konference/src/rtp/jrtplib/rtpconfig_unix.h.in
===================================================================
--- konference/src/rtp/jrtplib/rtpconfig_unix.h.in	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpconfig_unix.h.in	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,72 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPCONFIG_UNIX_H
+
+#define RTPCONFIG_UNIX_H
+
+ at RTP_FILIO@
+
+ at RTP_SOCKIO@
+
+ at RTP_ENDIAN@
+
+ at RTP_SOCKLENTYPE_UINT@
+
+ at RTP_HAVE_SOCKADDR_LEN@
+
+ at RTP_SUPPORT_IPV4MULTICAST@
+
+ at RTP_SUPPORT_THREAD@
+
+ at RTP_SUPPORT_SDESPRIV@
+
+ at RTP_SUPPORT_INLINETEMPLATEPARAM@
+
+ at RTP_SUPPORT_PROBATION@
+
+ at RTP_SUPPORT_GNUDRAND@
+
+ at RTP_SUPPORT_RANDR@
+
+ at RTP_SUPPORT_GETLOGINR@
+
+ at RTP_SUPPORT_IPV6@
+
+ at RTP_SUPPORT_IPV6MULTICAST@
+
+ at RTP_SUPPORT_IFADDRS@
+
+ at RTP_SUPPORT_GST@
+
+#endif // RTPCONFIG_UNIX_H
+

Added: konference/src/rtp/jrtplib/rtpconfig_win.h
===================================================================
--- konference/src/rtp/jrtplib/rtpconfig_win.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpconfig_win.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,50 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPCONFIG_WIN_H
+
+#define RTPCONFIG_WIN_H
+
+#define RTP_SUPPORT_IPV4MULTICAST
+
+#define RTP_SUPPORT_THREAD
+
+#define RTP_SUPPORT_PROBATION
+
+#define RTP_SUPPORT_SDESPRIV
+
+//#define RTP_SUPPORT_IPV6
+
+//#define RTP_SUPPORT_IPV6MULTICAST
+
+#endif // RTPCONFIG_WIN_H
+

Added: konference/src/rtp/jrtplib/rtpdebug.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpdebug.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpdebug.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,177 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtpconfig.h"
+
+#ifdef RTPDEBUG
+
+#include "rtptypes.h"
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+struct MemoryInfo
+{
+	void *ptr;
+	size_t size;
+	int lineno;
+	char *filename;
+	
+	MemoryInfo *next;
+};
+
+class MemoryTracker
+{
+public:
+	MemoryTracker() { firstblock = NULL; }
+	~MemoryTracker()
+	{
+		MemoryInfo *tmp;
+		int count = 0;
+		
+		printf("Checking for memory leaks...\n");fflush(stdout);
+		while(firstblock)
+		{
+			count++;
+			printf("Unfreed block %p of %d bytes (file '%s', line %d)\n",firstblock->ptr,(int)firstblock->size,firstblock->filename,firstblock->lineno);;
+			
+			tmp = firstblock->next;
+			
+			free(firstblock->ptr);
+			if (firstblock->filename)
+				free(firstblock->filename);
+			free(firstblock);
+			firstblock = tmp;
+		}
+		if (count == 0)
+			printf("No memory leaks found\n");
+		else
+			printf("%d leaks found\n",count);
+	}
+	
+	MemoryInfo *firstblock;	
+};
+
+static MemoryTracker memtrack;
+
+void *donew(size_t s,char filename[],int line)
+{	
+	void *p;
+	MemoryInfo *meminf;
+	
+	p = malloc(s);
+	meminf = (MemoryInfo *)malloc(sizeof(MemoryInfo));
+	
+	meminf->ptr = p;
+	meminf->size = s;
+	meminf->lineno = line;
+	meminf->filename = (char *)malloc(strlen(filename)+1);
+	strcpy(meminf->filename,filename);
+	meminf->next = memtrack.firstblock;
+	
+	memtrack.firstblock = meminf;
+	
+	return p;
+}
+
+void dodelete(void *p)
+{
+	MemoryInfo *tmp,*tmpprev;
+	bool found;
+	
+	tmpprev = NULL;
+	tmp = memtrack.firstblock;
+	found = false;
+	while (tmp != NULL && !found)
+	{
+		if (tmp->ptr == p)
+			found = true;
+		else
+		{
+			tmpprev = tmp;
+			tmp = tmp->next;
+		}
+	}
+	if (!found)
+	{
+		printf("Couldn't free block %p!\n",p);
+		fflush(stdout);
+	}
+	else
+	{
+		MemoryInfo *n;
+		
+		fflush(stdout);
+		n = tmp->next;
+		free(tmp->ptr);
+		if (tmp->filename)
+			free(tmp->filename);
+		free(tmp);
+		
+		if (tmpprev)
+			tmpprev->next = n;
+		else
+			memtrack.firstblock = n;
+	}
+}
+
+void *operator new(size_t s)
+{
+	return donew(s,"UNKNOWN FILE",0);
+}
+
+void *operator new[](size_t s)
+{
+	return donew(s,"UNKNOWN FILE",0);
+}
+
+void *operator new(size_t s,char filename[],int line)
+{
+	return donew(s,filename,line);
+}
+
+void *operator new[](size_t s,char filename[],int line)
+{
+	return donew(s,filename,line);
+}
+
+void operator delete(void *p)
+{
+	dodelete(p);
+}
+
+void operator delete[](void *p)
+{
+	dodelete(p);
+}
+
+#endif // RTPDEBUG

Added: konference/src/rtp/jrtplib/rtpdebug.h
===================================================================
--- konference/src/rtp/jrtplib/rtpdebug.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpdebug.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,52 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPDEBUG_H
+
+#define RTPDEBUG_H
+
+#include "rtpconfig.h"
+
+#ifdef RTPDEBUG
+	#include "rtptypes.h"
+
+	void *operator new(size_t s,char filename[],int line);
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	void *operator new[](size_t s,char filename[],int line);
+	#define new new (__FILE__,__LINE__)
+#else
+	#define new new (__FILE__,__LINE__)
+#endif // WIN32
+#endif // RTPDEBUG
+
+#endif // RTPDEBUG_H
+

Added: konference/src/rtp/jrtplib/rtpdefines.h
===================================================================
--- konference/src/rtp/jrtplib/rtpdefines.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpdefines.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,75 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPDEFINES_H
+
+#define RTPDEFINES_H
+
+#define RTP_VERSION							2
+#define RTP_MAXCSRCS							15
+#define RTP_MINPACKETSIZE						600
+#define RTP_DEFAULTPACKETSIZE						1400
+#define RTP_PROBATIONCOUNT						2
+#define RTP_MAXPRIVITEMS						256
+#define RTP_SENDERTIMEOUTMULTIPLIER					2
+#define RTP_BYETIMEOUTMULTIPLIER					1
+#define RTP_MEMBERTIMEOUTMULTIPLIER					5
+#define RTP_COLLISIONTIMEOUTMULTIPLIER					10
+#define RTP_NOTETTIMEOUTMULTIPLIER					25
+#define RTP_DEFAULTSESSIONBANDWIDTH					10000.0
+
+#define RTP_RTCPTYPE_SR							200
+#define RTP_RTCPTYPE_RR							201
+#define RTP_RTCPTYPE_SDES						202
+#define RTP_RTCPTYPE_BYE						203
+#define RTP_RTCPTYPE_APP						204
+
+#define RTCP_SDES_ID_CNAME						1
+#define RTCP_SDES_ID_NAME						2
+#define RTCP_SDES_ID_EMAIL						3
+#define RTCP_SDES_ID_PHONE						4
+#define RTCP_SDES_ID_LOCATION						5
+#define RTCP_SDES_ID_TOOL						6
+#define RTCP_SDES_ID_NOTE						7
+#define RTCP_SDES_ID_PRIVATE						8
+#define RTCP_SDES_NUMITEMS_NONPRIVATE					7
+#define RTCP_SDES_MAXITEMLENGTH						255
+
+#define RTCP_BYE_MAXREASONLENGTH					255
+#define RTCP_DEFAULTMININTERVAL						5.0	
+#define RTCP_DEFAULTBANDWIDTHFRACTION					0.05
+#define RTCP_DEFAULTSENDERFRACTION					0.25
+#define RTCP_DEFAULTHALFATSTARTUP					true
+#define RTCP_DEFAULTIMMEDIATEBYE					true
+#define RTCP_DEFAULTSRBYE						true
+
+#endif // RTPDEFINES_H

Added: konference/src/rtp/jrtplib/rtperrors.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtperrors.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtperrors.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,223 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtperrors.h"
+
+#include "rtpdebug.h"
+
+struct RTPErrorInfo
+{
+	int code;
+	char *description;
+};
+
+static RTPErrorInfo ErrorDescriptions[]=
+{
+	{ ERR_RTP_OUTOFMEM,"Out of memory" },
+	{ ERR_RTP_NOTHREADSUPPORT, "No JThread support was compiled in"},
+	{ ERR_RTP_COLLISIONLIST_BADADDRESS, "Passed invalid address (null) to collision list"},
+	{ ERR_RTP_HASHTABLE_ELEMENTALREADYEXISTS, "Element already exists in hash table"},
+	{ ERR_RTP_HASHTABLE_ELEMENTNOTFOUND, "Element not found in hash table"},
+	{ ERR_RTP_HASHTABLE_FUNCTIONRETURNEDINVALIDHASHINDEX, "Function returned an illegal hash index"},
+	{ ERR_RTP_HASHTABLE_NOCURRENTELEMENT, "No current element selected in hash table"},
+	{ ERR_RTP_KEYHASHTABLE_FUNCTIONRETURNEDINVALIDHASHINDEX, "Function returned an illegal hash index"},
+	{ ERR_RTP_KEYHASHTABLE_KEYALREADYEXISTS, "Key value already exists in key hash table"},
+	{ ERR_RTP_KEYHASHTABLE_KEYNOTFOUND, "Key value not found in key hash table"},
+	{ ERR_RTP_KEYHASHTABLE_NOCURRENTELEMENT, "No current element selected in key hash table"},
+	{ ERR_RTP_PACKBUILD_ALREADYINIT, "RTP packet builder is already initialized"},
+	{ ERR_RTP_PACKBUILD_CSRCALREADYINLIST, "The specified CSRC is already in the RTP packet builder's CSRC list"},
+	{ ERR_RTP_PACKBUILD_CSRCLISTFULL, "The RTP packet builder's CSRC list already contains 15 entries"},
+	{ ERR_RTP_PACKBUILD_CSRCNOTINLIST, "The specified CSRC was not found in the RTP packet builder's CSRC list"},
+	{ ERR_RTP_PACKBUILD_DEFAULTMARKNOTSET, "The RTP packet builder's default mark flag is not set"},
+	{ ERR_RTP_PACKBUILD_DEFAULTPAYLOADTYPENOTSET, "The RTP packet builder's default payload type is not set"},
+	{ ERR_RTP_PACKBUILD_DEFAULTTSINCNOTSET, "The RTP packet builder's default timestamp increment is not set"},
+	{ ERR_RTP_PACKBUILD_INVALIDMAXPACKETSIZE, "The specified maximum packet size for the RTP packet builder is invalid"},
+	{ ERR_RTP_PACKBUILD_NOTINIT, "The RTP packet builder is not initialized"},
+	{ ERR_RTP_PACKET_BADPAYLOADTYPE, "Invalid payload type"},
+	{ ERR_RTP_PACKET_DATAEXCEEDSMAXSIZE, "Tried to create an RTP packet which whould exceed the specified maximum packet size"},
+	{ ERR_RTP_PACKET_EXTERNALBUFFERNULL, "Illegal value (null) passed as external buffer for the RTP packet"},
+	{ ERR_RTP_PACKET_ILLEGALBUFFERSIZE, "Illegal buffer size specified for the RTP packet"},
+	{ ERR_RTP_PACKET_INVALIDPACKET, "Invalid RTP packet format"},
+	{ ERR_RTP_PACKET_TOOMANYCSRCS, "More than 15 CSRCs specified for the RTP packet"},
+	{ ERR_RTP_POLLTHREAD_ALREADYRUNNING, "Poll thread is already running"},
+	{ ERR_RTP_POLLTHREAD_CANTINITMUTEX, "Can't initialize a mutex for the poll thread"},
+	{ ERR_RTP_POLLTHREAD_CANTSTARTTHREAD, "Can't start the poll thread"},
+	{ ERR_RTP_RTCPCOMPOUND_INVALIDPACKET, "Invalid RTCP compound packet format"},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYBUILDING, "Already building this RTCP compound packet"},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYBUILT, "This RTCP compound packet is already built"},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYGOTREPORT, "There's already a SR or RR in this RTCP compound packet"},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_APPDATALENTOOBIG, "The specified APP data length for the RTCP compound packet is too big"},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_BUFFERSIZETOOSMALL, "The specified buffer size for the RTCP comound packet is too small"},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_ILLEGALAPPDATALENGTH, "The APP data length must be a multiple of four"},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_ILLEGALSUBTYPE, "The APP packet subtype must be smaller than 32"},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_INVALIDITEMTYPE, "Invalid SDES item type specified for the RTCP compound packet"},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_MAXPACKETSIZETOOSMALL, "The specified maximum packet size for the RTCP compound packet is too small"},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_NOCURRENTSOURCE, "Tried to add an SDES item to the RTCP compound packet when no SSRC was present"},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_NOREPORTPRESENT, "An RTCP compound packet must contain a SR or RR"},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING, "The RTCP compound packet builder is not initialized"},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT, "Adding this data would exceed the specified maximum RTCP compound packet size"},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_REPORTNOTSTARTED, "Tried to add a report block to the RTCP compound packet when no SR or RR was started"},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_TOOMANYSSRCS, "Only 31 SSRCs will fit into a BYE packet for the RTCP compound packet"},
+	{ ERR_RTP_RTCPCOMPPACKBUILDER_TOTALITEMLENGTHTOOBIG, "The total data for the SDES PRIV item exceeds the maximum size (255 bytes) of an SDES item"},
+	{ ERR_RTP_RTCPPACKETBUILDER_ALREADYINIT, "The RTCP packet builder is already initialized"},
+	{ ERR_RTP_RTCPPACKETBUILDER_ILLEGALMAXPACKSIZE, "The specified maximum packet size for the RTCP packet builder is too small"},
+	{ ERR_RTP_RTCPPACKETBUILDER_ILLEGALTIMESTAMPUNIT, "Speficied an illegal timestamp unit for the the RTCP packet builder"},
+	{ ERR_RTP_RTCPPACKETBUILDER_NOTINIT, "The RTCP packet builder was not initialized"},
+	{ ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON, "The RTCP compound packet filled sooner than expected"},
+	{ ERR_RTP_SCHEDPARAMS_BADFRACTION, "Illegal sender bandwidth fraction specified"},
+	{ ERR_RTP_SCHEDPARAMS_BADMINIMUMINTERVAL, "The minimum RTCP interval specified for the scheduler is too small"},
+	{ ERR_RTP_SCHEDPARAMS_INVALIDBANDWIDTH, "Invalid RTCP bandwidth specified for the RTCP scheduler"},
+	{ ERR_RTP_SDES_LENGTHTOOBIG, "Specified size for the SDES item exceeds 255 bytes"},
+	{ ERR_RTP_SDES_PREFIXNOTFOUND, "The specified SDES PRIV prefix was not found"},
+	{ ERR_RTP_SESSION_ALREADYCREATED, "The session is already created"},
+	{ ERR_RTP_SESSION_CANTGETLOGINNAME, "Can't retrieve login name"},
+	{ ERR_RTP_SESSION_CANTINITMUTEX, "A mutex for the RTP session couldn't be initialized"},
+	{ ERR_RTP_SESSION_MAXPACKETSIZETOOSMALL, "The maximum packet size specified for the RTP session is too small"},
+	{ ERR_RTP_SESSION_NOTCREATED, "The RTP session was not created"},
+	{ ERR_RTP_SESSION_UNSUPPORTEDTRANSMISSIONPROTOCOL, "The requested transmission protocol for the RTP session is not supported"},
+	{ ERR_RTP_SESSION_USINGPOLLTHREAD, "This function is not available when using the RTP poll thread feature"},
+	{ ERR_RTP_SESSION_USERDEFINEDTRANSMITTERNULL, "A user-defined transmitter was requested but the supplied transmitter component is NULL"},
+	{ ERR_RTP_SOURCES_ALREADYHAVEOWNSSRC, "Only one source can be marked as own SSRC in the source table"},
+	{ ERR_RTP_SOURCES_DONTHAVEOWNSSRC, "No source was marked as own SSRC in the source table"},
+	{ ERR_RTP_SOURCES_ILLEGALSDESTYPE, "Illegal SDES type specified for processing into the source table"},
+	{ ERR_RTP_SOURCES_SSRCEXISTS, "Can't create own SSRC because this SSRC identifier is already in the source table"},
+	{ ERR_RTP_UDPV4TRANS_ALREADYCREATED, "The transmitter was already created"},
+	{ ERR_RTP_UDPV4TRANS_ALREADYINIT, "The transmitter was already initialize"},
+	{ ERR_RTP_UDPV4TRANS_ALREADYWAITING, "The transmitter is already waiting for incoming data"},
+	{ ERR_RTP_UDPV4TRANS_CANTBINDRTCPSOCKET, "The 'bind' call for the RTCP socket failed"},
+	{ ERR_RTP_UDPV4TRANS_CANTBINDRTPSOCKET, "The 'bind' call for the RTP socket failed"},
+	{ ERR_RTP_UDPV4TRANS_CANTCALCULATELOCALIP, "The local IP addresses could not be determined"},
+	{ ERR_RTP_UDPV4TRANS_CANTCREATEABORTDESCRIPTORS, "Couldn't create the sockets used to abort waiting for incoming data"},
+	{ ERR_RTP_UDPV4TRANS_CANTCREATEPIPE, "Couldn't create the pipe used to abort waiting for incoming data"},
+	{ ERR_RTP_UDPV4TRANS_CANTCREATESOCKET, "Couldn't create the RTP or RTCP socket"},
+	{ ERR_RTP_UDPV4TRANS_CANTINITMUTEX, "Failed to initialize a mutex used by the transmitter"},
+	{ ERR_RTP_UDPV4TRANS_CANTSETRTCPRECEIVEBUF, "Couldn't set the receive buffer size for the RTCP socket"},
+	{ ERR_RTP_UDPV4TRANS_CANTSETRTCPTRANSMITBUF, "Couldn't set the transmission buffer size for the RTCP socket"},
+	{ ERR_RTP_UDPV4TRANS_CANTSETRTPRECEIVEBUF, "Couldn't set the receive buffer size for the RTP socket"},
+	{ ERR_RTP_UDPV4TRANS_CANTSETRTPTRANSMITBUF, "Couldn't set the transmission buffer size for the RTP socket"},
+	{ ERR_RTP_UDPV4TRANS_COULDNTJOINMULTICASTGROUP, "Unable to join the specified multicast group"},
+	{ ERR_RTP_UDPV4TRANS_DIFFERENTRECEIVEMODE, "The function called doens't match the current receive mode"},
+	{ ERR_RTP_UDPV4TRANS_ERRORINSELECT, "Error in the transmitter's 'select' call"},
+	{ ERR_RTP_UDPV4TRANS_ILLEGALPARAMETERS, "Illegal parameters type passed to the transmitter"},
+	{ ERR_RTP_UDPV4TRANS_INVALIDADDRESSTYPE, "Specified address type isn't compatible with this transmitter"},
+	{ ERR_RTP_UDPV4TRANS_NOLOCALIPS, "Couldn't determine the local host name since the local IP list is empty"},
+	{ ERR_RTP_UDPV4TRANS_NOMULTICASTSUPPORT, "Multicast support is not available"},
+	{ ERR_RTP_UDPV4TRANS_NOSUCHENTRY, "Specified entry could not be found"},
+	{ ERR_RTP_UDPV4TRANS_NOTAMULTICASTADDRESS, "The specified address is not a multicast address"},
+	{ ERR_RTP_UDPV4TRANS_NOTCREATED, "The 'Create' call for this transmitter has not been called"},
+	{ ERR_RTP_UDPV4TRANS_NOTINIT, "The 'Init' call for this transmitter has not been called"},
+	{ ERR_RTP_UDPV4TRANS_NOTWAITING, "The transmitter is not waiting for incoming data"},
+	{ ERR_RTP_UDPV4TRANS_PORTBASENOTEVEN, "The specified port base is not an even number"},
+	{ ERR_RTP_UDPV4TRANS_SPECIFIEDSIZETOOBIG, "The maximum packet size is too big for this transmitter"},
+	{ ERR_RTP_UDPV6TRANS_ALREADYCREATED, "The transmitter was already created"},
+	{ ERR_RTP_UDPV6TRANS_ALREADYINIT, "The transmitter was already initialize"},
+	{ ERR_RTP_UDPV6TRANS_ALREADYWAITING, "The transmitter is already waiting for incoming data"},
+	{ ERR_RTP_UDPV6TRANS_CANTBINDRTCPSOCKET, "The 'bind' call for the RTCP socket failed"},
+	{ ERR_RTP_UDPV6TRANS_CANTBINDRTPSOCKET, "The 'bind' call for the RTP socket failed"},
+	{ ERR_RTP_UDPV6TRANS_CANTCALCULATELOCALIP, "The local IP addresses could not be determined"},
+	{ ERR_RTP_UDPV6TRANS_CANTCREATEABORTDESCRIPTORS, "Couldn't create the sockets used to abort waiting for incoming data"},
+	{ ERR_RTP_UDPV6TRANS_CANTCREATEPIPE, "Couldn't create the pipe used to abort waiting for incoming data"},
+	{ ERR_RTP_UDPV6TRANS_CANTCREATESOCKET, "Couldn't create the RTP or RTCP socket"},
+	{ ERR_RTP_UDPV6TRANS_CANTINITMUTEX, "Failed to initialize a mutex used by the transmitter"},
+	{ ERR_RTP_UDPV6TRANS_CANTSETRTCPRECEIVEBUF, "Couldn't set the receive buffer size for the RTCP socket"},
+	{ ERR_RTP_UDPV6TRANS_CANTSETRTCPTRANSMITBUF, "Couldn't set the transmission buffer size for the RTCP socket"},
+	{ ERR_RTP_UDPV6TRANS_CANTSETRTPRECEIVEBUF, "Couldn't set the receive buffer size for the RTP socket"},
+	{ ERR_RTP_UDPV6TRANS_CANTSETRTPTRANSMITBUF, "Couldn't set the transmission buffer size for the RTP socket"},
+	{ ERR_RTP_UDPV6TRANS_COULDNTJOINMULTICASTGROUP, "Unable to join the specified multicast group"},
+	{ ERR_RTP_UDPV6TRANS_DIFFERENTRECEIVEMODE, "The function called doens't match the current receive mode"},
+	{ ERR_RTP_UDPV6TRANS_ERRORINSELECT, "Error in the transmitter's 'select' call"},
+	{ ERR_RTP_UDPV6TRANS_ILLEGALPARAMETERS, "Illegal parameters type passed to the transmitter"},
+	{ ERR_RTP_UDPV6TRANS_INVALIDADDRESSTYPE, "Specified address type isn't compatible with this transmitter"},
+	{ ERR_RTP_UDPV6TRANS_NOLOCALIPS, "Couldn't determine the local host name since the local IP list is empty"},
+	{ ERR_RTP_UDPV6TRANS_NOMULTICASTSUPPORT, "Multicast support is not available"},
+	{ ERR_RTP_UDPV6TRANS_NOSUCHENTRY, "Specified entry could not be found"},
+	{ ERR_RTP_UDPV6TRANS_NOTAMULTICASTADDRESS, "The specified address is not a multicast address"},
+	{ ERR_RTP_UDPV6TRANS_NOTCREATED, "The 'Create' call for this transmitter has not been called"},
+	{ ERR_RTP_UDPV6TRANS_NOTINIT, "The 'Init' call for this transmitter has not been called"},
+	{ ERR_RTP_UDPV6TRANS_NOTWAITING, "The transmitter is not waiting for incoming data"},
+	{ ERR_RTP_UDPV6TRANS_PORTBASENOTEVEN, "The specified port base is not an even number"},
+	{ ERR_RTP_UDPV6TRANS_SPECIFIEDSIZETOOBIG, "The maximum packet size is too big for this transmitter"},
+	{ ERR_RTP_TRANS_BUFFERLENGTHTOOSMALL,"The hostname is larger than the specified buffer size"},
+	{ ERR_RTP_SDES_MAXPRIVITEMS,"The maximum number of SDES private item prefixes was reached"},
+	{ ERR_RTP_INTERNALSOURCEDATA_INVALIDPROBATIONTYPE,"An invalid probation type was specified"},
+	{ ERR_RTP_GSTV4TRANS_ALREADYCREATED, "The transmitter was already created"},
+	{ ERR_RTP_GSTV4TRANS_ALREADYINIT, "The transmitter was already initialize"},
+	{ ERR_RTP_GSTV4TRANS_ALREADYWAITING, "The transmitter is already waiting for incoming data"},
+	{ ERR_RTP_GSTV4TRANS_CANTBINDRTCPSOCKET, "The 'bind' call for the RTCP socket failed"},
+	{ ERR_RTP_GSTV4TRANS_CANTBINDRTPSOCKET, "The 'bind' call for the RTP socket failed"},
+	{ ERR_RTP_GSTV4TRANS_CANTCALCULATELOCALIP, "The local IP addresses could not be determined"},
+	{ ERR_RTP_GSTV4TRANS_CANTCREATEABORTDESCRIPTORS, "Couldn't create the sockets used to abort waiting for incoming data"},
+	{ ERR_RTP_GSTV4TRANS_CANTCREATEPIPE, "Couldn't create the pipe used to abort waiting for incoming data"},
+	{ ERR_RTP_GSTV4TRANS_CANTCREATESOCKET, "Couldn't create the RTP or RTCP socket"},
+	{ ERR_RTP_GSTV4TRANS_CANTINITMUTEX, "Failed to initialize a mutex used by the transmitter"},
+	{ ERR_RTP_GSTV4TRANS_CANTSETRTCPRECEIVEBUF, "Couldn't set the receive buffer size for the RTCP socket"},
+	{ ERR_RTP_GSTV4TRANS_CANTSETRTCPTRANSMITBUF, "Couldn't set the transmission buffer size for the RTCP socket"},
+	{ ERR_RTP_GSTV4TRANS_CANTSETRTPRECEIVEBUF, "Couldn't set the receive buffer size for the RTP socket"},
+	{ ERR_RTP_GSTV4TRANS_CANTSETRTPTRANSMITBUF, "Couldn't set the transmission buffer size for the RTP socket"},
+	{ ERR_RTP_GSTV4TRANS_COULDNTJOINMULTICASTGROUP, "Unable to join the specified multicast group"},
+	{ ERR_RTP_GSTV4TRANS_DIFFERENTRECEIVEMODE, "The function called doens't match the current receive mode"},
+	{ ERR_RTP_GSTV4TRANS_ERRORINSELECT, "Error in the transmitter's 'select' call"},
+	{ ERR_RTP_GSTV4TRANS_ILLEGALPARAMETERS, "Illegal parameters type passed to the transmitter"},
+	{ ERR_RTP_GSTV4TRANS_INVALIDADDRESSTYPE, "Specified address type isn't compatible with this transmitter"},
+	{ ERR_RTP_GSTV4TRANS_NOLOCALIPS, "Couldn't determine the local host name since the local IP list is empty"},
+	{ ERR_RTP_GSTV4TRANS_NOMULTICASTSUPPORT, "Multicast support is not available"},
+	{ ERR_RTP_GSTV4TRANS_NOSUCHENTRY, "Specified entry could not be found"},
+	{ ERR_RTP_GSTV4TRANS_NOTAMULTICASTADDRESS, "The specified address is not a multicast address"},
+	{ ERR_RTP_GSTV4TRANS_NOTCREATED, "The 'Create' call for this transmitter has not been called"},
+	{ ERR_RTP_GSTV4TRANS_NOTINIT, "The 'Init' call for this transmitter has not been called"},
+	{ ERR_RTP_GSTV4TRANS_NOTWAITING, "The transmitter is not waiting for incoming data"},
+	{ ERR_RTP_GSTV4TRANS_PORTBASENOTEVEN, "The specified port base is not an even number"},
+	{ ERR_RTP_GSTV4TRANS_SPECIFIEDSIZETOOBIG, "The maximum packet size is too big for this transmitter"},
+	{ ERR_RTP_GSTV4TRANS_INVALIDEVENT, "Expecting UNKNOWN_EVENT to set source address but got another type of event"},
+	{ ERR_RTP_GSTV4TRANS_SRCADDRNOTSET, "Got packet but src address information was not set, returning"},
+	{ ERR_RTP_GSTV4TRANS_NOTNETBUFFER, "Received buffer is not a GstNetBuffer"},
+	{ ERR_RTP_GSTV4TRANS_WAITNOTIMPLEMENTED, "The WaitForIncomingData is not implemented in the Gst transmitter"},
+	{ 0,0 }
+};
+
+std::string RTPGetErrorString(int errcode)
+{
+	int i;
+	
+	if (errcode >= 0)
+		return std::string("No error");
+	
+	i = 0;
+	while (ErrorDescriptions[i].code != 0)
+	{
+		if (ErrorDescriptions[i].code == errcode)
+			return std::string(ErrorDescriptions[i].description);
+		i++;
+	}
+	return std::string("Unknown error code");
+}
+

Added: konference/src/rtp/jrtplib/rtperrors.h
===================================================================
--- konference/src/rtp/jrtplib/rtperrors.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtperrors.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,202 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPERRORS_H
+
+#define RTPERRORS_H
+
+#include <string>
+
+std::string RTPGetErrorString(int errcode);
+
+#define ERR_RTP_OUTOFMEM					-1
+#define ERR_RTP_NOTHREADSUPPORT					-2
+#define ERR_RTP_COLLISIONLIST_BADADDRESS			-3
+#define ERR_RTP_HASHTABLE_ELEMENTALREADYEXISTS			-4
+#define ERR_RTP_HASHTABLE_ELEMENTNOTFOUND			-5
+#define ERR_RTP_HASHTABLE_FUNCTIONRETURNEDINVALIDHASHINDEX	-6
+#define ERR_RTP_HASHTABLE_NOCURRENTELEMENT			-7
+#define ERR_RTP_KEYHASHTABLE_FUNCTIONRETURNEDINVALIDHASHINDEX	-8
+#define ERR_RTP_KEYHASHTABLE_KEYALREADYEXISTS			-9
+#define ERR_RTP_KEYHASHTABLE_KEYNOTFOUND			-10
+#define ERR_RTP_KEYHASHTABLE_NOCURRENTELEMENT			-11
+#define ERR_RTP_PACKBUILD_ALREADYINIT				-12
+#define ERR_RTP_PACKBUILD_CSRCALREADYINLIST			-13
+#define ERR_RTP_PACKBUILD_CSRCLISTFULL				-14
+#define ERR_RTP_PACKBUILD_CSRCNOTINLIST				-15
+#define ERR_RTP_PACKBUILD_DEFAULTMARKNOTSET			-16
+#define ERR_RTP_PACKBUILD_DEFAULTPAYLOADTYPENOTSET		-17
+#define ERR_RTP_PACKBUILD_DEFAULTTSINCNOTSET			-18
+#define ERR_RTP_PACKBUILD_INVALIDMAXPACKETSIZE			-19
+#define ERR_RTP_PACKBUILD_NOTINIT				-20
+#define ERR_RTP_PACKET_BADPAYLOADTYPE				-21
+#define ERR_RTP_PACKET_DATAEXCEEDSMAXSIZE			-22
+#define ERR_RTP_PACKET_EXTERNALBUFFERNULL			-23
+#define ERR_RTP_PACKET_ILLEGALBUFFERSIZE			-24
+#define ERR_RTP_PACKET_INVALIDPACKET				-25
+#define ERR_RTP_PACKET_TOOMANYCSRCS				-26
+#define ERR_RTP_POLLTHREAD_ALREADYRUNNING			-27
+#define ERR_RTP_POLLTHREAD_CANTINITMUTEX			-28
+#define ERR_RTP_POLLTHREAD_CANTSTARTTHREAD			-29
+#define ERR_RTP_RTCPCOMPOUND_INVALIDPACKET			-30
+#define ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYBUILDING		-31
+#define ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYBUILT		-32
+#define ERR_RTP_RTCPCOMPPACKBUILDER_ALREADYGOTREPORT		-33
+#define ERR_RTP_RTCPCOMPPACKBUILDER_APPDATALENTOOBIG		-34
+#define ERR_RTP_RTCPCOMPPACKBUILDER_BUFFERSIZETOOSMALL		-35
+#define ERR_RTP_RTCPCOMPPACKBUILDER_ILLEGALAPPDATALENGTH	-36
+#define ERR_RTP_RTCPCOMPPACKBUILDER_ILLEGALSUBTYPE		-37
+#define ERR_RTP_RTCPCOMPPACKBUILDER_INVALIDITEMTYPE		-38
+#define ERR_RTP_RTCPCOMPPACKBUILDER_MAXPACKETSIZETOOSMALL	-39
+#define ERR_RTP_RTCPCOMPPACKBUILDER_NOCURRENTSOURCE		-40
+#define ERR_RTP_RTCPCOMPPACKBUILDER_NOREPORTPRESENT		-41
+#define ERR_RTP_RTCPCOMPPACKBUILDER_NOTBUILDING			-42
+#define ERR_RTP_RTCPCOMPPACKBUILDER_NOTENOUGHBYTESLEFT		-43
+#define ERR_RTP_RTCPCOMPPACKBUILDER_REPORTNOTSTARTED		-44
+#define ERR_RTP_RTCPCOMPPACKBUILDER_TOOMANYSSRCS		-45
+#define ERR_RTP_RTCPCOMPPACKBUILDER_TOTALITEMLENGTHTOOBIG	-46
+#define ERR_RTP_RTCPPACKETBUILDER_ALREADYINIT			-47
+#define ERR_RTP_RTCPPACKETBUILDER_ILLEGALMAXPACKSIZE		-48
+#define ERR_RTP_RTCPPACKETBUILDER_ILLEGALTIMESTAMPUNIT		-49
+#define ERR_RTP_RTCPPACKETBUILDER_NOTINIT			-50
+#define ERR_RTP_RTCPPACKETBUILDER_PACKETFILLEDTOOSOON		-51
+#define ERR_RTP_SCHEDPARAMS_BADFRACTION				-52
+#define ERR_RTP_SCHEDPARAMS_BADMINIMUMINTERVAL			-53
+#define ERR_RTP_SCHEDPARAMS_INVALIDBANDWIDTH			-54
+#define ERR_RTP_SDES_LENGTHTOOBIG				-55
+#define ERR_RTP_SDES_MAXPRIVITEMS				-56
+#define ERR_RTP_SDES_PREFIXNOTFOUND				-57
+#define ERR_RTP_SESSION_ALREADYCREATED				-58
+#define ERR_RTP_SESSION_CANTGETLOGINNAME			-59
+#define ERR_RTP_SESSION_CANTINITMUTEX				-60
+#define ERR_RTP_SESSION_MAXPACKETSIZETOOSMALL			-61
+#define ERR_RTP_SESSION_NOTCREATED				-62
+#define ERR_RTP_SESSION_UNSUPPORTEDTRANSMISSIONPROTOCOL		-63
+#define ERR_RTP_SESSION_USINGPOLLTHREAD				-64
+#define ERR_RTP_SOURCES_ALREADYHAVEOWNSSRC			-65
+#define ERR_RTP_SOURCES_DONTHAVEOWNSSRC				-66
+#define ERR_RTP_SOURCES_ILLEGALSDESTYPE				-67
+#define ERR_RTP_SOURCES_SSRCEXISTS				-68
+#define ERR_RTP_TRANS_BUFFERLENGTHTOOSMALL			-69
+#define ERR_RTP_UDPV4TRANS_ALREADYCREATED			-70
+#define ERR_RTP_UDPV4TRANS_ALREADYINIT				-71
+#define ERR_RTP_UDPV4TRANS_ALREADYWAITING			-72
+#define ERR_RTP_UDPV4TRANS_CANTBINDRTCPSOCKET			-73
+#define ERR_RTP_UDPV4TRANS_CANTBINDRTPSOCKET			-74
+#define ERR_RTP_UDPV4TRANS_CANTCALCULATELOCALIP			-75
+#define ERR_RTP_UDPV4TRANS_CANTCREATEABORTDESCRIPTORS		-76
+#define ERR_RTP_UDPV4TRANS_CANTCREATEPIPE			-77
+#define ERR_RTP_UDPV4TRANS_CANTCREATESOCKET			-78
+#define ERR_RTP_UDPV4TRANS_CANTINITMUTEX			-79
+#define ERR_RTP_UDPV4TRANS_CANTSETRTCPRECEIVEBUF		-80
+#define ERR_RTP_UDPV4TRANS_CANTSETRTCPTRANSMITBUF		-81
+#define ERR_RTP_UDPV4TRANS_CANTSETRTPRECEIVEBUF			-82
+#define ERR_RTP_UDPV4TRANS_CANTSETRTPTRANSMITBUF		-83
+#define ERR_RTP_UDPV4TRANS_COULDNTJOINMULTICASTGROUP		-84
+#define ERR_RTP_UDPV4TRANS_DIFFERENTRECEIVEMODE			-85
+#define ERR_RTP_UDPV4TRANS_ERRORINSELECT			-86
+#define ERR_RTP_UDPV4TRANS_ILLEGALPARAMETERS			-87
+#define ERR_RTP_UDPV4TRANS_INVALIDADDRESSTYPE			-88
+#define ERR_RTP_UDPV4TRANS_NOLOCALIPS				-89
+#define ERR_RTP_UDPV4TRANS_NOMULTICASTSUPPORT			-90
+#define ERR_RTP_UDPV4TRANS_NOSUCHENTRY				-91
+#define ERR_RTP_UDPV4TRANS_NOTAMULTICASTADDRESS			-92
+#define ERR_RTP_UDPV4TRANS_NOTCREATED				-93
+#define ERR_RTP_UDPV4TRANS_NOTINIT				-94
+#define ERR_RTP_UDPV4TRANS_NOTWAITING				-95
+#define ERR_RTP_UDPV4TRANS_PORTBASENOTEVEN			-96
+#define ERR_RTP_UDPV4TRANS_SPECIFIEDSIZETOOBIG			-97
+#define ERR_RTP_UDPV6TRANS_ALREADYCREATED			-98
+#define ERR_RTP_UDPV6TRANS_ALREADYINIT				-99
+#define ERR_RTP_UDPV6TRANS_ALREADYWAITING			-100
+#define ERR_RTP_UDPV6TRANS_CANTBINDRTCPSOCKET			-101
+#define ERR_RTP_UDPV6TRANS_CANTBINDRTPSOCKET			-102
+#define ERR_RTP_UDPV6TRANS_CANTCALCULATELOCALIP			-103
+#define ERR_RTP_UDPV6TRANS_CANTCREATEABORTDESCRIPTORS		-104
+#define ERR_RTP_UDPV6TRANS_CANTCREATEPIPE			-105
+#define ERR_RTP_UDPV6TRANS_CANTCREATESOCKET			-106
+#define ERR_RTP_UDPV6TRANS_CANTINITMUTEX			-107
+#define ERR_RTP_UDPV6TRANS_CANTSETRTCPRECEIVEBUF		-108
+#define ERR_RTP_UDPV6TRANS_CANTSETRTCPTRANSMITBUF		-109
+#define ERR_RTP_UDPV6TRANS_CANTSETRTPRECEIVEBUF			-110
+#define ERR_RTP_UDPV6TRANS_CANTSETRTPTRANSMITBUF		-111
+#define ERR_RTP_UDPV6TRANS_COULDNTJOINMULTICASTGROUP		-112
+#define ERR_RTP_UDPV6TRANS_DIFFERENTRECEIVEMODE			-113
+#define ERR_RTP_UDPV6TRANS_ERRORINSELECT			-114
+#define ERR_RTP_UDPV6TRANS_ILLEGALPARAMETERS			-115
+#define ERR_RTP_UDPV6TRANS_INVALIDADDRESSTYPE			-116
+#define ERR_RTP_UDPV6TRANS_NOLOCALIPS				-117
+#define ERR_RTP_UDPV6TRANS_NOMULTICASTSUPPORT			-118
+#define ERR_RTP_UDPV6TRANS_NOSUCHENTRY				-119
+#define ERR_RTP_UDPV6TRANS_NOTAMULTICASTADDRESS			-120
+#define ERR_RTP_UDPV6TRANS_NOTCREATED				-121
+#define ERR_RTP_UDPV6TRANS_NOTINIT				-122
+#define ERR_RTP_UDPV6TRANS_NOTWAITING				-123
+#define ERR_RTP_UDPV6TRANS_PORTBASENOTEVEN			-124
+#define ERR_RTP_UDPV6TRANS_SPECIFIEDSIZETOOBIG			-125
+#define ERR_RTP_INTERNALSOURCEDATA_INVALIDPROBATIONTYPE		-126
+#define ERR_RTP_SESSION_USERDEFINEDTRANSMITTERNULL		-127
+#define ERR_RTP_GSTV4TRANS_ALREADYCREATED			-128
+#define ERR_RTP_GSTV4TRANS_ALREADYINIT				-129
+#define ERR_RTP_GSTV4TRANS_ALREADYWAITING			-130
+#define ERR_RTP_GSTV4TRANS_CANTBINDRTCPSOCKET			-131
+#define ERR_RTP_GSTV4TRANS_CANTBINDRTPSOCKET			-132
+#define ERR_RTP_GSTV4TRANS_CANTCALCULATELOCALIP			-133
+#define ERR_RTP_GSTV4TRANS_CANTCREATEABORTDESCRIPTORS		-134
+#define ERR_RTP_GSTV4TRANS_CANTCREATEPIPE			-135
+#define ERR_RTP_GSTV4TRANS_CANTCREATESOCKET			-136
+#define ERR_RTP_GSTV4TRANS_CANTINITMUTEX			-137
+#define ERR_RTP_GSTV4TRANS_CANTSETRTCPRECEIVEBUF		-138
+#define ERR_RTP_GSTV4TRANS_CANTSETRTCPTRANSMITBUF		-139
+#define ERR_RTP_GSTV4TRANS_CANTSETRTPRECEIVEBUF			-140
+#define ERR_RTP_GSTV4TRANS_CANTSETRTPTRANSMITBUF		-141
+#define ERR_RTP_GSTV4TRANS_COULDNTJOINMULTICASTGROUP		-142
+#define ERR_RTP_GSTV4TRANS_DIFFERENTRECEIVEMODE			-143
+#define ERR_RTP_GSTV4TRANS_ERRORINSELECT			-144
+#define ERR_RTP_GSTV4TRANS_ILLEGALPARAMETERS			-145
+#define ERR_RTP_GSTV4TRANS_INVALIDADDRESSTYPE			-146
+#define ERR_RTP_GSTV4TRANS_NOLOCALIPS				-147
+#define ERR_RTP_GSTV4TRANS_NOMULTICASTSUPPORT			-148
+#define ERR_RTP_GSTV4TRANS_NOSUCHENTRY				-149
+#define ERR_RTP_GSTV4TRANS_NOTAMULTICASTADDRESS			-150
+#define ERR_RTP_GSTV4TRANS_NOTCREATED				-151
+#define ERR_RTP_GSTV4TRANS_NOTINIT				-152
+#define ERR_RTP_GSTV4TRANS_NOTWAITING				-153
+#define ERR_RTP_GSTV4TRANS_PORTBASENOTEVEN			-154
+#define ERR_RTP_GSTV4TRANS_SPECIFIEDSIZETOOBIG			-155
+#define ERR_RTP_GSTV4TRANS_INVALIDEVENT         		-156
+#define ERR_RTP_GSTV4TRANS_SRCADDRNOTSET        		-157
+#define ERR_RTP_GSTV4TRANS_NOTNETBUFFER         		-158
+#define ERR_RTP_GSTV4TRANS_WAITNOTIMPLEMENTED			-159
+
+#endif // RTPERRORS_H
+

Added: konference/src/rtp/jrtplib/rtpgsttransmitter.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpgsttransmitter.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpgsttransmitter.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,1806 @@
+/*
+
+  This class allows for jrtp to send GstBuffers. Allows for integration of RTP 
+  into gstreamer.
+  Copyright (c) 2005 Philippe Khalaf <burger at speedy.org>
+  
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2004 Jori Liesenborgs
+
+  Contact: jori at lumumba.luc.ac.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.luc.ac.be), a research center of the "Limburgs Universitair
+  Centrum" (http://www.luc.ac.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtpgsttransmitter.h"
+
+#ifdef RTP_SUPPORT_GST
+
+#include "rtprawpacket.h"
+#include "rtpipv4address.h"
+#include "rtptimeutilities.h"
+#include <stdio.h>
+
+#include <net/if.h>
+#include <string.h>
+#include <netdb.h>
+#include <unistd.h>
+
+#ifdef RTP_HAVE_SYS_FILIO
+#include <sys/filio.h>
+#endif // RTP_HAVE_SYS_FILIO
+
+#define RTPIOCTL								ioctl
+
+#ifdef RTPDEBUG
+	#include <iostream>
+#endif // RTPDEBUG
+
+#include "rtpdebug.h"
+
+//GST_DEBUG_CATEGORY (gst_rtp_bin_debug);
+//#define GST_CAT_DEFAULT (gst_rtp_bin_debug)
+
+#define RTPGSTv4TRANS_RTPRECEIVEBUFFER							32768
+#define RTPGSTv4TRANS_RTCPRECEIVEBUFFER							32768
+#define RTPGSTv4TRANS_RTPTRANSMITBUFFER							32768
+#define RTPGSTv4TRANS_RTCPTRANSMITBUFFER						32768
+#define RTPGSTv4TRANS_MAXPACKSIZE							65535
+#define RTPGSTv4TRANS_IFREQBUFSIZE							8192
+
+//#define RTPGSTv4TRANS_IS_MCASTADDR(x)							(((x)&0xF0000000) == 0xE0000000)
+
+/*#define RTPGSTv4TRANS_MCASTMEMBERSHIP(socket,type,mcastip,status)	{\
+										struct ip_mreq mreq;\
+										\
+										mreq.imr_multiaddr.s_addr = htonl(mcastip);\
+										mreq.imr_interface.s_addr = htonl(bindIP);\
+										status = setsockopt(socket,IPPROTO_IP,type,(const char *)&mreq,sizeof(struct ip_mreq));\
+									}*/
+#ifndef RTP_SUPPORT_INLINETEMPLATEPARAM
+	int RTPGSTv4Trans_GetHashIndex_IPv4Dest(const RTPIPv4Destination &d)				{ return d.GetIP_HBO()%RTPGSTv4TRANS_HASHSIZE; }
+	int RTPGSTv4Trans_GetHashIndex_u_int32_t(const u_int32_t &k)					{ return k%RTPGSTv4TRANS_HASHSIZE; }
+#endif // !RTP_SUPPORT_INLINETEMPLATEPARAM
+	
+#ifdef RTP_SUPPORT_THREAD
+	#define MAINMUTEX_LOCK 		{ if (threadsafe) mainmutex.Lock(); }
+	#define MAINMUTEX_UNLOCK	{ if (threadsafe) mainmutex.Unlock(); }
+	#define WAITMUTEX_LOCK		{ if (threadsafe) waitmutex.Lock(); }
+	#define WAITMUTEX_UNLOCK	{ if (threadsafe) waitmutex.Unlock(); }
+#else
+	#define MAINMUTEX_LOCK
+	#define MAINMUTEX_UNLOCK
+	#define WAITMUTEX_LOCK
+	#define WAITMUTEX_UNLOCK
+#endif // RTP_SUPPORT_THREAD
+
+RTPGSTv4Transmitter::RTPGSTv4Transmitter()
+{
+	created = false;
+	init = false;
+}
+
+RTPGSTv4Transmitter::~RTPGSTv4Transmitter()
+{
+	Destroy();
+}
+
+int RTPGSTv4Transmitter::Init(bool tsafe)
+{
+	if (init)
+		return ERR_RTP_GSTV4TRANS_ALREADYINIT;
+	
+#ifdef RTP_SUPPORT_THREAD
+	threadsafe = tsafe;
+	if (threadsafe)
+	{
+		int status;
+		
+		status = mainmutex.Init();
+		if (status < 0)
+			return ERR_RTP_GSTV4TRANS_CANTINITMUTEX;
+		status = waitmutex.Init();
+		if (status < 0)
+			return ERR_RTP_GSTV4TRANS_CANTINITMUTEX;
+	}
+#else
+	if (tsafe)
+		return ERR_RTP_NOTHREADSUPPORT;
+#endif // RTP_SUPPORT_THREAD
+
+	init = true;
+	return 0;
+}
+
+int RTPGSTv4Transmitter::Create(size_t maximumpacketsize,const RTPTransmissionParams *transparams)
+{
+	struct sockaddr_in addr;
+	int status;
+
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+
+	if (created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_ALREADYCREATED;
+	}
+	
+	// Obtain transmission parameters
+	
+	if (transparams == 0)
+		params = new RTPGSTv4TransmissionParams;
+	else
+	{
+		if (transparams->GetTransmissionProtocol() != RTPTransmitter::IPv4GSTProto)
+			return ERR_RTP_GSTV4TRANS_ILLEGALPARAMETERS;
+		params = (RTPGSTv4TransmissionParams *)transparams;
+	}
+
+	// Check if portbase is even
+	//if (params->GetPortbase()%2 != 0)
+	//{
+	//	MAINMUTEX_UNLOCK
+	//	return ERR_RTP_GSTV4TRANS_PORTBASENOTEVEN;
+	//}
+
+	// Try to obtain local IP addresses
+
+	localIPs = params->GetLocalIPList();
+	if (localIPs.empty()) // User did not provide list of local IP addresses, calculate them
+	{
+		int status;
+		
+		if ((status = CreateLocalIPList()) < 0)
+		{
+			MAINMUTEX_UNLOCK
+			return status;
+		}
+#ifdef RTPDEBUG
+		std::cout << "Found these local IP addresses:" << std::endl;
+		
+		std::list<u_int32_t>::const_iterator it;
+
+		for (it = localIPs.begin() ; it != localIPs.end() ; it++)
+		{
+			RTPIPv4Address a(*it);
+
+			std::cout << a.GetAddressString() << std::endl;
+		}
+#endif // RTPDEBUG
+	}
+
+//#ifdef RTP_SUPPORT_IPV4MULTICAST
+//	if (SetMulticastTTL(params->GetMulticastTTL()))
+//		supportsmulticasting = true;
+//	else
+//		supportsmulticasting = false;
+//#else // no multicast support enabled
+	supportsmulticasting = false;
+//#endif // RTP_SUPPORT_IPV4MULTICAST
+
+	if (maximumpacketsize > RTPGSTv4TRANS_MAXPACKSIZE)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_SPECIFIEDSIZETOOBIG;
+	}
+	
+	maxpacksize = maximumpacketsize;
+	portbase = params->GetPortbase();
+	multicastTTL = params->GetMulticastTTL();
+	receivemode = RTPTransmitter::AcceptAll;
+
+	localhostname = 0;
+	localhostnamelength = 0;
+
+	rtppackcount = 0;
+	rtcppackcount = 0;
+	
+	waitingfordata = false;
+	created = true;
+
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+void RTPGSTv4Transmitter::Destroy()
+{
+	if (!init)
+		return;
+
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK;
+		return;
+	}
+
+	if (localhostname)
+	{
+		delete [] localhostname;
+		localhostname = 0;
+		localhostnamelength = 0;
+	}
+	
+	destinations.Clear();
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+//	multicastgroups.Clear();
+#endif // RTP_SUPPORT_IPV4MULTICAST
+	FlushPackets();
+	ClearAcceptIgnoreInfo();
+	localIPs.clear();
+	created = false;
+    delete params;
+	
+	MAINMUTEX_UNLOCK
+}
+
+RTPTransmissionInfo *RTPGSTv4Transmitter::GetTransmissionInfo()
+{
+	if (!init)
+		return 0;
+
+	MAINMUTEX_LOCK
+	RTPTransmissionInfo *tinf = new RTPGSTv4TransmissionInfo(localIPs, 
+            params->GetGstRTPSrc(), params->GetGstRTPSrc(), params);
+	MAINMUTEX_UNLOCK
+	return tinf;
+}
+
+int RTPGSTv4Transmitter::GetLocalHostName(u_int8_t *buffer,size_t *bufferlength)
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+
+	if (localhostname == 0)
+	{
+		if (localIPs.empty())
+		{
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_GSTV4TRANS_NOLOCALIPS;
+		}
+		
+		std::list<u_int32_t>::const_iterator it;
+		std::list<std::string> hostnames;
+	
+		for (it = localIPs.begin() ; it != localIPs.end() ; it++)
+		{
+			struct hostent *he;
+			u_int8_t addr[4];
+			u_int32_t ip = (*it);
+	
+			addr[0] = (u_int8_t)((ip>>24)&0xFF);
+			addr[1] = (u_int8_t)((ip>>16)&0xFF);
+			addr[2] = (u_int8_t)((ip>>8)&0xFF);
+			addr[3] = (u_int8_t)(ip&0xFF);
+			he = gethostbyaddr((char *)addr,4,AF_INET);
+			if (he != 0)
+			{
+				std::string hname = std::string(he->h_name);
+				hostnames.push_back(hname);
+			}
+		}
+	
+		bool found  = false;
+		
+		if (!hostnames.empty())	// try to select the most appropriate hostname
+		{
+			std::list<std::string>::const_iterator it;
+			
+			for (it = hostnames.begin() ; !found && it != hostnames.end() ; it++)
+			{
+				if ((*it).find('.') != std::string::npos)
+				{
+					found = true;
+					localhostnamelength = (*it).length();
+					localhostname = new u_int8_t [localhostnamelength+1];
+					if (localhostname == 0)
+					{
+						MAINMUTEX_UNLOCK
+						return ERR_RTP_OUTOFMEM;
+					}
+					memcpy(localhostname,(*it).c_str(),localhostnamelength);
+					localhostname[localhostnamelength] = 0;
+				}
+			}
+		}
+	
+		if (!found) // use an IP address
+		{
+			u_int32_t ip;
+			int len;
+			char str[256];
+			
+			it = localIPs.begin();
+			ip = (*it);
+			
+			sprintf(str,"%d.%d.%d.%d",(int)((ip>>24)&0xFF),(int)((ip>>16)&0xFF),(int)((ip>>8)&0xFF),(int)(ip&0xFF));
+			len = strlen(str);
+	
+			localhostnamelength = len;
+			localhostname = new u_int8_t [localhostnamelength + 1];
+			if (localhostname == 0)
+			{
+				MAINMUTEX_UNLOCK
+				return ERR_RTP_OUTOFMEM;
+			}
+			memcpy(localhostname,str,localhostnamelength);
+			localhostname[localhostnamelength] = 0;
+		}
+	}
+	
+	if ((*bufferlength) < localhostnamelength)
+	{
+		*bufferlength = localhostnamelength; // tell the application the required size of the buffer
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_TRANS_BUFFERLENGTHTOOSMALL;
+	}
+
+	memcpy(buffer,localhostname,localhostnamelength);
+	*bufferlength = localhostnamelength;
+	
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+bool RTPGSTv4Transmitter::ComesFromThisTransmitter(const RTPAddress *addr)
+{
+	if (!init)
+		return false;
+
+	if (addr == 0)
+		return false;
+	
+	MAINMUTEX_LOCK
+	
+	bool v;
+		
+	if (created && addr->GetAddressType() == RTPAddress::IPv4Address)
+	{	
+		const RTPIPv4Address *addr2 = (const RTPIPv4Address *)addr;
+		bool found = false;
+		std::list<u_int32_t>::const_iterator it;
+	
+		it = localIPs.begin();
+		while (!found && it != localIPs.end())
+		{
+			if (addr2->GetIP() == *it)
+				found = true;
+			else
+				++it;
+		}
+	
+		if (!found)
+			v = false;
+		else
+		{
+			if (addr2->GetPort() == params->GetPortbase()) // check for RTP port
+				v = true;
+			else if (addr2->GetPort() == (params->GetPortbase()+1)) // check for RTCP port
+				v = true;
+			else 
+				v = false;
+		}
+	}
+	else
+		v = false;
+
+	MAINMUTEX_UNLOCK
+	return v;
+}
+
+int RTPGSTv4Transmitter::Poll()
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+
+	int status;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	status = FakePoll(); // poll RTP socket
+    params->SetCurrentData(NULL);
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPGSTv4Transmitter::WaitForIncomingData(const RTPTime &delay,bool *dataavailable)
+{
+/*	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	fd_set fdset;
+	struct timeval tv;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (waitingfordata)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_ALREADYWAITING;
+	}
+	
+	FD_ZERO(&fdset);
+	FD_SET(rtpsock,&fdset);
+	FD_SET(rtcpsock,&fdset);
+	FD_SET(abortdesc[0],&fdset);
+	tv.tv_sec = delay.GetSeconds();
+	tv.tv_usec = delay.GetMicroSeconds();
+	
+	waitingfordata = true;
+	
+	WAITMUTEX_LOCK
+	MAINMUTEX_UNLOCK
+
+	if (select(FD_SETSIZE,&fdset,0,0,&tv) < 0)
+	{
+		MAINMUTEX_LOCK
+		waitingfordata = false;
+		MAINMUTEX_UNLOCK
+		WAITMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_ERRORINSELECT;
+	}
+	
+	MAINMUTEX_LOCK
+	waitingfordata = false;
+	if (!created) // destroy called
+	{
+		MAINMUTEX_UNLOCK;
+		WAITMUTEX_UNLOCK
+		return 0;
+	}
+		
+	// if aborted, read from abort buffer
+	if (FD_ISSET(abortdesc[0],&fdset))
+	{
+#ifdef WIN32
+		char buf[1];
+		
+		recv(abortdesc[0],buf,1,0);
+#else 
+		unsigned char buf[1];
+
+		read(abortdesc[0],buf,1);
+#endif // WIN32
+	}
+	
+	MAINMUTEX_UNLOCK
+	WAITMUTEX_UNLOCK
+	return 0;*/
+	return ERR_RTP_GSTV4TRANS_WAITNOTIMPLEMENTED;
+}
+
+int RTPGSTv4Transmitter::AbortWait()
+{
+/*	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (!waitingfordata)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTWAITING;
+	}
+
+	AbortWaitInternal();
+	
+	MAINMUTEX_UNLOCK
+	return 0;*/
+	return 0;
+}
+
+int RTPGSTv4Transmitter::SendRTPData(const void *data,size_t len)	
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+    GstNetBuffer *out_buf;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (len > maxpacksize)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_SPECIFIEDSIZETOOBIG;
+	}
+
+
+	destinations.GotoFirstElement();
+    // send to each destination
+	while (destinations.HasCurrentElement())
+	{
+        // create GstNetBuffer from data
+        out_buf = gst_netbuffer_new ();
+        GST_BUFFER_DATA (out_buf) = (guint8*)data;
+        GST_BUFFER_SIZE (out_buf) = len;
+        gst_netaddress_set_ip4_address (&out_buf->to, destinations.GetCurrentElement().GetIP_NBO(),
+                destinations.GetCurrentElement().GetRTPPort_NBO());
+        GST_DEBUG("Sending RTP packet to ip %d port %d", destinations.GetCurrentElement().GetIP_NBO(), 
+                destinations.GetCurrentElement().GetRTPPort_NBO());
+
+        // push data
+        gst_pad_push( params->GetGstRTPSrc(), GST_BUFFER(out_buf) );
+		destinations.GotoNextElement();
+	}
+	
+	rtppackcount++;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+int RTPGSTv4Transmitter::SendRTCPData(const void *data,size_t len)
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+
+    // if it's NULL we dont want to transmit RTCPs
+    if (params->GetGstRTCPSrc() == NULL)
+    {
+        return 0;
+    }
+    
+	MAINMUTEX_LOCK
+
+    GstNetBuffer *out_buf;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (len > maxpacksize)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_SPECIFIEDSIZETOOBIG;
+	}
+
+	destinations.GotoFirstElement();
+    // send to each destination
+	while (destinations.HasCurrentElement())
+	{
+        // create GstNetBuffer from data
+        out_buf = gst_netbuffer_new ();
+        GST_BUFFER_DATA (out_buf) = (guint8 *)data;
+        GST_BUFFER_SIZE (out_buf) = len;
+        gst_netaddress_set_ip4_address (&out_buf->to, destinations.GetCurrentElement().GetIP_NBO(),
+                destinations.GetCurrentElement().GetRTCPPort_NBO());
+        GST_DEBUG("Sending RTCP packet");
+
+        // push data
+        gst_pad_push( params->GetGstRTCPSrc(), GST_BUFFER(out_buf) );
+		destinations.GotoNextElement();
+	}
+	
+	rtcppackcount++;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+void RTPGSTv4Transmitter::ResetPacketCount()
+{
+	if (!init)
+		return;
+
+	MAINMUTEX_LOCK
+	if (created)
+	{
+		rtppackcount = 0;
+		rtcppackcount = 0;	
+	}
+	MAINMUTEX_UNLOCK	
+}
+
+u_int32_t RTPGSTv4Transmitter::GetNumRTPPacketsSent()
+{
+	if (!init)
+		return 0;
+
+	MAINMUTEX_LOCK
+	
+	u_int32_t num;
+
+	if (!created)
+		num = 0;
+	else
+		num = rtppackcount;
+
+	MAINMUTEX_UNLOCK
+
+	return num;
+}
+
+u_int32_t RTPGSTv4Transmitter::GetNumRTCPPacketsSent()
+{
+	if (!init)
+		return 0;
+	
+	MAINMUTEX_LOCK
+	
+	u_int32_t num;
+
+	if (!created)
+		num = 0;
+	else
+		num = rtcppackcount;
+
+	MAINMUTEX_UNLOCK
+
+	return num;
+}
+	
+int RTPGSTv4Transmitter::AddDestination(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	RTPIPv4Address &address = (RTPIPv4Address &)addr;
+	RTPIPv4Destination dest(address.GetIP(),address.GetPort());
+	int status = destinations.AddElement(dest);
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPGSTv4Transmitter::DeleteDestination(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	RTPIPv4Address &address = (RTPIPv4Address &)addr;	
+	RTPIPv4Destination dest(address.GetIP(),address.GetPort());
+	int status = destinations.DeleteElement(dest);
+	
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPGSTv4Transmitter::ClearDestinations()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created)
+		destinations.Clear();
+	MAINMUTEX_UNLOCK
+}
+
+bool RTPGSTv4Transmitter::SupportsMulticasting()
+{
+	if (!init)
+		return false;
+	
+	MAINMUTEX_LOCK
+	
+	bool v;
+		
+	if (!created)
+		v = false;
+	else
+		v = supportsmulticasting;
+
+	MAINMUTEX_UNLOCK
+	return v;
+}
+
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+
+int RTPGSTv4Transmitter::JoinMulticastGroup(const RTPAddress &addr)
+{
+// hrrm wonder how will manage to get multicast info thru to the UDPSINK
+/*	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	const RTPIPv4Address &address = (const RTPIPv4Address &)addr;
+	u_int32_t mcastIP = address.GetIP();
+	
+	if (!RTPGSTv4TRANS_IS_MCASTADDR(mcastIP))
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTAMULTICASTADDRESS;
+	}
+	
+	status = multicastgroups.AddElement(mcastIP);
+	if (status >= 0)
+	{
+		RTPGSTv4TRANS_MCASTMEMBERSHIP(rtpsock,IP_ADD_MEMBERSHIP,mcastIP,status);
+		if (status != 0)
+		{
+			multicastgroups.DeleteElement(mcastIP);
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_GSTV4TRANS_COULDNTJOINMULTICASTGROUP;
+		}
+		RTPGSTv4TRANS_MCASTMEMBERSHIP(rtcpsock,IP_ADD_MEMBERSHIP,mcastIP,status);
+		if (status != 0)
+		{
+			RTPGSTv4TRANS_MCASTMEMBERSHIP(rtpsock,IP_DROP_MEMBERSHIP,mcastIP,status);
+			multicastgroups.DeleteElement(mcastIP);
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_GSTV4TRANS_COULDNTJOINMULTICASTGROUP;
+		}
+	}
+	MAINMUTEX_UNLOCK	
+	return status;*/
+	return ERR_RTP_GSTV4TRANS_NOMULTICASTSUPPORT;
+}
+
+int RTPGSTv4Transmitter::LeaveMulticastGroup(const RTPAddress &addr)
+{
+    /*
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	const RTPIPv4Address &address = (const RTPIPv4Address &)addr;
+	u_int32_t mcastIP = address.GetIP();
+	
+	if (!RTPGSTv4TRANS_IS_MCASTADDR(mcastIP))
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTAMULTICASTADDRESS;
+	}
+	
+	status = multicastgroups.DeleteElement(mcastIP);
+	if (status >= 0)
+	{	
+		RTPGSTv4TRANS_MCASTMEMBERSHIP(rtpsock,IP_DROP_MEMBERSHIP,mcastIP,status);
+		RTPGSTv4TRANS_MCASTMEMBERSHIP(rtcpsock,IP_DROP_MEMBERSHIP,mcastIP,status);
+		status = 0;
+	}
+	
+	MAINMUTEX_UNLOCK
+	return status;
+    */
+	return ERR_RTP_GSTV4TRANS_NOMULTICASTSUPPORT;
+}
+
+void RTPGSTv4Transmitter::LeaveAllMulticastGroups()
+{
+/*	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created)
+	{
+		multicastgroups.GotoFirstElement();
+		while (multicastgroups.HasCurrentElement())
+		{
+			u_int32_t mcastIP;
+			int status = 0;
+
+			mcastIP = multicastgroups.GetCurrentElement();
+			RTPGSTv4TRANS_MCASTMEMBERSHIP(rtpsock,IP_DROP_MEMBERSHIP,mcastIP,status);
+			RTPGSTv4TRANS_MCASTMEMBERSHIP(rtcpsock,IP_DROP_MEMBERSHIP,mcastIP,status);
+			multicastgroups.GotoNextElement();
+		}
+		multicastgroups.Clear();
+	}
+	MAINMUTEX_UNLOCK*/
+}
+
+#else // no multicast support
+
+int RTPGSTv4Transmitter::JoinMulticastGroup(const RTPAddress &addr)
+{
+	return ERR_RTP_GSTV4TRANS_NOMULTICASTSUPPORT;
+}
+
+int RTPGSTv4Transmitter::LeaveMulticastGroup(const RTPAddress &addr)
+{
+	return ERR_RTP_GSTV4TRANS_NOMULTICASTSUPPORT;
+}
+
+void RTPGSTv4Transmitter::LeaveAllMulticastGroups()
+{
+}
+
+#endif // RTP_SUPPORT_IPV4MULTICAST
+
+int RTPGSTv4Transmitter::SetReceiveMode(RTPTransmitter::ReceiveMode m)
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (m != receivemode)
+	{
+		receivemode = m;
+		acceptignoreinfo.Clear();
+	}
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+int RTPGSTv4Transmitter::AddToIgnoreList(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	int status;
+
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::IgnoreSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv4Address &address = (const RTPIPv4Address &)addr;
+	status = ProcessAddAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+	
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPGSTv4Transmitter::DeleteFromIgnoreList(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::IgnoreSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv4Address &address = (const RTPIPv4Address &)addr;	
+	status = ProcessDeleteAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPGSTv4Transmitter::ClearIgnoreList()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created && receivemode == RTPTransmitter::IgnoreSome)
+		ClearAcceptIgnoreInfo();
+	MAINMUTEX_UNLOCK
+}
+
+int RTPGSTv4Transmitter::AddToAcceptList(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::AcceptSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv4Address &address = (const RTPIPv4Address &)addr;
+	status = ProcessAddAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPGSTv4Transmitter::DeleteFromAcceptList(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::AcceptSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv4Address &address = (const RTPIPv4Address &)addr;
+	status = ProcessDeleteAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPGSTv4Transmitter::ClearAcceptList()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created && receivemode == RTPTransmitter::AcceptSome)
+		ClearAcceptIgnoreInfo();
+	MAINMUTEX_UNLOCK
+}
+
+int RTPGSTv4Transmitter::SetMaximumPacketSize(size_t s)	
+{
+	if (!init)
+		return ERR_RTP_GSTV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_NOTCREATED;
+	}
+	if (s > RTPGSTv4TRANS_MAXPACKSIZE)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_GSTV4TRANS_SPECIFIEDSIZETOOBIG;
+	}
+	maxpacksize = s;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+bool RTPGSTv4Transmitter::NewDataAvailable()
+{
+	if (!init)
+		return false;
+	
+	MAINMUTEX_LOCK
+	
+	bool v;
+		
+	if (!created)
+		v = false;
+	else
+	{
+		if (rawpacketlist.empty())
+			v = false;
+		else
+			v = true;
+	}
+	
+	MAINMUTEX_UNLOCK
+	return v;
+}
+
+RTPRawPacket *RTPGSTv4Transmitter::GetNextPacket()
+{
+	if (!init)
+		return 0;
+	
+	MAINMUTEX_LOCK
+	
+	RTPRawPacket *p;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return 0;
+	}
+	if (rawpacketlist.empty())
+	{
+		MAINMUTEX_UNLOCK
+		return 0;
+	}
+
+	p = *(rawpacketlist.begin());
+	rawpacketlist.pop_front();
+
+	MAINMUTEX_UNLOCK
+	return p;
+}
+
+// Here the private functions start...
+
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+bool RTPGSTv4Transmitter::SetMulticastTTL(u_int8_t ttl)
+{
+/*	int ttl2,status;
+
+	ttl2 = (int)ttl;
+	status = setsockopt(rtpsock,IPPROTO_IP,IP_MULTICAST_TTL,(const char *)&ttl2,sizeof(int));
+	if (status != 0)
+		return false;
+	status = setsockopt(rtcpsock,IPPROTO_IP,IP_MULTICAST_TTL,(const char *)&ttl2,sizeof(int));
+	if (status != 0)
+		return false;
+	return true;*/
+}
+#endif // RTP_SUPPORT_IPV4MULTICAST
+
+void RTPGSTv4Transmitter::FlushPackets()
+{
+	std::list<RTPRawPacket*>::const_iterator it;
+
+	for (it = rawpacketlist.begin() ; it != rawpacketlist.end() ; ++it)
+		delete (*it);
+	rawpacketlist.clear();
+}
+
+int RTPGSTv4Transmitter::FakePoll()
+{
+    int recvlen;
+    GstNetBuffer *packetbuffer;
+
+    RTPTime curtime = RTPTime::CurrentTime();
+
+    packetbuffer = params->GetCurrentData();
+    bool rtp = params->GetCurrentDataType();
+    // lets make sure we got something
+    if (packetbuffer == NULL )
+    {
+        //GST_DEBUG("No packetbuffer to poll");
+        return 0;
+    }
+    // should be a netbuffer
+    if (GST_IS_NETBUFFER (packetbuffer))
+    {
+        guint16 senderport;
+        guint32 senderaddr;
+        // let's get the address from the netbuffer
+        gst_netaddress_get_ip4_address (&packetbuffer->from, &senderaddr, &senderport);
+        RTPIPv4Address *addr = new RTPIPv4Address(ntohl(senderaddr), ntohs(senderport));
+        if (addr == 0)
+        {
+            return ERR_RTP_OUTOFMEM;
+        }
+        GST_DEBUG("Got netbuffer, saving src info %d %d", addr->GetIP(), addr->GetPort());
+        // ok we got the src addr, now this should be the actual packet
+        recvlen = GST_BUFFER_SIZE(packetbuffer);
+        if (GST_BUFFER_DATA(packetbuffer) && recvlen > 0)
+        {
+            GST_DEBUG("Got packet %d", recvlen);
+            bool acceptdata;
+
+            // got data, process it
+            if (receivemode == RTPTransmitter::AcceptAll)
+                acceptdata = true;
+            else
+                acceptdata = ShouldAcceptData(addr->GetIP(),addr->GetPort());
+
+            if (acceptdata)
+            {
+                GST_DEBUG("Adding packet to queue");
+                RTPRawPacket *pack;
+                u_int8_t *datacopy;
+
+                datacopy = new u_int8_t[recvlen];
+                if (datacopy == 0)
+                {
+                    delete addr;
+                    return ERR_RTP_OUTOFMEM;
+                }
+                memcpy(datacopy, GST_BUFFER_DATA(packetbuffer),recvlen);
+                pack = new RTPRawPacket(datacopy,recvlen,addr,curtime,rtp);
+
+                GST_DEBUG("lenght %d is RTP? %d", pack->GetDataLength(), pack->IsRTP());
+                if (pack == 0)
+                {
+                    delete addr;
+                    delete [] datacopy;
+                    return ERR_RTP_OUTOFMEM;
+                }
+                rawpacketlist.push_back(pack);	
+            }
+        }
+    } else {
+        return ERR_RTP_GSTV4TRANS_NOTNETBUFFER;
+    }
+    return 0;
+}
+
+int RTPGSTv4Transmitter::ProcessAddAcceptIgnoreEntry(u_int32_t ip,u_int16_t port)
+{
+	acceptignoreinfo.GotoElement(ip);
+	if (acceptignoreinfo.HasCurrentElement()) // An entry for this IP address already exists
+	{
+		PortInfo *portinf = acceptignoreinfo.GetCurrentElement();
+		
+		if (port == 0) // select all ports
+		{
+			portinf->all = true;
+			portinf->portlist.clear();
+		}
+		else if (!portinf->all)
+		{
+			std::list<u_int16_t>::const_iterator it,begin,end;
+
+			begin = portinf->portlist.begin();
+			end = portinf->portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == port) // already in list
+					return 0;
+			}
+			portinf->portlist.push_front(port);
+		}
+	}
+	else // got to create an entry for this IP address
+	{
+		PortInfo *portinf;
+		int status;
+		
+		portinf = new PortInfo();
+		if (port == 0) // select all ports
+			portinf->all = true;
+		else
+			portinf->portlist.push_front(port);
+		
+		status = acceptignoreinfo.AddElement(ip,portinf);
+		if (status < 0)
+		{
+			delete portinf;
+			return status;
+		}
+	}
+
+	return 0;
+}
+
+void RTPGSTv4Transmitter::ClearAcceptIgnoreInfo()
+{
+	acceptignoreinfo.GotoFirstElement();
+	while (acceptignoreinfo.HasCurrentElement())
+	{
+		PortInfo *inf;
+
+		inf = acceptignoreinfo.GetCurrentElement();
+		delete inf;
+		acceptignoreinfo.GotoNextElement();
+	}
+	acceptignoreinfo.Clear();
+}
+	
+int RTPGSTv4Transmitter::ProcessDeleteAcceptIgnoreEntry(u_int32_t ip,u_int16_t port)
+{
+	acceptignoreinfo.GotoElement(ip);
+	if (!acceptignoreinfo.HasCurrentElement())
+		return ERR_RTP_GSTV4TRANS_NOSUCHENTRY;
+	
+	PortInfo *inf;
+
+	inf = acceptignoreinfo.GetCurrentElement();
+	if (port == 0) // delete all entries
+	{
+		inf->all = false;
+		inf->portlist.clear();
+	}
+	else // a specific port was selected
+	{
+		if (inf->all) // currently, all ports are selected. Add the one to remove to the list
+		{
+			// we have to check if the list doesn't contain the port already
+			std::list<u_int16_t>::const_iterator it,begin,end;
+
+			begin = inf->portlist.begin();
+			end = inf->portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == port) // already in list: this means we already deleted the entry
+					return ERR_RTP_GSTV4TRANS_NOSUCHENTRY;
+			}
+			inf->portlist.push_front(port);
+		}
+		else // check if we can find the port in the list
+		{
+			std::list<u_int16_t>::iterator it,begin,end;
+			
+			begin = inf->portlist.begin();
+			end = inf->portlist.end();
+			for (it = begin ; it != end ; ++it)
+			{
+				if (*it == port) // found it!
+				{
+					inf->portlist.erase(it);
+					return 0;
+				}
+			}
+			// didn't find it
+			return ERR_RTP_GSTV4TRANS_NOSUCHENTRY;			
+		}
+	}
+	return 0;
+}
+
+bool RTPGSTv4Transmitter::ShouldAcceptData(u_int32_t srcip,u_int16_t srcport)
+{
+	if (receivemode == RTPTransmitter::AcceptSome)
+	{
+		PortInfo *inf;
+
+		acceptignoreinfo.GotoElement(srcip);
+		if (!acceptignoreinfo.HasCurrentElement())
+			return false;
+		
+		inf = acceptignoreinfo.GetCurrentElement();
+		if (!inf->all) // only accept the ones in the list
+		{
+			std::list<u_int16_t>::const_iterator it,begin,end;
+
+			begin = inf->portlist.begin();
+			end = inf->portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return true;
+			}
+			return false;
+		}
+		else // accept all, except the ones in the list
+		{
+			std::list<u_int16_t>::const_iterator it,begin,end;
+
+			begin = inf->portlist.begin();
+			end = inf->portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return false;
+			}
+			return true;
+		}
+	}
+	else // IgnoreSome
+	{
+		PortInfo *inf;
+
+		acceptignoreinfo.GotoElement(srcip);
+		if (!acceptignoreinfo.HasCurrentElement())
+			return true;
+		
+		inf = acceptignoreinfo.GetCurrentElement();
+		if (!inf->all) // ignore the ports in the list
+		{
+			std::list<u_int16_t>::const_iterator it,begin,end;
+
+			begin = inf->portlist.begin();
+			end = inf->portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return false;
+			}
+			return true;
+		}
+		else // ignore all, except the ones in the list
+		{
+			std::list<u_int16_t>::const_iterator it,begin,end;
+
+			begin = inf->portlist.begin();
+			end = inf->portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return true;
+			}
+			return false;
+		}
+	}
+	return true;
+}
+
+#ifdef WIN32
+
+int RTPGSTv4Transmitter::CreateAbortDescriptors()
+{
+    // no need for these no more
+/*
+	SOCKET listensock;
+	int size;
+	struct sockaddr_in addr;
+
+	listensock = socket(PF_INET,SOCK_STREAM,0);
+	if (listensock == RTPSOCKERR)
+		return ERR_RTP_GSTV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	
+	memset(&addr,0,sizeof(struct sockaddr_in));
+	addr.sin_family = AF_INET;
+	if (bind(listensock,(struct sockaddr *)&addr,sizeof(struct sockaddr_in)) != 0)
+	{
+		RTPCLOSE(listensock);
+		return ERR_RTP_GSTV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&addr,0,sizeof(struct sockaddr_in));
+	size = sizeof(struct sockaddr_in);
+	if (getsockname(listensock,(struct sockaddr*)&addr,&size) != 0)
+	{
+		RTPCLOSE(listensock);
+		return ERR_RTP_GSTV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	unsigned short connectport = ntohs(addr.sin_port);
+
+	abortdesc[0] = socket(PF_INET,SOCK_STREAM,0);
+	if (abortdesc[0] == RTPSOCKERR)
+	{
+		RTPCLOSE(listensock);
+		return ERR_RTP_GSTV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&addr,0,sizeof(struct sockaddr_in));
+	addr.sin_family = AF_INET;
+	if (bind(abortdesc[0],(struct sockaddr *)&addr,sizeof(struct sockaddr_in)) != 0)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_GSTV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	if (listen(listensock,1) != 0)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_GSTV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&addr,0,sizeof(struct sockaddr_in));
+	addr.sin_family = AF_INET;
+	addr.sin_addr.s_addr = inet_addr("127.0.0.1");
+	addr.sin_port = htons(connectport);
+	
+	if (connect(abortdesc[0],(struct sockaddr *)&addr,sizeof(struct sockaddr_in)) != 0)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_GSTV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&addr,0,sizeof(struct sockaddr_in));
+	size = sizeof(struct sockaddr_in);
+	abortdesc[1] = accept(listensock,(struct sockaddr *)&addr,&size);
+	if (abortdesc[1] == RTPSOCKERR)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_GSTV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	// okay, got the connection, close the listening socket
+
+	RTPCLOSE(listensock);
+	return 0;*/
+}
+
+void RTPGSTv4Transmitter::DestroyAbortDescriptors()
+{
+//	RTPCLOSE(abortdesc[0]);
+//	RTPCLOSE(abortdesc[1]);
+}
+
+#else // in a non winsock environment we can use pipes
+
+int RTPGSTv4Transmitter::CreateAbortDescriptors()
+{
+//	if (pipe(abortdesc) < 0)
+//		return ERR_RTP_GSTV4TRANS_CANTCREATEPIPE;
+//	return 0;
+}
+
+void RTPGSTv4Transmitter::DestroyAbortDescriptors()
+{
+//	close(abortdesc[0]);
+//	close(abortdesc[1]);
+}
+
+#endif // WIN32
+
+int RTPGSTv4Transmitter::CreateLocalIPList()
+{
+	 // first try to obtain the list from the network interface info
+
+	if (!GetLocalIPList_Interfaces())
+	{
+		// If this fails, we'll have to depend on DNS info
+		GetLocalIPList_DNS();
+	}
+	AddLoopbackAddress();
+	return 0;
+}
+
+//#ifdef WIN32
+
+bool RTPGSTv4Transmitter::GetLocalIPList_Interfaces()
+{
+	// REMINDER: got to find out how to do this
+	return false;
+}
+/*
+#else // use ioctl
+
+bool RTPGSTv4Transmitter::GetLocalIPList_Interfaces()
+{
+	int status;
+	char buffer[RTPGSTv4TRANS_IFREQBUFSIZE];
+	struct ifconf ifc;
+	struct ifreq *ifr;
+	struct sockaddr *sa;
+	char *startptr,*endptr;
+	int remlen;
+	
+	ifc.ifc_len = RTPGSTv4TRANS_IFREQBUFSIZE;
+	ifc.ifc_buf = buffer;
+	status = ioctl(rtpsock,SIOCGIFCONF,&ifc);
+	if (status < 0)
+		return false;
+	
+	startptr = (char *)ifc.ifc_req;
+	endptr = startptr + ifc.ifc_len;
+	remlen = ifc.ifc_len;
+	while((startptr < endptr) && remlen >= (int)sizeof(struct ifreq))
+	{
+		ifr = (struct ifreq *)startptr;
+		sa = &(ifr->ifr_addr);
+#ifdef RTP_HAVE_SOCKADDR_LEN
+		if (sa->sa_len <= sizeof(struct sockaddr))
+		{
+			if (sa->sa_len == sizeof(struct sockaddr_in) && sa->sa_family == PF_INET)
+			{
+				u_int32_t ip;
+				struct sockaddr_in *addr = (struct sockaddr_in *)sa;
+				
+				ip = ntohl(addr->sin_addr.s_addr);
+				localIPs.push_back(ip);
+			}
+			remlen -= sizeof(struct ifreq);
+			startptr += sizeof(struct ifreq);
+		}
+		else
+		{
+			int l = sa->sa_len-sizeof(struct sockaddr)+sizeof(struct ifreq);
+			
+			remlen -= l;
+			startptr += l;
+		}
+#else // don't have sa_len in struct sockaddr
+		if (sa->sa_family == PF_INET)
+		{
+			u_int32_t ip;
+			struct sockaddr_in *addr = (struct sockaddr_in *)sa;
+		
+			ip = ntohl(addr->sin_addr.s_addr);
+			localIPs.push_back(ip);
+		}
+		remlen -= sizeof(struct ifreq);
+		startptr += sizeof(struct ifreq);
+	
+#endif // RTP_HAVE_SOCKADDR_LEN
+	}
+
+	if (localIPs.empty())
+		return false;
+	return true;
+}
+
+#endif // WIN32
+*/
+void RTPGSTv4Transmitter::GetLocalIPList_DNS()
+{
+	struct hostent *he;
+	char name[1024];
+	u_int32_t ip;
+	bool done;
+	int i,j;
+
+	gethostname(name,1023);
+	name[1023] = 0;
+	he = gethostbyname(name);
+	if (he == 0)
+		return;
+	
+	ip = 0;
+	i = 0;
+	done = false;
+	while (!done)
+	{
+		if (he->h_addr_list[i] == NULL)
+			done = true;
+		else
+		{
+			ip = 0;
+			for (j = 0 ; j < 4 ; j++)
+				ip |= ((u_int32_t)((unsigned char)he->h_addr_list[i][j])<<((3-j)*8));
+			localIPs.push_back(ip);
+			i++;
+		}
+	}
+}
+
+void RTPGSTv4Transmitter::AbortWaitInternal()
+{
+/*#ifdef WIN32
+	send(abortdesc[1],"*",1,0);
+#else
+	write(abortdesc[1],"*",1);
+#endif // WIN32*/
+}
+
+void RTPGSTv4Transmitter::AddLoopbackAddress()
+{
+	u_int32_t loopbackaddr = (((u_int32_t)127)<<24)|((u_int32_t)1);
+	std::list<u_int32_t>::const_iterator it;
+	bool found = false;
+	
+	for (it = localIPs.begin() ; !found && it != localIPs.end() ; it++)
+	{
+		if (*it == loopbackaddr)
+			found = true;
+	}
+
+	if (!found)
+		localIPs.push_back(loopbackaddr);
+}
+
+#ifdef RTPDEBUG
+void RTPGSTv4Transmitter::Dump()
+{
+	if (!init)
+		std::cout << "Not initialized" << std::endl;
+	else
+	{
+		MAINMUTEX_LOCK
+	
+		if (!created)
+			std::cout << "Not created" << std::endl;
+		else
+		{
+			char str[1024];
+			u_int32_t ip;
+			std::list<u_int32_t>::const_iterator it;
+			
+			std::cout << "Portbase:                       " << params->GetPortbase() << std::endl;
+			std::cout << "Local IP addresses:" << std::endl;
+			for (it = localIPs.begin() ; it != localIPs.end() ; it++)
+			{
+				ip = (*it);
+				sprintf(str,"%d.%d.%d.%d",(int)((ip>>24)&0xFF),(int)((ip>>16)&0xFF),(int)((ip>>8)&0xFF),(int)(ip&0xFF));
+				std::cout << "    " << str << std::endl;
+			}
+//			std::cout << "Multicast TTL:                  " << (int)multicastTTL << std::endl;
+			std::cout << "Receive mode:                   ";
+			switch (receivemode)
+			{
+			case RTPTransmitter::AcceptAll:
+				std::cout << "Accept all";
+				break;
+			case RTPTransmitter::AcceptSome:
+				std::cout << "Accept some";
+				break;
+			case RTPTransmitter::IgnoreSome:
+				std::cout << "Ignore some";
+			}
+			std::cout << std::endl;
+			if (receivemode != RTPTransmitter::AcceptAll)
+			{
+				acceptignoreinfo.GotoFirstElement();
+				while(acceptignoreinfo.HasCurrentElement())
+				{
+					ip = acceptignoreinfo.GetCurrentKey();
+					sprintf(str,"%d.%d.%d.%d",(int)((ip>>24)&0xFF),(int)((ip>>16)&0xFF),(int)((ip>>8)&0xFF),(int)(ip&0xFF));
+					PortInfo *pinfo = acceptignoreinfo.GetCurrentElement();
+					std::cout << "    " << str << ": ";
+					if (pinfo->all)
+					{
+						std::cout << "All ports";
+						if (!pinfo->portlist.empty())
+							std::cout << ", except ";
+					}
+					
+					std::list<u_int16_t>::const_iterator it;
+					
+					for (it = pinfo->portlist.begin() ; it != pinfo->portlist.end() ; )
+					{
+						std::cout << (*it);
+						it++;
+						if (it != pinfo->portlist.end())
+							std::cout << ", ";
+					}
+					std::cout << std::endl;
+				}
+			}
+			
+			std::cout << "Local host name:                ";
+			if (localhostname == 0)
+				std::cout << "Not set";
+			else
+				std::cout << localhostname;
+			std::cout << std::endl;
+
+			std::cout << "List of destinations:           ";
+			destinations.GotoFirstElement();
+			if (destinations.HasCurrentElement())
+			{
+				std::cout << std::endl;
+				do
+				{
+					std::cout << "    " << destinations.GetCurrentElement().GetDestinationString() << std::endl;
+					destinations.GotoNextElement();
+				} while (destinations.HasCurrentElement());
+			}
+			else
+				std::cout << "Empty" << std::endl;
+		
+			std::cout << "Supports multicasting:          " << ((supportsmulticasting)?"Yes":"No") << std::endl;
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+/*			std::cout << "List of multicast groups:       ";
+			multicastgroups.GotoFirstElement();
+			if (multicastgroups.HasCurrentElement())
+			{
+				std::cout << std::endl;
+				do
+				{
+					ip = multicastgroups.GetCurrentElement();
+					sprintf(str,"%d.%d.%d.%d",(int)((ip>>24)&0xFF),(int)((ip>>16)&0xFF),(int)((ip>>8)&0xFF),(int)(ip&0xFF));
+					std::cout << "    " << str << std::endl;
+					multicastgroups.GotoNextElement();
+				} while (multicastgroups.HasCurrentElement());
+			}
+			else
+				std::cout << "Empty" << std::endl;*/
+#endif // RTP_SUPPORT_IPV4MULTICAST
+			
+			std::cout << "Number of raw packets in queue: " << rawpacketlist.size() << std::endl;
+			std::cout << "Maximum allowed packet size:    " << maxpacksize << std::endl;
+			std::cout << "RTP packet count:               " << rtppackcount << std::endl;
+			std::cout << "RTCP packet count:              " << rtcppackcount << std::endl;
+		}
+		
+		MAINMUTEX_UNLOCK
+	}
+}
+#endif // RTPDEBUG
+
+#endif // RTP_SUPPORT_GST
+

Added: konference/src/rtp/jrtplib/rtpgsttransmitter.h
===================================================================
--- konference/src/rtp/jrtplib/rtpgsttransmitter.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpgsttransmitter.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,234 @@
+/*
+
+  This class allows for jrtp to send GstBuffers. Allows for integration of RTP 
+  into gstreamer.
+  Copyright (c) 2005 Philippe Khalaf <burger at speedy.org>
+  
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2004 Jori Liesenborgs
+
+  Contact: jori at lumumba.luc.ac.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.luc.ac.be), a research center of the "Limburgs Universitair
+  Centrum" (http://www.luc.ac.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPGSTV4TRANSMITTER_H
+
+#define RTPGSTV4TRANSMITTER_H
+
+#include "rtpconfig.h"
+
+#ifdef RTP_SUPPORT_GST
+
+#include "rtptransmitter.h"
+#include "rtpipv4destination.h"
+#include "rtphashtable.h"
+#include "rtpkeyhashtable.h"
+#include <list>
+
+#include <gst/gst.h>
+#include <gst/net/gstnetbuffer.h>
+
+#ifdef RTP_SUPPORT_THREAD
+	#include <jmutex.h>
+#endif // RTP_SUPPORT_THREAD
+
+#define RTPGSTv4TRANS_HASHSIZE									8317
+#define RTPGSTv4TRANS_DEFAULTPORTBASE								5000
+
+class RTPGSTv4TransmissionParams : public RTPTransmissionParams
+{
+public:
+	RTPGSTv4TransmissionParams():RTPTransmissionParams(RTPTransmitter::IPv4GSTProto)	{ portbase = RTPGSTv4TRANS_DEFAULTPORTBASE; bindIP = 0; multicastTTL = 1; rtpsrcpad = NULL, rtcpsrcpad = NULL; currentdata = NULL;}
+	void SetBindIP(u_int32_t ip)								{ bindIP = ip; }
+	void SetPortbase(u_int16_t pbase)							{ portbase = pbase; }
+	void SetMulticastTTL(u_int8_t mcastTTL)							{ multicastTTL = mcastTTL; }
+	void SetLocalIPList(std::list<u_int32_t> &iplist)					{ localIPs = iplist; } 
+	void ClearLocalIPList()									{ localIPs.clear(); }
+    void SetGstRTPSrc(GstPad *src)                          { rtpsrcpad = src; }
+    void SetGstRTCPSrc(GstPad *src)                          { rtcpsrcpad = src; }
+    void SetCurrentData(GstNetBuffer *data)                      { currentdata = data; }
+    void SetCurrentDataType(bool type)                      { currentdatatype = type; }
+	u_int32_t GetBindIP() const								{ return bindIP; }
+	u_int16_t GetPortbase() const								{ return portbase; }
+	u_int8_t GetMulticastTTL() const							{ return multicastTTL; }
+	const std::list<u_int32_t> &GetLocalIPList() const					{ return localIPs; }
+    GstPad* GetGstRTPSrc() const                         { return rtpsrcpad; }
+    GstPad* GetGstRTCPSrc() const                          { return rtcpsrcpad; }
+    GstNetBuffer* GetCurrentData() const                     { return currentdata; }
+    bool GetCurrentDataType() const                     { return currentdatatype; }
+private:
+	u_int16_t portbase;
+	u_int32_t bindIP;
+	std::list<u_int32_t> localIPs;
+	u_int8_t multicastTTL;
+    GstPad *rtpsrcpad;
+    GstPad *rtcpsrcpad;
+    bool currentdatatype;
+    GstNetBuffer* currentdata;
+};
+
+class RTPGSTv4TransmissionInfo : public RTPTransmissionInfo
+{
+public:
+	RTPGSTv4TransmissionInfo(std::list<u_int32_t> iplist,
+            GstPad* rtpsrc, GstPad* rtcpsrc, RTPGSTv4TransmissionParams *transparams) : 
+        RTPTransmissionInfo(RTPTransmitter::IPv4GSTProto) 
+    { localIPlist = iplist; rtpsrcpad = rtpsrc;
+        rtcpsrcpad = rtcpsrc; params = transparams; } 
+
+	~RTPGSTv4TransmissionInfo()								{ }
+	std::list<u_int32_t> GetLocalIPList() const						{ return localIPlist; }
+    GstPad* GetGstRTPSrc()                          { return rtpsrcpad; }
+    GstPad* GetGstRTCPSrc()                          { return rtcpsrcpad; }
+    RTPGSTv4TransmissionParams* GetTransParams()             { return params; }
+private:
+	std::list<u_int32_t> localIPlist;
+    GstPad *rtpsrcpad;
+    GstPad *rtcpsrcpad;
+    RTPGSTv4TransmissionParams *params;
+};
+	
+#ifdef RTP_SUPPORT_INLINETEMPLATEPARAM
+	inline int RTPGSTv4Trans_GetHashIndex_IPv4Dest(const RTPIPv4Destination &d)				{ return d.GetIP_HBO()%RTPGSTv4TRANS_HASHSIZE; }
+	inline int RTPGSTv4Trans_GetHashIndex_u_int32_t(const u_int32_t &k)					{ return k%RTPGSTv4TRANS_HASHSIZE; }
+#else // No support for inline function as template parameter
+	int RTPGSTv4Trans_GetHashIndex_IPv4Dest(const RTPIPv4Destination &d);
+	int RTPGSTv4Trans_GetHashIndex_u_int32_t(const u_int32_t &k);
+#endif // RTP_SUPPORT_INLINETEMPLATEPARAM
+
+#define RTPGSTv4TRANS_HEADERSIZE						(20+8)
+	
+class RTPGSTv4Transmitter : public RTPTransmitter
+{
+public:
+	RTPGSTv4Transmitter();
+	~RTPGSTv4Transmitter();
+
+	int Init(bool treadsafe);
+	int Create(size_t maxpacksize,const RTPTransmissionParams *transparams);
+	void Destroy();
+	RTPTransmissionInfo *GetTransmissionInfo();
+
+	int GetLocalHostName(u_int8_t *buffer,size_t *bufferlength);
+	bool ComesFromThisTransmitter(const RTPAddress *addr);
+	size_t GetHeaderOverhead()							{ return RTPGSTv4TRANS_HEADERSIZE; }
+	
+	int Poll();
+	int WaitForIncomingData(const RTPTime &delay,bool *dataavailable = 0);
+	int AbortWait();
+	
+	int SendRTPData(const void *data,size_t len);	
+	int SendRTCPData(const void *data,size_t len);
+
+	void ResetPacketCount();
+	u_int32_t GetNumRTPPacketsSent();
+	u_int32_t GetNumRTCPPacketsSent();
+				
+	int AddDestination(const RTPAddress &addr);
+	int DeleteDestination(const RTPAddress &addr);
+	void ClearDestinations();
+
+	bool SupportsMulticasting();
+	int JoinMulticastGroup(const RTPAddress &addr);
+	int LeaveMulticastGroup(const RTPAddress &addr);
+	void LeaveAllMulticastGroups();
+
+	int SetReceiveMode(RTPTransmitter::ReceiveMode m);
+	int AddToIgnoreList(const RTPAddress &addr);
+	int DeleteFromIgnoreList(const RTPAddress &addr);
+	void ClearIgnoreList();
+	int AddToAcceptList(const RTPAddress &addr);
+	int DeleteFromAcceptList(const RTPAddress &addr);
+	void ClearAcceptList();
+	int SetMaximumPacketSize(size_t s);	
+	
+	bool NewDataAvailable();
+	RTPRawPacket *GetNextPacket();
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+private:
+	int CreateLocalIPList();
+	bool GetLocalIPList_Interfaces();
+	void GetLocalIPList_DNS();
+	void AddLoopbackAddress();
+	void FlushPackets();
+	int FakePoll();
+	int ProcessAddAcceptIgnoreEntry(u_int32_t ip,u_int16_t port);
+	int ProcessDeleteAcceptIgnoreEntry(u_int32_t ip,u_int16_t port);
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+	bool SetMulticastTTL(u_int8_t ttl);
+#endif // RTP_SUPPORT_IPV4MULTICAST
+	bool ShouldAcceptData(u_int32_t srcip,u_int16_t srcport);
+	void ClearAcceptIgnoreInfo();
+	
+    RTPGSTv4TransmissionParams *params;
+	bool init;
+	bool created;
+	bool waitingfordata;
+	std::list<u_int32_t> localIPs;
+	u_int16_t portbase;
+	u_int8_t multicastTTL;
+	RTPTransmitter::ReceiveMode receivemode;
+
+	u_int8_t *localhostname;
+	size_t localhostnamelength;
+	
+	RTPHashTable<const RTPIPv4Destination,RTPGSTv4Trans_GetHashIndex_IPv4Dest,RTPGSTv4TRANS_HASHSIZE> destinations;
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+//	RTPHashTable<const u_int32_t,RTPGSTv4Trans_GetHashIndex_u_int32_t,RTPGSTv4TRANS_HASHSIZE> multicastgroups;
+#endif // RTP_SUPPORT_IPV4MULTICAST
+	std::list<RTPRawPacket*> rawpacketlist;
+
+	bool supportsmulticasting;
+	size_t maxpacksize;
+
+	class PortInfo
+	{
+	public:
+		PortInfo() { all = false; }
+		
+		bool all;
+		std::list<u_int16_t> portlist;
+	};
+
+	RTPKeyHashTable<const u_int32_t,PortInfo*,RTPGSTv4Trans_GetHashIndex_u_int32_t,RTPGSTv4TRANS_HASHSIZE> acceptignoreinfo;
+
+	int CreateAbortDescriptors();
+	void DestroyAbortDescriptors();
+	void AbortWaitInternal();
+#ifdef RTP_SUPPORT_THREAD
+	JMutex mainmutex,waitmutex;
+	int threadsafe;
+#endif // RTP_SUPPORT_THREAD
+
+	u_int32_t rtppackcount,rtcppackcount;
+};
+
+#endif // RTP_SUPPORT_GST
+
+#endif // RTPGSTv4TRANSMITTER_H
+

Added: konference/src/rtp/jrtplib/rtphashtable.h
===================================================================
--- konference/src/rtp/jrtplib/rtphashtable.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtphashtable.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,325 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPHASHTABLE_H
+
+#define RTPHASHTABLE_H
+
+#include "rtperrors.h"
+
+#ifdef RTPDEBUG
+#include <iostream>
+#endif // RTPDEBUG
+
+template<class Element,int GetIndex(const Element &k),int hashsize>
+class RTPHashTable
+{
+public:
+	RTPHashTable();
+	~RTPHashTable()						{ Clear(); }
+
+	void GotoFirstElement()					{ curhashelem = firsthashelem; }
+	void GotoLastElement()					{ curhashelem = lasthashelem; }
+	bool HasCurrentElement()				{ return (curhashelem == 0)?false:true; }
+	int DeleteCurrentElement();
+	Element &GetCurrentElement()				{ return curhashelem->GetElement(); }
+	int GotoElement(const Element &e);
+	bool HasElement(const Element &e);
+	void GotoNextElement();
+	void GotoPreviousElement();
+	void Clear();
+
+	int AddElement(const Element &elem);
+	int DeleteElement(const Element &elem);
+
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+private:
+	class HashElement
+	{
+	public:
+		HashElement(const Element &e,int index):element(e) { hashprev = 0; hashnext = 0; listnext = 0; listprev = 0; hashindex = index; }
+		int GetHashIndex() 						{ return hashindex; }
+		Element &GetElement()						{ return element; }
+#ifdef RTPDEBUG
+		void Dump()							{ std::cout << "\tHash index " << hashindex << " | Element " << element << std::endl; }
+#endif // RTPDEBUG
+	private:
+		int hashindex;
+		Element element;
+	public:
+		HashElement *hashprev,*hashnext;
+		HashElement *listprev,*listnext;
+	};
+
+	HashElement *table[hashsize];
+	HashElement *firsthashelem,*lasthashelem;
+	HashElement *curhashelem;
+};
+
+template<class Element,int GetIndex(const Element &e),int hashsize>
+inline RTPHashTable<Element,GetIndex,hashsize>::RTPHashTable()
+{
+	for (int i = 0 ; i < hashsize ; i++)
+		table[i] = 0;
+	firsthashelem = 0;
+	lasthashelem = 0;
+}
+
+template<class Element,int GetIndex(const Element &e),int hashsize>
+inline int RTPHashTable<Element,GetIndex,hashsize>::DeleteCurrentElement()
+{
+	if (curhashelem)
+	{
+		HashElement *tmp1,*tmp2;
+		int index;
+		
+		// First, relink elements in current hash bucket
+		
+		index = curhashelem->GetHashIndex();
+		tmp1 = curhashelem->hashprev;
+		tmp2 = curhashelem->hashnext;
+		if (tmp1 == 0) // no previous element in hash bucket
+		{
+			table[index] = tmp2;
+			if (tmp2 != 0)
+				tmp2->hashprev = 0;
+		}
+		else // there is a previous element in the hash bucket
+		{
+			tmp1->hashnext = tmp2;
+			if (tmp2 != 0)
+				tmp2->hashprev = 0;
+		}
+
+		// Relink elements in list
+		
+		tmp1 = curhashelem->listprev;
+		tmp2 = curhashelem->listnext;
+		if (tmp1 == 0) // curhashelem is first in list
+		{
+			firsthashelem = tmp2;
+			if (tmp2 != 0)
+				tmp2->listprev = 0;
+			else // curhashelem is also last in list
+				lasthashelem = 0;	
+		}
+		else
+		{
+			tmp1->listnext = tmp2;
+			if (tmp2 != 0)
+				tmp2->listprev = tmp1;
+			else // curhashelem is last in list
+				lasthashelem = tmp1;
+		}
+		
+		// finally, with everything being relinked, we can delete curhashelem
+		delete curhashelem;
+		curhashelem = tmp2; // Set to next element in the list
+	}
+	else
+		return ERR_RTP_HASHTABLE_NOCURRENTELEMENT;
+	return 0;
+}
+
+template<class Element,int GetIndex(const Element &e),int hashsize>
+inline int RTPHashTable<Element,GetIndex,hashsize>::GotoElement(const Element &e)
+{
+	int index;
+	bool found;
+	
+	index = GetIndex(e);
+	if (index >= hashsize)
+		return ERR_RTP_HASHTABLE_FUNCTIONRETURNEDINVALIDHASHINDEX;
+	
+	curhashelem = table[index]; 
+	found = false;
+	while(!found && curhashelem != 0)
+	{
+		if (curhashelem->GetElement() == e)
+			found = true;
+		else
+			curhashelem = curhashelem->hashnext;
+	}
+	if (!found)
+		return ERR_RTP_HASHTABLE_ELEMENTNOTFOUND;
+	return 0;
+}
+
+template<class Element,int GetIndex(const Element &e),int hashsize>
+inline bool RTPHashTable<Element,GetIndex,hashsize>::HasElement(const Element &e)
+{
+	int index;
+	bool found;
+	HashElement *tmp;
+	
+	index = GetIndex(e);
+	if (index >= hashsize)
+		return false;
+	
+	tmp = table[index]; 
+	found = false;
+	while(!found && tmp != 0)
+	{
+		if (tmp->GetElement() == e)
+			found = true;
+		else
+			tmp = tmp->hashnext;
+	}
+	return found;
+}
+
+template<class Element,int GetIndex(const Element &e),int hashsize>
+inline void RTPHashTable<Element,GetIndex,hashsize>::GotoNextElement()
+{
+	if (curhashelem)
+		curhashelem = curhashelem->listnext;
+}
+
+template<class Element,int GetIndex(const Element &e),int hashsize>
+inline void RTPHashTable<Element,GetIndex,hashsize>::GotoPreviousElement()
+{
+	if (curhashelem)
+		curhashelem = curhashelem->listprev;
+}
+
+template<class Element,int GetIndex(const Element &e),int hashsize>
+inline void RTPHashTable<Element,GetIndex,hashsize>::Clear()
+{
+	HashElement *tmp1,*tmp2;
+	
+	for (int i = 0 ; i < hashsize ; i++)
+		table[i] = 0;
+	
+	tmp1 = firsthashelem;
+	while (tmp1 != 0)
+	{
+		tmp2 = tmp1->listnext;
+		delete tmp1;
+		tmp1 = tmp2;
+	}
+	firsthashelem = 0;
+	lasthashelem = 0;
+}
+
+template<class Element,int GetIndex(const Element &e),int hashsize>
+inline int RTPHashTable<Element,GetIndex,hashsize>::AddElement(const Element &elem)
+{
+	int index;
+	bool found;
+	HashElement *e,*newelem;
+	
+	index = GetIndex(elem);
+	if (index >= hashsize)
+		return ERR_RTP_HASHTABLE_FUNCTIONRETURNEDINVALIDHASHINDEX;
+	
+	e = table[index];
+	found = false;
+	while(!found && e != 0)
+	{
+		if (e->GetElement() == elem)
+			found = true;
+		else
+			e = e->hashnext;
+	}
+	if (found)
+		return ERR_RTP_HASHTABLE_ELEMENTALREADYEXISTS;
+	
+	// Okay, the key doesn't exist, so we can add the new element in the hash table
+	
+	newelem = new HashElement(elem,index);
+	if (newelem == 0)
+		return ERR_RTP_OUTOFMEM;
+
+	e = table[index];
+	table[index] = newelem;
+	newelem->hashnext = e;
+	if (e != 0)
+		e->hashprev = newelem;
+	
+	// Now, we still got to add it to the linked list
+	
+	if (firsthashelem == 0)
+	{
+		firsthashelem = newelem;
+		lasthashelem = newelem;
+	}
+	else // there already are some elements in the list
+	{
+		lasthashelem->listnext = newelem;
+		newelem->listprev = lasthashelem;
+		lasthashelem = newelem;
+	}
+	return 0;
+}
+
+template<class Element,int GetIndex(const Element &e),int hashsize>
+inline int RTPHashTable<Element,GetIndex,hashsize>::DeleteElement(const Element &elem)
+{
+	int status;
+
+	status = GotoElement(elem);
+	if (status < 0)
+		return status;
+	return DeleteCurrentElement();
+}
+
+#ifdef RTPDEBUG
+template<class Element,int GetIndex(const Element &e),int hashsize>
+inline void RTPHashTable<Element,GetIndex,hashsize>::Dump()
+{
+	HashElement *e;
+	
+	std::cout << "DUMPING TABLE CONTENTS:" << std::endl;
+	for (int i = 0 ; i < hashsize ; i++)
+	{
+		e = table[i];
+		while (e != 0)
+		{
+			e->Dump();
+			e = e->hashnext;
+		}
+	}
+	
+	std::cout << "DUMPING LIST CONTENTS:" << std::endl;
+	e = firsthashelem;
+	while (e != 0)
+	{
+		e->Dump();
+		e = e->listnext;
+	}
+}
+#endif // RTPDEBUG
+
+#endif // RTPHASHTABLE_H
+

Added: konference/src/rtp/jrtplib/rtpinternalsourcedata.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpinternalsourcedata.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpinternalsourcedata.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,282 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtpinternalsourcedata.h"
+#include "rtppacket.h"
+#include <string.h>
+
+#include "rtpdebug.h"
+
+#define RTPINTERNALSOURCEDATA_MAXPROBATIONPACKETS		32
+
+RTPInternalSourceData::RTPInternalSourceData(u_int32_t ssrc,RTPSources::ProbationType probtype):RTPSourceData(ssrc)
+{
+#ifdef RTP_SUPPORT_PROBATION
+	probationtype = probtype;
+#endif // RTP_SUPPORT_PROBATION
+}
+
+RTPInternalSourceData::~RTPInternalSourceData()
+{
+}
+
+// The following function should delete rtppack if necessary
+int RTPInternalSourceData::ProcessRTPPacket(RTPPacket *rtppack,const RTPTime &receivetime,bool *stored)
+{
+	bool accept,onprobation,applyprobation;
+	double tsunit;
+	
+	*stored = false;
+	
+	if (timestampunit < 0) 
+		tsunit = INF_GetEstimatedTimestampUnit();
+	else
+		tsunit = timestampunit;
+
+#ifdef RTP_SUPPORT_PROBATION
+	if (validated) 				// If the source is our own process, we can already be validated. No 
+		applyprobation = false;		// probation should be applied in that case.
+	else
+	{
+		if (probationtype == RTPSources::NoProbation)
+			applyprobation = false;
+		else
+			applyprobation = true;
+	}
+#else
+	applyprobation = false;
+#endif // RTP_SUPPORT_PROBATION
+
+	stats.ProcessPacket(rtppack,receivetime,tsunit,ownssrc,&accept,applyprobation,&onprobation);
+
+#ifdef RTP_SUPPORT_PROBATION
+	switch (probationtype)
+	{
+		case RTPSources::ProbationStore:
+			if (!(onprobation || accept))
+				return 0;
+			if (accept)
+				validated = true;
+			break;
+		case RTPSources::ProbationDiscard:
+		case RTPSources::NoProbation:
+			if (!accept)
+				return 0;
+			validated = true;
+			break;
+		default:
+			return ERR_RTP_INTERNALSOURCEDATA_INVALIDPROBATIONTYPE;
+	}
+#else
+	if (!accept)
+		return 0;
+	validated = true;
+#endif // RTP_SUPPORT_PROBATION;
+	
+	if (validated && !ownssrc) // for own ssrc these variables depend on the outgoing packets, not on the incoming
+		issender = true;
+	
+	// Now, we can place the packet in the queue
+	
+	if (packetlist.empty())
+	{
+		*stored = true;
+		packetlist.push_back(rtppack);
+		return 0;
+	}
+	
+	if (!validated) // still on probation
+	{
+		// Make sure that we don't buffer too much packets to avoid wasting memory
+		// on a bad source. Delete the packet in the queue with the lowest sequence
+		// number.
+		if (packetlist.size() == RTPINTERNALSOURCEDATA_MAXPROBATIONPACKETS)
+		{
+			RTPPacket *p = *(packetlist.begin());
+			packetlist.pop_front();
+			delete p;
+		}
+	}
+
+	// find the right position to insert the packet
+	
+	std::list<RTPPacket*>::iterator it,start;
+	bool done = false;
+	u_int32_t newseqnr = rtppack->GetExtendedSequenceNumber();
+	
+	it = packetlist.end();
+	--it;
+	start = packetlist.begin();
+	
+	while (!done)
+	{
+		RTPPacket *p;
+		u_int32_t seqnr;
+		
+		p = *it;
+		seqnr = p->GetExtendedSequenceNumber();
+		if (seqnr > newseqnr)
+		{
+			if (it != start)
+				--it;
+			else // we're at the start of the list
+			{
+				*stored = true;
+				done = true;
+				packetlist.push_front(rtppack);
+			}
+		}
+		else if (seqnr < newseqnr) // insert after this packet
+		{
+			++it;
+			packetlist.insert(it,rtppack);
+			done = true;
+			*stored = true;
+		}
+		else // they're equal !! Drop packet
+		{
+			done = true;
+		}
+	}
+
+	return 0;
+}
+
+int RTPInternalSourceData::ProcessSDESItem(u_int8_t id,const u_int8_t *data,size_t itemlen,const RTPTime &receivetime,bool *cnamecollis)
+{
+	*cnamecollis = false;
+	
+	stats.SetLastMessageTime(receivetime);
+	
+	switch(id)
+	{
+	case RTCP_SDES_ID_CNAME:
+		{
+			size_t curlen;
+			u_int8_t *oldcname;
+			
+			// NOTE: we're going to make sure that the CNAME is only set once.
+			oldcname = SDESinf.GetCNAME(&curlen);
+			if (curlen == 0)
+			{
+				// if CNAME is set, the source is validated
+				SDESinf.SetCNAME(data,itemlen);
+				validated = true;
+			}
+			else // check if this CNAME is equal to the one that is already present
+			{
+				if (curlen != itemlen)
+					*cnamecollis = true;
+				else
+				{
+					if (memcmp(data,oldcname,itemlen) != 0)
+						*cnamecollis = true;
+				}
+			}
+		}
+		break;
+	case RTCP_SDES_ID_NAME:
+		{
+			u_int8_t *oldname;
+			size_t oldlen;
+
+			oldname = SDESinf.GetName(&oldlen);
+			if (oldlen == 0) // Name not set
+				return SDESinf.SetName(data,itemlen);
+		}
+		break;
+	case RTCP_SDES_ID_EMAIL:
+		{
+			u_int8_t *oldemail;
+			size_t oldlen;
+
+			oldemail = SDESinf.GetEMail(&oldlen);
+			if (oldlen == 0)
+				return SDESinf.SetEMail(data,itemlen);
+		}
+		break;
+	case RTCP_SDES_ID_PHONE:
+		return SDESinf.SetPhone(data,itemlen);
+	case RTCP_SDES_ID_LOCATION:
+		return SDESinf.SetLocation(data,itemlen);
+	case RTCP_SDES_ID_TOOL:
+		{
+			u_int8_t *oldtool;
+			size_t oldlen;
+
+			oldtool = SDESinf.GetTool(&oldlen);
+			if (oldlen == 0)
+				return SDESinf.SetTool(data,itemlen);
+		}
+		break;
+	case RTCP_SDES_ID_NOTE:
+		stats.SetLastNoteTime(receivetime);
+		return SDESinf.SetNote(data,itemlen);
+	}
+	return 0;
+}
+
+#ifdef RTP_SUPPORT_SDESPRIV
+
+int RTPInternalSourceData::ProcessPrivateSDESItem(const u_int8_t *prefix,size_t prefixlen,const u_int8_t *value,size_t valuelen,const RTPTime &receivetime)
+{
+	int status;
+	
+	stats.SetLastMessageTime(receivetime);
+	status = SDESinf.SetPrivateValue(prefix,prefixlen,value,valuelen);
+	if (status == ERR_RTP_SDES_MAXPRIVITEMS)
+		return 0; // don't stop processing just because the number of items is full
+	return status;
+}
+
+#endif // RTP_SUPPORT_SDESPRIV
+
+int RTPInternalSourceData::ProcessBYEPacket(const u_int8_t *reason,size_t reasonlen,const RTPTime &receivetime)
+{
+	if (byereason)
+	{
+		delete [] byereason;
+		byereason = 0;
+		byereasonlen = 0;
+	}
+
+	byetime = receivetime;
+	byereason = new u_int8_t[reasonlen];
+	if (byereason == 0)
+		return ERR_RTP_OUTOFMEM;
+	memcpy(byereason,reason,reasonlen);
+	byereasonlen = reasonlen;
+	receivedbye = true;
+	stats.SetLastMessageTime(receivetime);
+	return 0;
+}
+

Added: konference/src/rtp/jrtplib/rtpinternalsourcedata.h
===================================================================
--- konference/src/rtp/jrtplib/rtpinternalsourcedata.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpinternalsourcedata.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,126 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPINTERNALSOURCEDATA_H
+
+#define RTPINTERNALSOURCEDATA_H
+
+#include "rtpconfig.h"
+#include "rtpsourcedata.h"
+#include "rtpaddress.h"
+#include "rtptimeutilities.h"
+#include "rtpsources.h"
+
+class RTPInternalSourceData : public RTPSourceData
+{
+public:
+	RTPInternalSourceData(u_int32_t ssrc, RTPSources::ProbationType probtype);
+	~RTPInternalSourceData();
+
+	int ProcessRTPPacket(RTPPacket *rtppack,const RTPTime &receivetime,bool *stored);
+	void ProcessSenderInfo(const RTPNTPTime &ntptime,u_int32_t rtptime,u_int32_t packetcount,
+	                       u_int32_t octetcount,const RTPTime &receivetime)				{ SRprevinf = SRinf; SRinf.Set(ntptime,rtptime,packetcount,octetcount,receivetime); stats.SetLastMessageTime(receivetime); }
+	void ProcessReportBlock(u_int8_t fractionlost,int32_t lostpackets,u_int32_t exthighseqnr,
+	                        u_int32_t jitter,u_int32_t lsr,u_int32_t dlsr,
+				const RTPTime &receivetime)						{ RRprevinf = RRinf; RRinf.Set(fractionlost,lostpackets,exthighseqnr,jitter,lsr,dlsr,receivetime); stats.SetLastMessageTime(receivetime); }
+	void UpdateMessageTime(const RTPTime &receivetime)						{ stats.SetLastMessageTime(receivetime); }
+	int ProcessSDESItem(u_int8_t id,const u_int8_t *data,size_t itemlen,const RTPTime &receivetime,bool *cnamecollis);
+#ifdef RTP_SUPPORT_SDESPRIV
+	int ProcessPrivateSDESItem(const u_int8_t *prefix,size_t prefixlen,const u_int8_t *value,size_t valuelen,const RTPTime &receivetime);
+#endif // RTP_SUPPORT_SDESPRIV
+	int ProcessBYEPacket(const u_int8_t *reason,size_t reasonlen,const RTPTime &receivetime);
+		
+	int SetRTPDataAddress(const RTPAddress *a);
+	int SetRTCPDataAddress(const RTPAddress *a);
+
+	void ClearSenderFlag()										{ issender = false; }
+	void SentRTPPacket()										{ if (!ownssrc) return; RTPTime t = RTPTime::CurrentTime(); issender = true; stats.SetLastRTPPacketTime(t); stats.SetLastMessageTime(t); }
+	void SetOwnSSRC()										{ ownssrc = true; validated = true; }
+	void SetCSRC()											{ validated = true; iscsrc = true; }
+	void ClearNote()										{ SDESinf.SetNote(0,0); }
+	
+#ifdef RTP_SUPPORT_PROBATION
+private:
+	RTPSources::ProbationType probationtype;
+#endif // RTP_SUPPORT_PROBATION
+};
+
+inline int RTPInternalSourceData::SetRTPDataAddress(const RTPAddress *a)
+{
+	if (a == 0)
+	{
+		if (rtpaddr)
+		{
+			delete rtpaddr;
+			rtpaddr = 0;
+		}
+	}
+	else
+	{
+		RTPAddress *newaddr = a->CreateCopy();
+		if (newaddr == 0)
+			return ERR_RTP_OUTOFMEM;
+		
+		if (rtpaddr && a != rtpaddr)
+			delete rtpaddr;
+		rtpaddr = newaddr;
+	}
+	isrtpaddrset = true;
+	return 0;
+}
+
+inline int RTPInternalSourceData::SetRTCPDataAddress(const RTPAddress *a)
+{
+	if (a == 0)
+	{
+		if (rtcpaddr)
+		{
+			delete rtcpaddr;
+			rtcpaddr = 0;
+		}
+	}
+	else
+	{
+		RTPAddress *newaddr = a->CreateCopy();
+		if (newaddr == 0)
+			return ERR_RTP_OUTOFMEM;
+		
+		if (rtcpaddr && a != rtcpaddr)
+			delete rtcpaddr;
+		rtcpaddr = newaddr;
+	}
+	isrtcpaddrset = true;
+	return 0;
+}
+	
+#endif // RTPINTERNALSOURCEDATA_H
+

Added: konference/src/rtp/jrtplib/rtpipv4address.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpipv4address.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpipv4address.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,81 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtpipv4address.h"
+#ifdef RTPDEBUG
+	#include <stdio.h>
+#endif // RTPDEBUG
+
+#include "rtpdebug.h"
+
+bool RTPIPv4Address::IsSameAddress(const RTPAddress *addr) const
+{
+	if (addr == 0)
+		return false;
+	if (addr->GetAddressType() != IPv4Address)
+		return false;
+
+	const RTPIPv4Address *addr2 = (const RTPIPv4Address *)addr;
+	if (addr2->GetIP() == ip && addr2->GetPort() == port)
+		return true;
+	return false;
+}
+
+bool RTPIPv4Address::IsFromSameHost(const RTPAddress *addr) const
+{
+	if (addr == 0)
+		return false;
+	if (addr->GetAddressType() != IPv4Address)
+		return false;
+	
+	const RTPIPv4Address *addr2 = (const RTPIPv4Address *)addr;
+	if (addr2->GetIP() == ip)
+		return true;
+	return false;
+}
+
+RTPAddress *RTPIPv4Address::CreateCopy() const
+{
+	RTPIPv4Address *a = new RTPIPv4Address(ip,port);
+	return a;
+}
+
+#ifdef RTPDEBUG
+std::string RTPIPv4Address::GetAddressString() const
+{
+	char str[1024];
+
+	sprintf(str,"%d.%d.%d.%d:%d",(int)((ip>>24)&0xFF),(int)((ip>>16)&0xFF),(int)((ip>>8)&0xFF),
+	                             (int)(ip&0xFF),(int)port);
+	return std::string(str);
+}
+#endif // RTPDEBUG

Added: konference/src/rtp/jrtplib/rtpipv4address.h
===================================================================
--- konference/src/rtp/jrtplib/rtpipv4address.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpipv4address.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,64 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPIPV4ADDRESS_H
+
+#define RTPIPV4ADDRESS_H
+
+#include "rtpconfig.h"
+#include "rtpaddress.h"
+#include "rtptypes.h"
+
+class RTPIPv4Address : public RTPAddress
+{
+public:
+	RTPIPv4Address(u_int32_t ip = 0, u_int16_t port = 0):RTPAddress(IPv4Address) 		{ RTPIPv4Address::ip = ip; RTPIPv4Address::port = port; }
+	RTPIPv4Address(const u_int8_t ip[4],u_int16_t port = 0):RTPAddress(IPv4Address)		{ RTPIPv4Address::ip = (u_int32_t)ip[3]; RTPIPv4Address::ip |= (((u_int32_t)ip[2])<<8); RTPIPv4Address::ip |= (((u_int32_t)ip[1])<<16); RTPIPv4Address::ip |= (((u_int32_t)ip[0])<<24); RTPIPv4Address::port = port; }
+	~RTPIPv4Address()									{ }
+	void SetIP(u_int32_t ip)								{ RTPIPv4Address::ip = ip; }
+	void SetIP(const u_int8_t ip[4])							{ RTPIPv4Address::ip = (u_int32_t)ip[3]; RTPIPv4Address::ip |= (((u_int32_t)ip[2])<<8); RTPIPv4Address::ip |= (((u_int32_t)ip[1])<<16); RTPIPv4Address::ip |= (((u_int32_t)ip[0])<<24); }
+	void SetPort(u_int16_t port)								{ RTPIPv4Address::port = port; }
+	u_int32_t GetIP() const									{ return ip; }
+	u_int16_t GetPort() const								{ return port; }
+	RTPAddress *CreateCopy() const;
+	bool IsSameAddress(const RTPAddress *addr) const;
+	bool IsFromSameHost(const RTPAddress *addr) const;
+#ifdef RTPDEBUG
+	std::string GetAddressString() const;
+#endif // RTPDEBUG
+private:
+	u_int32_t ip;
+	u_int16_t port;
+};
+
+#endif // RTPIPV4ADDRESS_H
+

Added: konference/src/rtp/jrtplib/rtpipv4destination.h
===================================================================
--- konference/src/rtp/jrtplib/rtpipv4destination.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpipv4destination.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,79 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPIPV4DESTINATION
+
+#define RTPIPV4DESTINATION
+
+#include "rtpconfig.h"
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include <netinet/in.h>
+#endif // WIN32
+#ifdef RTPDEBUG
+	#include <stdio.h>
+	#include <string>
+#endif // RTPDEBUG
+
+class RTPIPv4Destination
+{
+public:
+	// (nbo = network byte order, hbo = host byte order)
+	
+	RTPIPv4Destination(u_int32_t ip,u_int16_t rtpportbase)					{ ipaddr_hbo = ip; ipaddr_nbo = htonl(ip); rtpport_nbo = htons(rtpportbase); rtcpport_nbo = htons(rtpportbase+1); }
+	u_int32_t GetIP_HBO() const								{ return ipaddr_hbo; }
+	u_int32_t GetIP_NBO() const								{ return ipaddr_nbo; }
+	u_int16_t GetRTPPort_NBO() const							{ return rtpport_nbo; }
+	u_int16_t GetRTCPPort_NBO() const							{ return rtcpport_nbo; }
+	bool operator==(const RTPIPv4Destination &src) const		{ if (src.ipaddr_nbo == ipaddr_nbo && src.rtpport_nbo == rtpport_nbo) return true; return false; } // NOTE: I only check IP and portbase
+#ifdef RTPDEBUG
+	std::string GetDestinationString() const;
+#endif // RTPDEBUG
+private:
+	u_int32_t ipaddr_hbo;
+	u_int32_t ipaddr_nbo;
+	u_int16_t rtpport_nbo;
+	u_int16_t rtcpport_nbo;
+};
+
+#ifdef RTPDEBUG
+inline std::string RTPIPv4Destination::GetDestinationString() const
+{
+	char str[1024];
+	u_int32_t ip = ipaddr_hbo;
+	u_int16_t portbase = ntohs(rtpport_nbo);
+	
+	sprintf(str,"%d.%d.%d.%d:%d",(int)((ip>>24)&0xFF),(int)((ip>>16)&0xFF),(int)((ip>>8)&0xFF),(int)(ip&0xFF),(int)(portbase));
+	return std::string(str);
+}
+#endif // RTPDEBUG
+
+#endif // RTPIPV4DESTINATION

Added: konference/src/rtp/jrtplib/rtpipv6address.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpipv6address.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpipv6address.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,106 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtpipv6address.h"
+
+#ifdef RTP_SUPPORT_IPV6
+
+#ifdef RTPDEBUG
+	#include <stdio.h>
+#endif // RTPDEBUG
+
+#include "rtpdebug.h"
+
+RTPAddress *RTPIPv6Address::CreateCopy() const
+{
+	RTPIPv6Address *newaddr = new RTPIPv6Address(ip,port);
+	return newaddr;
+}
+
+bool RTPIPv6Address::IsSameAddress(const RTPAddress *addr) const
+{
+	if (addr == 0)
+		return false;
+	if (addr->GetAddressType() != RTPAddress::IPv6Address)
+		return false;
+
+	const RTPIPv6Address *addr2 = (const RTPIPv6Address *)addr;
+	const u_int8_t *ip2 = addr2->ip.s6_addr;
+	
+	if (port != addr2->port)
+		return false;
+	
+	for (int i = 0 ; i < 16 ; i++)
+	{
+		if (ip.s6_addr[i] != ip2[i])
+			return false;
+	}
+	return true;
+}
+
+bool RTPIPv6Address::IsFromSameHost(const RTPAddress *addr) const
+{
+	if (addr == 0)
+		return false;
+	if (addr->GetAddressType() != RTPAddress::IPv6Address)
+		return false;
+
+	const RTPIPv6Address *addr2 = (const RTPIPv6Address *)addr;
+	const u_int8_t *ip2 = addr2->ip.s6_addr;
+	for (int i = 0 ; i < 16 ; i++)
+	{
+		if (ip.s6_addr[i] != ip2[i])
+			return false;
+	}
+	return true;
+}
+
+#ifdef RTPDEBUG
+std::string RTPIPv6Address::GetAddressString() const
+{
+	char str[256];
+	u_int16_t ip16[8];
+	int i,j;
+
+	for (i = 0,j = 0 ; j < 8 ; j++,i += 2)
+	{
+		ip16[j] = (((u_int16_t)ip.s6_addr[i])<<8);
+		ip16[j] |= ((u_int16_t)ip.s6_addr[i+1]);
+	}
+	
+	sprintf(str,"%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X - %d",(int)ip16[0],(int)ip16[1],(int)ip16[2],(int)ip16[3],(int)ip16[4],(int)ip16[5],(int)ip16[6],(int)ip16[7],(int)port);
+	return std::string(str);
+}
+#endif // RTPDEBUG
+
+#endif // RTP_SUPPORT_IPV6
+

Added: konference/src/rtp/jrtplib/rtpipv6address.h
===================================================================
--- konference/src/rtp/jrtplib/rtpipv6address.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpipv6address.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,75 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPIPV6ADDRESS_H
+
+#define RTPIPV6ADDRESS_H
+
+#include "rtpconfig.h"
+
+#ifdef RTP_SUPPORT_IPV6
+
+#include "rtpaddress.h"
+#include "rtptypes.h"
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include <netinet/in.h>
+#endif // WIN32
+
+class RTPIPv6Address : public RTPAddress
+{
+public:
+	RTPIPv6Address():RTPAddress(IPv6Address)						{ for (int i = 0 ; i < 16 ; i++) ip.s6_addr[i] = 0; port = 0; }
+	RTPIPv6Address(const u_int8_t ip[16],u_int16_t port = 0):RTPAddress(IPv6Address)	{ SetIP(ip); RTPIPv6Address::port = port; }
+	RTPIPv6Address(in6_addr ip,u_int16_t port = 0):RTPAddress(IPv6Address)			{ RTPIPv6Address::ip = ip; RTPIPv6Address::port = port; }
+	~RTPIPv6Address()									{ }
+	void SetIP(in6_addr ip)									{ RTPIPv6Address::ip = ip; }
+	void SetIP(const u_int8_t ip[16])							{ for (int i = 0 ; i < 16 ; i++) RTPIPv6Address::ip.s6_addr[i] = ip[i]; }
+	void SetPort(u_int16_t port)								{ RTPIPv6Address::port = port; }
+	void GetIP(u_int8_t ip[16]) const							{ for (int i = 0 ; i < 16 ; i++) ip[i] = RTPIPv6Address::ip.s6_addr[i]; }
+	in6_addr GetIP() const									{ return ip; }
+	u_int16_t GetPort() const								{ return port; }
+
+	RTPAddress *CreateCopy() const;
+	bool IsSameAddress(const RTPAddress *addr) const;
+	bool IsFromSameHost(const RTPAddress *addr) const;
+#ifdef RTPDEBUG
+	std::string GetAddressString() const;
+#endif // RTPDEBUG
+private:
+	in6_addr ip;
+	u_int16_t port;
+};
+
+#endif // RTP_SUPPORT_IPV6
+
+#endif // RTPIPV6ADDRESS_H
+

Added: konference/src/rtp/jrtplib/rtpipv6destination.h
===================================================================
--- konference/src/rtp/jrtplib/rtpipv6destination.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpipv6destination.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,83 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPIPV6DESTINATION
+
+#define RTPIPV6DESTINATION
+
+#include "rtpconfig.h"
+
+#ifdef RTP_SUPPORT_IPV6
+
+#include "rtptypes.h"
+#include <string.h>
+#ifndef WIN32
+	#include <netinet/in.h>
+#endif // WIN32
+#ifdef RTPDEBUG
+	#include <stdio.h>
+	#include <string>
+#endif // RTPDEBUG
+
+class RTPIPv6Destination
+{
+public:
+	RTPIPv6Destination(in6_addr ip,u_int16_t portbase)	 			{ RTPIPv6Destination::ip = ip; rtpport_nbo = htons(portbase); rtcpport_nbo = htons(portbase+1); }
+	in6_addr GetIP() const								{ return ip; }
+	u_int16_t GetRTPPort_NBO() const						{ return rtpport_nbo; }
+	u_int16_t GetRTCPPort_NBO() const						{ return rtcpport_nbo; }
+	bool operator==(const RTPIPv6Destination &src) const				{ if (src.rtpport_nbo == rtpport_nbo && (memcmp(&(src.ip),&ip,sizeof(in6_addr)) == 0)) return true; return false; } // NOTE: I only check IP and portbase
+#ifdef RTPDEBUG
+	std::string GetDestinationString() const;
+#endif // RTPDEBUG
+private:
+	in6_addr ip;
+	u_int16_t rtpport_nbo,rtcpport_nbo;
+};
+
+#ifdef RTPDEBUG
+inline std::string RTPIPv6Destination::GetDestinationString() const
+{
+	u_int16_t ip16[8];
+	char str[1024];
+	u_int16_t portbase = ntohs(rtpport_nbo);
+	int i,j;
+	for (i = 0,j = 0 ; j < 8 ; j++,i += 2)	{ ip16[j] = (((u_int16_t)ip.s6_addr[i])<<8); ip16[j] |= ((u_int16_t)ip.s6_addr[i+1]); }
+	sprintf(str,"%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X/%d",(int)ip16[0],(int)ip16[1],(int)ip16[2],(int)ip16[3],(int)ip16[4],(int)ip16[5],(int)ip16[6],(int)ip16[7],(int)portbase);
+	return std::string(str);
+}
+#endif // RTPDEBUG
+
+#endif // RTP_SUPPORT_IPV6
+
+#endif // RTPIPV6DESTINATION
+

Added: konference/src/rtp/jrtplib/rtpkeyhashtable.h
===================================================================
--- konference/src/rtp/jrtplib/rtpkeyhashtable.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpkeyhashtable.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,328 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPKEYHASHTABLE_H
+
+#define RTPKEYHASHTABLE_H
+
+#include "rtpconfig.h"
+#include "rtperrors.h"
+
+#ifdef RTPDEBUG
+#include <iostream>
+#endif // RTPDEBUG
+
+template<class Key,class Element,int GetIndex(const Key &k),int hashsize>
+class RTPKeyHashTable
+{
+public:
+	RTPKeyHashTable();
+	~RTPKeyHashTable()					{ Clear(); }
+
+	void GotoFirstElement()					{ curhashelem = firsthashelem; }
+	void GotoLastElement()					{ curhashelem = lasthashelem; }
+	bool HasCurrentElement()				{ return (curhashelem == 0)?false:true; }
+	int DeleteCurrentElement();
+	Element &GetCurrentElement()				{ return curhashelem->GetElement(); }
+	Key &GetCurrentKey()					{ return curhashelem->GetKey(); }
+	int GotoElement(const Key &k);
+	bool HasElement(const Key &k);
+	void GotoNextElement();
+	void GotoPreviousElement();
+	void Clear();
+
+	int AddElement(const Key &k,const Element &elem);
+	int DeleteElement(const Key &k);
+
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+private:
+	class HashElement
+	{
+	public:
+		HashElement(const Key &k,const Element &e,int index):key(k),element(e) { hashprev = 0; hashnext = 0; listnext = 0; listprev = 0; hashindex = index; }
+		int GetHashIndex() 						{ return hashindex; }
+		Key &GetKey()							{ return key; }
+		Element &GetElement()						{ return element; }
+#ifdef RTPDEBUG
+		void Dump()							{ std::cout << "\tHash index " << hashindex << " | Key " << key << " | Element " << element << std::endl; }
+#endif // RTPDEBUG
+	private:
+		int hashindex;
+		Key key;
+		Element element;
+	public:
+		HashElement *hashprev,*hashnext;
+		HashElement *listprev,*listnext;
+	};
+
+	HashElement *table[hashsize];
+	HashElement *firsthashelem,*lasthashelem;
+	HashElement *curhashelem;
+};
+
+template<class Key,class Element,int GetIndex(const Key &k),int hashsize>
+inline RTPKeyHashTable<Key,Element,GetIndex,hashsize>::RTPKeyHashTable()
+{
+	for (int i = 0 ; i < hashsize ; i++)
+		table[i] = 0;
+	firsthashelem = 0;
+	lasthashelem = 0;
+}
+
+template<class Key,class Element,int GetIndex(const Key &k),int hashsize>
+inline int RTPKeyHashTable<Key,Element,GetIndex,hashsize>::DeleteCurrentElement()
+{
+	if (curhashelem)
+	{
+		HashElement *tmp1,*tmp2;
+		int index;
+		
+		// First, relink elements in current hash bucket
+		
+		index = curhashelem->GetHashIndex();
+		tmp1 = curhashelem->hashprev;
+		tmp2 = curhashelem->hashnext;
+		if (tmp1 == 0) // no previous element in hash bucket
+		{
+			table[index] = tmp2;
+			if (tmp2 != 0)
+				tmp2->hashprev = 0;
+		}
+		else // there is a previous element in the hash bucket
+		{
+			tmp1->hashnext = tmp2;
+			if (tmp2 != 0)
+				tmp2->hashprev = 0;
+		}
+
+		// Relink elements in list
+		
+		tmp1 = curhashelem->listprev;
+		tmp2 = curhashelem->listnext;
+		if (tmp1 == 0) // curhashelem is first in list
+		{
+			firsthashelem = tmp2;
+			if (tmp2 != 0)
+				tmp2->listprev = 0;
+			else // curhashelem is also last in list
+				lasthashelem = 0;	
+		}
+		else
+		{
+			tmp1->listnext = tmp2;
+			if (tmp2 != 0)
+				tmp2->listprev = tmp1;
+			else // curhashelem is last in list
+				lasthashelem = tmp1;
+		}
+		
+		// finally, with everything being relinked, we can delete curhashelem
+		delete curhashelem;
+		curhashelem = tmp2; // Set to next element in list
+	}
+	else
+		return ERR_RTP_KEYHASHTABLE_NOCURRENTELEMENT;
+	return 0;
+}
+	
+template<class Key,class Element,int GetIndex(const Key &k),int hashsize>
+inline int RTPKeyHashTable<Key,Element,GetIndex,hashsize>::GotoElement(const Key &k)
+{
+	int index;
+	bool found;
+	
+	index = GetIndex(k);
+	if (index >= hashsize)
+		return ERR_RTP_KEYHASHTABLE_FUNCTIONRETURNEDINVALIDHASHINDEX;
+	
+	curhashelem = table[index]; 
+	found = false;
+	while(!found && curhashelem != 0)
+	{
+		if (curhashelem->GetKey() == k)
+			found = true;
+		else
+			curhashelem = curhashelem->hashnext;
+	}
+	if (!found)
+		return ERR_RTP_KEYHASHTABLE_KEYNOTFOUND;
+	return 0;
+}
+
+template<class Key,class Element,int GetIndex(const Key &k),int hashsize>
+inline bool RTPKeyHashTable<Key,Element,GetIndex,hashsize>::HasElement(const Key &k)
+{
+	int index;
+	bool found;
+	HashElement *tmp;
+	
+	index = GetIndex(k);
+	if (index >= hashsize)
+		return false;
+	
+	tmp = table[index]; 
+	found = false;
+	while(!found && tmp != 0)
+	{
+		if (tmp->GetKey() == k)
+			found = true;
+		else
+			tmp = tmp->hashnext;
+	}
+	return found;
+}
+
+template<class Key,class Element,int GetIndex(const Key &k),int hashsize>
+inline void RTPKeyHashTable<Key,Element,GetIndex,hashsize>::GotoNextElement()
+{
+	if (curhashelem)
+		curhashelem = curhashelem->listnext;
+}
+
+template<class Key,class Element,int GetIndex(const Key &k),int hashsize>
+inline void RTPKeyHashTable<Key,Element,GetIndex,hashsize>::GotoPreviousElement()
+{
+	if (curhashelem)
+		curhashelem = curhashelem->listprev;
+}
+
+template<class Key,class Element,int GetIndex(const Key &k),int hashsize>
+inline void RTPKeyHashTable<Key,Element,GetIndex,hashsize>::Clear()
+{
+	HashElement *tmp1,*tmp2;
+	
+	for (int i = 0 ; i < hashsize ; i++)
+		table[i] = 0;
+	
+	tmp1 = firsthashelem;
+	while (tmp1 != 0)
+	{
+		tmp2 = tmp1->listnext;
+		delete tmp1;
+		tmp1 = tmp2;
+	}
+	firsthashelem = 0;
+	lasthashelem = 0;
+}
+
+template<class Key,class Element,int GetIndex(const Key &k),int hashsize>
+inline int RTPKeyHashTable<Key,Element,GetIndex,hashsize>::AddElement(const Key &k,const Element &elem)
+{
+	int index;
+	bool found;
+	HashElement *e,*newelem;
+	
+	index = GetIndex(k);
+	if (index >= hashsize)
+		return ERR_RTP_KEYHASHTABLE_FUNCTIONRETURNEDINVALIDHASHINDEX;
+	
+	e = table[index];
+	found = false;
+	while(!found && e != 0)
+	{
+		if (e->GetKey() == k)
+			found = true;
+		else
+			e = e->hashnext;
+	}
+	if (found)
+		return ERR_RTP_KEYHASHTABLE_KEYALREADYEXISTS;
+	
+	// Okay, the key doesn't exist, so we can add the new element in the hash table
+	
+	newelem = new HashElement(k,elem,index);
+	if (newelem == 0)
+		return ERR_RTP_OUTOFMEM;
+
+	e = table[index];
+	table[index] = newelem;
+	newelem->hashnext = e;
+	if (e != 0)
+		e->hashprev = newelem;
+	
+	// Now, we still got to add it to the linked list
+	
+	if (firsthashelem == 0)
+	{
+		firsthashelem = newelem;
+		lasthashelem = newelem;
+	}
+	else // there already are some elements in the list
+	{
+		lasthashelem->listnext = newelem;
+		newelem->listprev = lasthashelem;
+		lasthashelem = newelem;
+	}
+	return 0;
+}
+
+template<class Key,class Element,int GetIndex(const Key &k),int hashsize>
+inline int RTPKeyHashTable<Key,Element,GetIndex,hashsize>::DeleteElement(const Key &k)
+{
+	int status;
+
+	status = GotoElement(k);
+	if (status < 0)
+		return status;
+	return DeleteCurrentElement();
+}
+
+#ifdef RTPDEBUG
+template<class Key,class Element,int GetIndex(const Key &k),int hashsize>
+inline void RTPKeyHashTable<Key,Element,GetIndex,hashsize>::Dump()
+{
+	HashElement *e;
+	
+	std::cout << "DUMPING TABLE CONTENTS:" << std::endl;
+	for (int i = 0 ; i < hashsize ; i++)
+	{
+		e = table[i];
+		while (e != 0)
+		{
+			e->Dump();
+			e = e->hashnext;
+		}
+	}
+	
+	std::cout << "DUMPING LIST CONTENTS:" << std::endl;
+	e = firsthashelem;
+	while (e != 0)
+	{
+		e->Dump();
+		e = e->listnext;
+	}
+}
+#endif // RTPDEBUG
+
+#endif // RTPKEYHASHTABLE_H

Added: konference/src/rtp/jrtplib/rtplibraryversion.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtplibraryversion.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtplibraryversion.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,39 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtplibraryversion.h"
+
+RTPLibraryVersion RTPLibraryVersion::GetVersion()
+{
+	return RTPLibraryVersion(3,3,0);
+}
+

Added: konference/src/rtp/jrtplib/rtplibraryversion.h
===================================================================
--- konference/src/rtp/jrtplib/rtplibraryversion.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtplibraryversion.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,65 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPLIBRARYVERSION_H
+
+#define RTPLIBRARYVERSION_H
+
+#include <string>
+#include <stdio.h>
+
+class RTPLibraryVersion
+{
+public:
+      	static RTPLibraryVersion GetVersion();
+private:
+	RTPLibraryVersion(int major,int minor,int debug) 			{ majornr = major; minornr = minor; debugnr = debug; }
+public:
+	int GetMajorNumber() const						{ return majornr; }
+	int GetMinorNumber() const						{ return minornr; }
+	int GetDebugNumber() const						{ return debugnr; }
+	std::string GetVersionString() const;
+private:
+	int debugnr,minornr,majornr;
+};
+
+inline std::string RTPLibraryVersion::GetVersionString() const
+{
+	char str[16];
+
+	sprintf(str,"%d.%d.%d",majornr,minornr,debugnr);
+	
+	return std::string(str);
+}
+
+#endif // RTPLIBRARYVERSION_H
+

Added: konference/src/rtp/jrtplib/rtppacket.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtppacket.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtppacket.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,344 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtppacket.h"
+#include "rtpstructs.h"
+#include "rtpdefines.h"
+#include "rtperrors.h"
+#include "rtprawpacket.h"
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include <netinet/in.h>
+#endif // WIN32
+
+#ifdef RTPDEBUG
+	#include <stdio.h>
+#endif // RTPDEBUG
+
+#include "rtpdebug.h"
+
+void RTPPacket::Clear()
+{
+	hasextension = false;
+	hasmarker = false;
+	numcsrcs = 0;
+	payloadtype = 0;
+	extseqnr = 0;
+	timestamp = 0;
+	ssrc = 0;
+	packet = 0;
+	payload = 0; 
+	packetlength = 0;
+	payloadlength = 0;
+	extid = 0;
+	extension = 0;
+	extensionlength = 0;
+	error = 0;
+	externalbuffer = false;
+}
+
+RTPPacket::RTPPacket(RTPRawPacket &rawpack) : receivetime(rawpack.GetReceiveTime())
+{
+	Clear();
+	error = ParseRawPacket(rawpack);
+}
+
+RTPPacket::RTPPacket(u_int8_t payloadtype,const void *payloaddata,size_t payloadlen,u_int16_t seqnr,
+		  u_int32_t timestamp,u_int32_t ssrc,bool gotmarker,u_int8_t numcsrcs,const u_int32_t *csrcs,
+		  bool gotextension,u_int16_t extensionid,u_int16_t extensionlen_numwords,const void *extensiondata,
+		  size_t maxpacksize /* = 0 */ ) : receivetime(0,0)
+{
+	Clear();
+	error = BuildPacket(payloadtype,payloaddata,payloadlen,seqnr,timestamp,ssrc,gotmarker,numcsrcs,
+	       	            csrcs,gotextension,extensionid,extensionlen_numwords,extensiondata,0,maxpacksize);
+}
+
+RTPPacket::RTPPacket(u_int8_t payloadtype,const void *payloaddata,size_t payloadlen,u_int16_t seqnr,
+		  u_int32_t timestamp,u_int32_t ssrc,bool gotmarker,u_int8_t numcsrcs,const u_int32_t *csrcs,
+		  bool gotextension,u_int16_t extensionid,u_int16_t extensionlen_numwords,const void *extensiondata,
+		  void *buffer,size_t buffersize) : receivetime(0,0)
+{
+	Clear();
+	if (buffer == 0)
+		error = ERR_RTP_PACKET_EXTERNALBUFFERNULL;
+	else if (buffersize <= 0)
+		error = ERR_RTP_PACKET_ILLEGALBUFFERSIZE;
+	else
+		error = BuildPacket(payloadtype,payloaddata,payloadlen,seqnr,timestamp,ssrc,gotmarker,numcsrcs,
+		                    csrcs,gotextension,extensionid,extensionlen_numwords,extensiondata,buffer,buffersize);
+}
+
+int RTPPacket::ParseRawPacket(RTPRawPacket &rawpack)
+{
+	u_int8_t *packetbytes;
+	size_t packetlen;
+	u_int8_t payloadtype;
+	RTPHeader *rtpheader;
+	bool marker;
+	int csrccount;
+	bool hasextension;
+	int payloadoffset,payloadlength;
+	int numpadbytes;
+	RTPExtensionHeader *rtpextheader;
+	u_int16_t exthdrlen;
+	
+	if (!rawpack.IsRTP()) // If we didn't receive it on the RTP port, we'll ignore it
+		return ERR_RTP_PACKET_INVALIDPACKET;
+	
+	// The length should be at least the size of the RTP header
+	packetlen = rawpack.GetDataLength();
+	if (packetlen < sizeof(RTPHeader))
+		return ERR_RTP_PACKET_INVALIDPACKET;
+	
+	packetbytes = (u_int8_t *)rawpack.GetData();
+	rtpheader = (RTPHeader *)packetbytes;
+	
+	// The version number should be correct
+	if (rtpheader->version != RTP_VERSION)
+		return ERR_RTP_PACKET_INVALIDPACKET;
+	
+	// We'll check if this is possibly a RTCP packet. For this to be possible
+	// the marker bit and payload type combined should be either an SR or RR
+	// identifier
+	marker = (rtpheader->marker == 0)?false:true;
+	payloadtype = rtpheader->payloadtype;
+	if (marker)
+	{
+		if (payloadtype == (RTP_RTCPTYPE_SR & 127)) // don't check high bit (this was the marker!!)
+			return ERR_RTP_PACKET_INVALIDPACKET;
+		if (payloadtype == (RTP_RTCPTYPE_RR & 127))
+			return ERR_RTP_PACKET_INVALIDPACKET;
+	}
+
+	csrccount = rtpheader->csrccount;
+	payloadoffset = sizeof(RTPHeader)+(int)(csrccount*sizeof(u_int32_t));
+	
+	if (rtpheader->padding) // adjust payload length to take padding into account
+	{
+		numpadbytes = (int)packetbytes[packetlen-1]; // last byte contains number of padding bytes
+		if (numpadbytes <= 0)
+			return ERR_RTP_PACKET_INVALIDPACKET;
+	}
+	else
+		numpadbytes = 0;
+
+	hasextension = (rtpheader->extension == 0)?false:true;
+	if (hasextension) // got header extension
+	{
+		rtpextheader = (RTPExtensionHeader *)(packetbytes+payloadoffset);
+		payloadoffset += sizeof(RTPExtensionHeader);
+		exthdrlen = ntohs(rtpextheader->length);
+		payloadoffset += ((int)exthdrlen)*sizeof(u_int32_t);
+	}
+	else
+	{
+		rtpextheader = 0;
+		exthdrlen = 0;
+	}	
+	
+	payloadlength = packetlen-numpadbytes-payloadoffset;
+	if (payloadlength < 0)
+		return ERR_RTP_PACKET_INVALIDPACKET;
+
+	// Now, we've got a valid packet, so we can create a new instance of RTPPacket
+	// and fill in the members
+	
+	RTPPacket::hasextension = hasextension;
+	if (hasextension)
+	{
+		RTPPacket::extid = ntohs(rtpextheader->id);
+		RTPPacket::extensionlength = ((int)ntohs(rtpextheader->length))*sizeof(u_int32_t);
+		RTPPacket::extension = ((u_int8_t *)rtpextheader)+sizeof(RTPExtensionHeader);
+	}
+
+	RTPPacket::hasmarker = marker;
+	RTPPacket::numcsrcs = csrccount;
+	RTPPacket::payloadtype = payloadtype;
+	
+	// Note: we don't fill in the EXTENDED sequence number here, since we
+	// don't have information about the source here. We just fill in the low
+	// 16 bits
+	RTPPacket::extseqnr = (u_int32_t)ntohs(rtpheader->sequencenumber);
+
+	RTPPacket::timestamp = ntohl(rtpheader->timestamp);
+	RTPPacket::ssrc = ntohl(rtpheader->ssrc);
+	RTPPacket::packet = packetbytes;
+	RTPPacket::payload = packetbytes+payloadoffset;
+	RTPPacket::packetlength = packetlen;
+	RTPPacket::payloadlength = payloadlength;
+
+	// We'll zero the data of the raw packet, since we're using it here now!
+	rawpack.ZeroData();
+
+	return 0;
+}
+
+u_int32_t RTPPacket::GetCSRC(int num) const
+{
+	if (num >= numcsrcs)
+		return 0;
+
+	u_int8_t *csrcpos;
+	u_int32_t *csrcval_nbo;
+	u_int32_t csrcval_hbo;
+	
+	csrcpos = packet+sizeof(RTPHeader)+num*sizeof(u_int32_t);
+	csrcval_nbo = (u_int32_t *)csrcpos;
+	csrcval_hbo = ntohl(*csrcval_nbo);
+	return csrcval_hbo;
+}
+
+int RTPPacket::BuildPacket(u_int8_t payloadtype,const void *payloaddata,size_t payloadlen,u_int16_t seqnr,
+		  u_int32_t timestamp,u_int32_t ssrc,bool gotmarker,u_int8_t numcsrcs,const u_int32_t *csrcs,
+		  bool gotextension,u_int16_t extensionid,u_int16_t extensionlen_numwords,const void *extensiondata,
+		  void *buffer,size_t maxsize)
+{
+	if (numcsrcs > RTP_MAXCSRCS)
+		return ERR_RTP_PACKET_TOOMANYCSRCS;
+
+	if (payloadtype > 127) // high bit should not be used
+		return ERR_RTP_PACKET_BADPAYLOADTYPE;
+	if (payloadtype == 72 || payloadtype == 73) // could cause confusion with rtcp types
+		return ERR_RTP_PACKET_BADPAYLOADTYPE;
+	
+	packetlength = sizeof(RTPHeader);
+	packetlength += sizeof(u_int32_t)*((size_t)numcsrcs);
+	if (gotextension)
+	{
+		packetlength += sizeof(RTPExtensionHeader);
+		packetlength += sizeof(u_int32_t)*((size_t)extensionlen_numwords);
+	}
+	packetlength += payloadlen;
+
+	if (maxsize > 0 && packetlength > maxsize)
+	{
+		packetlength = 0;
+		return ERR_RTP_PACKET_DATAEXCEEDSMAXSIZE;
+	}
+
+	// Ok, now we'll just fill in...
+	
+	RTPHeader *rtphdr;
+	
+	if (buffer == 0)
+	{
+		packet = new u_int8_t [packetlength];
+		if (packet == 0)
+		{
+			packetlength = 0;
+			return ERR_RTP_OUTOFMEM;
+		}
+		externalbuffer = false;
+	}
+	else
+	{
+		packet = (u_int8_t *)buffer;
+		externalbuffer = true;
+	}
+	
+	RTPPacket::hasmarker = gotmarker;
+	RTPPacket::hasextension = gotextension;
+	RTPPacket::numcsrcs = numcsrcs;
+	RTPPacket::payloadtype = payloadtype;
+	RTPPacket::extseqnr = (u_int32_t)seqnr;
+	RTPPacket::timestamp = timestamp;
+	RTPPacket::ssrc = ssrc;
+	RTPPacket::payloadlength = payloadlen;
+	RTPPacket::extid = extensionid;
+	RTPPacket::extensionlength = ((size_t)extensionlen_numwords)*sizeof(u_int32_t);
+	
+	rtphdr = (RTPHeader *)packet;
+	rtphdr->version = RTP_VERSION;
+	rtphdr->padding = 0;
+	if (gotmarker)
+		rtphdr->marker = 1;
+	else
+		rtphdr->marker = 0;
+	if (gotextension)
+		rtphdr->extension = 1;
+	else
+		rtphdr->extension = 0;
+	rtphdr->csrccount = numcsrcs;
+	rtphdr->payloadtype = payloadtype&127; // make sure high bit isn't set
+	rtphdr->sequencenumber = htons(seqnr);
+	rtphdr->timestamp = htonl(timestamp);
+	rtphdr->ssrc = htonl(ssrc);
+	
+	u_int32_t *curcsrc;
+	int i;
+
+	curcsrc = (u_int32_t *)(packet+sizeof(RTPHeader));
+	for (i = 0 ; i < numcsrcs ; i++,curcsrc++)
+		*curcsrc = htonl(csrcs[i]);
+
+	payload = packet+sizeof(RTPHeader)+((size_t)numcsrcs)*sizeof(u_int32_t); 
+	if (gotextension)
+	{
+		RTPExtensionHeader *rtpexthdr = (RTPExtensionHeader *)payload;
+
+		rtpexthdr->id = htons(extensionid);
+		rtpexthdr->length = htons((u_int16_t)extensionlen_numwords);
+		
+		payload += sizeof(RTPExtensionHeader);
+		memcpy(payload,extensiondata,RTPPacket::extensionlength);
+		
+		payload += RTPPacket::extensionlength;
+	}
+	memcpy(payload,payloaddata,payloadlen);
+	return 0;
+}
+
+#ifdef RTPDEBUG	
+void RTPPacket::Dump()
+{
+	int i;
+	
+	printf("Payload type:                %d\n",(int)GetPayloadType());
+	printf("Extended sequence number:    0x%08x\n",GetExtendedSequenceNumber());
+	printf("Timestamp:                   0x%08x\n",GetTimestamp());
+	printf("SSRC:                        0x%08x\n",GetSSRC());
+	printf("Marker:                      %s\n",HasMarker()?"yes":"no");
+	printf("CSRC count:                  %d\n",GetCSRCCount());
+	for (i = 0 ; i < GetCSRCCount() ; i++)
+		printf("    CSRC[%02d]:                0x%08x\n",i,GetCSRC(i));
+	printf("Payload:                     %s\n",GetPayloadData());
+	printf("Payload length:              %d\n",GetPayloadLength());
+	printf("Packet length:               %d\n",GetPacketLength());
+	printf("Extension:                   %s\n",HasExtension()?"yes":"no");
+	if (HasExtension())
+	{
+		printf("    Extension ID:            0x%04x\n",GetExtensionID());
+		printf("    Extension data:          %s\n",GetExtensionData());
+		printf("    Extension length:        %d\n",GetExtensionLength());
+	}
+}
+#endif // RTPDEBUG
+

Added: konference/src/rtp/jrtplib/rtppacket.h
===================================================================
--- konference/src/rtp/jrtplib/rtppacket.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtppacket.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,125 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPPACKET_H
+
+#define RTPPACKET_H
+
+
+#include "rtpconfig.h"
+#include "rtptypes.h"
+#include "rtptimeutilities.h"
+
+class RTPRawPacket;
+
+class RTPPacket
+{
+public:
+	// If successfull, the data is moved from the raw packet to the RTPPacket instance
+	RTPPacket(RTPRawPacket &rawpack);
+
+	// if maxpacksize == 0, it is ignored
+	RTPPacket(u_int8_t payloadtype,const void *payloaddata,size_t payloadlen,u_int16_t seqnr,
+		  u_int32_t timestamp,u_int32_t ssrc,bool gotmarker,u_int8_t numcsrcs,const u_int32_t *csrcs,
+		  bool gotextension,u_int16_t extensionid,u_int16_t extensionlen_numwords,const void *extensiondata,
+		  size_t maxpacksize = 0);
+	// pretty much the same function, except that here the data is placed in an external buffer
+	RTPPacket(u_int8_t payloadtype,const void *payloaddata,size_t payloadlen,u_int16_t seqnr,
+		  u_int32_t timestamp,u_int32_t ssrc,bool gotmarker,u_int8_t numcsrcs,const u_int32_t *csrcs,
+		  bool gotextension,u_int16_t extensionid,u_int16_t extensionlen_numwords,const void *extensiondata,
+		  void *buffer,size_t buffersize);
+
+	virtual ~RTPPacket()							{ if (packet && !externalbuffer) delete [] packet; }
+	int GetCreationError() const						{ return error; }
+
+	bool HasExtension() const						{ return hasextension; }
+	bool HasMarker() const							{ return hasmarker; }
+	
+	int GetCSRCCount() const						{ return numcsrcs; }
+	u_int32_t GetCSRC(int num) const;
+	
+	u_int8_t GetPayloadType() const						{ return payloadtype; }
+
+	// On reception, this is actually a 16 bit value. The high 16 bits
+	// are filled in when the packet is processed in the source
+	// table
+	u_int32_t GetExtendedSequenceNumber() const				{ return extseqnr; }
+	u_int16_t GetSequenceNumber() const					{ return (u_int16_t)(extseqnr&0x0000FFFF); }
+	void SetExtendedSequenceNumber(u_int32_t seq)				{ extseqnr = seq; }
+
+	u_int32_t GetTimestamp() const						{ return timestamp; }
+	u_int32_t GetSSRC() const						{ return ssrc; }
+
+	u_int8_t *GetPacketData() const						{ return packet; }
+	u_int8_t *GetPayloadData() const					{ return payload; }
+	size_t GetPacketLength() const						{ return packetlength; }
+	size_t GetPayloadLength() const						{ return payloadlength; }
+	
+	u_int16_t GetExtensionID() const					{ return extid; }
+	u_int8_t *GetExtensionData() const					{ return extension; }
+	size_t GetExtensionLength() const					{ return extensionlength; }
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+
+	// If parsed from a raw packet, the receive time is also copied.
+	// This function can be used to retrieve it.
+	RTPTime GetReceiveTime() const						{ return receivetime; }
+private:
+	void Clear();
+	int ParseRawPacket(RTPRawPacket &rawpack);
+	int BuildPacket(u_int8_t payloadtype,const void *payloaddata,size_t payloadlen,u_int16_t seqnr,
+	                u_int32_t timestamp,u_int32_t ssrc,bool gotmarker,u_int8_t numcsrcs,const u_int32_t *csrcs,
+	                bool gotextension,u_int16_t extensionid,u_int16_t extensionlen_numwords,const void *extensiondata,
+	                void *buffer,size_t maxsize);
+
+	int error;
+	
+	bool hasextension,hasmarker;
+	int numcsrcs;
+
+	u_int8_t payloadtype;
+	u_int32_t extseqnr,timestamp,ssrc;
+	u_int8_t *packet,*payload;
+	size_t packetlength,payloadlength;
+
+	u_int16_t extid;
+	u_int8_t *extension;
+	size_t extensionlength;
+
+	bool externalbuffer;
+
+	RTPTime receivetime;
+};
+
+#endif // RTPPACKET_H
+

Added: konference/src/rtp/jrtplib/rtppacketbuilder.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtppacketbuilder.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtppacketbuilder.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,269 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtppacketbuilder.h"
+#include "rtperrors.h"
+#include "rtppacket.h"
+#include "rtpsources.h"
+#include <time.h>
+#include <stdlib.h>
+#ifdef RTPDEBUG
+	#include <iostream>
+#endif // RTPDEBUG
+
+#include "rtpdebug.h"
+
+RTPPacketBuilder::RTPPacketBuilder() : lastwallclocktime(0,0)
+{
+	init = false;
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	timeinit.Dummy();
+#endif // WIN32 || _WIN32_WCE
+}
+
+RTPPacketBuilder::~RTPPacketBuilder()
+{
+	Destroy();
+}
+
+int RTPPacketBuilder::Init(size_t max)
+{
+	if (init)
+		return ERR_RTP_PACKBUILD_ALREADYINIT;
+	if (max <= 0)
+		return ERR_RTP_PACKBUILD_INVALIDMAXPACKETSIZE;
+	
+	maxpacksize = max;
+	buffer = new u_int8_t [max];
+	if (buffer == 0)
+		return ERR_RTP_OUTOFMEM;
+	packetlength = 0;
+	
+	CreateNewSSRC();
+
+	deftsset = false;
+	defptset = false;
+	defmarkset = false;
+		
+	numcsrcs = 0;
+	
+	init = true;
+	return 0;
+}
+
+void RTPPacketBuilder::Destroy()
+{
+	if (!init)
+		return;
+	delete [] buffer;
+	init = false;
+}
+
+int RTPPacketBuilder::SetMaximumPacketSize(size_t max)
+{
+	u_int8_t *newbuf;
+
+	if (max <= 0)
+		return ERR_RTP_PACKBUILD_INVALIDMAXPACKETSIZE;
+	newbuf = new u_int8_t[max];
+	if (newbuf == 0)
+		return ERR_RTP_OUTOFMEM;
+	
+	delete [] buffer;
+	buffer = newbuf;
+	maxpacksize = max;
+	return 0;
+}
+
+int RTPPacketBuilder::AddCSRC(u_int32_t csrc)
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	if (numcsrcs >= RTP_MAXCSRCS)
+		return ERR_RTP_PACKBUILD_CSRCLISTFULL;
+
+	int i;
+	
+	for (i = 0 ; i < numcsrcs ; i++)
+	{
+		if (csrcs[i] == csrc)
+			return ERR_RTP_PACKBUILD_CSRCALREADYINLIST;
+	}
+	csrcs[numcsrcs] = csrc;
+	numcsrcs++;
+	return 0;
+}
+
+int RTPPacketBuilder::DeleteCSRC(u_int32_t csrc)
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	
+	int i = 0;
+	bool found = false;
+
+	while (!found && i < numcsrcs)
+	{
+		if (csrcs[i] == csrc)
+			found = true;
+		else
+			i++;
+	}
+
+	if (!found)
+		return ERR_RTP_PACKBUILD_CSRCNOTINLIST;
+	
+	// move the last csrc in the place of the deleted one
+	numcsrcs--;
+	if (numcsrcs > 0 && numcsrcs != i)
+		csrcs[i] = csrcs[numcsrcs];
+	return 0;
+}
+
+void RTPPacketBuilder::ClearCSRCList()
+{
+	if (!init)
+		return;
+	numcsrcs = 0;
+}
+
+u_int32_t RTPPacketBuilder::CreateNewSSRC()
+{
+	ssrc = rtprnd.GetRandom32();
+	timestamp = rtprnd.GetRandom32();
+	seqnr = rtprnd.GetRandom16();
+
+	// p 38: the count SHOULD be reset if the sender changes its SSRC identifier
+	numpayloadbytes = 0;
+	numpackets = 0;
+	return ssrc;
+}
+
+u_int32_t RTPPacketBuilder::CreateNewSSRC(RTPSources &sources)
+{
+	bool found;
+	
+	do
+	{
+		ssrc = rtprnd.GetRandom32();
+		found = sources.GotEntry(ssrc);
+	} while (found);
+	
+	timestamp = rtprnd.GetRandom32();
+	seqnr = rtprnd.GetRandom16();
+
+	// p 38: the count SHOULD be reset if the sender changes its SSRC identifier
+	numpayloadbytes = 0;
+	numpackets = 0;
+	return ssrc;
+}
+
+int RTPPacketBuilder::BuildPacket(const void *data,size_t len)
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	if (!defptset)
+		return ERR_RTP_PACKBUILD_DEFAULTPAYLOADTYPENOTSET;
+	if (!defmarkset)
+		return ERR_RTP_PACKBUILD_DEFAULTMARKNOTSET;
+	if (!deftsset)
+		return ERR_RTP_PACKBUILD_DEFAULTTSINCNOTSET;
+	return PrivateBuildPacket(data,len,defaultpayloadtype,defaultmark,defaulttimestampinc,false);
+}
+
+int RTPPacketBuilder::BuildPacket(const void *data,size_t len,
+                u_int8_t pt,bool mark,u_int32_t timestampinc)
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	return PrivateBuildPacket(data,len,pt,mark,timestampinc,false);
+}
+
+int RTPPacketBuilder::BuildPacketEx(const void *data,size_t len,
+                  u_int16_t hdrextID,const void *hdrextdata,size_t numhdrextwords)
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	if (!defptset)
+		return ERR_RTP_PACKBUILD_DEFAULTPAYLOADTYPENOTSET;
+	if (!defmarkset)
+		return ERR_RTP_PACKBUILD_DEFAULTMARKNOTSET;
+	if (!deftsset)
+		return ERR_RTP_PACKBUILD_DEFAULTTSINCNOTSET;
+	return PrivateBuildPacket(data,len,defaultpayloadtype,defaultmark,defaulttimestampinc,true,hdrextID,hdrextdata,numhdrextwords);
+}
+
+int RTPPacketBuilder::BuildPacketEx(const void *data,size_t len,
+                  u_int8_t pt,bool mark,u_int32_t timestampinc,
+		  u_int16_t hdrextID,const void *hdrextdata,size_t numhdrextwords)
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	return PrivateBuildPacket(data,len,pt,mark,timestampinc,true,hdrextID,hdrextdata,numhdrextwords);
+
+}
+
+int RTPPacketBuilder::PrivateBuildPacket(const void *data,size_t len,
+	                  u_int8_t pt,bool mark,u_int32_t timestampinc,bool gotextension,
+	                  u_int16_t hdrextID,const void *hdrextdata,size_t numhdrextwords)
+{
+	RTPPacket p(pt,data,len,seqnr,timestamp,ssrc,mark,numcsrcs,csrcs,gotextension,hdrextID,
+	            (u_int16_t)numhdrextwords,hdrextdata,buffer,maxpacksize);
+	int status = p.GetCreationError();
+
+	if (status < 0)
+		return status;
+	packetlength = p.GetPacketLength();
+
+	if (numpackets == 0) // first packet
+	{
+		lastwallclocktime = RTPTime::CurrentTime();
+		lastrtptimestamp = timestamp;
+		prevrtptimestamp = timestamp;
+	}
+	else if (timestamp != prevrtptimestamp)
+	{
+		lastwallclocktime = RTPTime::CurrentTime();
+		lastrtptimestamp = timestamp;
+		prevrtptimestamp = timestamp;
+	}
+	
+	numpayloadbytes += (u_int32_t)p.GetPayloadLength();
+	numpackets++;
+	timestamp += timestampinc;
+	seqnr++;
+
+
+	return 0;
+}
+
+

Added: konference/src/rtp/jrtplib/rtppacketbuilder.h
===================================================================
--- konference/src/rtp/jrtplib/rtppacketbuilder.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtppacketbuilder.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,165 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPPACKETBUILDER_H
+
+#define RTPPACKETBUILDER_H
+
+#include "rtpconfig.h"
+#include "rtperrors.h"
+#include "rtpdefines.h"
+#include "rtprandom.h"
+#include "rtptimeutilities.h"
+#include "rtptypes.h"
+
+class RTPSources;
+
+class RTPPacketBuilder
+{
+public:
+	RTPPacketBuilder();
+	~RTPPacketBuilder();
+	int Init(size_t maxpacksize);
+	void Destroy();
+	u_int32_t GetPacketCount()					{ if (!init) return 0; return numpackets; }
+	u_int32_t GetPayloadOctetCount()				{ if (!init) return 0; return numpayloadbytes; }
+	int SetMaximumPacketSize(size_t maxpacksize);
+
+	int AddCSRC(u_int32_t csrc);
+	int DeleteCSRC(u_int32_t csrc);
+	void ClearCSRCList();	
+	
+	int BuildPacket(const void *data,size_t len);
+	int BuildPacket(const void *data,size_t len,
+	                u_int8_t pt,bool mark,u_int32_t timestampinc);
+	int BuildPacketEx(const void *data,size_t len,
+	                  u_int16_t hdrextID,const void *hdrextdata,size_t numhdrextwords);
+	int BuildPacketEx(const void *data,size_t len,
+	                  u_int8_t pt,bool mark,u_int32_t timestampinc,
+	                  u_int16_t hdrextID,const void *hdrextdata,size_t numhdrextwords);
+	u_int8_t *GetPacket()						{ if (!init) return 0; return buffer; }
+	size_t GetPacketLength()					{ if (!init) return 0; return packetlength; }
+	
+	int SetDefaultPayloadType(u_int8_t pt);
+	int SetDefaultMark(bool m);
+	int SetDefaultTimestampIncrement(u_int32_t timestampinc);
+	int IncrementTimestamp(u_int32_t inc);
+	int IncrementTimestampDefault();
+	
+	u_int32_t CreateNewSSRC();
+	u_int32_t CreateNewSSRC(RTPSources &sources);
+	u_int32_t GetSSRC() const					{ if (!init) return 0; return ssrc; }
+	u_int32_t GetTimestamp() const					{ if (!init) return 0; return timestamp; }
+	u_int16_t GetSequenceNumber() const				{ if (!init) return 0; return seqnr; }
+
+	// note: these are not necessarily from the last packet!
+	RTPTime GetPacketTime() const					{ if (!init) return RTPTime(0,0); return lastwallclocktime; }
+	u_int32_t GetPacketTimestamp() const				{ if (!init) return 0; return lastrtptimestamp; }
+private:
+	int PrivateBuildPacket(const void *data,size_t len,
+	                  u_int8_t pt,bool mark,u_int32_t timestampinc,bool gotextension,
+	                  u_int16_t hdrextID = 0,const void *hdrextdata = 0,size_t numhdrextwords = 0);
+
+	RTPRandom rtprnd;	
+	size_t maxpacksize;
+	u_int8_t *buffer;
+	size_t packetlength;
+	
+	u_int32_t numpayloadbytes;
+	u_int32_t numpackets;
+	bool init;
+
+	u_int32_t ssrc;
+	u_int32_t timestamp;
+	u_int16_t seqnr;
+
+	u_int32_t defaulttimestampinc;
+	u_int8_t defaultpayloadtype;
+	bool defaultmark;
+
+	bool deftsset,defptset,defmarkset;
+
+	u_int32_t csrcs[RTP_MAXCSRCS];
+	int numcsrcs;
+
+	RTPTime lastwallclocktime;
+	u_int32_t lastrtptimestamp;
+	u_int32_t prevrtptimestamp;
+};
+
+inline int RTPPacketBuilder::SetDefaultPayloadType(u_int8_t pt)
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	defptset = true;
+	defaultpayloadtype = pt;
+	return 0;
+}
+
+inline int RTPPacketBuilder::SetDefaultMark(bool m)
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	defmarkset = true;
+	defaultmark = m;
+	return 0;
+}
+
+inline int RTPPacketBuilder::SetDefaultTimestampIncrement(u_int32_t timestampinc)
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	deftsset = true;
+	defaulttimestampinc = timestampinc;
+	return 0;
+}
+
+inline int RTPPacketBuilder::IncrementTimestamp(u_int32_t inc)
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	timestamp += inc;
+	return 0;
+}
+
+inline int RTPPacketBuilder::IncrementTimestampDefault()
+{
+	if (!init)
+		return ERR_RTP_PACKBUILD_NOTINIT;
+	if (!deftsset)
+		return ERR_RTP_PACKBUILD_DEFAULTTSINCNOTSET;
+	timestamp += defaulttimestampinc;
+	return 0;
+}
+
+#endif // RTPPACKETBUILDER_H
+

Added: konference/src/rtp/jrtplib/rtppollthread.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtppollthread.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtppollthread.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,169 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtppollthread.h"
+
+#ifdef RTP_SUPPORT_THREAD
+
+#include "rtpsession.h"
+#include "rtcpscheduler.h"
+#include "rtperrors.h"
+#include "rtprawpacket.h"
+#include <time.h>
+
+#ifndef _WIN32_WCE
+	#include <iostream>
+#endif // _WIN32_WCE
+
+#include "rtpdebug.h"
+
+RTPPollThread::RTPPollThread(RTPSession &session,RTCPScheduler &sched):rtpsession(session),rtcpsched(sched)
+{
+	stop = false;
+	transmitter = 0;
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	timeinit.Dummy();
+#endif // WIN32 || _WIN32_WCE
+}
+
+RTPPollThread::~RTPPollThread()
+{
+	Stop();
+}
+ 
+int RTPPollThread::Start(RTPTransmitter *trans)
+{
+	if (JThread::IsRunning())
+		return ERR_RTP_POLLTHREAD_ALREADYRUNNING;
+	
+	transmitter = trans;
+	if (!stopmutex.IsInitialized())
+	{
+		if (stopmutex.Init() < 0)
+			return ERR_RTP_POLLTHREAD_CANTINITMUTEX;
+	}
+	stop = false;
+	if (JThread::Start() < 0)
+		return ERR_RTP_POLLTHREAD_CANTSTARTTHREAD;
+	return 0;
+}
+
+void RTPPollThread::Stop()
+{	
+	if (!IsRunning())
+		return;
+	
+	stopmutex.Lock();
+	stop = true;
+	stopmutex.Unlock();
+	
+	if (transmitter)
+		transmitter->AbortWait();
+	
+	RTPTime thetime = RTPTime::CurrentTime();
+	bool done = false;
+
+	while (JThread::IsRunning() && !done)
+	{
+		// wait max 5 sec
+		RTPTime curtime = RTPTime::CurrentTime();
+		if ((curtime.GetDouble()-thetime.GetDouble()) > 5.0)
+			done = true;
+		RTPTime::Wait(RTPTime(0,10000));
+	}
+
+	if (JThread::IsRunning())
+	{
+#ifndef _WIN32_WCE
+		std::cerr << "RTPPollThread: Warning! Having to kill thread!" << std::endl;
+#endif // _WIN32_WCE
+		JThread::Kill();
+	}
+	stop = false;
+	transmitter = 0;
+}
+
+void *RTPPollThread::Thread()
+{
+	JThread::ThreadStarted();
+	
+	bool stopthread;
+
+	stopmutex.Lock();
+	stopthread = stop;
+	stopmutex.Unlock();
+	while (!stopthread)
+	{
+		int status;
+
+		rtpsession.schedmutex.Lock();
+		rtpsession.sourcesmutex.Lock();
+		
+		RTPTime rtcpdelay = rtcpsched.GetTransmissionDelay();
+		
+		rtpsession.sourcesmutex.Unlock();
+		rtpsession.schedmutex.Unlock();
+		
+		if ((status = transmitter->WaitForIncomingData(rtcpdelay)) < 0)
+		{
+			stopthread = true;
+			rtpsession.OnPollThreadError(status);
+		}
+		else
+		{
+			if ((status = transmitter->Poll()) < 0)
+			{
+				stopthread = true;
+				rtpsession.OnPollThreadError(status);
+			}
+			else
+			{
+				if ((status = rtpsession.ProcessPolledData()) < 0)
+				{
+					stopthread = true;
+					rtpsession.OnPollThreadError(status);
+				}
+				else
+				{
+					rtpsession.OnPollThreadStep();
+					stopmutex.Lock();
+					stopthread = stop;
+					stopmutex.Unlock();
+				}
+			}
+		}
+	}
+	return 0;
+}
+
+#endif // RTP_SUPPORT_THREAD
+

Added: konference/src/rtp/jrtplib/rtppollthread.h
===================================================================
--- konference/src/rtp/jrtplib/rtppollthread.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtppollthread.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,70 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPPOLLTHREAD_H
+
+#define RTPPOLLTHREAD_H
+
+#include "rtpconfig.h"
+
+#ifdef RTP_SUPPORT_THREAD
+
+#include "rtptransmitter.h"
+
+#include <jthread.h>
+#include <jmutex.h>
+#include <list>
+
+class RTPSession;
+class RTCPScheduler;
+
+class RTPPollThread : private JThread
+{
+public:
+	RTPPollThread(RTPSession &session,RTCPScheduler &rtcpsched);
+	~RTPPollThread();
+	int Start(RTPTransmitter *trans);
+	void Stop();
+private:
+	void *Thread();
+	
+	bool stop;
+	JMutex stopmutex;
+	RTPTransmitter *transmitter;
+	
+	RTPSession &rtpsession;
+	RTCPScheduler &rtcpsched;
+};
+
+#endif // RTP_SUPPORT_THREAD
+
+#endif // RTPPOLLTHREAD_H

Added: konference/src/rtp/jrtplib/rtprandom.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtprandom.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtprandom.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,213 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtprandom.h"
+#include <time.h>
+#ifndef WIN32
+	#include <unistd.h>
+#else
+	#ifndef _WIN32_WCE
+		#include <process.h>
+	#else
+		#include <windows.h>
+		#include <kfuncs.h>
+	#endif // _WIN32_WINCE
+	#include <stdlib.h>
+#endif // WIN32
+
+#include "rtpdebug.h"
+
+#if !defined(RTP_SUPPORT_GNUDRAND) && !defined(RTP_SUPPORT_RANDR)
+bool RTPRandom::init = false;
+#endif // WIN32
+
+RTPRandom::RTPRandom()
+{
+#if defined(RTP_SUPPORT_GNUDRAND) || defined(RTP_SUPPORT_RANDR)
+	u_int32_t x;
+
+	x = (u_int32_t)getpid();
+	x += (u_int32_t)time(0);
+	x -= (u_int32_t)clock();
+	x ^= (u_int32_t)(this);
+
+#ifdef RTP_SUPPORT_GNUDRAND
+	srand48_r(x,&drandbuffer);
+#else
+	state = (unsigned int)x;
+#endif
+	
+#else // use simple rand and srand functions
+	if (init)
+		return;
+
+	u_int32_t x;
+
+#ifndef _WIN32_WCE
+	x = (u_int32_t)getpid();
+	x += (u_int32_t)time(0);
+	x -= (u_int32_t)clock();
+#else
+	x = (u_int32_t)GetCurrentProcessId();
+
+	FILETIME ft;
+	SYSTEMTIME st;
+	
+	GetSystemTime(&st);
+	SystemTimeToFileTime(&st,&ft);
+	
+	x += ft.dwLowDateTime;
+#endif // _WIN32_WCE
+	x ^= (u_int32_t)(this);
+	srand((unsigned int)x);
+
+	init = true;
+#endif
+}
+
+RTPRandom::~RTPRandom()
+{
+}
+
+#ifdef RTP_SUPPORT_GNUDRAND
+
+u_int8_t RTPRandom::GetRandom8()
+{
+	double x;
+	drand48_r(&drandbuffer,&x);
+	u_int8_t y = (u_int8_t)(x*256.0);
+	return y;
+}
+
+u_int16_t RTPRandom::GetRandom16()
+{
+	double x;
+	drand48_r(&drandbuffer,&x);
+	u_int16_t y = (u_int16_t)(x*65536.0);
+	return y;
+}
+
+u_int32_t RTPRandom::GetRandom32()
+{
+	u_int32_t a = GetRandom16();
+	u_int32_t b = GetRandom16();
+	u_int32_t y = (a << 16)|b;
+	return y;
+}
+
+double RTPRandom::GetRandomDouble()
+{
+	double x;
+	drand48_r(&drandbuffer,&x);
+	return x;
+}
+
+#else 
+#ifdef RTP_SUPPORT_RANDR
+
+u_int8_t RTPRandom::GetRandom8()
+{
+	u_int8_t x;
+
+	x = (u_int8_t)(256.0*((double)rand_r(&state))/((double)RAND_MAX+1.0));
+	return x;
+}
+
+u_int16_t RTPRandom::GetRandom16()
+{
+	u_int16_t x;
+
+	x = (u_int16_t)(65536.0*((double)rand_r(&state))/((double)RAND_MAX+1.0));
+	return x;
+}
+
+u_int32_t RTPRandom::GetRandom32()
+{
+	u_int32_t x,y;
+
+	x = (u_int32_t)(65536.0*((double)rand_r(&state))/((double)RAND_MAX+1.0));
+	y = x;
+	x = (u_int32_t)(65536.0*((double)rand_r(&state))/((double)RAND_MAX+1.0));
+	y ^= (x<<8);
+	x = (u_int32_t)(65536.0*((double)rand_r(&state))/((double)RAND_MAX+1.0));
+	y ^= (x<<16);
+
+	return y;
+}
+
+double RTPRandom::GetRandomDouble()
+{
+	double x = ((double)rand_r(&state))/((double)RAND_MAX+1.0);
+	return x;
+}
+
+#else
+
+u_int8_t RTPRandom::GetRandom8()
+{
+	u_int8_t x;
+
+	x = (u_int8_t)(256.0*((double)rand())/((double)RAND_MAX+1.0));
+	return x;
+}
+
+u_int16_t RTPRandom::GetRandom16()
+{
+	u_int16_t x;
+
+	x = (u_int16_t)(65536.0*((double)rand())/((double)RAND_MAX+1.0));
+	return x;
+}
+
+u_int32_t RTPRandom::GetRandom32()
+{
+	u_int32_t x,y;
+
+	x = (u_int32_t)(65536.0*((double)rand())/((double)RAND_MAX+1.0));
+	y = x;
+	x = (u_int32_t)(65536.0*((double)rand())/((double)RAND_MAX+1.0));
+	y ^= (x<<8);
+	x = (u_int32_t)(65536.0*((double)rand())/((double)RAND_MAX+1.0));
+	y ^= (x<<16);
+
+	return y;
+}
+
+double RTPRandom::GetRandomDouble()
+{
+	double x = ((double)rand())/((double)RAND_MAX+1.0);
+	return x;
+}
+
+#endif // RTP_SUPPORT_RANDR
+#endif // RTP_SUPPORT_GNUDRAND
+

Added: konference/src/rtp/jrtplib/rtprandom.h
===================================================================
--- konference/src/rtp/jrtplib/rtprandom.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtprandom.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,62 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPRANDOM_H
+
+#define RTPRANDOM_H
+
+#include "rtpconfig.h"
+#include "rtptypes.h"
+#include <stdlib.h>
+
+class RTPRandom
+{
+public:
+	RTPRandom();
+	~RTPRandom();
+	u_int8_t GetRandom8();
+	u_int16_t GetRandom16();
+	u_int32_t GetRandom32();
+	double GetRandomDouble(); // returns random value between 0.0 and 1.0
+private:
+#ifdef RTP_SUPPORT_GNUDRAND
+	struct drand48_data drandbuffer;
+#else
+#ifdef RTP_SUPPORT_RANDR
+	unsigned int state;
+#else
+	static bool init;
+#endif // RTP_SUPPORT_RANDR
+#endif // RTP_SUPPORT_GNUDRAND
+};
+
+#endif // RTPRANDOM_H

Added: konference/src/rtp/jrtplib/rtprawpacket.h
===================================================================
--- konference/src/rtp/jrtplib/rtprawpacket.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtprawpacket.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,79 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPRAWPACKET_H
+
+#define RTPRAWPACKET_H
+
+#include "rtpconfig.h"
+#include "rtptimeutilities.h"
+#include "rtpaddress.h"
+#include "rtptypes.h"
+
+class RTPRawPacket
+{
+public:	
+	RTPRawPacket(u_int8_t *data,size_t datalen,RTPAddress *address,RTPTime &recvtime,bool rtp);
+	~RTPRawPacket();
+	
+	u_int8_t *GetData()						{ return packetdata; }
+	size_t GetDataLength() const					{ return packetdatalength; }
+	RTPTime GetReceiveTime() const					{ return receivetime; }
+	const RTPAddress *GetSenderAddress() const			{ return senderaddress; }
+	bool IsRTP() const						{ return isrtp; }
+	void ZeroData()							{ packetdata = 0; packetdatalength = 0; }
+private:
+	u_int8_t *packetdata;
+	size_t packetdatalength;
+	RTPTime receivetime;
+	RTPAddress *senderaddress;
+	bool isrtp;
+};
+
+inline RTPRawPacket::RTPRawPacket(u_int8_t *data,size_t datalen,RTPAddress *address,RTPTime &recvtime,bool rtp):receivetime(recvtime)
+{
+	packetdata = data;
+	packetdatalength = datalen;
+	senderaddress = address;
+	isrtp = rtp;
+}
+
+inline RTPRawPacket::~RTPRawPacket()
+{
+	if (packetdata)
+		delete [] packetdata;
+	if (senderaddress)
+		delete senderaddress;
+}
+
+#endif // RTPRAWPACKET_H
+

Added: konference/src/rtp/jrtplib/rtpsession.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpsession.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpsession.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,1284 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtpsession.h"
+#include "rtperrors.h"
+#include "rtppollthread.h"
+#include "rtpudpv4transmitter.h"
+#include "rtpudpv6transmitter.h"
+#include "rtpgsttransmitter.h"
+#include "rtpsessionparams.h"
+#include "rtpdefines.h"
+#include "rtprawpacket.h"
+#include "rtppacket.h"
+#include "rtptimeutilities.h"
+#include "rtcpcompoundpacket.h"
+#ifndef WIN32
+	#include <unistd.h>
+	#include <stdlib.h>
+#else
+	#include <winbase.h>
+#endif // WIN32
+
+#ifdef RTPDEBUG
+	#include <iostream>
+#endif // RTPDEBUG
+
+#include "rtpdebug.h"
+
+#ifdef RTP_SUPPORT_THREAD
+	#define SOURCES_LOCK					{ if (usingpollthread) sourcesmutex.Lock(); }
+	#define SOURCES_UNLOCK					{ if (usingpollthread) sourcesmutex.Unlock(); }
+	#define BUILDER_LOCK					{ if (usingpollthread) buildermutex.Lock(); }
+	#define BUILDER_UNLOCK					{ if (usingpollthread) buildermutex.Unlock(); }
+	#define SCHED_LOCK					{ if (usingpollthread) schedmutex.Lock(); }
+	#define SCHED_UNLOCK					{ if (usingpollthread) schedmutex.Unlock(); }
+#else
+	#define SOURCES_LOCK
+	#define SOURCES_UNLOCK
+	#define BUILDER_LOCK
+	#define BUILDER_UNLOCK
+	#define SCHED_LOCK
+	#define SCHED_UNLOCK
+#endif // RTP_SUPPORT_THREAD
+
+RTPSession::RTPSession(RTPTransmitter::TransmissionProtocol proto /* = RTPTransmitter::IPv4UDPProto */ ) 
+	: protocol(proto),sources(*this),rtcpsched(sources),rtcpbuilder(sources,packetbuilder)
+{
+	created = false;
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	timeinit.Dummy();
+#endif // WIN32 || _WIN32_WCE
+}
+
+RTPSession::~RTPSession()
+{
+	Destroy();
+}
+
+int RTPSession::Create(const RTPSessionParams &sessparams,const RTPTransmissionParams *transparams /* = 0 */)
+{
+	int status;
+	
+	if (created)
+		return ERR_RTP_SESSION_ALREADYCREATED;
+
+	usingpollthread = sessparams.IsUsingPollThread();
+	useSR_BYEifpossible = sessparams.GetSenderReportForBYE();
+	
+	// Check max packet size
+	
+	if ((maxpacksize = sessparams.GetMaximumPacketSize()) < RTP_MINPACKETSIZE)
+		return ERR_RTP_SESSION_MAXPACKETSIZETOOSMALL;
+		
+	// Initialize the transmission component
+	
+	rtptrans = 0;
+	switch(protocol)
+	{
+	case RTPTransmitter::IPv4UDPProto:
+		rtptrans = new RTPUDPv4Transmitter();
+		break;
+#ifdef RTP_SUPPORT_IPV6
+	case RTPTransmitter::IPv6UDPProto:
+		rtptrans = new RTPUDPv6Transmitter();
+		break;
+#endif // RTP_SUPPORT_IPV6
+#ifdef RTP_SUPPORT_GST
+	case RTPTransmitter::IPv4GSTProto:
+		rtptrans = new RTPGSTv4Transmitter();
+		break;
+#endif // RTP_SUPPORT_GST
+	case RTPTransmitter::UserDefinedProto:
+		rtptrans = NewUserDefinedTransmitter();
+		if (rtptrans == 0)
+			return ERR_RTP_SESSION_USERDEFINEDTRANSMITTERNULL;
+		break;
+	default:
+		return ERR_RTP_SESSION_UNSUPPORTEDTRANSMISSIONPROTOCOL;
+	}
+	
+	if (rtptrans == 0)
+		return ERR_RTP_OUTOFMEM;
+	if ((status = rtptrans->Init(usingpollthread)) < 0)
+	{
+		delete rtptrans;
+		return status;
+	}
+	if ((status = rtptrans->Create(maxpacksize,transparams)) < 0)
+	{
+		delete rtptrans;
+		return status;
+	}
+
+	// Initialize packet builder
+	
+	if ((status = packetbuilder.Init(maxpacksize)) < 0)
+	{
+		delete rtptrans;
+		return status;
+	}
+
+#ifdef RTP_SUPPORT_PROBATION
+
+	// Set probation type
+	sources.SetProbationType(sessparams.GetProbationType());
+
+#endif // RTP_SUPPORT_PROBATION
+
+	// Add our own ssrc to the source table
+	
+	if ((status = sources.CreateOwnSSRC(packetbuilder.GetSSRC())) < 0)
+	{
+		packetbuilder.Destroy();
+		delete rtptrans;
+		return status;
+	}
+
+	// Set the initial receive mode
+	
+	if ((status = rtptrans->SetReceiveMode(sessparams.GetReceiveMode())) < 0)
+	{
+		packetbuilder.Destroy();
+		sources.Clear();
+		delete rtptrans;
+		return status;
+	}
+
+	// Init the RTCP packet builder
+	
+	double timestampunit = sessparams.GetOwnTimestampUnit();
+	u_int8_t buf[1024];
+	size_t buflen = 1024;
+	
+	if ((status = CreateCNAME(buf,&buflen,sessparams.GetResolveLocalHostname())) < 0)
+	{
+		packetbuilder.Destroy();
+		sources.Clear();
+		delete rtptrans;
+		return status;
+	}
+	
+	if ((status = rtcpbuilder.Init(maxpacksize,timestampunit,buf,buflen)) < 0)
+	{
+		packetbuilder.Destroy();
+		sources.Clear();
+		delete rtptrans;
+		return status;
+	}
+
+	// Set scheduler parameters
+	
+	rtcpsched.Reset();
+	rtcpsched.SetHeaderOverhead(rtptrans->GetHeaderOverhead());
+
+	RTCPSchedulerParams schedparams;
+
+	sessionbandwidth = sessparams.GetSessionBandwidth();
+	controlfragment = sessparams.GetControlTrafficFraction();
+	
+	if ((status = schedparams.SetRTCPBandwidth(sessionbandwidth*controlfragment)) < 0)
+	{
+		delete rtptrans;
+		packetbuilder.Destroy();
+		sources.Clear();
+		rtcpbuilder.Destroy();
+		return status;
+	}
+	if ((status = schedparams.SetSenderBandwidthFraction(sessparams.GetSenderControlBandwidthFraction())) < 0)
+	{
+		delete rtptrans;
+		packetbuilder.Destroy();
+		sources.Clear();
+		rtcpbuilder.Destroy();
+		return status;
+	}
+	if ((status = schedparams.SetMinimumTransmissionInterval(sessparams.GetMinimumRTCPTransmissionInterval())) < 0)
+	{
+		delete rtptrans;
+		packetbuilder.Destroy();
+		sources.Clear();
+		rtcpbuilder.Destroy();
+		return status;
+	}
+	schedparams.SetUseHalfAtStartup(sessparams.GetUseHalfRTCPIntervalAtStartup());
+	schedparams.SetRequestImmediateBYE(sessparams.GetRequestImmediateBYE());
+	
+	rtcpsched.SetParameters(schedparams);
+
+	// copy other parameters
+	
+	acceptownpackets = sessparams.AcceptOwnPackets();
+	membermultiplier = sessparams.GetSourceTimeoutMultiplier();
+	sendermultiplier = sessparams.GetSenderTimeoutMultiplier();
+	byemultiplier = sessparams.GetBYETimeoutMultiplier();
+	collisionmultiplier = sessparams.GetCollisionTimeoutMultiplier();
+	notemultiplier = sessparams.GetNoteTimeoutMultiplier();
+
+	// Do thread stuff if necessary
+	
+#ifdef RTP_SUPPORT_THREAD
+	pollthread = 0;
+	if (usingpollthread)
+	{
+		if (!sourcesmutex.IsInitialized())	
+		{
+			if (sourcesmutex.Init() < 0)
+			{
+				delete rtptrans;
+				packetbuilder.Destroy();
+				sources.Clear();
+				rtcpbuilder.Destroy();
+				return ERR_RTP_SESSION_CANTINITMUTEX;
+			}
+		}
+		if (!buildermutex.IsInitialized())
+		{
+			if (buildermutex.Init() < 0)
+			{
+				delete rtptrans;
+				packetbuilder.Destroy();
+				sources.Clear();
+				rtcpbuilder.Destroy();
+				return ERR_RTP_SESSION_CANTINITMUTEX;
+			}
+		}
+		if (!schedmutex.IsInitialized())
+		{
+			if (schedmutex.Init() < 0)
+			{
+				delete rtptrans;
+				packetbuilder.Destroy();
+				sources.Clear();
+				rtcpbuilder.Destroy();
+				return ERR_RTP_SESSION_CANTINITMUTEX;
+			}
+		}
+		
+		pollthread = new RTPPollThread(*this,rtcpsched);
+		if (pollthread == 0)
+		{
+			delete rtptrans;
+			packetbuilder.Destroy();
+			sources.Clear();
+			rtcpbuilder.Destroy();
+			return ERR_RTP_OUTOFMEM;
+		}
+		if ((status = pollthread->Start(rtptrans)) < 0)
+		{
+			delete rtptrans;
+			delete pollthread;
+			packetbuilder.Destroy();
+			sources.Clear();
+			rtcpbuilder.Destroy();
+			return status;
+		}
+	}
+#endif // RTP_SUPPORT_THREAD	
+	
+	created = true;
+	return 0;
+}
+
+void RTPSession::Destroy()
+{
+	if (!created)
+		return;
+
+#ifdef RTP_SUPPORT_THREAD
+	if (pollthread)
+		delete pollthread;
+#endif // RTP_SUPPORT_THREAD
+	
+	delete rtptrans;
+	packetbuilder.Destroy();
+	rtcpbuilder.Destroy();
+	rtcpsched.Reset();
+	collisionlist.Clear();
+	sources.Clear();
+
+	std::list<RTCPCompoundPacket *>::const_iterator it;
+
+	for (it = byepackets.begin() ; it != byepackets.end() ; it++)
+		delete (*it);
+	byepackets.clear();
+	
+	created = false;
+}
+
+void RTPSession::BYEDestroy(const RTPTime &maxwaittime,const void *reason,size_t reasonlength)
+{
+	if (!created)
+		return;
+
+	// first, stop the thread so we have full control over all components
+	
+#ifdef RTP_SUPPORT_THREAD
+	if (pollthread)
+		delete pollthread;
+#endif // RTP_SUPPORT_THREAD
+
+	RTPTime stoptime = RTPTime::CurrentTime();
+	stoptime += maxwaittime;
+
+	// add bye packet to the list if we've sent data
+
+	RTCPCompoundPacket *pack;
+
+	if (rtptrans->GetNumRTPPacketsSent() != 0 || rtptrans->GetNumRTCPPacketsSent() != 0)
+	{
+		int status;
+		
+		reasonlength = (reasonlength>RTCP_BYE_MAXREASONLENGTH)?RTCP_BYE_MAXREASONLENGTH:reasonlength;
+	       	status = rtcpbuilder.BuildBYEPacket(&pack,reason,reasonlength,useSR_BYEifpossible);
+		if (status >= 0)
+		{
+			byepackets.push_back(pack);
+	
+			if (byepackets.size() == 1)
+				rtcpsched.ScheduleBYEPacket(pack->GetCompoundPacketLength());
+		}
+	}
+	
+	if (!byepackets.empty())
+	{
+		bool done = false;
+		
+		while (!done)
+		{
+			RTPTime curtime = RTPTime::CurrentTime();
+			
+			if (curtime >= stoptime)
+				done = true;
+		
+			if (rtcpsched.IsTime())
+			{
+				pack = *(byepackets.begin());
+				byepackets.pop_front();
+			
+				rtptrans->SendRTCPData(pack->GetCompoundPacketData(),pack->GetCompoundPacketLength());
+				delete pack;
+				if (!byepackets.empty()) // more bye packets to send, schedule them
+					rtcpsched.ScheduleBYEPacket((*(byepackets.begin()))->GetCompoundPacketLength());
+				else
+					done = true;
+			}
+			if (!done)
+				RTPTime::Wait(RTPTime(0,100000));
+		}
+	}
+	
+	delete rtptrans;
+	packetbuilder.Destroy();
+	rtcpbuilder.Destroy();
+	rtcpsched.Reset();
+	collisionlist.Clear();
+	sources.Clear();
+
+	// clear rest of bye packets
+	std::list<RTCPCompoundPacket *>::const_iterator it;
+
+	for (it = byepackets.begin() ; it != byepackets.end() ; it++)
+		delete (*it);
+	byepackets.clear();
+	
+	created = false;
+}
+
+bool RTPSession::IsActive()
+{
+	return created;
+}
+
+u_int32_t RTPSession::GetLocalSSRC()
+{
+	if (!created)
+		return 0;
+	
+	u_int32_t ssrc;
+
+	BUILDER_LOCK
+	ssrc = packetbuilder.GetSSRC();
+	BUILDER_UNLOCK
+	return ssrc;
+}
+
+int RTPSession::AddDestination(const RTPAddress &addr)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	return rtptrans->AddDestination(addr);
+}
+
+int RTPSession::DeleteDestination(const RTPAddress &addr)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	return rtptrans->DeleteDestination(addr);
+}
+
+void RTPSession::ClearDestinations()
+{
+	if (!created)
+		return;
+	rtptrans->ClearDestinations();
+}
+
+bool RTPSession::SupportsMulticasting()
+{
+	if (!created)
+		return false;
+	return rtptrans->SupportsMulticasting();
+}
+
+int RTPSession::JoinMulticastGroup(const RTPAddress &addr)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	return rtptrans->JoinMulticastGroup(addr);
+}
+
+int RTPSession::LeaveMulticastGroup(const RTPAddress &addr)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	return rtptrans->LeaveMulticastGroup(addr);
+}
+
+void RTPSession::LeaveAllMulticastGroups()
+{
+	if (!created)
+		return;
+	rtptrans->LeaveAllMulticastGroups();
+}
+
+int RTPSession::SendPacket(const void *data,size_t len)
+{
+	int status;
+	
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	BUILDER_LOCK
+	if ((status = packetbuilder.BuildPacket(data,len)) < 0)
+	{
+		BUILDER_UNLOCK
+		return status;
+	}
+	if ((status = rtptrans->SendRTPData(packetbuilder.GetPacket(),packetbuilder.GetPacketLength())) < 0)
+	{
+		BUILDER_UNLOCK
+		return status;
+	}
+	BUILDER_UNLOCK
+
+	SOURCES_LOCK
+	sources.SentRTPPacket();
+	SOURCES_UNLOCK
+	return 0;
+}
+
+int RTPSession::SendPacket(const void *data,size_t len,
+                u_int8_t pt,bool mark,u_int32_t timestampinc)
+{
+	int status;
+
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	
+	BUILDER_LOCK
+	if ((status = packetbuilder.BuildPacket(data,len,pt,mark,timestampinc)) < 0)
+	{
+		BUILDER_UNLOCK
+		return status;
+	}
+	if ((status = rtptrans->SendRTPData(packetbuilder.GetPacket(),packetbuilder.GetPacketLength())) < 0)
+	{
+		BUILDER_UNLOCK
+		return status;
+	}
+	BUILDER_UNLOCK
+	
+	SOURCES_LOCK
+	sources.SentRTPPacket();
+	SOURCES_UNLOCK
+	return 0;
+}
+
+int RTPSession::SendPacketEx(const void *data,size_t len,
+                  u_int16_t hdrextID,const void *hdrextdata,size_t numhdrextwords)
+{
+	int status;
+	
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	BUILDER_LOCK
+	if ((status = packetbuilder.BuildPacketEx(data,len,hdrextID,hdrextdata,numhdrextwords)) < 0)
+	{
+		BUILDER_UNLOCK
+		return status;
+	}
+	if ((status = rtptrans->SendRTPData(packetbuilder.GetPacket(),packetbuilder.GetPacketLength())) < 0)
+	{
+		BUILDER_UNLOCK
+		return status;
+	}
+	BUILDER_UNLOCK
+
+	SOURCES_LOCK
+	sources.SentRTPPacket();
+	SOURCES_UNLOCK
+	return 0;
+}
+
+int RTPSession::SendPacketEx(const void *data,size_t len,
+                  u_int8_t pt,bool mark,u_int32_t timestampinc,
+                  u_int16_t hdrextID,const void *hdrextdata,size_t numhdrextwords)
+{
+	int status;
+	
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	
+	BUILDER_LOCK
+	if ((status = packetbuilder.BuildPacketEx(data,len,pt,mark,timestampinc,hdrextID,hdrextdata,numhdrextwords)) < 0)
+	{
+		BUILDER_UNLOCK
+		return status;
+	}
+	if ((status = rtptrans->SendRTPData(packetbuilder.GetPacket(),packetbuilder.GetPacketLength())) < 0)
+	{
+		BUILDER_UNLOCK
+		return status;
+	}
+	BUILDER_UNLOCK
+
+	SOURCES_LOCK
+	sources.SentRTPPacket();
+	SOURCES_UNLOCK
+	return 0;
+}
+
+int RTPSession::SetDefaultPayloadType(u_int8_t pt)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	
+	int status;
+	
+	BUILDER_LOCK
+	status = packetbuilder.SetDefaultPayloadType(pt);
+	BUILDER_UNLOCK
+	return status;
+}
+
+int RTPSession::SetDefaultMark(bool m)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+
+	BUILDER_LOCK
+	status = packetbuilder.SetDefaultMark(m);
+	BUILDER_UNLOCK
+	return status;
+}
+
+int RTPSession::SetDefaultTimestampIncrement(u_int32_t timestampinc)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+
+	BUILDER_LOCK
+	status = packetbuilder.SetDefaultTimestampIncrement(timestampinc);
+	BUILDER_UNLOCK
+	return status;
+}
+
+int RTPSession::IncrementTimestamp(u_int32_t inc)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+
+	BUILDER_LOCK
+	status = packetbuilder.IncrementTimestamp(inc);
+	BUILDER_UNLOCK
+	return status;
+}
+
+int RTPSession::IncrementTimestampDefault()
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+	
+	BUILDER_LOCK
+	status = packetbuilder.IncrementTimestampDefault();
+	BUILDER_UNLOCK
+	return status;
+}
+
+RTPTransmissionInfo *RTPSession::GetTransmissionInfo()
+{
+	if (!created)
+		return 0;
+	return rtptrans->GetTransmissionInfo();
+}
+
+int RTPSession::Poll()
+{
+	int status;
+	
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	if (usingpollthread)
+		return ERR_RTP_SESSION_USINGPOLLTHREAD;
+	if ((status = rtptrans->Poll()) < 0)
+		return status;
+	return ProcessPolledData();
+}
+
+int RTPSession::WaitForIncomingData(const RTPTime &delay,bool *dataavailable)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	if (usingpollthread)
+		return ERR_RTP_SESSION_USINGPOLLTHREAD;
+	return rtptrans->WaitForIncomingData(delay,dataavailable);
+}
+
+int RTPSession::AbortWait()
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	if (usingpollthread)
+		return ERR_RTP_SESSION_USINGPOLLTHREAD;
+	return rtptrans->AbortWait();
+}
+
+RTPTime RTPSession::GetRTCPDelay()
+{
+	if (!created)
+		return RTPTime(0,0);
+	if (usingpollthread)
+		return RTPTime(0,0);
+
+	SOURCES_LOCK
+	SCHED_LOCK
+	RTPTime t = rtcpsched.GetTransmissionDelay();
+	SCHED_UNLOCK
+	SOURCES_UNLOCK
+	return t;
+}
+
+int RTPSession::BeginDataAccess()
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	SOURCES_LOCK
+	return 0;
+}
+
+bool RTPSession::GotoFirstSource()
+{
+	if (!created)
+		return false;
+	return sources.GotoFirstSource();
+}
+
+bool RTPSession::GotoNextSource()
+{
+	if (!created)
+		return false;
+	return sources.GotoNextSource();
+}
+
+bool RTPSession::GotoPreviousSource()
+{
+	if (!created)
+		return false;
+	return sources.GotoPreviousSource();
+}
+
+bool RTPSession::GotoFirstSourceWithData()
+{
+	if (!created)
+		return false;
+	return sources.GotoFirstSourceWithData();
+}
+
+bool RTPSession::GotoNextSourceWithData()
+{
+	if (!created)
+		return false;
+	return sources.GotoNextSourceWithData();
+}
+
+bool RTPSession::GotoPreviousSourceWithData()
+{
+	if (!created)
+		return false;
+	return sources.GotoPreviousSourceWithData();
+}
+
+RTPSourceData *RTPSession::GetCurrentSourceInfo()
+{
+	if (!created)
+		return 0;
+	return sources.GetCurrentSourceInfo();
+}
+
+RTPSourceData *RTPSession::GetSourceInfo(u_int32_t ssrc)
+{
+	if (!created)
+		return 0;
+	return sources.GetSourceInfo(ssrc);
+}
+
+RTPPacket *RTPSession::GetNextPacket()
+{
+	if (!created)
+		return 0;
+	return sources.GetNextPacket();
+}
+
+int RTPSession::EndDataAccess()
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	SOURCES_UNLOCK
+	return 0;
+}
+
+int RTPSession::SetReceiveMode(RTPTransmitter::ReceiveMode m)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	return rtptrans->SetReceiveMode(m);
+}
+
+int RTPSession::AddToIgnoreList(const RTPAddress &addr)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	return rtptrans->AddToIgnoreList(addr);
+}
+
+int RTPSession::DeleteFromIgnoreList(const RTPAddress &addr)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	return rtptrans->DeleteFromIgnoreList(addr);
+}
+
+void RTPSession::ClearIgnoreList()
+{
+	if (!created)
+		return;
+	rtptrans->ClearIgnoreList();
+}
+
+int RTPSession::AddToAcceptList(const RTPAddress &addr)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	return rtptrans->AddToAcceptList(addr);
+}
+
+int RTPSession::DeleteFromAcceptList(const RTPAddress &addr)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+	return rtptrans->DeleteFromAcceptList(addr);
+}
+
+void RTPSession::ClearAcceptList()
+{
+	if (!created)
+		return;
+	rtptrans->ClearAcceptList();
+}
+
+int RTPSession::SetMaximumPacketSize(size_t s)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	if (s < RTP_MINPACKETSIZE)
+		return ERR_RTP_SESSION_MAXPACKETSIZETOOSMALL;
+	
+	int status;
+
+	if ((status = rtptrans->SetMaximumPacketSize(s)) < 0)
+		return status;
+
+	BUILDER_LOCK
+	if ((status = packetbuilder.SetMaximumPacketSize(s)) < 0)
+	{
+		BUILDER_UNLOCK
+		// restore previous max packet size
+		rtptrans->SetMaximumPacketSize(maxpacksize);
+		return status;
+	}
+	if ((status = rtcpbuilder.SetMaximumPacketSize(s)) < 0)
+	{
+		// restore previous max packet size
+		packetbuilder.SetMaximumPacketSize(maxpacksize);
+		BUILDER_UNLOCK
+		rtptrans->SetMaximumPacketSize(maxpacksize);
+		return status;
+	}
+	BUILDER_UNLOCK
+	maxpacksize = s;
+	return 0;
+}
+
+int RTPSession::SetSessionBandwidth(double bw)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+	SCHED_LOCK
+	RTCPSchedulerParams p = rtcpsched.GetParameters();
+	status = p.SetRTCPBandwidth(bw*controlfragment);
+	if (status >= 0)
+	{
+		rtcpsched.SetParameters(p);
+		sessionbandwidth = bw;
+	}
+	SCHED_UNLOCK
+	return status;
+}
+
+int RTPSession::SetTimestampUnit(double u)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+
+	BUILDER_LOCK
+	status = rtcpbuilder.SetTimestampUnit(u);
+	BUILDER_UNLOCK
+	return status;
+}
+
+void RTPSession::SetNameInterval(int count)
+{
+	if (!created)
+		return;
+	BUILDER_LOCK
+	rtcpbuilder.SetNameInterval(count);
+	BUILDER_UNLOCK
+}
+
+void RTPSession::SetEMailInterval(int count)
+{
+	if (!created)
+		return;
+	BUILDER_LOCK
+	rtcpbuilder.SetEMailInterval(count);
+	BUILDER_UNLOCK
+}
+
+void RTPSession::SetLocationInterval(int count)
+{
+	if (!created)
+		return;
+	BUILDER_LOCK
+	rtcpbuilder.SetLocationInterval(count);
+	BUILDER_UNLOCK
+}
+
+void RTPSession::SetPhoneInterval(int count)
+{
+	if (!created)
+		return;
+	BUILDER_LOCK
+	rtcpbuilder.SetPhoneInterval(count);
+	BUILDER_UNLOCK
+}
+
+void RTPSession::SetToolInterval(int count)
+{
+	if (!created)
+		return;
+	BUILDER_LOCK
+	rtcpbuilder.SetToolInterval(count);
+	BUILDER_UNLOCK
+}
+
+void RTPSession::SetNoteInterval(int count)
+{
+	if (!created)
+		return;
+	BUILDER_LOCK
+	rtcpbuilder.SetNoteInterval(count);
+	BUILDER_UNLOCK
+}
+
+int RTPSession::SetLocalName(const void *s,size_t len)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+	BUILDER_LOCK
+	status = rtcpbuilder.SetLocalName(s,len);
+	BUILDER_UNLOCK
+	return status;
+}
+
+int RTPSession::SetLocalEMail(const void *s,size_t len)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+	BUILDER_LOCK
+	status = rtcpbuilder.SetLocalEMail(s,len);
+	BUILDER_UNLOCK
+	return status;
+}
+
+int RTPSession::SetLocalLocation(const void *s,size_t len)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+	BUILDER_LOCK
+	status = rtcpbuilder.SetLocalLocation(s,len);
+	BUILDER_UNLOCK
+	return status;
+}
+
+int RTPSession::SetLocalPhone(const void *s,size_t len)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+	BUILDER_LOCK
+	status = rtcpbuilder.SetLocalPhone(s,len);
+	BUILDER_UNLOCK
+	return status;
+}
+
+int RTPSession::SetLocalTool(const void *s,size_t len)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+	BUILDER_LOCK
+	status = rtcpbuilder.SetLocalTool(s,len);
+	BUILDER_UNLOCK
+	return status;
+}
+
+int RTPSession::SetLocalNote(const void *s,size_t len)
+{
+	if (!created)
+		return ERR_RTP_SESSION_NOTCREATED;
+
+	int status;
+	BUILDER_LOCK
+	status = rtcpbuilder.SetLocalNote(s,len);
+	BUILDER_UNLOCK
+	return status;
+}
+
+int RTPSession::ProcessPolledData()
+{
+	RTPRawPacket *rawpack;
+	int status;
+	
+	SOURCES_LOCK
+	while ((rawpack = rtptrans->GetNextPacket()) != 0)
+	{
+		sources.ClearOwnCollisionFlag();
+
+		// since our sources instance also uses the scheduler (analysis of incoming packets)
+		// we'll lock it
+		SCHED_LOCK
+		if ((status = sources.ProcessRawPacket(rawpack,rtptrans,acceptownpackets)) < 0)
+		{
+			SCHED_UNLOCK
+			SOURCES_UNLOCK
+			delete rawpack;
+			return status;
+		}
+		SCHED_UNLOCK
+				
+		if (sources.DetectedOwnCollision()) // collision handling!
+		{
+			bool created;
+			
+			if ((status = collisionlist.UpdateAddress(rawpack->GetSenderAddress(),rawpack->GetReceiveTime(),&created)) < 0)
+			{
+				SOURCES_UNLOCK
+				delete rawpack;
+				return status;
+			}
+
+			if (created) // first time we've encountered this address, send bye packet and
+			{            // change our own SSRC
+				if (rtptrans->GetNumRTPPacketsSent() != 0 || rtptrans->GetNumRTCPPacketsSent() != 0)
+				{
+					// Only send BYE packet if we've actually sent data using this
+					// SSRC
+					
+					RTCPCompoundPacket *rtcpcomppack;
+
+					BUILDER_LOCK
+					if ((status = rtcpbuilder.BuildBYEPacket(&rtcpcomppack,0,0,useSR_BYEifpossible)) < 0)
+					{
+						BUILDER_UNLOCK
+						SOURCES_UNLOCK
+						delete rawpack;
+						return status;
+					}
+					BUILDER_UNLOCK
+
+					byepackets.push_back(rtcpcomppack);
+					if (byepackets.size() == 1) // was the first packet, schedule a BYE packet (otherwise there's already one scheduled)
+					{
+						SCHED_LOCK
+						rtcpsched.ScheduleBYEPacket(rtcpcomppack->GetCompoundPacketLength());
+						SCHED_UNLOCK
+					}
+				}
+				// bye packet is built and scheduled, now change our SSRC
+				// and reset the packet count in the transmitter
+				
+				BUILDER_LOCK
+				u_int32_t newssrc = packetbuilder.CreateNewSSRC(sources);
+				BUILDER_UNLOCK
+					
+				rtptrans->ResetPacketCount();
+
+				// remove old entry in source table and add new one
+
+				if ((status = sources.DeleteOwnSSRC()) < 0)
+				{
+					SOURCES_UNLOCK
+					delete rawpack;
+					return status;
+				}
+				if ((status = sources.CreateOwnSSRC(newssrc)) < 0)
+				{
+					SOURCES_UNLOCK
+					delete rawpack;
+					return status;
+				}
+			}
+		}
+		
+		delete rawpack;
+	}
+
+	SCHED_LOCK
+	RTPTime d = rtcpsched.CalculateDeterministicInterval(false);
+	SCHED_UNLOCK
+	
+	RTPTime t = RTPTime::CurrentTime();
+	double Td = d.GetDouble();
+	RTPTime sendertimeout = RTPTime(Td*sendermultiplier);
+	RTPTime generaltimeout = RTPTime(Td*membermultiplier);
+	RTPTime byetimeout = RTPTime(Td*byemultiplier);
+	RTPTime colltimeout = RTPTime(Td*collisionmultiplier);
+	RTPTime notetimeout = RTPTime(Td*notemultiplier);
+	
+	sources.MultipleTimeouts(t,sendertimeout,byetimeout,generaltimeout,notetimeout);
+	collisionlist.Timeout(t,colltimeout);
+	
+	// We'll check if it's time for RTCP stuff
+
+	SCHED_LOCK
+	bool istime = rtcpsched.IsTime();
+	SCHED_UNLOCK
+	
+	if (istime)
+	{
+		RTCPCompoundPacket *pack;
+	
+		// we'll check if there's a bye packet to send, or just a normal packet
+
+		if (byepackets.empty())
+		{
+			BUILDER_LOCK
+			if ((status = rtcpbuilder.BuildNextPacket(&pack)) < 0)
+			{
+				BUILDER_UNLOCK
+				SOURCES_UNLOCK
+				return status;
+			}
+			BUILDER_UNLOCK
+			if ((status = rtptrans->SendRTCPData(pack->GetCompoundPacketData(),pack->GetCompoundPacketLength())) < 0)
+			{
+				SOURCES_UNLOCK
+				delete pack;
+				return status;
+			}
+		}
+		else
+		{
+			pack = *(byepackets.begin());
+			byepackets.pop_front();
+			
+			if ((status = rtptrans->SendRTCPData(pack->GetCompoundPacketData(),pack->GetCompoundPacketLength())) < 0)
+			{
+				SOURCES_UNLOCK
+				delete pack;
+				return status;
+			}
+			
+			if (!byepackets.empty()) // more bye packets to send, schedule them
+			{
+				SCHED_LOCK
+				rtcpsched.ScheduleBYEPacket((*(byepackets.begin()))->GetCompoundPacketLength());
+				SCHED_UNLOCK
+			}
+		}
+		
+		SCHED_LOCK
+		rtcpsched.AnalyseOutgoing(*pack);
+		SCHED_UNLOCK
+
+		delete pack;
+	}
+	SOURCES_UNLOCK
+	return 0;
+}
+
+int RTPSession::CreateCNAME(u_int8_t *buffer,size_t *bufferlength,bool resolve)
+{
+#ifndef WIN32
+	bool gotlogin = true;
+#ifdef RTP_SUPPORT_GETLOGINR
+	buffer[0] = 0;
+	if (getlogin_r((char *)buffer,*bufferlength) != 0)
+		gotlogin = false;
+	else
+	{
+		if (buffer[0] == 0)
+			gotlogin = false;
+	}
+	
+	if (!gotlogin) // try regular getlogin
+	{
+		char *loginname = getlogin();
+		if (loginname == 0)
+			gotlogin = false;
+		else
+			strncpy((char *)buffer,loginname,*bufferlength);
+	}
+#else
+	char *loginname = getlogin();
+	if (loginname == 0)
+		gotlogin = false;
+	else
+		strncpy((char *)buffer,loginname,*bufferlength);
+#endif // RTP_SUPPORT_GETLOGINR
+	if (!gotlogin)
+	{
+		char *logname = getenv("LOGNAME");
+		if (logname == 0)
+			return ERR_RTP_SESSION_CANTGETLOGINNAME;
+		strncpy((char *)buffer,logname,*bufferlength);
+	}
+#else // Win32 version
+
+#ifndef _WIN32_WCE
+	DWORD len = *bufferlength;
+	if (!GetUserName((LPTSTR)buffer,&len))
+		strcpy((char *)buffer,"unknown");
+#else 
+	strcpy((char *)buffer,"unknown");
+#endif // _WIN32_WCE
+	
+#endif // WIN32
+	buffer[*bufferlength-1] = 0;
+
+	size_t offset = strlen((const char *)buffer);
+	if (offset < (*bufferlength-1))
+		buffer[offset] = (u_int8_t)'@';
+	offset++;
+
+	size_t buflen2 = *bufferlength-offset;
+	int status;
+	
+	if (resolve)
+	{
+		if ((status = rtptrans->GetLocalHostName(buffer+offset,&buflen2)) < 0)
+			return status;
+		*bufferlength = buflen2+offset;
+	}
+	else
+	{
+		char hostname[1024];
+		
+		strcpy(hostname,"localhost"); // just in case gethostname fails
+		gethostname(hostname,1024);
+		strncpy((char *)(buffer+offset),hostname,buflen2);
+		*bufferlength = offset+strlen(hostname);
+	}
+	if (*bufferlength > RTCP_SDES_MAXITEMLENGTH)
+		*bufferlength = RTCP_SDES_MAXITEMLENGTH;
+	return 0;
+}
+
+#ifdef RTPDEBUG
+void RTPSession::DumpSources()
+{
+	BeginDataAccess();
+	std::cout << "----------------------------------------------------------------" << std::endl;
+	sources.Dump();
+	EndDataAccess();
+}
+
+void RTPSession::DumpTransmitter()
+{
+	if (created)
+		rtptrans->Dump();
+}
+#endif // RTPDEBUG
+

Added: konference/src/rtp/jrtplib/rtpsession.h
===================================================================
--- konference/src/rtp/jrtplib/rtpsession.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpsession.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,215 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPSESSION_H
+
+#define RTPSESSION_H
+
+#include "rtpconfig.h"
+#include "rtplibraryversion.h"
+#include "rtppacketbuilder.h"
+#include "rtpsessionsources.h"
+#include "rtptransmitter.h"
+#include "rtpcollisionlist.h"
+#include "rtcpscheduler.h"
+#include "rtcppacketbuilder.h"
+#include "rtptimeutilities.h"
+#include <list>
+
+#ifdef RTP_SUPPORT_THREAD
+	#include <jmutex.h>	
+#endif // RTP_SUPPORT_THREAD
+
+class RTPTransmitter;
+class RTPSessionParams;
+class RTPTransmissionParams;
+class RTPAddress;
+class RTPSourceData;
+class RTPPacket;
+class RTPPollThread;
+class RTPTransmissionInfo;
+class RTCPCompoundPacket;
+class RTCPPacket;
+class RTCPAPPPacket;
+
+class RTPSession
+{
+public:
+	RTPSession(RTPTransmitter::TransmissionProtocol proto = RTPTransmitter::IPv4UDPProto);
+	virtual ~RTPSession();
+	
+	int Create(const RTPSessionParams &sessparams,const RTPTransmissionParams *transparams = 0);
+	void Destroy();
+	void BYEDestroy(const RTPTime &maxwaittime,const void *reason,size_t reasonlength);
+	bool IsActive();
+	
+	u_int32_t GetLocalSSRC();
+	
+	int AddDestination(const RTPAddress &addr);
+	int DeleteDestination(const RTPAddress &addr);
+	void ClearDestinations();
+
+	bool SupportsMulticasting();
+	int JoinMulticastGroup(const RTPAddress &addr);
+	int LeaveMulticastGroup(const RTPAddress &addr);
+	void LeaveAllMulticastGroups();
+
+	int SendPacket(const void *data,size_t len);
+	int SendPacket(const void *data,size_t len,
+	                u_int8_t pt,bool mark,u_int32_t timestampinc);
+	int SendPacketEx(const void *data,size_t len,
+	                  u_int16_t hdrextID,const void *hdrextdata,size_t numhdrextwords);
+	int SendPacketEx(const void *data,size_t len,
+	                  u_int8_t pt,bool mark,u_int32_t timestampinc,
+	                  u_int16_t hdrextID,const void *hdrextdata,size_t numhdrextwords);
+	int SetDefaultPayloadType(u_int8_t pt);
+	int SetDefaultMark(bool m);
+	int SetDefaultTimestampIncrement(u_int32_t timestampinc);
+	int IncrementTimestamp(u_int32_t inc);
+	int IncrementTimestampDefault();
+	
+	RTPTransmissionInfo *GetTransmissionInfo();
+	int Poll();
+	int WaitForIncomingData(const RTPTime &delay,bool *dataavailable = 0);
+	int AbortWait();
+	RTPTime GetRTCPDelay();
+
+	// The following methods (GotoFirstSource till GetNextPacket) should
+	// be called between calls to BeginDataAccess end EndDataAccess. This
+	// makes sure that nasty things don't happen (e.g. when a background
+	// thread is polling for data)
+	int BeginDataAccess();
+	bool GotoFirstSource();
+	bool GotoNextSource();
+	bool GotoPreviousSource();
+	bool GotoFirstSourceWithData();
+	bool GotoNextSourceWithData();
+	bool GotoPreviousSourceWithData();
+	RTPSourceData *GetCurrentSourceInfo();
+	RTPSourceData *GetSourceInfo(u_int32_t ssrc);
+	RTPPacket *GetNextPacket();
+	int EndDataAccess();
+	
+	int SetReceiveMode(RTPTransmitter::ReceiveMode m);
+	int AddToIgnoreList(const RTPAddress &addr);
+	int DeleteFromIgnoreList(const RTPAddress &addr);
+	void ClearIgnoreList();
+	int AddToAcceptList(const RTPAddress &addr);
+	int DeleteFromAcceptList(const RTPAddress &addr);
+	void ClearAcceptList();
+	
+	int SetMaximumPacketSize(size_t s);
+	int SetSessionBandwidth(double bw);
+	int SetTimestampUnit(double u);
+	
+	void SetNameInterval(int count);
+	void SetEMailInterval(int count);
+	void SetLocationInterval(int count);
+	void SetPhoneInterval(int count);
+	void SetToolInterval(int count);
+	void SetNoteInterval(int count);
+	int SetLocalName(const void *s,size_t len);
+	int SetLocalEMail(const void *s,size_t len);
+	int SetLocalLocation(const void *s,size_t len);
+	int SetLocalPhone(const void *s,size_t len);
+	int SetLocalTool(const void *s,size_t len);
+	int SetLocalNote(const void *s,size_t len);
+
+#ifdef RTPDEBUG
+	void DumpSources();
+	void DumpTransmitter();
+#endif // RTPDEBUG
+protected:
+	virtual RTPTransmitter *NewUserDefinedTransmitter()						{ return 0; }
+	
+	virtual void OnRTPPacket(RTPPacket *pack,const RTPTime &receivetime,
+	                         const RTPAddress *senderaddress) 					{ }
+	virtual void OnRTCPCompoundPacket(RTCPCompoundPacket *pack,const RTPTime &receivetime,
+	                                  const RTPAddress *senderaddress) 				{ }
+	virtual void OnSSRCCollision(RTPSourceData *srcdat,const RTPAddress *senderaddress,bool isrtp)	{ }
+	virtual void OnCNAMECollision(RTPSourceData *srcdat,const RTPAddress *senderaddress,
+	                              const u_int8_t *cname,size_t cnamelength)				{ }
+	virtual void OnNewSource(RTPSourceData *srcdat)			 				{ }
+	virtual void OnRemoveSource(RTPSourceData *srcdat)						{ }
+	virtual void OnTimeout(RTPSourceData *srcdat)							{ }
+	virtual void OnBYETimeout(RTPSourceData *srcdat)						{ }
+	virtual void OnAPPPacket(RTCPAPPPacket *apppacket,const RTPTime &receivetime,
+	                         const RTPAddress *senderaddress)					{ }
+	virtual void OnUnknownPacketType(RTCPPacket *rtcppack,const RTPTime &receivetime,
+	                                 const RTPAddress *senderaddress)				{ }
+	virtual void OnUnknownPacketFormat(RTCPPacket *rtcppack,const RTPTime &receivetime,
+	                                   const RTPAddress *senderaddress)				{ }
+	virtual void OnNoteTimeout(RTPSourceData *srcdat)						{ }
+	virtual void OnBYEPacket(RTPSourceData *srcdat)							{ }
+#ifdef RTP_SUPPORT_THREAD
+	virtual void OnPollThreadError(int errcode)							{ }
+	virtual void OnPollThreadStep()									{ }
+#endif // RTP_SUPPORT_THREAD
+private:
+	int CreateCNAME(u_int8_t *buffer,size_t *bufferlength,bool resolve);
+	int ProcessPolledData();
+	int ProcessRTCPCompoundPacket(RTCPCompoundPacket &rtcpcomppack,RTPRawPacket *pack);
+	
+	RTPTransmitter *rtptrans;
+	const RTPTransmitter::TransmissionProtocol protocol;	
+	bool created;
+	bool usingpollthread;
+	bool acceptownpackets;
+	bool useSR_BYEifpossible;
+	size_t maxpacksize;
+	double sessionbandwidth;
+	double controlfragment;
+	double sendermultiplier;
+	double byemultiplier;
+	double membermultiplier;
+	double collisionmultiplier;
+	double notemultiplier;
+
+	RTPSessionSources sources;
+	RTPPacketBuilder packetbuilder;
+	RTCPScheduler rtcpsched;
+	RTCPPacketBuilder rtcpbuilder;
+	RTPCollisionList collisionlist;
+
+	std::list<RTCPCompoundPacket *> byepackets;
+	
+#ifdef RTP_SUPPORT_THREAD
+	RTPPollThread *pollthread;
+	JMutex sourcesmutex,buildermutex,schedmutex;
+
+	friend class RTPPollThread;
+#endif // RTP_SUPPORT_THREAD
+	friend class RTPSessionSources;
+};
+
+#endif // RTPSESSION_H
+

Added: konference/src/rtp/jrtplib/rtpsessionparams.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpsessionparams.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpsessionparams.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,80 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtpconfig.h"
+#include "rtpsessionparams.h"
+#include "rtpdefines.h"
+#include "rtperrors.h"
+
+#include "rtpdebug.h"
+
+RTPSessionParams::RTPSessionParams() : mininterval(0,0)
+{
+#ifdef RTP_SUPPORT_THREAD
+	usepollthread = true;
+#else
+	usepollthread = false;
+#endif // RTP_SUPPORT_THREAD
+	maxpacksize = RTP_DEFAULTPACKETSIZE;
+	receivemode = RTPTransmitter::AcceptAll;
+	acceptown = false;
+	owntsunit = -1; // The user will have to set it to the correct value himself
+	resolvehostname = false;
+#ifdef RTP_SUPPORT_PROBATION
+	probationtype = RTPSources::ProbationStore;
+#endif // RTP_SUPPORT_PROBATION
+
+	mininterval = RTPTime(RTCP_DEFAULTMININTERVAL);
+	sessionbandwidth = RTP_DEFAULTSESSIONBANDWIDTH;
+	controlfrac = RTCP_DEFAULTBANDWIDTHFRACTION;
+	senderfrac = RTCP_DEFAULTSENDERFRACTION;
+	usehalfatstartup = RTCP_DEFAULTHALFATSTARTUP;
+	immediatebye = RTCP_DEFAULTIMMEDIATEBYE;
+	SR_BYE = RTCP_DEFAULTSRBYE;
+
+	sendermultiplier = RTP_SENDERTIMEOUTMULTIPLIER;
+	generaltimeoutmultiplier = RTP_MEMBERTIMEOUTMULTIPLIER;
+	byetimeoutmultiplier = RTP_BYETIMEOUTMULTIPLIER;
+	collisionmultiplier = RTP_COLLISIONTIMEOUTMULTIPLIER;
+	notemultiplier = RTP_NOTETTIMEOUTMULTIPLIER;
+}
+
+int RTPSessionParams::SetUsePollThread(bool usethread)
+{
+#ifndef RTP_SUPPORT_THREAD
+	return ERR_RTP_NOTHREADSUPPORT;
+#else
+	usepollthread = usethread;
+	return 0;
+#endif // RTP_SUPPORT_THREAD
+}
+

Added: konference/src/rtp/jrtplib/rtpsessionparams.h
===================================================================
--- konference/src/rtp/jrtplib/rtpsessionparams.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpsessionparams.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,117 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPSESSIONPARAMS_H
+
+#define RTPSESSIONPARAMS_H
+
+#include "rtpconfig.h"
+#include "rtptypes.h"
+#include "rtptransmitter.h"
+#include "rtptimeutilities.h"
+#include "rtpsources.h"
+
+class RTPSessionParams
+{
+public:
+	RTPSessionParams();
+
+	int SetUsePollThread(bool usethread);
+	bool IsUsingPollThread() const						{ return usepollthread; }
+	void SetMaximumPacketSize(size_t max)					{ maxpacksize = max; }
+	size_t GetMaximumPacketSize() const					{ return maxpacksize; }
+	void SetAcceptOwnPackets(bool accept)					{ acceptown = accept; }
+	bool AcceptOwnPackets() const						{ return acceptown; }
+	void SetReceiveMode(RTPTransmitter::ReceiveMode recvmode)		{ receivemode = recvmode; }
+	RTPTransmitter::ReceiveMode GetReceiveMode() const			{ return receivemode; }
+	void SetOwnTimestampUnit(double tsunit)					{ owntsunit = tsunit; }
+	double GetOwnTimestampUnit() const					{ return owntsunit; }
+	void SetResolveLocalHostname(bool v)					{ resolvehostname = v; }
+	bool GetResolveLocalHostname() const					{ return resolvehostname; }
+#ifdef RTP_SUPPORT_PROBATION
+	void SetProbationType(RTPSources::ProbationType probtype)		{ probationtype = probtype; }
+	RTPSources::ProbationType GetProbationType() const			{ return probationtype; }
+#endif // RTP_SUPPORT_PROBATION
+
+	void SetSessionBandwidth(double sessbw)					{ sessionbandwidth = sessbw; }
+	double GetSessionBandwidth() const					{ return sessionbandwidth; }
+	void SetControlTrafficFraction(double frac)				{ controlfrac = frac; }
+	double GetControlTrafficFraction() const				{ return controlfrac; }
+	void SetSenderControlBandwidthFraction(double frac)			{ senderfrac = frac; }
+	double GetSenderControlBandwidthFraction() const			{ return senderfrac; }
+	void SetMinimumRTCPTransmissionInterval(const RTPTime &t)		{ mininterval = t; }
+	RTPTime GetMinimumRTCPTransmissionInterval() const			{ return mininterval; }
+	void SetUseHalfRTCPIntervalAtStartup(bool usehalf)			{ usehalfatstartup = usehalf; }
+	bool GetUseHalfRTCPIntervalAtStartup() const				{ return usehalfatstartup; }
+	void SetRequestImmediateBYE(bool v) 					{ immediatebye = v; }
+	bool GetRequestImmediateBYE() const					{ return immediatebye; }
+	void SetSenderReportForBYE(bool v)					{ SR_BYE = v; }
+	bool GetSenderReportForBYE() const					{ return SR_BYE; }
+
+	void SetSenderTimeoutMultiplier(double m)				{ sendermultiplier = m; }
+	double GetSenderTimeoutMultiplier() const				{ return sendermultiplier; }
+	void SetSourceTimeoutMultiplier(double m)				{ generaltimeoutmultiplier = m; }
+	double GetSourceTimeoutMultiplier() const				{ return generaltimeoutmultiplier; }
+	void SetBYETimeoutMultiplier(double m)					{ byetimeoutmultiplier = m; }
+	double GetBYETimeoutMultiplier() const					{ return byetimeoutmultiplier; }
+	void SetCollisionTimeoutMultiplier(double m)				{ collisionmultiplier = m; }
+	double GetCollisionTimeoutMultiplier() const				{ return collisionmultiplier; }
+	void SetNoteTimeoutMultiplier(double m)					{ notemultiplier = m; }
+	double GetNoteTimeoutMultiplier() const					{ return notemultiplier; }
+private:
+	bool acceptown;
+	bool usepollthread;
+	int maxpacksize;
+	double owntsunit;
+	RTPTransmitter::ReceiveMode receivemode;
+	bool resolvehostname;
+#ifdef RTP_SUPPORT_PROBATION
+	RTPSources::ProbationType probationtype;
+#endif // RTP_SUPPORT_PROBATION
+	
+	double sessionbandwidth;
+	double controlfrac;
+	double senderfrac;
+	RTPTime mininterval;
+	bool usehalfatstartup;
+	bool immediatebye;
+	bool SR_BYE;
+
+	double sendermultiplier;
+	double generaltimeoutmultiplier;
+	double byetimeoutmultiplier;
+	double collisionmultiplier;
+	double notemultiplier;
+};
+
+#endif // RTPSESSIONPARAMS_H
+

Added: konference/src/rtp/jrtplib/rtpsessionsources.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpsessionsources.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpsessionsources.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,109 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtpsessionsources.h"
+#include "rtpsession.h"
+#include "rtpsourcedata.h"
+
+#include "rtpdebug.h"
+
+void RTPSessionSources::OnRTPPacket(RTPPacket *pack,const RTPTime &receivetime,const RTPAddress *senderaddress)
+{
+	rtpsession.OnRTPPacket(pack,receivetime,senderaddress);
+}
+
+void RTPSessionSources::OnRTCPCompoundPacket(RTCPCompoundPacket *pack,const RTPTime &receivetime,const RTPAddress *senderaddress)
+{
+	if (senderaddress != 0) // don't analyse own RTCP packets again (they're already analysed on their way out)
+		rtpsession.rtcpsched.AnalyseIncoming(*pack);
+	rtpsession.OnRTCPCompoundPacket(pack,receivetime,senderaddress);
+}
+
+void RTPSessionSources::OnSSRCCollision(RTPSourceData *srcdat,const RTPAddress *senderaddress,bool isrtp)
+{
+	if (srcdat->IsOwnSSRC())
+		owncollision = true;
+	rtpsession.OnSSRCCollision(srcdat,senderaddress,isrtp);
+}
+
+void RTPSessionSources::OnCNAMECollision(RTPSourceData *srcdat,const RTPAddress *senderaddress,const u_int8_t *cname,size_t cnamelength)
+{
+	rtpsession.OnCNAMECollision(srcdat,senderaddress,cname,cnamelength);
+}
+
+void RTPSessionSources::OnNewSource(RTPSourceData *srcdat)
+{
+	rtpsession.OnNewSource(srcdat);
+}
+
+void RTPSessionSources::OnRemoveSource(RTPSourceData *srcdat)
+{
+	rtpsession.OnRemoveSource(srcdat);
+}
+
+void RTPSessionSources::OnTimeout(RTPSourceData *srcdat)
+{
+	rtpsession.rtcpsched.ActiveMemberDecrease();
+	rtpsession.OnTimeout(srcdat);
+}
+
+void RTPSessionSources::OnBYETimeout(RTPSourceData *srcdat)
+{
+	rtpsession.OnBYETimeout(srcdat);
+}
+
+void RTPSessionSources::OnBYEPacket(RTPSourceData *srcdat)
+{
+	rtpsession.rtcpsched.ActiveMemberDecrease();
+	rtpsession.OnBYEPacket(srcdat);
+}
+
+void RTPSessionSources::OnAPPPacket(RTCPAPPPacket *apppacket,const RTPTime &receivetime,const RTPAddress *senderaddress)
+{
+	rtpsession.OnAPPPacket(apppacket,receivetime,senderaddress);
+}
+
+void RTPSessionSources::OnUnknownPacketType(RTCPPacket *rtcppack,const RTPTime &receivetime, const RTPAddress *senderaddress)
+{
+	rtpsession.OnUnknownPacketType(rtcppack,receivetime,senderaddress);
+}
+
+void RTPSessionSources::OnUnknownPacketFormat(RTCPPacket *rtcppack,const RTPTime &receivetime,const RTPAddress *senderaddress)
+{
+	rtpsession.OnUnknownPacketFormat(rtcppack,receivetime,senderaddress);
+}
+
+void RTPSessionSources::OnNoteTimeout(RTPSourceData *srcdat)
+{
+	rtpsession.OnNoteTimeout(srcdat);
+}
+

Added: konference/src/rtp/jrtplib/rtpsessionsources.h
===================================================================
--- konference/src/rtp/jrtplib/rtpsessionsources.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpsessionsources.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,74 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPSESSIONSOURCES_H
+
+#define RTPSESSIONSOURCES_H
+
+#include "rtpconfig.h"
+#include "rtpsources.h"
+
+class RTPSession;
+
+class RTPSessionSources : public RTPSources
+{
+public:
+	RTPSessionSources(RTPSession &sess) : rtpsession(sess) 					{ owncollision = false; }
+	~RTPSessionSources()									{ }
+	void ClearOwnCollisionFlag()								{ owncollision = false; }
+	bool DetectedOwnCollision() const							{ return owncollision; }
+private:
+	void OnRTPPacket(RTPPacket *pack,const RTPTime &receivetime,
+	                 const RTPAddress *senderaddress);
+	void OnRTCPCompoundPacket(RTCPCompoundPacket *pack,const RTPTime &receivetime,
+	                          const RTPAddress *senderaddress);
+	void OnSSRCCollision(RTPSourceData *srcdat,const RTPAddress *senderaddress,bool isrtp);
+	void OnCNAMECollision(RTPSourceData *srcdat,const RTPAddress *senderaddress,
+	                              const u_int8_t *cname,size_t cnamelength);
+	void OnNewSource(RTPSourceData *srcdat);
+	void OnRemoveSource(RTPSourceData *srcdat);
+	void OnTimeout(RTPSourceData *srcdat);
+	void OnBYETimeout(RTPSourceData *srcdat);
+	void OnBYEPacket(RTPSourceData *srcdat);
+	void OnAPPPacket(RTCPAPPPacket *apppacket,const RTPTime &receivetime,
+	                 const RTPAddress *senderaddress);
+	void OnUnknownPacketType(RTCPPacket *rtcppack,const RTPTime &receivetime,
+	                         const RTPAddress *senderaddress);
+	void OnUnknownPacketFormat(RTCPPacket *rtcppack,const RTPTime &receivetime,
+	                           const RTPAddress *senderaddress);
+	void OnNoteTimeout(RTPSourceData *srcdat);
+	
+	RTPSession &rtpsession;
+	bool owncollision;
+};
+
+#endif // RTPSESSIONSOURCES_H

Added: konference/src/rtp/jrtplib/rtpsourcedata.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpsourcedata.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpsourcedata.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,445 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtpsourcedata.h"
+#include "rtpdefines.h"
+#include "rtpaddress.h"
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include <netinet/in.h>
+#endif // WIN32
+
+#ifdef RTPDEBUG
+	#include <iostream>
+	#include <string>
+#endif // RTPDEBUG
+
+#include "rtpdebug.h"
+
+#define ACCEPTPACKETCODE									\
+		*accept = true;									\
+												\
+		sentdata = true;								\
+		packetsreceived++;								\
+		numnewpackets++;								\
+												\
+		if (pack->GetExtendedSequenceNumber() == 0)					\
+		{										\
+			baseseqnr = 0x0000FFFF;							\
+			numcycles = 0x00010000;							\
+		}										\
+		else										\
+			baseseqnr = pack->GetExtendedSequenceNumber() - 1;			\
+												\
+		exthighseqnr = baseseqnr + 1;							\
+		prevpacktime = receivetime;							\
+		prevexthighseqnr = baseseqnr;							\
+		savedextseqnr = baseseqnr;							\
+												\
+		pack->SetExtendedSequenceNumber(exthighseqnr);					\
+												\
+		prevtimestamp = pack->GetTimestamp();						\
+		lastmsgtime = prevpacktime;							\
+		if (!ownpacket) /* for own packet, this value is set on an outgoing packet */	\
+			lastrtptime = prevpacktime;
+
+void RTPSourceStats::ProcessPacket(RTPPacket *pack,const RTPTime &receivetime,double tsunit,
+                                   bool ownpacket,bool *accept,bool applyprobation,bool *onprobation)
+{
+	// Note that the sequence number in the RTP packet is still just the
+	// 16 bit number contained in the RTP header
+
+	*onprobation = false;
+	
+	if (!sentdata) // no valid packets received yet
+	{
+#ifdef RTP_SUPPORT_PROBATION
+		if (applyprobation)
+		{
+			bool acceptpack = false;
+
+			if (probation)  
+			{	
+				u_int16_t pseq;
+				u_int32_t pseq2;
+	
+				pseq = prevseqnr;
+				pseq++;
+				pseq2 = (u_int32_t)pseq;
+				if (pseq2 == pack->GetExtendedSequenceNumber()) // ok, its the next expected packet
+				{
+					prevseqnr = (u_int16_t)pack->GetExtendedSequenceNumber();
+					probation--;	
+					if (probation == 0) // probation over
+						acceptpack = true;
+					else
+						*onprobation = true;
+				}
+				else // not next packet
+				{
+					probation = RTP_PROBATIONCOUNT;
+					prevseqnr = (u_int16_t)pack->GetExtendedSequenceNumber();
+					*onprobation = true;
+				}
+			}
+			else // first packet received with this SSRC ID, start probation
+			{
+				probation = RTP_PROBATIONCOUNT;
+				prevseqnr = (u_int16_t)pack->GetExtendedSequenceNumber();	
+				*onprobation = true;
+			}
+	
+			if (acceptpack)
+			{
+				ACCEPTPACKETCODE
+			}
+			else
+			{
+				*accept = false;
+				lastmsgtime = receivetime;
+			}
+		}
+		else // No probation
+		{
+			ACCEPTPACKETCODE
+		}
+#else // No compiled-in probation support
+
+		ACCEPTPACKETCODE
+
+#endif // RTP_SUPPORT_PROBATION
+	}
+	else // already got packets
+	{
+		u_int16_t maxseq16;
+		u_int32_t extseqnr;
+
+		// Adjust max extended sequence number and set extende seq nr of packet
+
+		*accept = true;
+		packetsreceived++;
+		numnewpackets++;
+
+		maxseq16 = (u_int16_t)(exthighseqnr&0x0000FFFF);
+		if (pack->GetExtendedSequenceNumber() >= maxseq16)
+		{
+			extseqnr = numcycles+pack->GetExtendedSequenceNumber();
+			exthighseqnr = extseqnr;
+		}
+		else
+		{
+			u_int16_t dif1,dif2;
+
+			dif1 = ((u_int16_t)pack->GetExtendedSequenceNumber());
+			dif1 -= maxseq16;
+			dif2 = maxseq16;
+			dif2 -= ((u_int16_t)pack->GetExtendedSequenceNumber());
+			if (dif1 < dif2)
+			{
+				numcycles += 0x00010000;
+				extseqnr = numcycles+pack->GetExtendedSequenceNumber();
+				exthighseqnr = extseqnr;
+			}
+			else
+				extseqnr = numcycles+pack->GetExtendedSequenceNumber();
+		}
+
+		pack->SetExtendedSequenceNumber(extseqnr);
+
+		// Calculate jitter
+
+		if (tsunit > 0)
+		{
+			RTPTime curtime = receivetime;
+			double diffts1,diffts2,diff;
+
+			curtime -= prevpacktime;
+			diffts1 = curtime.GetDouble()/tsunit;	
+			diffts2 = (double)pack->GetTimestamp() - (double)prevtimestamp;
+			diff = diffts1 - diffts2;
+			if (diff < 0)
+				diff = -diff;
+			diff -= djitter;
+			diff /= 16.0;
+			djitter += diff;
+			jitter = (u_int32_t)djitter;
+		}
+		else
+		{
+			djitter = 0;
+			jitter = 0;
+		}
+
+		prevpacktime = receivetime;
+		prevtimestamp = pack->GetTimestamp();
+		lastmsgtime = prevpacktime;
+		if (!ownpacket) // for own packet, this value is set on an outgoing packet
+			lastrtptime = prevpacktime;
+	}
+}
+
+RTPSourceData::RTPSourceData(u_int32_t s) : byetime(0,0)
+{
+	ssrc = s;
+	issender = false;
+	iscsrc = false;
+	timestampunit = -1;
+	receivedbye = false;
+	byereason = 0;
+	byereasonlen = 0;
+	rtpaddr = 0;
+	rtcpaddr = 0;
+	ownssrc = false;
+	validated = false;
+	processedinrtcp = false;			
+	isrtpaddrset = false;
+	isrtcpaddrset = false;
+}
+
+RTPSourceData::~RTPSourceData()
+{
+	FlushPackets();
+	if (byereason)
+		delete [] byereason;
+	if (rtpaddr)
+		delete rtpaddr;
+	if (rtcpaddr)
+		delete rtcpaddr;
+}
+
+double RTPSourceData::INF_GetEstimatedTimestampUnit() const
+{
+	if (!SRprevinf.HasInfo())
+		return -1.0;
+	
+	RTPTime t1 = RTPTime(SRinf.GetNTPTimestamp());
+	RTPTime t2 = RTPTime(SRprevinf.GetNTPTimestamp());
+	if ((t1.GetSeconds() == 0 && t1.GetMicroSeconds() == 0) ||
+	    (t2.GetSeconds() == 0 && t2.GetMicroSeconds() == 0)) // one of the times couldn't be calculated
+		return -1.0;
+
+	if (t1 < t2)
+		return -1.0;
+
+	t1 -= t2; // get the time difference
+	
+	u_int32_t tsdiff = SRinf.GetRTPTimestamp()-SRprevinf.GetRTPTimestamp();
+	
+	return (t1.GetDouble()/((double)tsdiff));
+}
+
+RTPTime RTPSourceData::INF_GetRoundtripTime() const
+{
+	if (!RRinf.HasInfo())
+		return RTPTime(0,0);
+	if (RRinf.GetDelaySinceLastSR() == 0 && RRinf.GetLastSRTimestamp() == 0)
+		return RTPTime(0,0);
+
+	RTPNTPTime recvtime = RRinf.GetReceiveTime().GetNTPTime();
+	u_int32_t rtt = ((recvtime.GetMSW()&0xFFFF)<<16)|((recvtime.GetLSW()>>16)&0xFFFF);
+	rtt -= RRinf.GetLastSRTimestamp();
+	rtt -= RRinf.GetDelaySinceLastSR();
+
+	double drtt = (((double)rtt)/65536.0);
+	return RTPTime(drtt);
+}
+
+#ifdef RTPDEBUG
+void RTPSourceData::Dump()
+{
+	std::cout << "Source data for SSRC:     " << ssrc << std::endl;
+	std::cout << "    Active:               " << ((IsActive())?"Yes":"No") << std::endl;
+	std::cout << "    Sender:               " << ((issender)?"Yes":"No") << std::endl;
+	std::cout << "    CSRC:                 " << ((iscsrc)?"Yes":"No") << std::endl;
+	std::cout << "    Received bye:         " << ((receivedbye)?"Yes":"No") << std::endl;
+	std::cout << "    ProcessedInRTCP:      " << ((processedinrtcp)?"Yes":"No") << std::endl;
+	std::cout << "    Timestamp unit:       " << timestampunit << std::endl;
+	std::cout << "    RTP address:          ";
+	if (!isrtpaddrset)
+		std::cout << "Not set" << std::endl;
+	else
+	{
+		if (rtpaddr == 0)
+			std::cout << "Own session" << std::endl;
+		else
+			std::cout << rtpaddr->GetAddressString() << std::endl;
+	}
+	std::cout << "    RTCP address:         ";
+	if (!isrtcpaddrset)
+		std::cout << "Not set" << std::endl;
+	else
+	{
+		if (rtcpaddr == 0)
+			std::cout << "Own session" << std::endl;
+		else
+			std::cout << rtcpaddr->GetAddressString() << std::endl;
+	}
+	if (SRinf.HasInfo())
+	{
+		if (!SRprevinf.HasInfo())
+		{
+			std::cout << "    SR Info:" << std::endl;
+			std::cout << "        NTP timestamp:    " << SRinf.GetNTPTimestamp().GetMSW() << ":" << SRinf.GetNTPTimestamp().GetLSW() << std::endl;
+			std::cout << "        RTP timestamp:    " << SRinf.GetRTPTimestamp() << std::endl;
+			std::cout << "        Packet count:     " << SRinf.GetPacketCount() << std::endl;
+			std::cout << "        Octet count:      " << SRinf.GetByteCount() << std::endl;
+			std::cout << "        Receive time:     " << SRinf.GetReceiveTime().GetSeconds() << std::endl;
+		}	
+		else
+		{
+			std::cout << "    SR Info:" << std::endl;
+			std::cout << "        NTP timestamp:    " << SRinf.GetNTPTimestamp().GetMSW() << ":" << SRinf.GetNTPTimestamp().GetLSW()
+				  << " (" << SRprevinf.GetNTPTimestamp().GetMSW() << ":" << SRprevinf.GetNTPTimestamp().GetLSW() << ")" << std::endl;
+			std::cout << "        RTP timestamp:    " << SRinf.GetRTPTimestamp()
+			          << " (" << SRprevinf.GetRTPTimestamp() << ")" << std::endl;
+			std::cout << "        Packet count:     " << SRinf.GetPacketCount()
+			          << " (" << SRprevinf.GetPacketCount() << ")" << std::endl;
+			std::cout << "        Octet count:      " << SRinf.GetByteCount() 
+			          << " (" << SRprevinf.GetByteCount() <<")" << std::endl;
+			std::cout << "        Receive time:     " << SRinf.GetReceiveTime().GetSeconds()
+			          << " (" << SRprevinf.GetReceiveTime().GetSeconds() << ")" << std::endl;
+		}
+	}
+	if (RRinf.HasInfo())
+	{
+		if (!RRprevinf.HasInfo())
+		{
+			std::cout << "    RR Info:" << std::endl;
+			std::cout << "        Fraction lost:    " << RRinf.GetFractionLost() << std::endl;
+			std::cout << "        Packets lost:     " << RRinf.GetPacketsLost() << std::endl;
+			std::cout << "        Ext.High.Seq:     " << RRinf.GetExtendedHighestSequenceNumber() << std::endl;
+			std::cout << "        Jitter:           " << RRinf.GetJitter() << std::endl;
+			std::cout << "        LSR:              " << RRinf.GetLastSRTimestamp() << std::endl;
+			std::cout << "        DLSR:             " << RRinf.GetDelaySinceLastSR() << std::endl;
+			std::cout << "        Receive time:     " << RRinf.GetReceiveTime().GetSeconds() << std::endl;
+		}
+		else
+		{
+			std::cout << "    RR Info:" << std::endl;
+			std::cout << "        Fraction lost:    " << RRinf.GetFractionLost() 
+				  << " (" << RRprevinf.GetFractionLost() << ")" << std::endl;
+			std::cout << "        Packets lost:     " << RRinf.GetPacketsLost() 
+			          << " (" << RRprevinf.GetPacketsLost() << ")" << std::endl;
+			std::cout << "        Ext.High.Seq:     " << RRinf.GetExtendedHighestSequenceNumber() 
+			          << " (" << RRprevinf.GetExtendedHighestSequenceNumber() << ")" << std::endl;
+			std::cout << "        Jitter:           " << RRinf.GetJitter() 
+			          << " (" << RRprevinf.GetJitter() << ")" << std::endl;
+			std::cout << "        LSR:              " << RRinf.GetLastSRTimestamp() 
+			          << " (" << RRprevinf.GetLastSRTimestamp() << ")" << std::endl;
+			std::cout << "        DLSR:             " << RRinf.GetDelaySinceLastSR() 
+			          << " (" << RRprevinf.GetDelaySinceLastSR() << ")" << std::endl;
+			std::cout << "        Receive time:     " << RRinf.GetReceiveTime().GetSeconds() 
+			          << " (" << RRprevinf.GetReceiveTime().GetSeconds() <<")" << std::endl;
+		}
+	}
+	std::cout << "    Stats:" << std::endl;
+	std::cout << "        Sent data:        " << ((stats.HasSentData())?"Yes":"No") << std::endl;
+	std::cout << "        Packets received: " << stats.GetNumPacketsReceived() << std::endl;
+	std::cout << "        Seq. base:        " << stats.GetBaseSequenceNumber() << std::endl;
+	std::cout << "        Ext.High.Seq:     " << stats.GetExtendedHighestSequenceNumber() << std::endl;
+	std::cout << "        Jitter:           " << stats.GetJitter() << std::endl;
+	std::cout << "        New packets:      " << stats.GetNumPacketsReceivedInInterval() << std::endl;	
+	std::cout << "        Saved seq. nr.:   " << stats.GetSavedExtendedSequenceNumber() << std::endl;	
+	std::cout << "        RTT:              " << INF_GetRoundtripTime().GetDouble() << " seconds" << std::endl;
+	if (INF_GetEstimatedTimestampUnit() > 0)
+		std::cout << "        Estimated:        " << (1.0/INF_GetEstimatedTimestampUnit()) << " samples per second" << std::endl;
+	std::cout << "    SDES Info:" << std::endl;
+
+	size_t len;
+	char str[1024];
+	u_int8_t *val;
+	
+	if ((val = SDESinf.GetCNAME(&len)) != 0)
+	{
+		memcpy(str,val,len);
+		str[len] = 0;
+		std::cout << "        CNAME:            " << std::string(str) << std::endl;
+	}
+	if ((val = SDESinf.GetName(&len)) != 0)
+	{
+		memcpy(str,val,len);
+		str[len] = 0;
+		std::cout << "        Name:             " << std::string(str) << std::endl;
+	}
+	if ((val = SDESinf.GetEMail(&len)) != 0)
+	{
+		memcpy(str,val,len);
+		str[len] = 0;
+		std::cout << "        EMail:            " << std::string(str) << std::endl;
+	}
+	if ((val = SDESinf.GetPhone(&len)) != 0)
+	{
+		memcpy(str,val,len);
+		str[len] = 0;
+		std::cout << "        phone:            " << std::string(str) << std::endl;
+	}
+	if ((val = SDESinf.GetLocation(&len)) != 0)
+	{
+		memcpy(str,val,len);
+		str[len] = 0;
+		std::cout << "        Location:         " << std::string(str) << std::endl;
+	}
+	if ((val = SDESinf.GetTool(&len)) != 0)
+	{
+		memcpy(str,val,len);
+		str[len] = 0;
+		std::cout << "        Tool:             " << std::string(str) << std::endl;
+	}	
+	if ((val = SDESinf.GetNote(&len)) != 0)
+	{
+		memcpy(str,val,len);
+		str[len] = 0;
+		std::cout << "        Note:             " << std::string(str) << std::endl;
+	}
+#ifdef RTP_SUPPORT_SDESPRIV
+	SDESinf.GotoFirstPrivateValue();
+	u_int8_t *pref;
+	size_t preflen;
+	while (SDESinf.GetNextPrivateValue(&pref,&preflen,&val,&len))
+	{
+		char prefstr[1024];
+		memcpy(prefstr,pref,preflen);
+		memcpy(str,val,len);
+		prefstr[preflen] = 0;
+		str[len] = 0;
+		std::cout << "        Private:          " << std::string(prefstr) << ":" << std::string(str) << std::endl;
+	}
+#endif // RTP_SUPPORT_SDESPRIV
+	if (byereason)
+	{
+		memcpy(str,byereason,byereasonlen);
+		str[byereasonlen] = 0;
+		std::cout << "    BYE Reason:           " << std::string(str) << std::endl;
+	}
+}
+
+#endif // RTPDEBUG
+

Added: konference/src/rtp/jrtplib/rtpsourcedata.h
===================================================================
--- konference/src/rtp/jrtplib/rtpsourcedata.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpsourcedata.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,305 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPSOURCEDATA_H
+
+#define RTPSOURCEDATA_H
+
+#include "rtpconfig.h"
+#include "rtptimeutilities.h"
+#include "rtppacket.h"
+#include "rtcpsdesinfo.h"
+#include "rtptypes.h"
+#include "rtpsources.h"
+#include <list>
+
+class RTPAddress;
+
+class RTCPSenderReportInfo
+{
+public:
+	RTCPSenderReportInfo():ntptimestamp(0,0),receivetime(0,0)		{ hasinfo = false; rtptimestamp = 0; packetcount = 0; bytecount = 0; }
+	void Set(const RTPNTPTime &ntptime,u_int32_t rtptime,u_int32_t pcount,
+	         u_int32_t bcount,const RTPTime &rcvtime)			{ ntptimestamp = ntptime; rtptimestamp = rtptime; packetcount = pcount; bytecount = bcount; receivetime = rcvtime; hasinfo = true; }
+	
+	bool HasInfo() const							{ return hasinfo; }
+	RTPNTPTime GetNTPTimestamp() const					{ return ntptimestamp; }
+	u_int32_t GetRTPTimestamp() const					{ return rtptimestamp; }
+	u_int32_t GetPacketCount() const					{ return packetcount; }
+	u_int32_t GetByteCount() const						{ return bytecount; }
+	RTPTime GetReceiveTime() const						{ return receivetime; }
+private:
+	bool hasinfo;
+	RTPNTPTime ntptimestamp;
+	u_int32_t rtptimestamp;
+	u_int32_t packetcount;
+	u_int32_t bytecount;
+	RTPTime receivetime;
+};
+
+class RTCPReceiverReportInfo
+{
+public:
+	RTCPReceiverReportInfo():receivetime(0,0)				{ hasinfo = false; fractionlost = 0; packetslost = 0; exthighseqnr = 0; jitter = 0; lsr = 0; dlsr = 0; } 
+	void Set(u_int8_t fraclost,int32_t plost,u_int32_t exthigh,
+	         u_int32_t jit,u_int32_t l,u_int32_t dl,const RTPTime &rcvtime) { fractionlost = ((double)fraclost)/256.0; packetslost = plost; exthighseqnr = exthigh; jitter = jit; lsr = l; dlsr = dl; receivetime = rcvtime; hasinfo = true; }
+		
+	bool HasInfo() const							{ return hasinfo; }
+	double GetFractionLost() const						{ return fractionlost; }
+	int32_t	GetPacketsLost() const						{ return packetslost; }
+	u_int32_t GetExtendedHighestSequenceNumber() const			{ return exthighseqnr; }
+	u_int32_t GetJitter() const						{ return jitter; }
+	u_int32_t GetLastSRTimestamp() const					{ return lsr; }
+	u_int32_t GetDelaySinceLastSR() const					{ return dlsr; }
+	RTPTime GetReceiveTime() const						{ return receivetime; }
+private:
+	bool hasinfo;
+	double fractionlost;
+	int32_t packetslost;
+	u_int32_t exthighseqnr;
+	u_int32_t jitter;
+	u_int32_t lsr;
+	u_int32_t dlsr;
+	RTPTime receivetime;
+};
+
+class RTPSourceStats
+{
+public:
+	RTPSourceStats();
+	void ProcessPacket(RTPPacket *pack,const RTPTime &receivetime,double tsunit,bool ownpacket,bool *accept,bool applyprobation,bool *onprobation);
+
+	bool HasSentData() const						{ return sentdata; }
+	u_int32_t GetNumPacketsReceived() const					{ return packetsreceived; }
+	u_int32_t GetBaseSequenceNumber() const					{ return baseseqnr; }
+	u_int32_t GetExtendedHighestSequenceNumber() const			{ return exthighseqnr; }
+	u_int32_t GetJitter() const						{ return jitter; }
+
+	int32_t GetNumPacketsReceivedInInterval() const				{ return numnewpackets; }
+	u_int32_t GetSavedExtendedSequenceNumber() const			{ return savedextseqnr; }
+	void StartNewInterval()							{ numnewpackets = 0; savedextseqnr = exthighseqnr; }
+	
+	void SetLastMessageTime(const RTPTime &t)				{ lastmsgtime = t; }
+	RTPTime GetLastMessageTime() const					{ return lastmsgtime; }
+	void SetLastRTPPacketTime(const RTPTime &t)				{ lastrtptime = t; }
+	RTPTime GetLastRTPPacketTime() const					{ return lastrtptime; }
+
+	void SetLastNoteTime(const RTPTime &t)					{ lastnotetime = t; }
+	RTPTime GetLastNoteTime() const						{ return lastnotetime; }
+private:
+	bool sentdata;
+	u_int32_t packetsreceived;
+	u_int32_t numcycles; // shifted left 16 bits
+	u_int32_t baseseqnr;
+	u_int32_t exthighseqnr,prevexthighseqnr;
+	u_int32_t jitter,prevtimestamp;
+	double djitter;
+	RTPTime prevpacktime;
+	RTPTime lastmsgtime;
+	RTPTime lastrtptime;
+	RTPTime lastnotetime;
+	u_int32_t numnewpackets;
+	u_int32_t savedextseqnr;
+#ifdef RTP_SUPPORT_PROBATION
+	u_int16_t prevseqnr;
+	int probation;
+	RTPSources::ProbationType probationtype;
+#endif // RTP_SUPPORT_PROBATION
+};
+	
+inline RTPSourceStats::RTPSourceStats():prevpacktime(0,0),lastmsgtime(0,0),lastrtptime(0,0),lastnotetime(0,0)
+{ 
+	sentdata = false; 
+	packetsreceived = 0; 
+	baseseqnr = 0; 
+	exthighseqnr = 0; 
+	prevexthighseqnr = 0; 
+	jitter = 0; 
+	numcycles = 0;
+	numnewpackets = 0;
+	prevtimestamp = 0;
+	djitter = 0;
+	savedextseqnr = 0;
+#ifdef RTP_SUPPORT_PROBATION
+	probation = 0; 
+	prevseqnr = 0; 
+#endif // RTP_SUPPORT_PROBATION
+}
+
+class RTPSourceData
+{
+protected:
+	RTPSourceData(u_int32_t ssrc);
+	virtual ~RTPSourceData();
+public:
+	RTPPacket *GetNextPacket();
+	void FlushPackets();
+	bool HasData() const							{ if (!validated) return false; return packetlist.empty()?false:true; }
+	u_int32_t GetSSRC() const						{ return ssrc; }
+	bool IsOwnSSRC() const							{ return ownssrc; }
+	bool IsCSRC() const							{ return iscsrc; }
+	bool IsSender() const							{ return issender; }
+	bool IsValidated() const						{ return validated; }
+	bool IsActive() const							{ if (!validated) return false; if (receivedbye) return false; return true; }
+
+	void SetProcessedInRTCP(bool v)						{ processedinrtcp = v; }
+	bool IsProcessedInRTCP() const						{ return processedinrtcp; }
+	
+	bool IsRTPAddressSet() const						{ return isrtpaddrset; }
+	bool IsRTCPAddressSet() const						{ return isrtcpaddrset; }
+	const RTPAddress *GetRTPDataAddress() const				{ return rtpaddr; }
+	const RTPAddress *GetRTCPDataAddress() const				{ return rtcpaddr; }
+	
+	bool ReceivedBYE() const						{ return receivedbye; }
+	u_int8_t *GetBYEReason(size_t *len) const				{ *len = byereasonlen; return byereason; }
+	RTPTime GetBYETime() const						{ return byetime; }
+		
+	void SetTimestampUnit(double tsu)					{ timestampunit = tsu; }
+	double GetTimestampUnit() const						{ return timestampunit; }
+
+	// Here is the info received in the last RTCP SR packet from this source
+	bool SR_HasInfo() const							{ return SRinf.HasInfo(); }
+	RTPNTPTime SR_GetNTPTimestamp() const					{ return SRinf.GetNTPTimestamp(); }
+	u_int32_t SR_GetRTPTimestamp() const					{ return SRinf.GetRTPTimestamp(); }
+	u_int32_t SR_GetPacketCount() const					{ return SRinf.GetPacketCount(); }
+	u_int32_t SR_GetByteCount() const					{ return SRinf.GetByteCount(); }
+	RTPTime SR_GetReceiveTime() const					{ return SRinf.GetReceiveTime(); }
+	
+	// Here is the info received in the previous RTCP SR packet from this source
+	bool SR_Prev_HasInfo() const						{ return SRprevinf.HasInfo(); }
+	RTPNTPTime SR_Prev_GetNTPTimestamp() const				{ return SRprevinf.GetNTPTimestamp(); }
+	u_int32_t SR_Prev_GetRTPTimestamp() const				{ return SRprevinf.GetRTPTimestamp(); }
+	u_int32_t SR_Prev_GetPacketCount() const				{ return SRprevinf.GetPacketCount(); }
+	u_int32_t SR_Prev_GetByteCount() const					{ return SRprevinf.GetByteCount(); }
+	RTPTime SR_Prev_GetReceiveTime() const					{ return SRprevinf.GetReceiveTime(); }
+
+	// Here is the info received in the last RTCP RR packet from this source
+	bool RR_HasInfo() const							{ return RRinf.HasInfo(); }
+	double RR_GetFractionLost() const					{ return RRinf.GetFractionLost(); }
+	int32_t	RR_GetPacketsLost() const					{ return RRinf.GetPacketsLost(); }
+	u_int32_t RR_GetExtendedHighestSequenceNumber() const			{ return RRinf.GetExtendedHighestSequenceNumber(); }
+	u_int32_t RR_GetJitter() const						{ return RRinf.GetJitter(); }
+	u_int32_t RR_GetLastSRTimestamp() const					{ return RRinf.GetLastSRTimestamp(); }
+	u_int32_t RR_GetDelaySinceLastSR() const				{ return RRinf.GetDelaySinceLastSR(); }
+	RTPTime RR_GetReceiveTime() const					{ return RRinf.GetReceiveTime(); }
+	
+	// Here is the info received in the last RTCP RR packet from this source
+	bool RR_Prev_HasInfo() const						{ return RRprevinf.HasInfo(); }
+	double RR_Prev_GetFractionLost() const					{ return RRprevinf.GetFractionLost(); }
+	int32_t	RR_Prev_GetPacketsLost() const					{ return RRprevinf.GetPacketsLost(); }
+	u_int32_t RR_Prev_GetExtendedHighestSequenceNumber() const		{ return RRprevinf.GetExtendedHighestSequenceNumber(); }
+	u_int32_t RR_Prev_GetJitter() const					{ return RRprevinf.GetJitter(); }
+	u_int32_t RR_Prev_GetLastSRTimestamp() const				{ return RRprevinf.GetLastSRTimestamp(); }
+	u_int32_t RR_Prev_GetDelaySinceLastSR() const				{ return RRprevinf.GetDelaySinceLastSR(); }
+	RTPTime RR_Prev_GetReceiveTime() const					{ return RRprevinf.GetReceiveTime(); }
+
+	// Here is info which is used when sending RTCP packets to this source
+	bool INF_HasSentData() const						{ return stats.HasSentData(); }
+	int32_t INF_GetNumPacketsReceived() const				{ return stats.GetNumPacketsReceived(); }
+	u_int32_t INF_GetBaseSequenceNumber() const				{ return stats.GetBaseSequenceNumber(); }
+	u_int32_t INF_GetExtendedHighestSequenceNumber() const			{ return stats.GetExtendedHighestSequenceNumber(); }
+	u_int32_t INF_GetJitter() const						{ return stats.GetJitter(); }
+	RTPTime INF_GetLastMessageTime() const					{ return stats.GetLastMessageTime(); }
+	RTPTime INF_GetLastRTPPacketTime() const				{ return stats.GetLastRTPPacketTime(); }
+	double INF_GetEstimatedTimestampUnit() const;
+	u_int32_t INF_GetNumPacketsReceivedInInterval() const			{ return stats.GetNumPacketsReceivedInInterval(); }
+	u_int32_t INF_GetSavedExtendedSequenceNumber() const			{ return stats.GetSavedExtendedSequenceNumber(); }
+	void INF_StartNewInterval()						{ stats.StartNewInterval(); }
+	RTPTime INF_GetRoundtripTime() const;
+	RTPTime INF_GetLastSDESNoteTime() const					{ return stats.GetLastNoteTime(); }
+	
+	u_int8_t *SDES_GetCNAME(size_t *len) const				{ return SDESinf.GetCNAME(len); }
+	u_int8_t *SDES_GetName(size_t *len) const				{ return SDESinf.GetName(len); }
+	u_int8_t *SDES_GetEMail(size_t *len) const				{ return SDESinf.GetEMail(len); }
+	u_int8_t *SDES_GetPhone(size_t *len) const				{ return SDESinf.GetPhone(len); }
+	u_int8_t *SDES_GetLocation(size_t *len) const				{ return SDESinf.GetLocation(len); }
+	u_int8_t *SDES_GetTool(size_t *len) const				{ return SDESinf.GetTool(len); }
+	u_int8_t *SDES_GetNote(size_t *len) const				{ return SDESinf.GetNote(len); }
+	
+#ifdef RTP_SUPPORT_SDESPRIV
+	void SDES_GotoFirstPrivateValue()										{ SDESinf.GotoFirstPrivateValue(); }
+	bool SDES_GetNextPrivateValue(u_int8_t **prefix,size_t *prefixlen,u_int8_t **value,size_t *valuelen) 		{ return SDESinf.GetNextPrivateValue(prefix,prefixlen,value,valuelen); }
+	bool SDES_GetPrivateValue(u_int8_t *prefix,size_t prefixlen,u_int8_t **value,size_t *valuelen) const 		{ return SDESinf.GetPrivateValue(prefix,prefixlen,value,valuelen); }
+#endif // RTP_SUPPORT_SDESPRIV
+
+#ifdef RTPDEBUG
+	virtual void Dump();
+#endif // RTPDEBUG
+protected:
+	std::list<RTPPacket *> packetlist;
+
+	u_int32_t ssrc;
+	bool ownssrc;
+	bool iscsrc;
+	double timestampunit;
+	bool receivedbye;
+	bool validated;
+	bool processedinrtcp;
+	bool issender;
+	
+	RTCPSenderReportInfo SRinf,SRprevinf;
+	RTCPReceiverReportInfo RRinf,RRprevinf;
+	RTPSourceStats stats;
+	RTCPSDESInfo SDESinf;
+	
+	bool isrtpaddrset,isrtcpaddrset;
+	RTPAddress *rtpaddr,*rtcpaddr;
+	
+	RTPTime byetime;
+	u_int8_t *byereason;
+	size_t byereasonlen;
+};
+
+inline RTPPacket *RTPSourceData::GetNextPacket()
+{
+	if (!validated)
+		return 0;
+
+	RTPPacket *p;
+
+	if (packetlist.empty())
+		return 0;
+	p = *(packetlist.begin());
+	packetlist.pop_front();
+	return p;
+}
+
+inline void RTPSourceData::FlushPackets()
+{
+	std::list<RTPPacket *>::const_iterator it;
+
+	for (it = packetlist.begin() ; it != packetlist.end() ; ++it)
+		delete (*it);
+	packetlist.clear();
+}
+#endif // RTPSOURCEDATA_H
+

Added: konference/src/rtp/jrtplib/rtpsources.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpsources.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpsources.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,1412 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtpsources.h"
+#include "rtperrors.h"
+#include "rtprawpacket.h"
+#include "rtpinternalsourcedata.h"
+#include "rtptimeutilities.h"
+#include "rtpdefines.h"
+#include "rtcpcompoundpacket.h"
+#include "rtcppacket.h"
+#include "rtcpapppacket.h"
+#include "rtcpbyepacket.h"
+#include "rtcpsdespacket.h"
+#include "rtcpsrpacket.h"
+#include "rtcprrpacket.h"
+#include "rtptransmitter.h"
+
+#ifdef RTPDEBUG
+	#include <iostream>
+#endif // RTPDEBUG
+
+#include "rtpdebug.h"
+
+#ifndef RTP_SUPPORT_INLINETEMPLATEPARAM
+	int RTPSources_GetHashIndex(const u_int32_t &ssrc)       { return ssrc%RTPSOURCES_HASHSIZE; }
+#endif // !RTP_SUPPORT_INLINETEMPLATEPARAM
+	
+RTPSources::RTPSources(ProbationType probtype)
+{
+	totalcount = 0;
+	sendercount = 0;
+	activecount = 0;
+	owndata = 0;
+#ifdef RTP_SUPPORT_PROBATION
+	probationtype = probtype;
+#endif // RTP_SUPPORT_PROBATION
+}
+
+RTPSources::~RTPSources()
+{
+	Clear();
+}
+
+void RTPSources::Clear()
+{
+	ClearSourceList();
+}
+
+void RTPSources::ClearSourceList()
+{
+	sourcelist.GotoFirstElement();
+	while (sourcelist.HasCurrentElement())
+	{
+		RTPInternalSourceData *sourcedata;
+
+		sourcedata = sourcelist.GetCurrentElement();
+		delete sourcedata;
+		sourcelist.GotoNextElement();
+	}
+	sourcelist.Clear();
+	owndata = 0;
+}
+
+int RTPSources::CreateOwnSSRC(u_int32_t ssrc)
+{
+	if (owndata != 0)
+		return ERR_RTP_SOURCES_ALREADYHAVEOWNSSRC;
+	if (GotEntry(ssrc))
+		return ERR_RTP_SOURCES_SSRCEXISTS;
+
+	int status;
+	bool created;
+	
+	status = ObtainSourceDataInstance(ssrc,&owndata,&created);
+	if (status < 0)
+	{
+		owndata = 0; // just to make sure
+		return status;
+	}
+	owndata->SetOwnSSRC();	
+	owndata->SetRTPDataAddress(0);
+	owndata->SetRTCPDataAddress(0);
+
+	// we've created a validated ssrc, so we should increase activecount
+	activecount++;
+
+	OnNewSource(owndata);
+	return 0;
+}
+
+int RTPSources::DeleteOwnSSRC()
+{
+	if (owndata == 0)
+		return ERR_RTP_SOURCES_DONTHAVEOWNSSRC;
+
+	u_int32_t ssrc = owndata->GetSSRC();
+
+	sourcelist.GotoElement(ssrc);
+	sourcelist.DeleteCurrentElement();
+
+	totalcount--;
+	if (owndata->IsSender())
+		sendercount--;
+	if (owndata->IsActive())
+		activecount--;
+
+	OnRemoveSource(owndata);
+	
+	delete owndata;
+	owndata = 0;
+	return 0;
+}
+
+void RTPSources::SentRTPPacket()
+{
+	if (owndata == 0)
+		return;
+
+	bool prevsender = owndata->IsSender();
+	
+	owndata->SentRTPPacket();
+	if (!prevsender && owndata->IsSender())
+		sendercount++;
+}
+
+int RTPSources::ProcessRawPacket(RTPRawPacket *rawpack,RTPTransmitter *rtptrans,bool acceptownpackets)
+{
+	RTPTransmitter *transmitters[1];
+	int num;
+	
+	transmitters[0] = rtptrans;
+	if (rtptrans == 0)
+		num = 0;
+	else
+		num = 1;
+	return ProcessRawPacket(rawpack,transmitters,num,acceptownpackets);
+}
+
+int RTPSources::ProcessRawPacket(RTPRawPacket *rawpack,RTPTransmitter *rtptrans[],int numtrans,bool acceptownpackets)
+{
+	int status;
+	
+	if (rawpack->IsRTP()) // RTP packet
+	{
+		RTPPacket *rtppack;
+		
+		// First, we'll see if the packet can be parsed
+		rtppack = new RTPPacket(*rawpack);
+		if (rtppack == 0)
+			return ERR_RTP_OUTOFMEM;
+		if ((status = rtppack->GetCreationError()) < 0)
+		{
+			if (status == ERR_RTP_PACKET_INVALIDPACKET)
+			{
+				delete rtppack;
+				rtppack = 0;
+			}
+			else
+			{
+				delete rtppack;
+				return status;
+			}
+		}
+				
+		// Check if the packet was valid
+		if (rtppack != 0)
+		{
+			bool stored = false;
+			bool ownpacket = false;
+			int i;
+			const RTPAddress *senderaddress = rawpack->GetSenderAddress();
+
+			for (i = 0 ; !ownpacket && i < numtrans ; i++)
+			{
+				if (rtptrans[i]->ComesFromThisTransmitter(senderaddress))
+					ownpacket = true;
+			}
+			
+			// Check if the packet is our own.
+			if (ownpacket)
+			{
+				// Now it depends on the user's preference
+				// what to do with this packet:
+				if (acceptownpackets)
+				{
+					// sender addres for own packets has to be NULL!
+					if ((status = ProcessRTPPacket(rtppack,rawpack->GetReceiveTime(),0,&stored)) < 0)
+					{
+						if (!stored)
+							delete rtppack;
+						return status;
+					}
+				}
+			}
+			else 
+			{
+				if ((status = ProcessRTPPacket(rtppack,rawpack->GetReceiveTime(),senderaddress,&stored)) < 0)
+				{
+					if (!stored)
+						delete rtppack;
+					return status;
+				}
+			}
+			if (!stored)
+				delete rtppack;
+		}
+	}
+	else // RTCP packet
+	{
+		RTCPCompoundPacket rtcpcomppack(*rawpack);
+		bool valid = false;
+		
+		if ((status = rtcpcomppack.GetCreationError()) < 0)
+		{
+			if (status != ERR_RTP_RTCPCOMPOUND_INVALIDPACKET)
+				return status;
+		}
+		else
+			valid = true;
+
+
+		if (valid)
+		{
+			bool ownpacket = false;
+			int i;
+			const RTPAddress *senderaddress = rawpack->GetSenderAddress();
+
+			for (i = 0 ; !ownpacket && i < numtrans ; i++)
+			{
+				if (rtptrans[i]->ComesFromThisTransmitter(senderaddress))
+					ownpacket = true;
+			}
+
+			// First check if it's a packet of this session.
+			if (ownpacket)
+			{
+				if (acceptownpackets)
+				{
+					// sender address for own packets has to be NULL
+					status = ProcessRTCPCompoundPacket(&rtcpcomppack,rawpack->GetReceiveTime(),0);
+					if (status < 0)
+						return status;
+				}
+			}
+			else // not our own packet
+			{
+				status = ProcessRTCPCompoundPacket(&rtcpcomppack,rawpack->GetReceiveTime(),rawpack->GetSenderAddress());
+				if (status < 0)
+					return status;
+			}
+		}
+	}
+	
+	return 0;
+}
+
+int RTPSources::ProcessRTPPacket(RTPPacket *rtppack,const RTPTime &receivetime,const RTPAddress *senderaddress,bool *stored)
+{
+	u_int32_t ssrc;
+	RTPInternalSourceData *srcdat;
+	int status;
+	bool created;
+
+	OnRTPPacket(rtppack,receivetime,senderaddress);
+
+	*stored = false;
+	
+	ssrc = rtppack->GetSSRC();
+	if ((status = ObtainSourceDataInstance(ssrc,&srcdat,&created)) < 0)
+		return status;
+
+	if (created)
+	{
+		if ((status = srcdat->SetRTPDataAddress(senderaddress)) < 0)
+			return status;
+	}
+	else // got a previously existing source
+	{
+		if (CheckCollision(srcdat,senderaddress,true))
+			return 0; // ignore packet on collision
+	}
+	
+	bool prevsender = srcdat->IsSender();
+	bool prevactive = srcdat->IsActive();
+	
+	// The packet comes from a valid source, we can process it further now
+	// The following function should delete rtppack itself if something goes
+	// wrong
+	if ((status = srcdat->ProcessRTPPacket(rtppack,receivetime,stored)) < 0)
+		return status;
+
+	if (!prevsender && srcdat->IsSender())
+		sendercount++;
+	if (!prevactive && srcdat->IsActive())
+		activecount++;
+
+	if (created)
+		OnNewSource(srcdat);
+
+	if (srcdat->IsValidated()) // process the CSRCs
+	{
+		RTPInternalSourceData *csrcdat;
+		bool createdcsrc;
+
+		int num = rtppack->GetCSRCCount();
+		int i;
+
+		for (i = 0 ; i < num ; i++)
+		{
+			if ((status = ObtainSourceDataInstance(rtppack->GetCSRC(i),&csrcdat,&createdcsrc)) < 0)
+				return status;
+			if (createdcsrc)
+			{
+				csrcdat->SetCSRC();
+				if (csrcdat->IsActive())
+					activecount++;
+				OnNewSource(csrcdat);
+			}
+			else // already found an entry, possibly because of RTCP data
+			{
+				if (!CheckCollision(csrcdat,senderaddress,true))
+					csrcdat->SetCSRC();
+			}
+		}
+	}
+	
+	return 0;
+}
+
+int RTPSources::ProcessRTCPCompoundPacket(RTCPCompoundPacket *rtcpcomppack,const RTPTime &receivetime,const RTPAddress *senderaddress)
+{
+	RTCPPacket *rtcppack;
+	int status;
+	bool gotownssrc = ((owndata == 0)?false:true);
+	u_int32_t ownssrc = ((owndata != 0)?owndata->GetSSRC():0);
+	
+	OnRTCPCompoundPacket(rtcpcomppack,receivetime,senderaddress);
+	
+	rtcpcomppack->GotoFirstPacket();	
+	while ((rtcppack = rtcpcomppack->GetNextPacket()) != 0)
+	{
+		if (rtcppack->IsKnownFormat())
+		{
+			switch (rtcppack->GetPacketType())
+			{
+			case RTCPPacket::SR:
+				{
+					RTCPSRPacket *p = (RTCPSRPacket *)rtcppack;
+					u_int32_t senderssrc = p->GetSenderSSRC();
+					
+					status = ProcessRTCPSenderInfo(senderssrc,p->GetNTPTimestamp(),p->GetRTPTimestamp(),
+						                       p->GetSenderPacketCount(),p->GetSenderOctetCount(),
+								       receivetime,senderaddress);
+					if (status < 0)
+						return status;
+					
+					bool gotinfo = false;
+					if (gotownssrc)
+					{
+						int i;
+						int num = p->GetReceptionReportCount();
+						for (i = 0 ; i < num ; i++)
+						{
+							if (p->GetSSRC(i) == ownssrc) // data is meant for us
+							{
+								gotinfo = true;
+								status = ProcessRTCPReportBlock(senderssrc,p->GetFractionLost(i),p->GetLostPacketCount(i),
+										                        p->GetExtendedHighestSequenceNumber(i),p->GetJitter(i),p->GetLSR(i),
+													p->GetDLSR(i),receivetime,senderaddress);
+								if (status < 0)
+									return status;
+							}
+						}
+					}
+					if (!gotinfo)
+					{
+						status = UpdateReceiveTime(senderssrc,receivetime,senderaddress);
+						if (status < 0)
+							return status;
+					}
+				}
+				break;
+			case RTCPPacket::RR:
+				{
+					RTCPRRPacket *p = (RTCPRRPacket *)rtcppack;
+					u_int32_t senderssrc = p->GetSenderSSRC();
+					
+					bool gotinfo = false;
+
+					if (gotownssrc)
+					{
+						int i;
+						int num = p->GetReceptionReportCount();
+						for (i = 0 ; i < num ; i++)
+						{
+							if (p->GetSSRC(i) == ownssrc)
+							{
+								gotinfo = true;
+								status = ProcessRTCPReportBlock(senderssrc,p->GetFractionLost(i),p->GetLostPacketCount(i),
+										                        p->GetExtendedHighestSequenceNumber(i),p->GetJitter(i),p->GetLSR(i),
+													p->GetDLSR(i),receivetime,senderaddress);
+								if (status < 0)
+									return status;
+							}
+						}
+					}
+					if (!gotinfo)
+					{
+						status = UpdateReceiveTime(senderssrc,receivetime,senderaddress);
+						if (status < 0)
+							return status;
+					}
+				}
+				break;
+			case RTCPPacket::SDES:
+				{
+					RTCPSDESPacket *p = (RTCPSDESPacket *)rtcppack;
+					
+					if (p->GotoFirstChunk())
+					{
+						do
+						{
+							u_int32_t sdesssrc = p->GetChunkSSRC();
+							bool updated = false;
+							if (p->GotoFirstItem())
+							{
+								do
+								{
+									RTCPSDESPacket::ItemType t;
+				
+									if ((t = p->GetItemType()) != RTCPSDESPacket::PRIV)
+									{
+										updated = true;
+										status = ProcessSDESNormalItem(sdesssrc,t,p->GetItemLength(),p->GetItemData(),receivetime,senderaddress);
+										if (status < 0)
+											return status;
+									}
+#ifdef RTP_SUPPORT_SDESPRIV
+									else
+									{
+										updated = true;
+										status = ProcessSDESPrivateItem(sdesssrc,p->GetPRIVPrefixLength(),p->GetPRIVPrefixData(),p->GetPRIVValueLength(),
+												                        p->GetPRIVValueData(),receivetime,senderaddress);
+										if (status < 0)
+											return status;
+									}
+#endif // RTP_SUPPORT_SDESPRIV
+								} while (p->GotoNextItem());
+							}
+							if (!updated)
+							{
+								status = UpdateReceiveTime(sdesssrc,receivetime,senderaddress);
+								if (status < 0)
+									return status;
+							}
+						} while (p->GotoNextChunk());
+					}
+				}
+				break;
+			case RTCPPacket::BYE:
+				{
+					RTCPBYEPacket *p = (RTCPBYEPacket *)rtcppack;
+					int i;
+					int num = p->GetSSRCCount();
+
+					for (i = 0 ; i < num ; i++)
+					{
+						u_int32_t byessrc = p->GetSSRC(i);
+						status = ProcessBYE(byessrc,p->GetReasonLength(),p->GetReasonData(),receivetime,senderaddress);
+						if (status < 0)
+							return status;
+					}
+				}
+				break;
+			case RTCPPacket::APP:
+				{
+					RTCPAPPPacket *p = (RTCPAPPPacket *)rtcppack;
+
+					OnAPPPacket(p,receivetime,senderaddress);
+				}
+				break; 
+			case RTCPPacket::Unknown:
+			default:
+				{
+					OnUnknownPacketType(rtcppack,receivetime,senderaddress);
+				}
+				break;
+			}
+		}
+		else
+		{
+			OnUnknownPacketFormat(rtcppack,receivetime,senderaddress);
+		}
+	}
+
+	return 0;
+}
+
+bool RTPSources::GotoFirstSource()
+{
+	sourcelist.GotoFirstElement();
+	if (sourcelist.HasCurrentElement())
+		return true;
+	return false;
+}
+
+bool RTPSources::GotoNextSource()
+{
+	sourcelist.GotoNextElement();
+	if (sourcelist.HasCurrentElement())
+		return true;
+	return false;
+}
+
+bool RTPSources::GotoPreviousSource()
+{
+	sourcelist.GotoPreviousElement();
+	if (sourcelist.HasCurrentElement())
+		return true;
+	return false;
+}
+
+bool RTPSources::GotoFirstSourceWithData()
+{
+	bool found = false;
+	
+	sourcelist.GotoFirstElement();
+	while (!found && sourcelist.HasCurrentElement())
+	{
+		RTPInternalSourceData *srcdat;
+
+		srcdat = sourcelist.GetCurrentElement();
+		if (srcdat->HasData())
+			found = true;
+		else
+			sourcelist.GotoNextElement();
+	}
+			
+	return found;
+}
+
+bool RTPSources::GotoNextSourceWithData()
+{
+	bool found = false;
+	
+	sourcelist.GotoNextElement();
+	while (!found && sourcelist.HasCurrentElement())
+	{
+		RTPInternalSourceData *srcdat;
+
+		srcdat = sourcelist.GetCurrentElement();
+		if (srcdat->HasData())
+			found = true;
+		else
+			sourcelist.GotoNextElement();
+	}
+			
+	return found;
+}
+
+bool RTPSources::GotoPreviousSourceWithData()
+{
+	bool found = false;
+	
+	sourcelist.GotoPreviousElement();
+	while (!found && sourcelist.HasCurrentElement())
+	{
+		RTPInternalSourceData *srcdat;
+
+		srcdat = sourcelist.GetCurrentElement();
+		if (srcdat->HasData())
+			found = true;
+		else
+			sourcelist.GotoNextElement();
+	}
+			
+	return found;
+}
+
+RTPSourceData *RTPSources::GetCurrentSourceInfo()
+{
+	if (!sourcelist.HasCurrentElement())
+		return 0;
+	return sourcelist.GetCurrentElement();
+}
+
+RTPSourceData *RTPSources::GetSourceInfo(u_int32_t ssrc)
+{
+	if (sourcelist.GotoElement(ssrc) < 0)
+		return 0;
+	if (!sourcelist.HasCurrentElement())
+		return 0;
+	return sourcelist.GetCurrentElement();
+}
+
+bool RTPSources::GotEntry(u_int32_t ssrc)
+{
+	return sourcelist.HasElement(ssrc);
+}
+
+RTPPacket *RTPSources::GetNextPacket()
+{
+	if (!sourcelist.HasCurrentElement())
+		return 0;
+	
+	RTPInternalSourceData *srcdat = sourcelist.GetCurrentElement();
+	RTPPacket *pack = srcdat->GetNextPacket();
+	return pack;
+}
+
+int RTPSources::ProcessRTCPSenderInfo(u_int32_t ssrc,const RTPNTPTime &ntptime,u_int32_t rtptime,
+                          u_int32_t packetcount,u_int32_t octetcount,const RTPTime &receivetime,
+			  const RTPAddress *senderaddress)
+{
+	RTPInternalSourceData *srcdat;
+	bool created;
+	int status;
+	
+	status = GetRTCPSourceData(ssrc,senderaddress,&srcdat,&created);
+	if (status < 0)
+		return status;
+	if (srcdat == 0)
+		return 0;
+	
+	srcdat->ProcessSenderInfo(ntptime,rtptime,packetcount,octetcount,receivetime);
+	
+	// Call the callback
+	if (created)
+		OnNewSource(srcdat);
+
+	return 0;
+}
+
+int RTPSources::ProcessRTCPReportBlock(u_int32_t ssrc,u_int8_t fractionlost,int32_t lostpackets,
+                           u_int32_t exthighseqnr,u_int32_t jitter,u_int32_t lsr,
+			   u_int32_t dlsr,const RTPTime &receivetime,const RTPAddress *senderaddress)
+{
+	RTPInternalSourceData *srcdat;
+	bool created;
+	int status;
+	
+	status = GetRTCPSourceData(ssrc,senderaddress,&srcdat,&created);
+	if (status < 0)
+		return status;
+	if (srcdat == 0)
+		return 0;
+	
+	srcdat->ProcessReportBlock(fractionlost,lostpackets,exthighseqnr,jitter,lsr,dlsr,receivetime);
+
+	// Call the callback
+	if (created)
+		OnNewSource(srcdat);
+			
+	return 0;
+}
+
+int RTPSources::ProcessSDESNormalItem(u_int32_t ssrc,RTCPSDESPacket::ItemType t,size_t itemlength,
+                          const void *itemdata,const RTPTime &receivetime,const RTPAddress *senderaddress)
+{
+	RTPInternalSourceData *srcdat;
+	bool created,cnamecollis;
+	int status;
+	u_int8_t id;
+	bool prevactive;
+
+	switch(t)
+	{
+	case RTCPSDESPacket::CNAME:
+		id = RTCP_SDES_ID_CNAME;
+		break;
+	case RTCPSDESPacket::NAME:
+		id = RTCP_SDES_ID_NAME;
+		break;
+	case RTCPSDESPacket::EMAIL:
+		id = RTCP_SDES_ID_EMAIL;
+		break;
+	case RTCPSDESPacket::PHONE:
+		id = RTCP_SDES_ID_PHONE;
+		break;
+	case RTCPSDESPacket::LOC:
+		id = RTCP_SDES_ID_LOCATION;
+		break;
+	case RTCPSDESPacket::TOOL:
+		id = RTCP_SDES_ID_TOOL;
+		break;
+	case RTCPSDESPacket::NOTE:
+		id = RTCP_SDES_ID_NOTE;
+		break;
+	default:
+		return ERR_RTP_SOURCES_ILLEGALSDESTYPE;
+	}	
+	
+	status = GetRTCPSourceData(ssrc,senderaddress,&srcdat,&created);
+	if (status < 0)
+		return status;
+	if (srcdat == 0)
+		return 0;
+
+	prevactive = srcdat->IsActive();
+	status = srcdat->ProcessSDESItem(id,(const u_int8_t *)itemdata,itemlength,receivetime,&cnamecollis);
+	if (!prevactive && srcdat->IsActive())
+		activecount++;
+	
+	// Call the callback
+	if (created)
+		OnNewSource(srcdat);
+	if (cnamecollis)
+		OnCNAMECollision(srcdat,senderaddress,(const u_int8_t *)itemdata,itemlength);
+	
+	return status;
+}
+
+#ifdef RTP_SUPPORT_SDESPRIV
+int RTPSources::ProcessSDESPrivateItem(u_int32_t ssrc,size_t prefixlen,const void *prefixdata,
+                           size_t valuelen,const void *valuedata,const RTPTime &receivetime,
+			   const RTPAddress *senderaddress)
+{
+	RTPInternalSourceData *srcdat;
+	bool created;
+	int status;
+	
+	status = GetRTCPSourceData(ssrc,senderaddress,&srcdat,&created);
+	if (status < 0)
+		return status;
+	if (srcdat == 0)
+		return 0;
+
+	status = srcdat->ProcessPrivateSDESItem((const u_int8_t *)prefixdata,prefixlen,(const u_int8_t *)valuedata,valuelen,receivetime);
+	// Call the callback
+	if (created)
+		OnNewSource(srcdat);
+	return status;
+}
+#endif //RTP_SUPPORT_SDESPRIV
+
+int RTPSources::ProcessBYE(u_int32_t ssrc,size_t reasonlength,const void *reasondata,
+		           const RTPTime &receivetime,const RTPAddress *senderaddress)
+{
+	RTPInternalSourceData *srcdat;
+	bool created;
+	int status;
+	bool prevactive;
+	
+	status = GetRTCPSourceData(ssrc,senderaddress,&srcdat,&created);
+	if (status < 0)
+		return status;
+	if (srcdat == 0)
+		return 0;
+
+	// we'll ignore BYE packets for our own ssrc
+	if (srcdat == owndata)
+		return 0;
+	
+	prevactive = srcdat->IsActive();
+	srcdat->ProcessBYEPacket((const u_int8_t *)reasondata,reasonlength,receivetime);
+	if (prevactive && !srcdat->IsActive())
+		activecount--;
+	
+	// Call the callback
+	if (created)
+		OnNewSource(srcdat);
+	OnBYEPacket(srcdat);
+	return 0;
+}
+
+int RTPSources::ObtainSourceDataInstance(u_int32_t ssrc,RTPInternalSourceData **srcdat,bool *created)
+{
+	RTPInternalSourceData *srcdat2;
+	int status;
+	
+	if (sourcelist.GotoElement(ssrc) < 0) // No entry for this source
+	{
+#ifdef RTP_SUPPORT_PROBATION
+		srcdat2 = new RTPInternalSourceData(ssrc,probationtype);
+#else
+		srcdat2 = new RTPInternalSourceData(ssrc,RTPSources::NoProbation);
+#endif // RTP_SUPPORT_PROBATION
+		if (srcdat2 == 0)
+			return ERR_RTP_OUTOFMEM;
+		if ((status = sourcelist.AddElement(ssrc,srcdat2)) < 0)
+		{
+			delete srcdat2;
+			return status;
+		}
+		*srcdat = srcdat2;
+		*created = true;
+		totalcount++;
+	}
+	else
+	{
+		*srcdat = sourcelist.GetCurrentElement();
+		*created = false;
+	}
+	return 0;
+}
+
+	
+int RTPSources::GetRTCPSourceData(u_int32_t ssrc,const RTPAddress *senderaddress,
+		                  RTPInternalSourceData **srcdat2,bool *newsource)
+{
+	int status;
+	bool created;
+	RTPInternalSourceData *srcdat;
+	
+	*srcdat2 = 0;
+	
+	if ((status = ObtainSourceDataInstance(ssrc,&srcdat,&created)) < 0)
+		return status;
+	
+	if (created)
+	{
+		if ((status = srcdat->SetRTCPDataAddress(senderaddress)) < 0)
+			return status;
+	}
+	else // got a previously existing source
+	{
+		if (CheckCollision(srcdat,senderaddress,false))
+			return 0; // ignore packet on collision
+	}
+	
+	*srcdat2 = srcdat;
+	*newsource = created;
+
+	return 0;
+}
+
+int RTPSources::UpdateReceiveTime(u_int32_t ssrc,const RTPTime &receivetime,const RTPAddress *senderaddress)
+{
+	RTPInternalSourceData *srcdat;
+	bool created;
+	int status;
+	
+	status = GetRTCPSourceData(ssrc,senderaddress,&srcdat,&created);
+	if (status < 0)
+		return status;
+	if (srcdat == 0)
+		return 0;
+	
+	// We got valid SSRC info
+	srcdat->UpdateMessageTime(receivetime);
+	
+	// Call the callback
+	if (created)
+		OnNewSource(srcdat);
+
+	return 0;
+}
+
+void RTPSources::Timeout(const RTPTime &curtime,const RTPTime &timeoutdelay)
+{
+	int newtotalcount = 0;
+	int newsendercount = 0;
+	int newactivecount = 0;
+	RTPTime checktime = curtime;
+	checktime -= timeoutdelay;
+	
+	sourcelist.GotoFirstElement();
+	while (sourcelist.HasCurrentElement())
+	{
+		RTPInternalSourceData *srcdat = sourcelist.GetCurrentElement();
+		RTPTime lastmsgtime = srcdat->INF_GetLastMessageTime();
+
+		// we don't want to time out ourselves
+		if ((srcdat != owndata) && (lastmsgtime < checktime)) // timeout
+		{
+			
+			totalcount--;
+			if (srcdat->IsSender())
+				sendercount--;
+			if (srcdat->IsActive())
+				activecount--;
+			
+			sourcelist.DeleteCurrentElement();
+
+			OnTimeout(srcdat);
+			OnRemoveSource(srcdat);
+			delete srcdat;
+		}
+		else
+		{
+			newtotalcount++;
+			if (srcdat->IsSender())
+				newsendercount++;
+			if (srcdat->IsActive())
+				newactivecount++;
+			sourcelist.GotoNextElement();
+		}
+	}
+	
+#ifdef RTPDEBUG
+	if (newtotalcount != totalcount)
+	{
+		std::cout << "New total count " << newtotalcount << " doesnt match old total count " << totalcount << std::endl;
+		SafeCountTotal();
+	}
+	if (newsendercount != sendercount)
+	{
+		std::cout << "New sender count " << newsendercount << " doesnt match old sender count " << sendercount << std::endl;
+		SafeCountSenders();
+	}
+	if (newactivecount != activecount)
+	{
+		std::cout << "New active count " << newactivecount << " doesnt match old active count " << activecount << std::endl;
+		SafeCountActive();
+	}
+#endif // RTPDEBUG
+	
+	totalcount = newtotalcount; // just to play it safe
+	sendercount = newsendercount;
+	activecount = newactivecount;
+}
+
+void RTPSources::SenderTimeout(const RTPTime &curtime,const RTPTime &timeoutdelay)
+{
+	int newtotalcount = 0;
+	int newsendercount = 0;
+	int newactivecount = 0;
+	RTPTime checktime = curtime;
+	checktime -= timeoutdelay;
+	
+	sourcelist.GotoFirstElement();
+	while (sourcelist.HasCurrentElement())
+	{
+		RTPInternalSourceData *srcdat = sourcelist.GetCurrentElement();
+
+		newtotalcount++;
+		if (srcdat->IsActive())
+			newactivecount++;
+
+		if (srcdat->IsSender())
+		{
+			RTPTime lastrtppacktime = srcdat->INF_GetLastRTPPacketTime();
+
+			if (lastrtppacktime < checktime) // timeout
+			{
+				srcdat->ClearSenderFlag();
+				sendercount--;
+			}
+			else
+				newsendercount++;
+		}
+		sourcelist.GotoNextElement();
+	}
+	
+#ifdef RTPDEBUG
+	if (newtotalcount != totalcount)
+	{
+		std::cout << "New total count " << newtotalcount << " doesnt match old total count " << totalcount << std::endl;
+		SafeCountTotal();
+	}
+	if (newsendercount != sendercount)
+	{
+		std::cout << "New sender count " << newsendercount << " doesnt match old sender count " << sendercount << std::endl;
+		SafeCountSenders();
+	}
+	if (newactivecount != activecount)
+	{
+		std::cout << "New active count " << newactivecount << " doesnt match old active count " << activecount << std::endl;
+		SafeCountActive();
+	}
+#endif // RTPDEBUG
+	
+	totalcount = newtotalcount; // just to play it safe
+	sendercount = newsendercount;
+	activecount = newactivecount;
+}
+
+void RTPSources::BYETimeout(const RTPTime &curtime,const RTPTime &timeoutdelay)
+{
+	int newtotalcount = 0;
+	int newsendercount = 0;
+	int newactivecount = 0;
+	RTPTime checktime = curtime;
+	checktime -= timeoutdelay;
+	
+	sourcelist.GotoFirstElement();
+	while (sourcelist.HasCurrentElement())
+	{
+		RTPInternalSourceData *srcdat = sourcelist.GetCurrentElement();
+		
+		if (srcdat->ReceivedBYE())
+		{
+			RTPTime byetime = srcdat->GetBYETime();
+
+			if ((srcdat != owndata) && (checktime > byetime))
+			{
+				totalcount--;
+				if (srcdat->IsSender())
+					sendercount--;
+				if (srcdat->IsActive())
+					activecount--;
+				sourcelist.DeleteCurrentElement();
+				OnBYETimeout(srcdat);
+				OnRemoveSource(srcdat);
+				delete srcdat;
+			}
+			else
+			{
+				newtotalcount++;
+				if (srcdat->IsSender())
+					newsendercount++;
+				if (srcdat->IsActive())
+					newactivecount++;
+				sourcelist.GotoNextElement();
+			}
+		}
+		else
+		{
+			newtotalcount++;
+			if (srcdat->IsSender())
+				newsendercount++;
+			if (srcdat->IsActive())
+				newactivecount++;
+			sourcelist.GotoNextElement();
+		}
+	}
+	
+#ifdef RTPDEBUG
+	if (newtotalcount != totalcount)
+	{
+		std::cout << "New total count " << newtotalcount << " doesnt match old total count " << totalcount << std::endl;
+		SafeCountTotal();
+	}
+	if (newsendercount != sendercount)
+	{
+		std::cout << "New sender count " << newsendercount << " doesnt match old sender count " << sendercount << std::endl;
+		SafeCountSenders();
+	}
+	if (newactivecount != activecount)
+	{
+		std::cout << "New active count " << newactivecount << " doesnt match old active count " << activecount << std::endl;
+		SafeCountActive();
+	}
+#endif // RTPDEBUG
+	
+	totalcount = newtotalcount; // just to play it safe
+	sendercount = newsendercount;
+	activecount = newactivecount;
+}
+
+void RTPSources::NoteTimeout(const RTPTime &curtime,const RTPTime &timeoutdelay)
+{
+	int newtotalcount = 0;
+	int newsendercount = 0;
+	int newactivecount = 0;
+	RTPTime checktime = curtime;
+	checktime -= timeoutdelay;
+	
+	sourcelist.GotoFirstElement();
+	while (sourcelist.HasCurrentElement())
+	{
+		RTPInternalSourceData *srcdat = sourcelist.GetCurrentElement();
+		u_int8_t *note;
+		size_t notelen;
+
+		note = srcdat->SDES_GetNote(&notelen);
+		if (notelen != 0) // Note has been set
+		{
+			RTPTime notetime = srcdat->INF_GetLastSDESNoteTime();
+			
+			if (checktime > notetime)
+			{
+				srcdat->ClearNote();
+				OnNoteTimeout(srcdat);
+			}
+		}
+		
+		newtotalcount++;
+		if (srcdat->IsSender())
+			newsendercount++;
+		if (srcdat->IsActive())
+			newactivecount++;
+		sourcelist.GotoNextElement();
+	}
+	
+#ifdef RTPDEBUG
+	if (newtotalcount != totalcount)
+	{
+		std::cout << "New total count " << newtotalcount << " doesnt match old total count " << totalcount << std::endl;
+		SafeCountTotal();
+	}
+	if (newsendercount != sendercount)
+	{
+		std::cout << "New sender count " << newsendercount << " doesnt match old sender count " << sendercount << std::endl;
+		SafeCountSenders();
+	}
+	if (newactivecount != activecount)
+	{
+		std::cout << "New active count " << newactivecount << " doesnt match old active count " << activecount << std::endl;
+		SafeCountActive();
+	}
+#endif // RTPDEBUG
+	
+	totalcount = newtotalcount; // just to play it safe
+	sendercount = newsendercount;
+	activecount = newactivecount;
+
+}
+	
+void RTPSources::MultipleTimeouts(const RTPTime &curtime,const RTPTime &sendertimeout,const RTPTime &byetimeout,const RTPTime &generaltimeout,const RTPTime &notetimeout)
+{
+	int newtotalcount = 0;
+	int newsendercount = 0;
+	int newactivecount = 0;
+	RTPTime senderchecktime = curtime;
+	RTPTime byechecktime = curtime;
+	RTPTime generaltchecktime = curtime;
+	RTPTime notechecktime = curtime;
+	senderchecktime -= sendertimeout;
+	byechecktime -= byetimeout;
+	generaltchecktime -= generaltimeout;
+	notechecktime -= notetimeout;
+	
+	sourcelist.GotoFirstElement();
+	while (sourcelist.HasCurrentElement())
+	{
+		RTPInternalSourceData *srcdat = sourcelist.GetCurrentElement();
+		bool deleted,issender,isactive;
+		bool byetimeout,normaltimeout,notetimeout;
+		u_int8_t *note;
+		size_t notelen;
+		
+		issender = srcdat->IsSender();
+		isactive = srcdat->IsActive();
+		deleted = false;
+		byetimeout = false;
+		normaltimeout = false;
+		notetimeout = false;
+
+		note = srcdat->SDES_GetNote(&notelen);
+		if (notelen != 0) // Note has been set
+		{
+			RTPTime notetime = srcdat->INF_GetLastSDESNoteTime();
+			
+			if (notechecktime > notetime)
+			{
+				notetimeout = true;
+				srcdat->ClearNote();
+			}
+		}
+
+		if (srcdat->ReceivedBYE())
+		{
+			RTPTime byetime = srcdat->GetBYETime();
+
+			if ((srcdat != owndata) && (byechecktime > byetime))
+			{
+				sourcelist.DeleteCurrentElement();
+				deleted = true;
+				byetimeout = true;
+			}
+		}
+
+		if (!deleted)
+		{
+			RTPTime lastmsgtime = srcdat->INF_GetLastMessageTime();
+
+			if ((srcdat != owndata) && (lastmsgtime < generaltchecktime))
+			{
+				sourcelist.DeleteCurrentElement();
+				deleted = true;
+				normaltimeout = true;
+			}
+		}
+		
+		if (!deleted)
+		{
+			newtotalcount++;
+			
+			if (issender)
+			{
+				RTPTime lastrtppacktime = srcdat->INF_GetLastRTPPacketTime();
+
+				if (lastrtppacktime < senderchecktime)
+				{
+					srcdat->ClearSenderFlag();
+					sendercount--;
+				}
+				else
+					newsendercount++;
+			}
+
+			if (isactive)
+				newactivecount++;
+
+			if (notetimeout)
+				OnNoteTimeout(srcdat);
+
+			sourcelist.GotoNextElement();
+		}
+		else // deleted entry
+		{
+			if (issender)
+				sendercount--;
+			if (isactive)
+				activecount--;
+			totalcount--;
+
+			if (byetimeout)
+				OnBYETimeout(srcdat);
+			if (normaltimeout)
+				OnTimeout(srcdat);
+			delete srcdat;
+		}
+	}	
+	
+#ifdef RTPDEBUG
+	if (newtotalcount != totalcount)
+	{
+		SafeCountTotal();
+		std::cout << "New total count " << newtotalcount << " doesnt match old total count " << totalcount << std::endl;
+	}
+	if (newsendercount != sendercount)
+	{
+		SafeCountSenders();
+		std::cout << "New sender count " << newsendercount << " doesnt match old sender count " << sendercount << std::endl;
+	}
+	if (newactivecount != activecount)
+	{
+		std::cout << "New active count " << newactivecount << " doesnt match old active count " << activecount << std::endl;
+		SafeCountActive();
+	}
+#endif // RTPDEBUG
+	
+	totalcount = newtotalcount; // just to play it safe
+	sendercount = newsendercount;
+	activecount = newactivecount;
+}
+
+#ifdef RTPDEBUG
+void RTPSources::Dump()
+{
+	std::cout << "Total count:  " << totalcount << std::endl;
+	std::cout << "Sender count: " << sendercount << std::endl;
+	std::cout << "Active count: " << activecount << std::endl;
+	if (GotoFirstSource())
+	{
+		do
+		{
+			RTPSourceData *s;
+			s = GetCurrentSourceInfo();
+			s->Dump();
+			std::cout << std::endl;
+		} while (GotoNextSource());
+	}
+}
+
+void RTPSources::SafeCountTotal()
+{
+	int count = 0;
+	
+	if (GotoFirstSource())
+	{
+		do
+		{
+			count++;	
+		} while (GotoNextSource());
+	}
+	std::cout << "Actual total count: " << count << std::endl;
+}
+
+void RTPSources::SafeCountSenders()
+{
+	int count = 0;
+	
+	if (GotoFirstSource())
+	{
+		do
+		{
+			RTPSourceData *s;
+			s = GetCurrentSourceInfo();
+			if (s->IsSender())
+				count++;	
+		} while (GotoNextSource());
+	}
+	std::cout << "Actual sender count: " << count << std::endl;
+}
+
+void RTPSources::SafeCountActive()
+{
+	int count = 0;
+	
+	if (GotoFirstSource())
+	{
+		do
+		{
+			RTPSourceData *s;
+			s = GetCurrentSourceInfo();
+			if (s->IsActive())
+				count++;	
+		} while (GotoNextSource());
+	}
+	std::cout << "Actual active count: " << count << std::endl;
+}
+
+#endif // RTPDEBUG
+
+bool RTPSources::CheckCollision(RTPInternalSourceData *srcdat,const RTPAddress *senderaddress,bool isrtp)
+{
+	bool isset,otherisset;
+	const RTPAddress *addr,*otheraddr;
+	
+	if (isrtp)
+	{
+		isset = srcdat->IsRTPAddressSet();
+		addr = srcdat->GetRTPDataAddress();
+		otherisset = srcdat->IsRTCPAddressSet();
+		otheraddr = srcdat->GetRTCPDataAddress();
+	}
+	else
+	{
+		isset = srcdat->IsRTCPAddressSet();
+		addr = srcdat->GetRTCPDataAddress();
+		otherisset = srcdat->IsRTPAddressSet();
+		otheraddr = srcdat->GetRTPDataAddress();
+	}
+
+	if (!isset)
+	{
+		if (otherisset) // got other address, can check if it comes from same host
+		{
+			if (otheraddr == 0) // other came from our own session
+			{
+				if (senderaddress != 0)
+				{
+					OnSSRCCollision(srcdat,senderaddress,isrtp);
+					return true;
+				}
+
+				// Ok, store it
+
+				if (isrtp)
+					srcdat->SetRTPDataAddress(senderaddress);
+				else
+					srcdat->SetRTCPDataAddress(senderaddress);
+			}
+			else
+			{
+				if (!otheraddr->IsFromSameHost(senderaddress))
+				{
+					OnSSRCCollision(srcdat,senderaddress,isrtp);
+					return true;
+				}
+
+				// Ok, comes from same host, store the address
+
+				if (isrtp)
+					srcdat->SetRTPDataAddress(senderaddress);
+				else
+					srcdat->SetRTCPDataAddress(senderaddress);
+			}
+		}
+		else // no other address, store this one
+		{
+			if (isrtp)
+				srcdat->SetRTPDataAddress(senderaddress);
+			else
+				srcdat->SetRTCPDataAddress(senderaddress);
+		}
+	}
+	else // already got an address
+	{
+		if (addr == 0)
+		{
+			if (senderaddress != 0)
+			{
+				OnSSRCCollision(srcdat,senderaddress,isrtp);
+				return true;
+			}
+		}
+		else
+		{
+			if (!addr->IsSameAddress(senderaddress))
+			{
+				OnSSRCCollision(srcdat,senderaddress,isrtp);
+				return true;
+			}
+		}
+	}
+	
+	return false;
+}

Added: konference/src/rtp/jrtplib/rtpsources.h
===================================================================
--- konference/src/rtp/jrtplib/rtpsources.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpsources.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,174 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPSOURCES_H
+
+#define RTPSOURCES_H
+
+#include "rtpconfig.h"
+#include "rtpkeyhashtable.h"
+#include "rtcpsdespacket.h"
+#include "rtptypes.h"
+
+#define RTPSOURCES_HASHSIZE							8317
+
+#ifdef RTP_SUPPORT_INLINETEMPLATEPARAM
+	inline int RTPSources_GetHashIndex(const u_int32_t &ssrc)	{ return ssrc%RTPSOURCES_HASHSIZE; }
+#else // can't use inline function as template parameter
+	int RTPSources_GetHashIndex(const u_int32_t &ssrc);
+#endif // RTP_SUPPORT_INLINETEMPLATEPARAM
+	
+class RTPNTPTime;
+class RTPTransmitter;
+class RTCPAPPPacket;
+class RTPInternalSourceData;
+class RTPRawPacket;
+class RTPPacket;
+class RTPTime;
+class RTPAddress;
+class RTPSourceData;
+
+class RTPSources
+{
+public:
+	enum ProbationType { NoProbation, ProbationDiscard, ProbationStore };
+	
+	RTPSources(ProbationType = ProbationStore);
+	virtual ~RTPSources();
+	void Clear();
+#ifdef RTP_SUPPORT_PROBATION
+	void SetProbationType(ProbationType probtype)							{ probationtype = probtype; }
+#endif // RTP_SUPPORT_PROBATION
+
+	int CreateOwnSSRC(u_int32_t ssrc);
+	int DeleteOwnSSRC();
+	void SentRTPPacket();
+
+	int ProcessRawPacket(RTPRawPacket *rawpack,RTPTransmitter *trans,bool acceptownpackets);
+	int ProcessRawPacket(RTPRawPacket *rawpack,RTPTransmitter *trans[],int numtrans,bool acceptownpackets);
+
+	// Note: if the packet originated from our own session, senderaddress has to be NULL
+	int ProcessRTPPacket(RTPPacket *rtppack,const RTPTime &receivetime,const RTPAddress *senderaddress,bool *stored);
+	int ProcessRTCPCompoundPacket(RTCPCompoundPacket *rtcpcomppack,const RTPTime &receivetime,
+	                              const RTPAddress *senderaddress);
+	
+	int ProcessRTCPSenderInfo(u_int32_t ssrc,const RTPNTPTime &ntptime,u_int32_t rtptime,
+	                          u_int32_t packetcount,u_int32_t octetcount,const RTPTime &receivetime,
+				  const RTPAddress *senderaddress);
+	int ProcessRTCPReportBlock(u_int32_t ssrc,u_int8_t fractionlost,int32_t lostpackets,
+	                           u_int32_t exthighseqnr,u_int32_t jitter,u_int32_t lsr,
+				   u_int32_t dlsr,const RTPTime &receivetime,const RTPAddress *senderaddress);
+	int ProcessSDESNormalItem(u_int32_t ssrc,RTCPSDESPacket::ItemType t,size_t itemlength,
+	                          const void *itemdata,const RTPTime &receivetime,const RTPAddress *senderaddress);
+#ifdef RTP_SUPPORT_SDESPRIV
+	int ProcessSDESPrivateItem(u_int32_t ssrc,size_t prefixlen,const void *prefixdata,
+	                           size_t valuelen,const void *valuedata,const RTPTime &receivetime,
+				   const RTPAddress *senderaddress);
+#endif //RTP_SUPPORT_SDESPRIV
+	int ProcessBYE(u_int32_t ssrc,size_t reasonlength,const void *reasondata,const RTPTime &receivetime,
+	               const RTPAddress *senderaddress);
+
+	// If no specific info was sent to us, but we did receive a packet from a SSRC, the following
+	// function can be used to update the time at which we last heard something from the SSRC.
+	// This way, premature timeouts can be avoided. 
+	int UpdateReceiveTime(u_int32_t ssrc,const RTPTime &receivetime,const RTPAddress *senderaddress);
+	
+	bool GotoFirstSource();
+	bool GotoNextSource();
+	bool GotoPreviousSource();
+	bool GotoFirstSourceWithData();
+	bool GotoNextSourceWithData();
+	bool GotoPreviousSourceWithData();
+	RTPSourceData *GetCurrentSourceInfo();
+	RTPSourceData *GetSourceInfo(u_int32_t ssrc);
+	RTPPacket *GetNextPacket();
+	bool GotEntry(u_int32_t ssrc);
+	RTPSourceData *GetOwnSourceInfo()								{ return (RTPSourceData *)owndata; }
+
+	void Timeout(const RTPTime &curtime,const RTPTime &timeoutdelay);
+	void SenderTimeout(const RTPTime &curtime,const RTPTime &timeoutdelay);
+	void BYETimeout(const RTPTime &curtime,const RTPTime &timeoutdelay);
+	void NoteTimeout(const RTPTime &curtime,const RTPTime &timeoutdelay);
+	void MultipleTimeouts(const RTPTime &curtime,const RTPTime &sendertimeout,
+			      const RTPTime &byetimeout,const RTPTime &generaltimeout,
+			      const RTPTime &notetimeout);
+
+	int GetSenderCount() const									{ return sendercount; }
+	int GetTotalCount() const									{ return totalcount; }
+	int GetActiveMemberCount() const								{ return activecount; } 
+#ifdef RTPDEBUG
+	void Dump();
+	void SafeCountTotal();
+	void SafeCountSenders();
+	void SafeCountActive();
+#endif // RTPDEBUG
+protected:
+	virtual void OnRTPPacket(RTPPacket *pack,const RTPTime &receivetime,
+	                         const RTPAddress *senderaddress) 					{ }
+	virtual void OnRTCPCompoundPacket(RTCPCompoundPacket *pack,const RTPTime &receivetime,
+	                                  const RTPAddress *senderaddress) 				{ }
+	virtual void OnSSRCCollision(RTPSourceData *srcdat,const RTPAddress *senderaddress,bool isrtp)  { }
+	virtual void OnCNAMECollision(RTPSourceData *srcdat,const RTPAddress *senderaddress,
+	                              const u_int8_t *cname,size_t cnamelength)				{ }
+	virtual void OnNewSource(RTPSourceData *srcdat)			 				{ }
+	virtual void OnRemoveSource(RTPSourceData *srcdat)						{ }
+	virtual void OnTimeout(RTPSourceData *srcdat)							{ }
+	virtual void OnBYETimeout(RTPSourceData *srcdat)						{ }
+	virtual void OnBYEPacket(RTPSourceData *srcdat)							{ }
+	virtual void OnAPPPacket(RTCPAPPPacket *apppacket,const RTPTime &receivetime,
+	                         const RTPAddress *senderaddress)					{ }
+	virtual void OnUnknownPacketType(RTCPPacket *rtcppack,const RTPTime &receivetime,
+	                                 const RTPAddress *senderaddress)				{ }
+	virtual void OnUnknownPacketFormat(RTCPPacket *rtcppack,const RTPTime &receivetime,
+	                                   const RTPAddress *senderaddress)				{ }
+	virtual void OnNoteTimeout(RTPSourceData *srcdat)						{ }
+private:
+	void ClearSourceList();
+	int ObtainSourceDataInstance(u_int32_t ssrc,RTPInternalSourceData **srcdat,bool *created);
+	int GetRTCPSourceData(u_int32_t ssrc,const RTPAddress *senderaddress,RTPInternalSourceData **srcdat,bool *newsource);
+	bool CheckCollision(RTPInternalSourceData *srcdat,const RTPAddress *senderaddress,bool isrtp);
+	
+	RTPKeyHashTable<const u_int32_t,RTPInternalSourceData*,RTPSources_GetHashIndex,RTPSOURCES_HASHSIZE> sourcelist;
+	
+	int sendercount;
+	int totalcount;
+	int activecount;
+
+#ifdef RTP_SUPPORT_PROBATION
+	ProbationType probationtype;
+#endif // RTP_SUPPORT_PROBATION
+
+	RTPInternalSourceData *owndata;
+};
+
+#endif // RTPSOURCES_H
+

Added: konference/src/rtp/jrtplib/rtpstructs.h
===================================================================
--- konference/src/rtp/jrtplib/rtpstructs.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpstructs.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,119 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPSTRUCTS_H
+
+#define RTPSTRUCTS_H
+
+#include "rtpconfig.h"
+#include "rtptypes.h"
+
+struct RTPHeader
+{
+#ifdef RTP_BIG_ENDIAN
+	u_int8_t version:2;
+	u_int8_t padding:1;
+	u_int8_t extension:1;
+	u_int8_t csrccount:4;
+	
+	u_int8_t marker:1;
+	u_int8_t payloadtype:7;
+#else // little endian
+	u_int8_t csrccount:4;
+	u_int8_t extension:1;
+	u_int8_t padding:1;
+	u_int8_t version:2;
+	
+	u_int8_t payloadtype:7;
+	u_int8_t marker:1;
+#endif // RTP_BIG_ENDIAN
+	
+	u_int16_t sequencenumber;
+	u_int32_t timestamp;
+	u_int32_t ssrc;
+};
+
+struct RTPExtensionHeader
+{
+	u_int16_t id;
+	u_int16_t length;
+};
+
+struct RTPSourceIdentifier
+{
+	u_int32_t ssrc;
+};
+
+struct RTCPCommonHeader
+{
+#ifdef RTP_BIG_ENDIAN
+	u_int8_t version:2;
+	u_int8_t padding:1;
+	u_int8_t count:5;
+#else // little endian
+	u_int8_t count:5;
+	u_int8_t padding:1;
+	u_int8_t version:2;
+#endif // RTP_BIG_ENDIAN
+
+	u_int8_t packettype;
+	u_int16_t length;
+};
+
+struct RTCPSenderReport
+{
+	u_int32_t ntptime_msw;
+	u_int32_t ntptime_lsw;
+	u_int32_t rtptimestamp;
+	u_int32_t packetcount;
+	u_int32_t octetcount;
+};
+
+struct RTCPReceiverReport
+{
+	u_int32_t ssrc; // Identifies about which SSRC's data this report is...
+	u_int8_t fractionlost;
+	u_int8_t packetslost[3];
+	u_int32_t exthighseqnr;
+	u_int32_t jitter;
+	u_int32_t lsr;
+	u_int32_t dlsr;
+};
+
+struct RTCPSDESHeader
+{
+	u_int8_t id;
+	u_int8_t length;
+};
+
+#endif // RTPSTRUCTS
+

Added: konference/src/rtp/jrtplib/rtptimeutilities.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtptimeutilities.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtptimeutilities.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,51 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#if (defined(WIN32) || defined(_WIN32_WCE))
+
+#include "rtptimeutilities.h"
+#ifdef RTPDEBUG
+	#include <iostream>
+#endif // RTPDEBUG
+
+RTPTimeInitializer::RTPTimeInitializer()
+{
+#ifdef RTPDEBUG
+	std::cout << "RTPTimeInitializer: Initializing RTPTime::CurrentTime()" << std::endl;
+#endif // RTPDEBUG
+	RTPTime curtime = RTPTime::CurrentTime();
+}
+
+RTPTimeInitializer timeinit;
+
+#endif // WIN32 || _WIN32_WCE
+

Added: konference/src/rtp/jrtplib/rtptimeutilities.h
===================================================================
--- konference/src/rtp/jrtplib/rtptimeutilities.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtptimeutilities.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,262 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPTIMEUTILITIES_H
+
+#define RTPTIMEUTILITIES_H
+
+#include "rtpconfig.h"
+#include "rtptypes.h"
+#ifndef WIN32
+	#include <sys/time.h>
+	#include <time.h>
+#else
+		#ifndef _WIN32_WCE
+        	#include <sys/timeb.h>
+        #endif // _WIN32_WINCE
+#endif // WIN32
+
+#define RTP_NTPTIMEOFFSET									2208988800UL
+
+class RTPNTPTime
+{
+public:
+	RTPNTPTime(u_int32_t m,u_int32_t l)							{ msw = m ; lsw = l; }
+	u_int32_t GetMSW() const								{ return msw; }
+	u_int32_t GetLSW() const								{ return lsw; }
+private:
+	u_int32_t msw,lsw;
+};
+
+class RTPTime
+{
+public:
+	static RTPTime CurrentTime();
+	static void Wait(const RTPTime &delay);
+		
+	RTPTime(double t);
+	RTPTime(RTPNTPTime ntptime);
+	RTPTime(u_int32_t seconds,u_int32_t microseconds)				{ sec = seconds; microsec = microseconds; }
+	u_int32_t GetSeconds() const							{ return sec; }
+	u_int32_t GetMicroSeconds() const						{ return microsec; }
+	double GetDouble() const 							{ return (((double)sec)+(((double)microsec)/1000000.0)); }
+	RTPTime &operator-=(const RTPTime &t);
+	RTPTime &operator+=(const RTPTime &t);
+	RTPNTPTime GetNTPTime() const;
+	bool operator<(const RTPTime &t) const;
+	bool operator>(const RTPTime &t) const;
+	bool operator<=(const RTPTime &t) const;
+	bool operator>=(const RTPTime &t) const;
+private:
+	u_int32_t sec,microsec;
+};
+
+inline RTPTime::RTPTime(double t)
+{
+	sec = (u_int32_t)t;
+
+	double t2 = t-((double)sec);
+	t2 *= 1000000.0;
+	microsec = (u_int32_t)t2;
+}
+
+inline RTPTime::RTPTime(RTPNTPTime ntptime)
+{
+	if (ntptime.GetMSW() < RTP_NTPTIMEOFFSET)
+	{
+		sec = 0;
+		microsec = 0;
+	}
+	else
+	{
+		sec = ntptime.GetMSW() - RTP_NTPTIMEOFFSET;
+		
+		double x = (double)ntptime.GetLSW();
+		x /= (65536.0*65536.0);
+		x *= 1000000.0;
+		microsec = (u_int32_t)x;
+	}
+}
+
+#if (defined(WIN32) || defined(_WIN32_WCE))
+
+inline RTPTime RTPTime::CurrentTime()
+{
+	static int inited = 0;
+	static unsigned __int64 microseconds, initmicroseconds;
+	static LARGE_INTEGER performancefrequency;
+
+	unsigned __int64 emulate_microseconds, microdiff;
+	SYSTEMTIME systemtime;
+	FILETIME filetime;
+
+	LARGE_INTEGER performancecount;
+
+	QueryPerformanceCounter(&performancecount);
+    
+	if(!inited){
+		inited = 1;
+		QueryPerformanceFrequency(&performancefrequency);
+		GetSystemTime(&systemtime);
+		SystemTimeToFileTime(&systemtime,&filetime);
+		microseconds = ( ((unsigned __int64)(filetime.dwHighDateTime) << 32) + (unsigned __int64)(filetime.dwLowDateTime) ) / 10ui64;
+		microseconds-= 11644473600000000ui64; // EPOCH
+		initmicroseconds = ( ( performancecount.QuadPart * 1000000ui64 ) / performancefrequency.QuadPart );
+	}
+    
+	emulate_microseconds = ( ( performancecount.QuadPart * 1000000ui64 ) / performancefrequency.QuadPart );
+
+	microdiff = emulate_microseconds - initmicroseconds;
+
+	return RTPTime((u_int32_t)((microseconds + microdiff) / 1000000ui64),((u_int32_t)((microseconds + microdiff) % 1000000ui64)));
+}
+
+inline void RTPTime::Wait(const RTPTime &delay)
+{
+	DWORD t;
+
+	t = ((DWORD)delay.GetSeconds())*1000+(((DWORD)delay.GetMicroSeconds())/1000);
+	Sleep(t);
+}
+
+class RTPTimeInitializer
+{
+public:
+	RTPTimeInitializer();
+	void Dummy() { }
+};
+
+extern RTPTimeInitializer timeinit;
+
+#else // unix style
+
+inline RTPTime RTPTime::CurrentTime()
+{
+	struct timeval tv;
+	
+	gettimeofday(&tv,0);
+	return RTPTime((u_int32_t)tv.tv_sec,(u_int32_t)tv.tv_usec);
+}
+
+inline void RTPTime::Wait(const RTPTime &delay)
+{
+	struct timespec req,rem;
+
+	req.tv_sec = (time_t)delay.sec;
+	req.tv_nsec = ((long)delay.microsec)*1000;
+	nanosleep(&req,&rem);
+}
+
+#endif // WIN32
+
+inline RTPTime &RTPTime::operator-=(const RTPTime &t)
+{ 
+	sec -= t.sec; 
+	if (t.microsec > microsec)
+	{
+		sec--;
+		microsec += 1000000;
+	}
+	microsec -= t.microsec;
+	return *this;
+}
+
+inline RTPTime &RTPTime::operator+=(const RTPTime &t)
+{ 
+	sec += t.sec; 
+	microsec += t.microsec;
+	if (microsec >= 1000000)
+	{
+		sec++;
+		microsec -= 1000000;
+	}
+	return *this;
+}
+
+inline RTPNTPTime RTPTime::GetNTPTime() const
+{
+	u_int32_t msw = sec+RTP_NTPTIMEOFFSET;
+	u_int32_t lsw;
+	double x;
+	
+      	x = microsec/1000000.0;
+	x *= (65536.0*65536.0);
+	lsw = (u_int32_t)x;
+
+	return RTPNTPTime(msw,lsw);
+}
+
+inline bool RTPTime::operator<(const RTPTime &t) const
+{
+	if (sec < t.sec)
+		return true;
+	if (sec > t.sec)
+		return false;
+	if (microsec < t.microsec)
+		return true;
+	return false;
+}
+
+inline bool RTPTime::operator>(const RTPTime &t) const
+{
+	if (sec > t.sec)
+		return true;
+	if (sec < t.sec)
+		return false;
+	if (microsec > t.microsec)
+		return true;
+	return false;
+}
+
+inline bool RTPTime::operator<=(const RTPTime &t) const
+{
+	if (sec < t.sec)
+		return true;
+	if (sec > t.sec)
+		return false;
+	if (microsec <= t.microsec)
+		return true;
+	return false;
+}
+
+inline bool RTPTime::operator>=(const RTPTime &t) const
+{
+	if (sec > t.sec)
+		return true;
+	if (sec < t.sec)
+		return false;
+	if (microsec >= t.microsec)
+		return true;
+	return false;
+}
+#endif // RTPTIMEUTILITIES_H
+

Added: konference/src/rtp/jrtplib/rtptransmitter.h
===================================================================
--- konference/src/rtp/jrtplib/rtptransmitter.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtptransmitter.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,141 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPTRANSMITTER_H
+
+#define RTPTRANSMITTER_H
+
+#include "rtpconfig.h"
+#include "rtptypes.h"
+
+class RTPRawPacket;
+class RTPAddress;
+class RTPTransmissionParams;
+class RTPTime;
+class RTPTransmissionInfo;
+
+// Abstract class from which actual transmission components should be derived
+
+class RTPTransmitter
+{
+public:
+	enum TransmissionProtocol { IPv4UDPProto, IPv6UDPProto, IPv4GSTProto, UserDefinedProto };
+	enum ReceiveMode { AcceptAll,AcceptSome,IgnoreSome };
+protected:
+	RTPTransmitter()															{ }
+public:
+	virtual ~RTPTransmitter()													{ }
+
+	// The init function is there for initialization before any other threads
+	// may access the object (e.g. initialization of mutexes)
+	virtual int Init(bool threadsafe) = 0;
+	virtual int Create(size_t maxpacksize,const RTPTransmissionParams *transparams) = 0;
+	virtual void Destroy() = 0;
+
+	// The user MUST delete the returned instance when it is no longer needed
+	virtual RTPTransmissionInfo *GetTransmissionInfo() = 0;
+
+	// If the buffersize ins't large enough, the transmitter must fill in the
+	// required length in 'bufferlength'
+	// If the size is ok, bufferlength is adjusted so that it indicates the
+	// amount of bytes in the buffer that are part of the hostname.
+	// The buffer is NOT null terminated!
+	virtual int GetLocalHostName(u_int8_t *buffer,size_t *bufferlength) = 0;
+
+	virtual bool ComesFromThisTransmitter(const RTPAddress *addr) = 0;
+	virtual size_t GetHeaderOverhead() = 0;
+	
+	virtual int Poll() = 0;
+	// If dataavailable is not NULL, it should be set to true if true if data was read
+	// and to false otherwise
+	virtual int WaitForIncomingData(const RTPTime &delay,bool *dataavailable = 0) = 0;
+	virtual int AbortWait() = 0;
+	
+	virtual int SendRTPData(const void *data,size_t len) = 0;	
+	virtual int SendRTCPData(const void *data,size_t len) = 0;
+
+	virtual void ResetPacketCount() = 0;
+	virtual u_int32_t GetNumRTPPacketsSent() = 0;
+	virtual u_int32_t GetNumRTCPPacketsSent() = 0;
+	
+	virtual int AddDestination(const RTPAddress &addr) = 0;
+	virtual int DeleteDestination(const RTPAddress &addr) = 0;
+	virtual void ClearDestinations() = 0;
+
+	virtual bool SupportsMulticasting() = 0;
+	virtual int JoinMulticastGroup(const RTPAddress &addr) = 0;
+	virtual int LeaveMulticastGroup(const RTPAddress &addr) = 0;
+	virtual void LeaveAllMulticastGroups() = 0;
+
+	// Note: the list of addresses must be cleared when the receive mode is changed!
+	virtual int SetReceiveMode(RTPTransmitter::ReceiveMode m) = 0;
+	virtual int AddToIgnoreList(const RTPAddress &addr) = 0;
+	virtual int DeleteFromIgnoreList(const RTPAddress &addr)= 0;
+	virtual void ClearIgnoreList() = 0;
+	virtual int AddToAcceptList(const RTPAddress &addr) = 0;
+	virtual int DeleteFromAcceptList(const RTPAddress &addr) = 0;
+	virtual void ClearAcceptList() = 0;
+	virtual int SetMaximumPacketSize(size_t s) = 0;	
+	
+	virtual bool NewDataAvailable() = 0;
+	virtual RTPRawPacket *GetNextPacket() = 0;
+#ifdef RTPDEBUG
+	virtual void Dump() = 0;
+#endif // RTPDEBUG
+};
+
+// Abstract class from which actual transmission parameters should be derived
+
+class RTPTransmissionParams
+{
+protected:
+	RTPTransmissionParams(RTPTransmitter::TransmissionProtocol p)				{ protocol = p; }
+public:
+	virtual ~RTPTransmissionParams() { }
+	RTPTransmitter::TransmissionProtocol GetTransmissionProtocol() const			{ return protocol; }
+private:
+	RTPTransmitter::TransmissionProtocol protocol;
+};
+
+class RTPTransmissionInfo
+{
+protected:
+	RTPTransmissionInfo(RTPTransmitter::TransmissionProtocol p)				{ protocol = p; }
+public:
+	virtual ~RTPTransmissionInfo() { }
+	RTPTransmitter::TransmissionProtocol GetTransmissionProtocol() const			{ return protocol; }
+private:
+	RTPTransmitter::TransmissionProtocol protocol;
+};
+
+#endif // RTPTRANSMITTER_H
+

Added: konference/src/rtp/jrtplib/rtptypes.h
===================================================================
--- konference/src/rtp/jrtplib/rtptypes.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtptypes.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,37 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include "rtptypes_unix.h"
+#else
+	#include "rtptypes_win.h"
+#endif // WIN32

Added: konference/src/rtp/jrtplib/rtptypes_unix.h
===================================================================
--- konference/src/rtp/jrtplib/rtptypes_unix.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtptypes_unix.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1 @@
+#include <sys/types.h>

Added: konference/src/rtp/jrtplib/rtptypes_win.h
===================================================================
--- konference/src/rtp/jrtplib/rtptypes_win.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtptypes_win.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,55 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPTYPES_H
+
+#define RTPTYPES_H
+
+#ifndef _WIN32_WCE
+	#include <winsock2.h>	
+	#include <ws2tcpip.h>
+	#include <sys/types.h>
+#else
+	#include <winsock2.h>	
+	#include <ws2tcpip.h>
+
+	typedef short int16_t;
+	typedef char int8_t;
+#endif // _WIN32_WCE
+
+typedef unsigned long u_int32_t;
+typedef unsigned short u_int16_t;
+typedef unsigned char u_int8_t;
+typedef long int32_t;
+
+#endif // RTPTYPES_H
+


Property changes on: konference/src/rtp/jrtplib/rtptypes_win.h
___________________________________________________________________
Name: svn:executable
   + *

Added: konference/src/rtp/jrtplib/rtpudpv4transmitter.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpudpv4transmitter.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpudpv4transmitter.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,1974 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtpudpv4transmitter.h"
+#include "rtprawpacket.h"
+#include "rtpipv4address.h"
+#include "rtptimeutilities.h"
+#include <stdio.h>
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	#define RTPSOCKERR								INVALID_SOCKET
+	#define RTPCLOSE(x)								closesocket(x)
+	#define RTPSOCKLENTYPE								int
+	#define RTPIOCTL								ioctlsocket
+#else // not Win32
+	#include <sys/socket.h>
+	#include <netinet/in.h>
+	#include <arpa/inet.h>
+	#include <sys/ioctl.h>
+	#include <net/if.h>
+	#include <string.h>
+	#include <netdb.h>
+	#include <unistd.h>
+
+	#ifdef RTP_HAVE_SYS_FILIO
+		#include <sys/filio.h>
+	#endif // RTP_HAVE_SYS_FILIO
+	#ifdef RTP_HAVE_SYS_SOCKIO
+		#include <sys/sockio.h>
+	#endif // RTP_HAVE_SYS_SOCKIO
+	#ifdef RTP_SUPPORT_IFADDRS
+		#include <ifaddrs.h>
+	#endif // RTP_SUPPORT_IFADDRS
+
+	#define RTPSOCKERR								-1
+	#define RTPCLOSE(x)								close(x)
+
+	#ifdef RTP_SOCKLENTYPE_UINT
+		#define RTPSOCKLENTYPE							unsigned int
+	#else
+		#define RTPSOCKLENTYPE							int
+	#endif // RTP_SOCKLENTYPE_UINT
+
+	#define RTPIOCTL								ioctl
+#endif // WIN32
+#ifdef RTPDEBUG
+	#include <iostream>
+#endif // RTPDEBUG
+
+#include "rtpdebug.h"
+
+#ifndef _WIN32_WCE
+	#define RTPUDPV4TRANS_RTPRECEIVEBUFFER							32768
+	#define RTPUDPV4TRANS_RTCPRECEIVEBUFFER							32768
+	#define RTPUDPV4TRANS_RTPTRANSMITBUFFER							32768
+	#define RTPUDPV4TRANS_RTCPTRANSMITBUFFER						32768
+	#define RTPUDPV4TRANS_MAXPACKSIZE							65535
+	#define RTPUDPV4TRANS_IFREQBUFSIZE							8192
+#else
+	#define RTPUDPV4TRANS_RTPRECEIVEBUFFER							2048
+	#define RTPUDPV4TRANS_RTCPRECEIVEBUFFER							2048
+	#define RTPUDPV4TRANS_RTPTRANSMITBUFFER							2048
+	#define RTPUDPV4TRANS_RTCPTRANSMITBUFFER						2048
+	#define RTPUDPV4TRANS_MAXPACKSIZE							2048
+	#define RTPUDPV4TRANS_IFREQBUFSIZE							2048
+#endif // _WIN32_WCE
+
+#define RTPUDPV4TRANS_IS_MCASTADDR(x)							(((x)&0xF0000000) == 0xE0000000)
+
+#define RTPUDPV4TRANS_MCASTMEMBERSHIP(socket,type,mcastip,status)	{\
+										struct ip_mreq mreq;\
+										\
+										mreq.imr_multiaddr.s_addr = htonl(mcastip);\
+										mreq.imr_interface.s_addr = htonl(bindIP);\
+										status = setsockopt(socket,IPPROTO_IP,type,(const char *)&mreq,sizeof(struct ip_mreq));\
+									}
+#ifndef RTP_SUPPORT_INLINETEMPLATEPARAM
+	int RTPUDPv4Trans_GetHashIndex_IPv4Dest(const RTPIPv4Destination &d)				{ return d.GetIP_HBO()%RTPUDPV4TRANS_HASHSIZE; }
+	int RTPUDPv4Trans_GetHashIndex_u_int32_t(const u_int32_t &k)					{ return k%RTPUDPV4TRANS_HASHSIZE; }
+#endif // !RTP_SUPPORT_INLINETEMPLATEPARAM
+	
+#ifdef RTP_SUPPORT_THREAD
+	#define MAINMUTEX_LOCK 		{ if (threadsafe) mainmutex.Lock(); }
+	#define MAINMUTEX_UNLOCK	{ if (threadsafe) mainmutex.Unlock(); }
+	#define WAITMUTEX_LOCK		{ if (threadsafe) waitmutex.Lock(); }
+	#define WAITMUTEX_UNLOCK	{ if (threadsafe) waitmutex.Unlock(); }
+#else
+	#define MAINMUTEX_LOCK
+	#define MAINMUTEX_UNLOCK
+	#define WAITMUTEX_LOCK
+	#define WAITMUTEX_UNLOCK
+#endif // RTP_SUPPORT_THREAD
+
+RTPUDPv4Transmitter::RTPUDPv4Transmitter()
+{
+	created = false;
+	init = false;
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	timeinit.Dummy();
+#endif // WIN32 || _WIN32_WCE
+}
+
+RTPUDPv4Transmitter::~RTPUDPv4Transmitter()
+{
+	Destroy();
+}
+
+int RTPUDPv4Transmitter::Init(bool tsafe)
+{
+	if (init)
+		return ERR_RTP_UDPV4TRANS_ALREADYINIT;
+	
+#ifdef RTP_SUPPORT_THREAD
+	threadsafe = tsafe;
+	if (threadsafe)
+	{
+		int status;
+		
+		status = mainmutex.Init();
+		if (status < 0)
+			return ERR_RTP_UDPV4TRANS_CANTINITMUTEX;
+		status = waitmutex.Init();
+		if (status < 0)
+			return ERR_RTP_UDPV4TRANS_CANTINITMUTEX;
+	}
+#else
+	if (tsafe)
+		return ERR_RTP_NOTHREADSUPPORT;
+#endif // RTP_SUPPORT_THREAD
+
+	init = true;
+	return 0;
+}
+
+int RTPUDPv4Transmitter::Create(size_t maximumpacketsize,const RTPTransmissionParams *transparams)
+{
+	const RTPUDPv4TransmissionParams *params,defaultparams;
+	struct sockaddr_in addr;
+	RTPSOCKLENTYPE size;
+	int status;
+
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+
+	if (created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_ALREADYCREATED;
+	}
+	
+	// Obtain transmission parameters
+	
+	if (transparams == 0)
+		params = &defaultparams;
+	else
+	{
+		if (transparams->GetTransmissionProtocol() != RTPTransmitter::IPv4UDPProto)
+		{
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_UDPV4TRANS_ILLEGALPARAMETERS;
+		}
+		params = (const RTPUDPv4TransmissionParams *)transparams;
+	}
+
+	// Check if portbase is even
+	if (params->GetPortbase()%2 != 0)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_PORTBASENOTEVEN;
+	}
+
+	// create sockets
+	
+	rtpsock = socket(PF_INET,SOCK_DGRAM,0);
+	if (rtpsock == RTPSOCKERR)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_CANTCREATESOCKET;
+	}
+	rtcpsock = socket(PF_INET,SOCK_DGRAM,0);
+	if (rtcpsock == RTPSOCKERR)
+	{
+		RTPCLOSE(rtpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_CANTCREATESOCKET;
+	}
+
+	// set socket buffer sizes
+	
+	size = RTPUDPV4TRANS_RTPRECEIVEBUFFER;
+	if (setsockopt(rtpsock,SOL_SOCKET,SO_RCVBUF,(const char *)&size,sizeof(int)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_CANTSETRTPRECEIVEBUF;
+	}
+	size = RTPUDPV4TRANS_RTPTRANSMITBUFFER;
+	if (setsockopt(rtpsock,SOL_SOCKET,SO_SNDBUF,(const char *)&size,sizeof(int)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_CANTSETRTPTRANSMITBUF;
+	}
+	size = RTPUDPV4TRANS_RTCPRECEIVEBUFFER;
+	if (setsockopt(rtcpsock,SOL_SOCKET,SO_RCVBUF,(const char *)&size,sizeof(int)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_CANTSETRTCPRECEIVEBUF;
+	}
+	size = RTPUDPV4TRANS_RTCPTRANSMITBUFFER;
+	if (setsockopt(rtcpsock,SOL_SOCKET,SO_SNDBUF,(const char *)&size,sizeof(int)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_CANTSETRTCPTRANSMITBUF;
+	}
+	
+	// bind sockets
+
+	bindIP = params->GetBindIP();
+	
+	memset(&addr,0,sizeof(struct sockaddr_in));
+	addr.sin_family = AF_INET;
+	addr.sin_port = htons(params->GetPortbase());
+	addr.sin_addr.s_addr = htonl(bindIP);
+	if (bind(rtpsock,(struct sockaddr *)&addr,sizeof(struct sockaddr_in)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_CANTBINDRTPSOCKET;
+	}
+	memset(&addr,0,sizeof(struct sockaddr_in));
+	addr.sin_family = AF_INET;
+	addr.sin_port = htons(params->GetPortbase()+1);
+	addr.sin_addr.s_addr = htonl(bindIP);
+	if (bind(rtcpsock,(struct sockaddr *)&addr,sizeof(struct sockaddr_in)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_CANTBINDRTCPSOCKET;
+	}
+
+	// Try to obtain local IP addresses
+
+	localIPs = params->GetLocalIPList();
+	if (localIPs.empty()) // User did not provide list of local IP addresses, calculate them
+	{
+		int status;
+		
+		if ((status = CreateLocalIPList()) < 0)
+		{
+			RTPCLOSE(rtpsock);
+			RTPCLOSE(rtcpsock);
+			MAINMUTEX_UNLOCK
+			return status;
+		}
+#ifdef RTPDEBUG
+		std::cout << "Found these local IP addresses:" << std::endl;
+		
+		std::list<u_int32_t>::const_iterator it;
+
+		for (it = localIPs.begin() ; it != localIPs.end() ; it++)
+		{
+			RTPIPv4Address a(*it);
+
+			std::cout << a.GetAddressString() << std::endl;
+		}
+#endif // RTPDEBUG
+	}
+
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+	if (SetMulticastTTL(params->GetMulticastTTL()))
+		supportsmulticasting = true;
+	else
+		supportsmulticasting = false;
+#else // no multicast support enabled
+	supportsmulticasting = false;
+#endif // RTP_SUPPORT_IPV4MULTICAST
+
+	if ((status = CreateAbortDescriptors()) < 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return status;
+	}
+	
+	if (maximumpacketsize > RTPUDPV4TRANS_MAXPACKSIZE)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		DestroyAbortDescriptors();
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_SPECIFIEDSIZETOOBIG;
+	}
+	
+	maxpacksize = maximumpacketsize;
+	portbase = params->GetPortbase();
+	multicastTTL = params->GetMulticastTTL();
+	receivemode = RTPTransmitter::AcceptAll;
+
+	localhostname = 0;
+	localhostnamelength = 0;
+
+	rtppackcount = 0;
+	rtcppackcount = 0;
+	
+	waitingfordata = false;
+	created = true;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+void RTPUDPv4Transmitter::Destroy()
+{
+	if (!init)
+		return;
+
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK;
+		return;
+	}
+
+	if (localhostname)
+	{
+		delete [] localhostname;
+		localhostname = 0;
+		localhostnamelength = 0;
+	}
+	
+	RTPCLOSE(rtpsock);
+	RTPCLOSE(rtcpsock);
+	destinations.Clear();
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+	multicastgroups.Clear();
+#endif // RTP_SUPPORT_IPV4MULTICAST
+	FlushPackets();
+	ClearAcceptIgnoreInfo();
+	localIPs.clear();
+	created = false;
+	
+	if (waitingfordata)
+	{
+		AbortWaitInternal();
+		DestroyAbortDescriptors();
+		MAINMUTEX_UNLOCK
+		WAITMUTEX_LOCK // to make sure that the WaitForIncomingData function ended
+		WAITMUTEX_UNLOCK
+	}
+	else
+		DestroyAbortDescriptors();
+
+	MAINMUTEX_UNLOCK
+}
+
+RTPTransmissionInfo *RTPUDPv4Transmitter::GetTransmissionInfo()
+{
+	if (!init)
+		return 0;
+
+	MAINMUTEX_LOCK
+	RTPTransmissionInfo *tinf = new RTPUDPv4TransmissionInfo(localIPs,rtpsock,rtcpsock);
+	MAINMUTEX_UNLOCK
+	return tinf;
+}
+
+int RTPUDPv4Transmitter::GetLocalHostName(u_int8_t *buffer,size_t *bufferlength)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+
+	if (localhostname == 0)
+	{
+		if (localIPs.empty())
+		{
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_UDPV4TRANS_NOLOCALIPS;
+		}
+		
+		std::list<u_int32_t>::const_iterator it;
+		std::list<std::string> hostnames;
+	
+		for (it = localIPs.begin() ; it != localIPs.end() ; it++)
+		{
+			struct hostent *he;
+			u_int8_t addr[4];
+			u_int32_t ip = (*it);
+	
+			addr[0] = (u_int8_t)((ip>>24)&0xFF);
+			addr[1] = (u_int8_t)((ip>>16)&0xFF);
+			addr[2] = (u_int8_t)((ip>>8)&0xFF);
+			addr[3] = (u_int8_t)(ip&0xFF);
+			he = gethostbyaddr((char *)addr,4,AF_INET);
+			if (he != 0)
+			{
+				std::string hname = std::string(he->h_name);
+				hostnames.push_back(hname);
+			}
+		}
+	
+		bool found  = false;
+		
+		if (!hostnames.empty())	// try to select the most appropriate hostname
+		{
+			std::list<std::string>::const_iterator it;
+			
+			for (it = hostnames.begin() ; !found && it != hostnames.end() ; it++)
+			{
+				if ((*it).find('.') != std::string::npos)
+				{
+					found = true;
+					localhostnamelength = (*it).length();
+					localhostname = new u_int8_t [localhostnamelength+1];
+					if (localhostname == 0)
+					{
+						MAINMUTEX_UNLOCK
+						return ERR_RTP_OUTOFMEM;
+					}
+					memcpy(localhostname,(*it).c_str(),localhostnamelength);
+					localhostname[localhostnamelength] = 0;
+				}
+			}
+		}
+	
+		if (!found) // use an IP address
+		{
+			u_int32_t ip;
+			int len;
+			char str[256];
+			
+			it = localIPs.begin();
+			ip = (*it);
+			
+			sprintf(str,"%d.%d.%d.%d",(int)((ip>>24)&0xFF),(int)((ip>>16)&0xFF),(int)((ip>>8)&0xFF),(int)(ip&0xFF));
+			len = strlen(str);
+	
+			localhostnamelength = len;
+			localhostname = new u_int8_t [localhostnamelength + 1];
+			if (localhostname == 0)
+			{
+				MAINMUTEX_UNLOCK
+				return ERR_RTP_OUTOFMEM;
+			}
+			memcpy(localhostname,str,localhostnamelength);
+			localhostname[localhostnamelength] = 0;
+		}
+	}
+	
+	if ((*bufferlength) < localhostnamelength)
+	{
+		*bufferlength = localhostnamelength; // tell the application the required size of the buffer
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_TRANS_BUFFERLENGTHTOOSMALL;
+	}
+
+	memcpy(buffer,localhostname,localhostnamelength);
+	*bufferlength = localhostnamelength;
+	
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+bool RTPUDPv4Transmitter::ComesFromThisTransmitter(const RTPAddress *addr)
+{
+	if (!init)
+		return false;
+
+	if (addr == 0)
+		return false;
+	
+	MAINMUTEX_LOCK
+	
+	bool v;
+		
+	if (created && addr->GetAddressType() == RTPAddress::IPv4Address)
+	{	
+		const RTPIPv4Address *addr2 = (const RTPIPv4Address *)addr;
+		bool found = false;
+		std::list<u_int32_t>::const_iterator it;
+	
+		it = localIPs.begin();
+		while (!found && it != localIPs.end())
+		{
+			if (addr2->GetIP() == *it)
+				found = true;
+			else
+				++it;
+		}
+	
+		if (!found)
+			v = false;
+		else
+		{
+			if (addr2->GetPort() == portbase) // check for RTP port
+				v = true;
+			else if (addr2->GetPort() == (portbase+1)) // check for RTCP port
+				v = true;
+			else 
+				v = false;
+		}
+	}
+	else
+		v = false;
+
+	MAINMUTEX_UNLOCK
+	return v;
+}
+
+int RTPUDPv4Transmitter::Poll()
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+
+	int status;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	status = PollSocket(true); // poll RTP socket
+	if (status >= 0)
+		status = PollSocket(false); // poll RTCP socket
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPUDPv4Transmitter::WaitForIncomingData(const RTPTime &delay,bool *dataavailable)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	fd_set fdset;
+	struct timeval tv;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (waitingfordata)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_ALREADYWAITING;
+	}
+	
+	FD_ZERO(&fdset);
+	FD_SET(rtpsock,&fdset);
+	FD_SET(rtcpsock,&fdset);
+	FD_SET(abortdesc[0],&fdset);
+	tv.tv_sec = delay.GetSeconds();
+	tv.tv_usec = delay.GetMicroSeconds();
+	
+	waitingfordata = true;
+	
+	WAITMUTEX_LOCK
+	MAINMUTEX_UNLOCK
+
+	if (select(FD_SETSIZE,&fdset,0,0,&tv) < 0)
+	{
+		MAINMUTEX_LOCK
+		waitingfordata = false;
+		MAINMUTEX_UNLOCK
+		WAITMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_ERRORINSELECT;
+	}
+	
+	MAINMUTEX_LOCK
+	waitingfordata = false;
+	if (!created) // destroy called
+	{
+		MAINMUTEX_UNLOCK;
+		WAITMUTEX_UNLOCK
+		return 0;
+	}
+		
+	// if aborted, read from abort buffer
+	if (FD_ISSET(abortdesc[0],&fdset))
+	{
+#if (defined(WIN32) || defined(_WIN32_WCE))
+		char buf[1];
+		
+		recv(abortdesc[0],buf,1,0);
+#else 
+		unsigned char buf[1];
+
+		read(abortdesc[0],buf,1);
+#endif // WIN32
+	}
+
+	if (dataavailable != 0)
+	{
+		if (FD_ISSET(rtpsock,&fdset) || FD_ISSET(rtcpsock,&fdset))
+			*dataavailable = true;
+		else
+			*dataavailable = false;
+	}	
+	
+	MAINMUTEX_UNLOCK
+	WAITMUTEX_UNLOCK
+	return 0;
+}
+
+int RTPUDPv4Transmitter::AbortWait()
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (!waitingfordata)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTWAITING;
+	}
+
+	AbortWaitInternal();
+	
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+int RTPUDPv4Transmitter::SendRTPData(const void *data,size_t len)	
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	struct sockaddr_in saddr;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (len > maxpacksize)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_SPECIFIEDSIZETOOBIG;
+	}
+	
+	memset(&saddr,0,sizeof(struct sockaddr_in));
+	saddr.sin_family = AF_INET;
+	destinations.GotoFirstElement();
+	while (destinations.HasCurrentElement())
+	{
+		saddr.sin_port = destinations.GetCurrentElement().GetRTPPort_NBO();
+		saddr.sin_addr.s_addr = destinations.GetCurrentElement().GetIP_NBO();
+		sendto(rtpsock,(const char *)data,len,0,(struct sockaddr *)&saddr,sizeof(struct sockaddr_in));
+		destinations.GotoNextElement();
+	}
+	
+	rtppackcount++;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+int RTPUDPv4Transmitter::SendRTCPData(const void *data,size_t len)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	struct sockaddr_in saddr;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (len > maxpacksize)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_SPECIFIEDSIZETOOBIG;
+	}
+	
+	memset(&saddr,0,sizeof(struct sockaddr_in));
+	saddr.sin_family = AF_INET;
+	destinations.GotoFirstElement();
+	while (destinations.HasCurrentElement())
+	{
+		saddr.sin_port = destinations.GetCurrentElement().GetRTCPPort_NBO();
+		saddr.sin_addr.s_addr = destinations.GetCurrentElement().GetIP_NBO();
+		sendto(rtcpsock,(const char *)data,len,0,(struct sockaddr *)&saddr,sizeof(struct sockaddr_in));
+		destinations.GotoNextElement();
+	}
+	
+	rtcppackcount++;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+void RTPUDPv4Transmitter::ResetPacketCount()
+{
+	if (!init)
+		return;
+
+	MAINMUTEX_LOCK
+	if (created)
+	{
+		rtppackcount = 0;
+		rtcppackcount = 0;	
+	}
+	MAINMUTEX_UNLOCK	
+}
+
+u_int32_t RTPUDPv4Transmitter::GetNumRTPPacketsSent()
+{
+	if (!init)
+		return 0;
+
+	MAINMUTEX_LOCK
+	
+	u_int32_t num;
+
+	if (!created)
+		num = 0;
+	else
+		num = rtppackcount;
+
+	MAINMUTEX_UNLOCK
+
+	return num;
+}
+
+u_int32_t RTPUDPv4Transmitter::GetNumRTCPPacketsSent()
+{
+	if (!init)
+		return 0;
+	
+	MAINMUTEX_LOCK
+	
+	u_int32_t num;
+
+	if (!created)
+		num = 0;
+	else
+		num = rtcppackcount;
+
+	MAINMUTEX_UNLOCK
+
+	return num;
+}
+	
+int RTPUDPv4Transmitter::AddDestination(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	RTPIPv4Address &address = (RTPIPv4Address &)addr;
+	RTPIPv4Destination dest(address.GetIP(),address.GetPort());
+	int status = destinations.AddElement(dest);
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPUDPv4Transmitter::DeleteDestination(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	RTPIPv4Address &address = (RTPIPv4Address &)addr;	
+	RTPIPv4Destination dest(address.GetIP(),address.GetPort());
+	int status = destinations.DeleteElement(dest);
+	
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPUDPv4Transmitter::ClearDestinations()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created)
+		destinations.Clear();
+	MAINMUTEX_UNLOCK
+}
+
+bool RTPUDPv4Transmitter::SupportsMulticasting()
+{
+	if (!init)
+		return false;
+	
+	MAINMUTEX_LOCK
+	
+	bool v;
+		
+	if (!created)
+		v = false;
+	else
+		v = supportsmulticasting;
+
+	MAINMUTEX_UNLOCK
+	return v;
+}
+
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+
+int RTPUDPv4Transmitter::JoinMulticastGroup(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	const RTPIPv4Address &address = (const RTPIPv4Address &)addr;
+	u_int32_t mcastIP = address.GetIP();
+	
+	if (!RTPUDPV4TRANS_IS_MCASTADDR(mcastIP))
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTAMULTICASTADDRESS;
+	}
+	
+	status = multicastgroups.AddElement(mcastIP);
+	if (status >= 0)
+	{
+		RTPUDPV4TRANS_MCASTMEMBERSHIP(rtpsock,IP_ADD_MEMBERSHIP,mcastIP,status);
+		if (status != 0)
+		{
+			multicastgroups.DeleteElement(mcastIP);
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_UDPV4TRANS_COULDNTJOINMULTICASTGROUP;
+		}
+		RTPUDPV4TRANS_MCASTMEMBERSHIP(rtcpsock,IP_ADD_MEMBERSHIP,mcastIP,status);
+		if (status != 0)
+		{
+			RTPUDPV4TRANS_MCASTMEMBERSHIP(rtpsock,IP_DROP_MEMBERSHIP,mcastIP,status);
+			multicastgroups.DeleteElement(mcastIP);
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_UDPV4TRANS_COULDNTJOINMULTICASTGROUP;
+		}
+	}
+	MAINMUTEX_UNLOCK	
+	return status;
+}
+
+int RTPUDPv4Transmitter::LeaveMulticastGroup(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	const RTPIPv4Address &address = (const RTPIPv4Address &)addr;
+	u_int32_t mcastIP = address.GetIP();
+	
+	if (!RTPUDPV4TRANS_IS_MCASTADDR(mcastIP))
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTAMULTICASTADDRESS;
+	}
+	
+	status = multicastgroups.DeleteElement(mcastIP);
+	if (status >= 0)
+	{	
+		RTPUDPV4TRANS_MCASTMEMBERSHIP(rtpsock,IP_DROP_MEMBERSHIP,mcastIP,status);
+		RTPUDPV4TRANS_MCASTMEMBERSHIP(rtcpsock,IP_DROP_MEMBERSHIP,mcastIP,status);
+		status = 0;
+	}
+	
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPUDPv4Transmitter::LeaveAllMulticastGroups()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created)
+	{
+		multicastgroups.GotoFirstElement();
+		while (multicastgroups.HasCurrentElement())
+		{
+			u_int32_t mcastIP;
+			int status = 0;
+
+			mcastIP = multicastgroups.GetCurrentElement();
+			RTPUDPV4TRANS_MCASTMEMBERSHIP(rtpsock,IP_DROP_MEMBERSHIP,mcastIP,status);
+			RTPUDPV4TRANS_MCASTMEMBERSHIP(rtcpsock,IP_DROP_MEMBERSHIP,mcastIP,status);
+			multicastgroups.GotoNextElement();
+		}
+		multicastgroups.Clear();
+	}
+	MAINMUTEX_UNLOCK
+}
+
+#else // no multicast support
+
+int RTPUDPv4Transmitter::JoinMulticastGroup(const RTPAddress &addr)
+{
+	return ERR_RTP_UDPV4TRANS_NOMULTICASTSUPPORT;
+}
+
+int RTPUDPv4Transmitter::LeaveMulticastGroup(const RTPAddress &addr)
+{
+	return ERR_RTP_UDPV4TRANS_NOMULTICASTSUPPORT;
+}
+
+void RTPUDPv4Transmitter::LeaveAllMulticastGroups()
+{
+}
+
+#endif // RTP_SUPPORT_IPV4MULTICAST
+
+int RTPUDPv4Transmitter::SetReceiveMode(RTPTransmitter::ReceiveMode m)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (m != receivemode)
+	{
+		receivemode = m;
+		acceptignoreinfo.Clear();
+	}
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+int RTPUDPv4Transmitter::AddToIgnoreList(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	int status;
+
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::IgnoreSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv4Address &address = (const RTPIPv4Address &)addr;
+	status = ProcessAddAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+	
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPUDPv4Transmitter::DeleteFromIgnoreList(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::IgnoreSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv4Address &address = (const RTPIPv4Address &)addr;	
+	status = ProcessDeleteAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPUDPv4Transmitter::ClearIgnoreList()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created && receivemode == RTPTransmitter::IgnoreSome)
+		ClearAcceptIgnoreInfo();
+	MAINMUTEX_UNLOCK
+}
+
+int RTPUDPv4Transmitter::AddToAcceptList(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::AcceptSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv4Address &address = (const RTPIPv4Address &)addr;
+	status = ProcessAddAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPUDPv4Transmitter::DeleteFromAcceptList(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv4Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::AcceptSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv4Address &address = (const RTPIPv4Address &)addr;
+	status = ProcessDeleteAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPUDPv4Transmitter::ClearAcceptList()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created && receivemode == RTPTransmitter::AcceptSome)
+		ClearAcceptIgnoreInfo();
+	MAINMUTEX_UNLOCK
+}
+
+int RTPUDPv4Transmitter::SetMaximumPacketSize(size_t s)	
+{
+	if (!init)
+		return ERR_RTP_UDPV4TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_NOTCREATED;
+	}
+	if (s > RTPUDPV4TRANS_MAXPACKSIZE)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV4TRANS_SPECIFIEDSIZETOOBIG;
+	}
+	maxpacksize = s;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+bool RTPUDPv4Transmitter::NewDataAvailable()
+{
+	if (!init)
+		return false;
+	
+	MAINMUTEX_LOCK
+	
+	bool v;
+		
+	if (!created)
+		v = false;
+	else
+	{
+		if (rawpacketlist.empty())
+			v = false;
+		else
+			v = true;
+	}
+	
+	MAINMUTEX_UNLOCK
+	return v;
+}
+
+RTPRawPacket *RTPUDPv4Transmitter::GetNextPacket()
+{
+	if (!init)
+		return 0;
+	
+	MAINMUTEX_LOCK
+	
+	RTPRawPacket *p;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return 0;
+	}
+	if (rawpacketlist.empty())
+	{
+		MAINMUTEX_UNLOCK
+		return 0;
+	}
+
+	p = *(rawpacketlist.begin());
+	rawpacketlist.pop_front();
+
+	MAINMUTEX_UNLOCK
+	return p;
+}
+
+// Here the private functions start...
+
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+bool RTPUDPv4Transmitter::SetMulticastTTL(u_int8_t ttl)
+{
+	int ttl2,status;
+
+	ttl2 = (int)ttl;
+	status = setsockopt(rtpsock,IPPROTO_IP,IP_MULTICAST_TTL,(const char *)&ttl2,sizeof(int));
+	if (status != 0)
+		return false;
+	status = setsockopt(rtcpsock,IPPROTO_IP,IP_MULTICAST_TTL,(const char *)&ttl2,sizeof(int));
+	if (status != 0)
+		return false;
+	return true;
+}
+#endif // RTP_SUPPORT_IPV4MULTICAST
+
+void RTPUDPv4Transmitter::FlushPackets()
+{
+	std::list<RTPRawPacket*>::const_iterator it;
+
+	for (it = rawpacketlist.begin() ; it != rawpacketlist.end() ; ++it)
+		delete (*it);
+	rawpacketlist.clear();
+}
+
+int RTPUDPv4Transmitter::PollSocket(bool rtp)
+{
+	RTPSOCKLENTYPE fromlen;
+	int recvlen;
+	char packetbuffer[RTPUDPV4TRANS_MAXPACKSIZE];
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	SOCKET sock;
+	unsigned long len;
+#else 
+	size_t len;
+	int sock;
+#endif // WIN32
+	struct sockaddr_in srcaddr;
+	
+	if (rtp)
+		sock = rtpsock;
+	else
+		sock = rtcpsock;
+	
+	len = 0;
+	RTPIOCTL(sock,FIONREAD,&len);
+	if (len <= 0)
+		return 0;
+
+	while (len > 0)
+	{
+		RTPTime curtime = RTPTime::CurrentTime();
+		fromlen = sizeof(struct sockaddr_in);
+		recvlen = recvfrom(sock,packetbuffer,(int)len,0,(struct sockaddr *)&srcaddr,&fromlen);
+		if (recvlen > 0)
+		{
+			bool acceptdata;
+
+			// got data, process it
+			if (receivemode == RTPTransmitter::AcceptAll)
+				acceptdata = true;
+			else
+				acceptdata = ShouldAcceptData(ntohl(srcaddr.sin_addr.s_addr),htons(srcaddr.sin_port));
+			
+			if (acceptdata)
+			{
+				RTPRawPacket *pack;
+				RTPIPv4Address *addr;
+				u_int8_t *datacopy;
+
+				addr = new RTPIPv4Address(ntohl(srcaddr.sin_addr.s_addr),ntohs(srcaddr.sin_port));
+				if (addr == 0)
+					return ERR_RTP_OUTOFMEM;
+				datacopy = new u_int8_t[recvlen];
+				if (datacopy == 0)
+				{
+					delete addr;
+					return ERR_RTP_OUTOFMEM;
+				}
+				memcpy(datacopy,packetbuffer,recvlen);
+				pack = new RTPRawPacket(datacopy,recvlen,addr,curtime,rtp);
+
+				if (pack == 0)
+				{
+					delete addr;
+					delete [] datacopy;
+					return ERR_RTP_OUTOFMEM;
+				}
+				rawpacketlist.push_back(pack);	
+			}
+		}
+		len = 0;
+		RTPIOCTL(sock,FIONREAD,&len);
+	}
+	return 0;
+}
+
+int RTPUDPv4Transmitter::ProcessAddAcceptIgnoreEntry(u_int32_t ip,u_int16_t port)
+{
+	acceptignoreinfo.GotoElement(ip);
+	if (acceptignoreinfo.HasCurrentElement()) // An entry for this IP address already exists
+	{
+		PortInfo *portinf = acceptignoreinfo.GetCurrentElement();
+		
+		if (port == 0) // select all ports
+		{
+			portinf->all = true;
+			portinf->portlist.clear();
+		}
+		else if (!portinf->all)
+		{
+			std::list<u_int16_t>::const_iterator it,begin,end;
+
+			begin = portinf->portlist.begin();
+			end = portinf->portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == port) // already in list
+					return 0;
+			}
+			portinf->portlist.push_front(port);
+		}
+	}
+	else // got to create an entry for this IP address
+	{
+		PortInfo *portinf;
+		int status;
+		
+		portinf = new PortInfo();
+		if (port == 0) // select all ports
+			portinf->all = true;
+		else
+			portinf->portlist.push_front(port);
+		
+		status = acceptignoreinfo.AddElement(ip,portinf);
+		if (status < 0)
+		{
+			delete portinf;
+			return status;
+		}
+	}
+
+	return 0;
+}
+
+void RTPUDPv4Transmitter::ClearAcceptIgnoreInfo()
+{
+	acceptignoreinfo.GotoFirstElement();
+	while (acceptignoreinfo.HasCurrentElement())
+	{
+		PortInfo *inf;
+
+		inf = acceptignoreinfo.GetCurrentElement();
+		delete inf;
+		acceptignoreinfo.GotoNextElement();
+	}
+	acceptignoreinfo.Clear();
+}
+	
+int RTPUDPv4Transmitter::ProcessDeleteAcceptIgnoreEntry(u_int32_t ip,u_int16_t port)
+{
+	acceptignoreinfo.GotoElement(ip);
+	if (!acceptignoreinfo.HasCurrentElement())
+		return ERR_RTP_UDPV4TRANS_NOSUCHENTRY;
+	
+	PortInfo *inf;
+
+	inf = acceptignoreinfo.GetCurrentElement();
+	if (port == 0) // delete all entries
+	{
+		inf->all = false;
+		inf->portlist.clear();
+	}
+	else // a specific port was selected
+	{
+		if (inf->all) // currently, all ports are selected. Add the one to remove to the list
+		{
+			// we have to check if the list doesn't contain the port already
+			std::list<u_int16_t>::const_iterator it,begin,end;
+
+			begin = inf->portlist.begin();
+			end = inf->portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == port) // already in list: this means we already deleted the entry
+					return ERR_RTP_UDPV4TRANS_NOSUCHENTRY;
+			}
+			inf->portlist.push_front(port);
+		}
+		else // check if we can find the port in the list
+		{
+			std::list<u_int16_t>::iterator it,begin,end;
+			
+			begin = inf->portlist.begin();
+			end = inf->portlist.end();
+			for (it = begin ; it != end ; ++it)
+			{
+				if (*it == port) // found it!
+				{
+					inf->portlist.erase(it);
+					return 0;
+				}
+			}
+			// didn't find it
+			return ERR_RTP_UDPV4TRANS_NOSUCHENTRY;			
+		}
+	}
+	return 0;
+}
+
+bool RTPUDPv4Transmitter::ShouldAcceptData(u_int32_t srcip,u_int16_t srcport)
+{
+	if (receivemode == RTPTransmitter::AcceptSome)
+	{
+		PortInfo *inf;
+
+		acceptignoreinfo.GotoElement(srcip);
+		if (!acceptignoreinfo.HasCurrentElement())
+			return false;
+		
+		inf = acceptignoreinfo.GetCurrentElement();
+		if (!inf->all) // only accept the ones in the list
+		{
+			std::list<u_int16_t>::const_iterator it,begin,end;
+
+			begin = inf->portlist.begin();
+			end = inf->portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return true;
+			}
+			return false;
+		}
+		else // accept all, except the ones in the list
+		{
+			std::list<u_int16_t>::const_iterator it,begin,end;
+
+			begin = inf->portlist.begin();
+			end = inf->portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return false;
+			}
+			return true;
+		}
+	}
+	else // IgnoreSome
+	{
+		PortInfo *inf;
+
+		acceptignoreinfo.GotoElement(srcip);
+		if (!acceptignoreinfo.HasCurrentElement())
+			return true;
+		
+		inf = acceptignoreinfo.GetCurrentElement();
+		if (!inf->all) // ignore the ports in the list
+		{
+			std::list<u_int16_t>::const_iterator it,begin,end;
+
+			begin = inf->portlist.begin();
+			end = inf->portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return false;
+			}
+			return true;
+		}
+		else // ignore all, except the ones in the list
+		{
+			std::list<u_int16_t>::const_iterator it,begin,end;
+
+			begin = inf->portlist.begin();
+			end = inf->portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return true;
+			}
+			return false;
+		}
+	}
+	return true;
+}
+
+#if (defined(WIN32) || defined(_WIN32_WCE))
+
+int RTPUDPv4Transmitter::CreateAbortDescriptors()
+{
+	SOCKET listensock;
+	int size;
+	struct sockaddr_in addr;
+
+	listensock = socket(PF_INET,SOCK_STREAM,0);
+	if (listensock == RTPSOCKERR)
+		return ERR_RTP_UDPV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	
+	memset(&addr,0,sizeof(struct sockaddr_in));
+	addr.sin_family = AF_INET;
+	if (bind(listensock,(struct sockaddr *)&addr,sizeof(struct sockaddr_in)) != 0)
+	{
+		RTPCLOSE(listensock);
+		return ERR_RTP_UDPV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&addr,0,sizeof(struct sockaddr_in));
+	size = sizeof(struct sockaddr_in);
+	if (getsockname(listensock,(struct sockaddr*)&addr,&size) != 0)
+	{
+		RTPCLOSE(listensock);
+		return ERR_RTP_UDPV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	unsigned short connectport = ntohs(addr.sin_port);
+
+	abortdesc[0] = socket(PF_INET,SOCK_STREAM,0);
+	if (abortdesc[0] == RTPSOCKERR)
+	{
+		RTPCLOSE(listensock);
+		return ERR_RTP_UDPV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&addr,0,sizeof(struct sockaddr_in));
+	addr.sin_family = AF_INET;
+	if (bind(abortdesc[0],(struct sockaddr *)&addr,sizeof(struct sockaddr_in)) != 0)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_UDPV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	if (listen(listensock,1) != 0)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_UDPV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&addr,0,sizeof(struct sockaddr_in));
+	addr.sin_family = AF_INET;
+	addr.sin_addr.s_addr = inet_addr("127.0.0.1");
+	addr.sin_port = htons(connectport);
+	
+	if (connect(abortdesc[0],(struct sockaddr *)&addr,sizeof(struct sockaddr_in)) != 0)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_UDPV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&addr,0,sizeof(struct sockaddr_in));
+	size = sizeof(struct sockaddr_in);
+	abortdesc[1] = accept(listensock,(struct sockaddr *)&addr,&size);
+	if (abortdesc[1] == RTPSOCKERR)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_UDPV4TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	// okay, got the connection, close the listening socket
+
+	RTPCLOSE(listensock);
+	return 0;
+}
+
+void RTPUDPv4Transmitter::DestroyAbortDescriptors()
+{
+	RTPCLOSE(abortdesc[0]);
+	RTPCLOSE(abortdesc[1]);
+}
+
+#else // in a non winsock environment we can use pipes
+
+int RTPUDPv4Transmitter::CreateAbortDescriptors()
+{
+	if (pipe(abortdesc) < 0)
+		return ERR_RTP_UDPV4TRANS_CANTCREATEPIPE;
+	return 0;
+}
+
+void RTPUDPv4Transmitter::DestroyAbortDescriptors()
+{
+	close(abortdesc[0]);
+	close(abortdesc[1]);
+}
+
+#endif // WIN32
+
+int RTPUDPv4Transmitter::CreateLocalIPList()
+{
+	 // first try to obtain the list from the network interface info
+
+	if (!GetLocalIPList_Interfaces())
+	{
+		// If this fails, we'll have to depend on DNS info
+		GetLocalIPList_DNS();
+	}
+	AddLoopbackAddress();
+	return 0;
+}
+
+#if (defined(WIN32) || defined(_WIN32_WCE))
+
+bool RTPUDPv4Transmitter::GetLocalIPList_Interfaces()
+{
+	unsigned char buffer[RTPUDPV4TRANS_IFREQBUFSIZE];
+	DWORD outputsize;
+	DWORD numaddresses,i;
+	SOCKET_ADDRESS_LIST *addrlist;
+
+	if (WSAIoctl(rtpsock,SIO_ADDRESS_LIST_QUERY,NULL,0,&buffer,RTPUDPV4TRANS_IFREQBUFSIZE,&outputsize,NULL,NULL))
+		return false;
+	
+	addrlist = (SOCKET_ADDRESS_LIST *)buffer;
+	numaddresses = addrlist->iAddressCount;
+	for (i = 0 ; i < numaddresses ; i++)
+	{
+		SOCKET_ADDRESS *sockaddr = &(addrlist->Address[i]);
+		if (sockaddr->iSockaddrLength == sizeof(struct sockaddr_in)) // IPv4 address
+		{
+			struct sockaddr_in *addr = (struct sockaddr_in *)sockaddr->lpSockaddr;
+
+			localIPs.push_back(ntohl(addr->sin_addr.s_addr));
+		}
+	}
+
+	if (localIPs.empty())
+		return false;
+
+	return true;
+}
+
+#else // use either getifaddrs or ioctl
+
+#ifdef RTP_SUPPORT_IFADDRS
+
+bool RTPUDPv4Transmitter::GetLocalIPList_Interfaces()
+{
+	struct ifaddrs *addrs,*tmp;
+	
+	getifaddrs(&addrs);
+	tmp = addrs;
+	
+	while (tmp != 0)
+	{
+		if (tmp->ifa_addr->sa_family == AF_INET)
+		{
+			struct sockaddr_in *inaddr = (struct sockaddr_in *)tmp->ifa_addr;
+			localIPs.push_back(ntohl(inaddr->sin_addr.s_addr));
+		}
+		tmp = tmp->ifa_next;
+	}
+	
+	freeifaddrs(addrs);
+	
+	if (localIPs.empty())
+		return false;
+	return true;
+}
+
+#else // user ioctl
+
+bool RTPUDPv4Transmitter::GetLocalIPList_Interfaces()
+{
+	int status;
+	char buffer[RTPUDPV4TRANS_IFREQBUFSIZE];
+	struct ifconf ifc;
+	struct ifreq *ifr;
+	struct sockaddr *sa;
+	char *startptr,*endptr;
+	int remlen;
+	
+	ifc.ifc_len = RTPUDPV4TRANS_IFREQBUFSIZE;
+	ifc.ifc_buf = buffer;
+	status = ioctl(rtpsock,SIOCGIFCONF,&ifc);
+	if (status < 0)
+		return false;
+	
+	startptr = (char *)ifc.ifc_req;
+	endptr = startptr + ifc.ifc_len;
+	remlen = ifc.ifc_len;
+	while((startptr < endptr) && remlen >= (int)sizeof(struct ifreq))
+	{
+		ifr = (struct ifreq *)startptr;
+		sa = &(ifr->ifr_addr);
+#ifdef RTP_HAVE_SOCKADDR_LEN
+		if (sa->sa_len <= sizeof(struct sockaddr))
+		{
+			if (sa->sa_len == sizeof(struct sockaddr_in) && sa->sa_family == PF_INET)
+			{
+				u_int32_t ip;
+				struct sockaddr_in *addr = (struct sockaddr_in *)sa;
+				
+				ip = ntohl(addr->sin_addr.s_addr);
+				localIPs.push_back(ip);
+			}
+			remlen -= sizeof(struct ifreq);
+			startptr += sizeof(struct ifreq);
+		}
+		else
+		{
+			int l = sa->sa_len-sizeof(struct sockaddr)+sizeof(struct ifreq);
+			
+			remlen -= l;
+			startptr += l;
+		}
+#else // don't have sa_len in struct sockaddr
+		if (sa->sa_family == PF_INET)
+		{
+			u_int32_t ip;
+			struct sockaddr_in *addr = (struct sockaddr_in *)sa;
+		
+			ip = ntohl(addr->sin_addr.s_addr);
+			localIPs.push_back(ip);
+		}
+		remlen -= sizeof(struct ifreq);
+		startptr += sizeof(struct ifreq);
+	
+#endif // RTP_HAVE_SOCKADDR_LEN
+	}
+
+	if (localIPs.empty())
+		return false;
+	return true;
+}
+
+#endif // RTP_SUPPORT_IFADDRS
+
+#endif // WIN32
+
+void RTPUDPv4Transmitter::GetLocalIPList_DNS()
+{
+	struct hostent *he;
+	char name[1024];
+	u_int32_t ip;
+	bool done;
+	int i,j;
+
+	gethostname(name,1023);
+	name[1023] = 0;
+	he = gethostbyname(name);
+	if (he == 0)
+		return;
+	
+	ip = 0;
+	i = 0;
+	done = false;
+	while (!done)
+	{
+		if (he->h_addr_list[i] == NULL)
+			done = true;
+		else
+		{
+			ip = 0;
+			for (j = 0 ; j < 4 ; j++)
+				ip |= ((u_int32_t)((unsigned char)he->h_addr_list[i][j])<<((3-j)*8));
+			localIPs.push_back(ip);
+			i++;
+		}
+	}
+}
+
+void RTPUDPv4Transmitter::AbortWaitInternal()
+{
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	send(abortdesc[1],"*",1,0);
+#else
+	write(abortdesc[1],"*",1);
+#endif // WIN32
+}
+
+void RTPUDPv4Transmitter::AddLoopbackAddress()
+{
+	u_int32_t loopbackaddr = (((u_int32_t)127)<<24)|((u_int32_t)1);
+	std::list<u_int32_t>::const_iterator it;
+	bool found = false;
+	
+	for (it = localIPs.begin() ; !found && it != localIPs.end() ; it++)
+	{
+		if (*it == loopbackaddr)
+			found = true;
+	}
+
+	if (!found)
+		localIPs.push_back(loopbackaddr);
+}
+
+#ifdef RTPDEBUG
+void RTPUDPv4Transmitter::Dump()
+{
+	if (!init)
+		std::cout << "Not initialized" << std::endl;
+	else
+	{
+		MAINMUTEX_LOCK
+	
+		if (!created)
+			std::cout << "Not created" << std::endl;
+		else
+		{
+			char str[1024];
+			u_int32_t ip;
+			std::list<u_int32_t>::const_iterator it;
+			
+			std::cout << "Portbase:                       " << portbase << std::endl;
+			std::cout << "RTP socket descriptor:          " << rtpsock << std::endl;
+			std::cout << "RTCP socket descriptor:         " << rtcpsock << std::endl;
+			ip = bindIP;
+			sprintf(str,"%d.%d.%d.%d",(int)((ip>>24)&0xFF),(int)((ip>>16)&0xFF),(int)((ip>>8)&0xFF),(int)(ip&0xFF));
+			std::cout << "Bind IP address:                " << str << std::endl;
+			std::cout << "Local IP addresses:" << std::endl;
+			for (it = localIPs.begin() ; it != localIPs.end() ; it++)
+			{
+				ip = (*it);
+				sprintf(str,"%d.%d.%d.%d",(int)((ip>>24)&0xFF),(int)((ip>>16)&0xFF),(int)((ip>>8)&0xFF),(int)(ip&0xFF));
+				std::cout << "    " << str << std::endl;
+			}
+			std::cout << "Multicast TTL:                  " << (int)multicastTTL << std::endl;
+			std::cout << "Receive mode:                   ";
+			switch (receivemode)
+			{
+			case RTPTransmitter::AcceptAll:
+				std::cout << "Accept all";
+				break;
+			case RTPTransmitter::AcceptSome:
+				std::cout << "Accept some";
+				break;
+			case RTPTransmitter::IgnoreSome:
+				std::cout << "Ignore some";
+			}
+			std::cout << std::endl;
+			if (receivemode != RTPTransmitter::AcceptAll)
+			{
+				acceptignoreinfo.GotoFirstElement();
+				while(acceptignoreinfo.HasCurrentElement())
+				{
+					ip = acceptignoreinfo.GetCurrentKey();
+					sprintf(str,"%d.%d.%d.%d",(int)((ip>>24)&0xFF),(int)((ip>>16)&0xFF),(int)((ip>>8)&0xFF),(int)(ip&0xFF));
+					PortInfo *pinfo = acceptignoreinfo.GetCurrentElement();
+					std::cout << "    " << str << ": ";
+					if (pinfo->all)
+					{
+						std::cout << "All ports";
+						if (!pinfo->portlist.empty())
+							std::cout << ", except ";
+					}
+					
+					std::list<u_int16_t>::const_iterator it;
+					
+					for (it = pinfo->portlist.begin() ; it != pinfo->portlist.end() ; )
+					{
+						std::cout << (*it);
+						it++;
+						if (it != pinfo->portlist.end())
+							std::cout << ", ";
+					}
+					std::cout << std::endl;
+				}
+			}
+			
+			std::cout << "Local host name:                ";
+			if (localhostname == 0)
+				std::cout << "Not set";
+			else
+				std::cout << localhostname;
+			std::cout << std::endl;
+
+			std::cout << "List of destinations:           ";
+			destinations.GotoFirstElement();
+			if (destinations.HasCurrentElement())
+			{
+				std::cout << std::endl;
+				do
+				{
+					std::cout << "    " << destinations.GetCurrentElement().GetDestinationString() << std::endl;
+					destinations.GotoNextElement();
+				} while (destinations.HasCurrentElement());
+			}
+			else
+				std::cout << "Empty" << std::endl;
+		
+			std::cout << "Supports multicasting:          " << ((supportsmulticasting)?"Yes":"No") << std::endl;
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+			std::cout << "List of multicast groups:       ";
+			multicastgroups.GotoFirstElement();
+			if (multicastgroups.HasCurrentElement())
+			{
+				std::cout << std::endl;
+				do
+				{
+					ip = multicastgroups.GetCurrentElement();
+					sprintf(str,"%d.%d.%d.%d",(int)((ip>>24)&0xFF),(int)((ip>>16)&0xFF),(int)((ip>>8)&0xFF),(int)(ip&0xFF));
+					std::cout << "    " << str << std::endl;
+					multicastgroups.GotoNextElement();
+				} while (multicastgroups.HasCurrentElement());
+			}
+			else
+				std::cout << "Empty" << std::endl;
+#endif // RTP_SUPPORT_IPV4MULTICAST
+			
+			std::cout << "Number of raw packets in queue: " << rawpacketlist.size() << std::endl;
+			std::cout << "Maximum allowed packet size:    " << maxpacksize << std::endl;
+			std::cout << "RTP packet count:               " << rtppackcount << std::endl;
+			std::cout << "RTCP packet count:              " << rtcppackcount << std::endl;
+		}
+		
+		MAINMUTEX_UNLOCK
+	}
+}
+#endif // RTPDEBUG
+

Added: konference/src/rtp/jrtplib/rtpudpv4transmitter.h
===================================================================
--- konference/src/rtp/jrtplib/rtpudpv4transmitter.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpudpv4transmitter.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,228 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPUDPV4TRANSMITTER_H
+
+#define RTPUDPV4TRANSMITTER_H
+
+#include "rtpconfig.h"
+#include "rtptransmitter.h"
+#include "rtpipv4destination.h"
+#include "rtphashtable.h"
+#include "rtpkeyhashtable.h"
+#include <list>
+
+#ifdef RTP_SUPPORT_THREAD
+	#include <jmutex.h>
+#endif // RTP_SUPPORT_THREAD
+
+#define RTPUDPV4TRANS_HASHSIZE									8317
+#define RTPUDPV4TRANS_DEFAULTPORTBASE								5000
+
+class RTPUDPv4TransmissionParams : public RTPTransmissionParams
+{
+public:
+	RTPUDPv4TransmissionParams():RTPTransmissionParams(RTPTransmitter::IPv4UDPProto)	{ portbase = RTPUDPV4TRANS_DEFAULTPORTBASE; bindIP = 0; multicastTTL = 1; }
+	void SetBindIP(u_int32_t ip)								{ bindIP = ip; }
+	void SetPortbase(u_int16_t pbase)							{ portbase = pbase; }
+	void SetMulticastTTL(u_int8_t mcastTTL)							{ multicastTTL = mcastTTL; }
+	void SetLocalIPList(std::list<u_int32_t> &iplist)					{ localIPs = iplist; } 
+	void ClearLocalIPList()									{ localIPs.clear(); }
+	u_int32_t GetBindIP() const								{ return bindIP; }
+	u_int16_t GetPortbase() const								{ return portbase; }
+	u_int8_t GetMulticastTTL() const							{ return multicastTTL; }
+	const std::list<u_int32_t> &GetLocalIPList() const					{ return localIPs; }
+private:
+	u_int16_t portbase;
+	u_int32_t bindIP;
+	std::list<u_int32_t> localIPs;
+	u_int8_t multicastTTL;
+};
+
+class RTPUDPv4TransmissionInfo : public RTPTransmissionInfo
+{
+public:
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	RTPUDPv4TransmissionInfo(std::list<u_int32_t> iplist,int rtpsock,int rtcpsock) : RTPTransmissionInfo(RTPTransmitter::IPv4UDPProto) 
+#else
+	RTPUDPv4TransmissionInfo(std::list<u_int32_t> iplist,SOCKET rtpsock,SOCKET rtcpsock) : RTPTransmissionInfo(RTPTransmitter::IPv4UDPProto) 
+#endif  // WIN32
+												{ localIPlist = iplist; rtpsocket = rtpsock; rtcpsocket = rtcpsock; }
+
+	~RTPUDPv4TransmissionInfo()								{ }
+	std::list<u_int32_t> GetLocalIPList() const						{ return localIPlist; }
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	int GetRTPSocket() const								{ return rtpsocket; }
+	int GetRTCPSocket() const								{ return rtcpsocket; }
+#else
+	SOCKET GetRTPSocket() const								{ return rtpsocket; }
+	SOCKET GetRTCPSocket() const								{ return rtcpsocket; }
+#endif // WIN32
+private:
+	std::list<u_int32_t> localIPlist;
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	int rtpsocket,rtcpsocket;
+#else
+	SOCKET rtpsocket,rtcpsocket;
+#endif // WIN32
+};
+	
+#ifdef RTP_SUPPORT_INLINETEMPLATEPARAM
+	inline int RTPUDPv4Trans_GetHashIndex_IPv4Dest(const RTPIPv4Destination &d)				{ return d.GetIP_HBO()%RTPUDPV4TRANS_HASHSIZE; }
+	inline int RTPUDPv4Trans_GetHashIndex_u_int32_t(const u_int32_t &k)					{ return k%RTPUDPV4TRANS_HASHSIZE; }
+#else // No support for inline function as template parameter
+	int RTPUDPv4Trans_GetHashIndex_IPv4Dest(const RTPIPv4Destination &d);
+	int RTPUDPv4Trans_GetHashIndex_u_int32_t(const u_int32_t &k);
+#endif // RTP_SUPPORT_INLINETEMPLATEPARAM
+
+#define RTPUDPV4TRANS_HEADERSIZE						(20+8)
+	
+class RTPUDPv4Transmitter : public RTPTransmitter
+{
+public:
+	RTPUDPv4Transmitter();
+	~RTPUDPv4Transmitter();
+
+	int Init(bool treadsafe);
+	int Create(size_t maxpacksize,const RTPTransmissionParams *transparams);
+	void Destroy();
+	RTPTransmissionInfo *GetTransmissionInfo();
+
+	int GetLocalHostName(u_int8_t *buffer,size_t *bufferlength);
+	bool ComesFromThisTransmitter(const RTPAddress *addr);
+	size_t GetHeaderOverhead()							{ return RTPUDPV4TRANS_HEADERSIZE; }
+	
+	int Poll();
+	int WaitForIncomingData(const RTPTime &delay,bool *dataavailable = 0);
+	int AbortWait();
+	
+	int SendRTPData(const void *data,size_t len);	
+	int SendRTCPData(const void *data,size_t len);
+
+	void ResetPacketCount();
+	u_int32_t GetNumRTPPacketsSent();
+	u_int32_t GetNumRTCPPacketsSent();
+				
+	int AddDestination(const RTPAddress &addr);
+	int DeleteDestination(const RTPAddress &addr);
+	void ClearDestinations();
+
+	bool SupportsMulticasting();
+	int JoinMulticastGroup(const RTPAddress &addr);
+	int LeaveMulticastGroup(const RTPAddress &addr);
+	void LeaveAllMulticastGroups();
+
+	int SetReceiveMode(RTPTransmitter::ReceiveMode m);
+	int AddToIgnoreList(const RTPAddress &addr);
+	int DeleteFromIgnoreList(const RTPAddress &addr);
+	void ClearIgnoreList();
+	int AddToAcceptList(const RTPAddress &addr);
+	int DeleteFromAcceptList(const RTPAddress &addr);
+	void ClearAcceptList();
+	int SetMaximumPacketSize(size_t s);	
+	
+	bool NewDataAvailable();
+	RTPRawPacket *GetNextPacket();
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+private:
+	int CreateLocalIPList();
+	bool GetLocalIPList_Interfaces();
+	void GetLocalIPList_DNS();
+	void AddLoopbackAddress();
+	void FlushPackets();
+	int PollSocket(bool rtp);
+	int ProcessAddAcceptIgnoreEntry(u_int32_t ip,u_int16_t port);
+	int ProcessDeleteAcceptIgnoreEntry(u_int32_t ip,u_int16_t port);
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+	bool SetMulticastTTL(u_int8_t ttl);
+#endif // RTP_SUPPORT_IPV4MULTICAST
+	bool ShouldAcceptData(u_int32_t srcip,u_int16_t srcport);
+	void ClearAcceptIgnoreInfo();
+	
+	bool init;
+	bool created;
+	bool waitingfordata;
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	SOCKET rtpsock,rtcpsock;
+#else // not using winsock
+	int rtpsock,rtcpsock;
+#endif // WIN32
+	u_int32_t bindIP;
+	std::list<u_int32_t> localIPs;
+	u_int16_t portbase;
+	u_int8_t multicastTTL;
+	RTPTransmitter::ReceiveMode receivemode;
+
+	u_int8_t *localhostname;
+	size_t localhostnamelength;
+	
+	RTPHashTable<const RTPIPv4Destination,RTPUDPv4Trans_GetHashIndex_IPv4Dest,RTPUDPV4TRANS_HASHSIZE> destinations;
+#ifdef RTP_SUPPORT_IPV4MULTICAST
+	RTPHashTable<const u_int32_t,RTPUDPv4Trans_GetHashIndex_u_int32_t,RTPUDPV4TRANS_HASHSIZE> multicastgroups;
+#endif // RTP_SUPPORT_IPV4MULTICAST
+	std::list<RTPRawPacket*> rawpacketlist;
+
+	bool supportsmulticasting;
+	size_t maxpacksize;
+
+	class PortInfo
+	{
+	public:
+		PortInfo() { all = false; }
+		
+		bool all;
+		std::list<u_int16_t> portlist;
+	};
+
+	RTPKeyHashTable<const u_int32_t,PortInfo*,RTPUDPv4Trans_GetHashIndex_u_int32_t,RTPUDPV4TRANS_HASHSIZE> acceptignoreinfo;
+
+	// notification descriptors for AbortWait (0 is for reading, 1 for writing)
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	SOCKET abortdesc[2];
+#else
+	int abortdesc[2];
+#endif // WIN32
+	int CreateAbortDescriptors();
+	void DestroyAbortDescriptors();
+	void AbortWaitInternal();
+#ifdef RTP_SUPPORT_THREAD
+	JMutex mainmutex,waitmutex;
+	int threadsafe;
+#endif // RTP_SUPPORT_THREAD
+
+	u_int32_t rtppackcount,rtcppackcount;
+};
+
+#endif // RTPUDPV4TRANSMITTER_H
+

Added: konference/src/rtp/jrtplib/rtpudpv6transmitter.cpp
===================================================================
--- konference/src/rtp/jrtplib/rtpudpv6transmitter.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpudpv6transmitter.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,1939 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#include "rtpudpv6transmitter.h"
+
+#ifdef RTP_SUPPORT_IPV6
+
+#include "rtprawpacket.h"
+#include "rtpipv6address.h"
+#include "rtptimeutilities.h"
+#include <stdio.h>
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	#define RTPSOCKERR								INVALID_SOCKET
+	#define RTPCLOSE(x)								closesocket(x)
+	#define RTPSOCKLENTYPE								int
+	#define RTPIOCTL								ioctlsocket
+#else // not Win32
+	#include <sys/socket.h>
+	#include <netinet/in.h>
+	#include <arpa/inet.h>
+	#include <sys/ioctl.h>
+	#include <net/if.h>
+	#include <string.h>
+	#include <netdb.h>
+	#include <unistd.h>
+
+	#ifdef RTP_HAVE_SYS_FILIO
+		#include <sys/filio.h>
+	#endif // RTP_HAVE_SYS_FILIO
+	#ifdef RTP_HAVE_SYS_SOCKIO
+		#include <sys/sockio.h>
+	#endif // RTP_HAVE_SYS_SOCKIO
+	#ifdef RTP_SUPPORT_IFADDRS
+		#include <ifaddrs.h>
+	#endif // RTP_SUPPORT_IFADDRS
+
+
+	#define RTPSOCKERR								-1
+	#define RTPCLOSE(x)								close(x)
+
+	#ifdef RTP_SOCKLENTYPE_UINT
+		#define RTPSOCKLENTYPE							unsigned int
+	#else
+		#define RTPSOCKLENTYPE							int
+	#endif // RTP_SOCKLENTYPE_UINT
+
+	#define RTPIOCTL								ioctl
+#endif // WIN32
+
+#include "rtpdebug.h"
+
+#ifndef _WIN32_WCE
+	#define RTPUDPV6TRANS_RTPRECEIVEBUFFER							32768
+	#define RTPUDPV6TRANS_RTCPRECEIVEBUFFER							32768
+	#define RTPUDPV6TRANS_RTPTRANSMITBUFFER							32768
+	#define RTPUDPV6TRANS_RTCPTRANSMITBUFFER						32768
+	#define RTPUDPV6TRANS_MAXPACKSIZE							65535
+	#define RTPUDPV6TRANS_IFREQBUFSIZE							8192
+#else
+	#define RTPUDPV6TRANS_RTPRECEIVEBUFFER							2048
+	#define RTPUDPV6TRANS_RTCPRECEIVEBUFFER							2048
+	#define RTPUDPV6TRANS_RTPTRANSMITBUFFER							2048
+	#define RTPUDPV6TRANS_RTCPTRANSMITBUFFER						2048
+	#define RTPUDPV6TRANS_MAXPACKSIZE							2048
+	#define RTPUDPV6TRANS_IFREQBUFSIZE							2048
+#endif // _WIN32_WCE
+
+#define RTPUDPV6TRANS_IS_MCASTADDR(x)							(x.s6_addr[0] == 0xFF)
+
+#define RTPUDPV6TRANS_MCASTMEMBERSHIP(socket,type,mcastip,status)	{\
+										struct ipv6_mreq mreq;\
+										\
+										mreq.ipv6mr_multiaddr = mcastip;\
+										mreq.ipv6mr_interface = 0;\
+										status = setsockopt(socket,IPPROTO_IPV6,type,(const char *)&mreq,sizeof(struct ipv6_mreq));\
+									}
+#ifndef RTP_SUPPORT_INLINETEMPLATEPARAM
+	int RTPUDPv6Trans_GetHashIndex_IPv6Dest(const RTPIPv6Destination &d)		{ in6_addr ip = d.GetIP(); return ((((u_int32_t)ip.s6_addr[12])<<24)|(((u_int32_t)ip.s6_addr[13])<<16)|(((u_int32_t)ip.s6_addr[14])<<8)|((u_int32_t)ip.s6_addr[15]))%RTPUDPV6TRANS_HASHSIZE; }
+	int RTPUDPv6Trans_GetHashIndex_in6_addr(const in6_addr &ip)			{ return ((((u_int32_t)ip.s6_addr[12])<<24)|(((u_int32_t)ip.s6_addr[13])<<16)|(((u_int32_t)ip.s6_addr[14])<<8)|((u_int32_t)ip.s6_addr[15]))%RTPUDPV6TRANS_HASHSIZE; }
+#endif // !RTP_SUPPORT_INLINETEMPLATEPARAM
+	
+#ifdef RTP_SUPPORT_THREAD
+	#define MAINMUTEX_LOCK 		{ if (threadsafe) mainmutex.Lock(); }
+	#define MAINMUTEX_UNLOCK	{ if (threadsafe) mainmutex.Unlock(); }
+	#define WAITMUTEX_LOCK		{ if (threadsafe) waitmutex.Lock(); }
+	#define WAITMUTEX_UNLOCK	{ if (threadsafe) waitmutex.Unlock(); }
+#else
+	#define MAINMUTEX_LOCK
+	#define MAINMUTEX_UNLOCK
+	#define WAITMUTEX_LOCK
+	#define WAITMUTEX_UNLOCK
+#endif // RTP_SUPPORT_THREAD
+	
+inline bool operator==(const in6_addr &ip1,const in6_addr &ip2)
+{
+	if (memcmp(&ip1,&ip2,sizeof(in6_addr)) == 0)
+		return true;
+	return false;
+}
+
+RTPUDPv6Transmitter::RTPUDPv6Transmitter()
+{
+	created = false;
+	init = false;
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	timeinit.Dummy();
+#endif // WIN32 || _WIN32_WCE
+}
+
+RTPUDPv6Transmitter::~RTPUDPv6Transmitter()
+{
+	Destroy();
+}
+
+int RTPUDPv6Transmitter::Init(bool tsafe)
+{
+	if (init)
+		return ERR_RTP_UDPV6TRANS_ALREADYINIT;
+	
+#ifdef RTP_SUPPORT_THREAD
+	threadsafe = tsafe;
+	if (threadsafe)
+	{
+		int status;
+		
+		status = mainmutex.Init();
+		if (status < 0)
+			return ERR_RTP_UDPV6TRANS_CANTINITMUTEX;
+		status = waitmutex.Init();
+		if (status < 0)
+			return ERR_RTP_UDPV6TRANS_CANTINITMUTEX;
+	}
+#else
+	if (tsafe)
+		return ERR_RTP_NOTHREADSUPPORT;
+#endif // RTP_SUPPORT_THREAD
+
+	init = true;
+	return 0;
+}
+
+int RTPUDPv6Transmitter::Create(size_t maximumpacketsize,const RTPTransmissionParams *transparams)
+{
+	const RTPUDPv6TransmissionParams *params,defaultparams;
+	struct sockaddr_in6 addr;
+	RTPSOCKLENTYPE size;
+	int status;
+
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+
+	if (created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_ALREADYCREATED;
+	}
+	
+	// Obtain transmission parameters
+	
+	if (transparams == 0)
+		params = &defaultparams;
+	else
+	{
+		if (transparams->GetTransmissionProtocol() != RTPTransmitter::IPv6UDPProto)
+		{
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_UDPV6TRANS_ILLEGALPARAMETERS;
+		}
+		params = (const RTPUDPv6TransmissionParams *)transparams;
+	}
+
+	// Check if portbase is even
+	if (params->GetPortbase()%2 != 0)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_PORTBASENOTEVEN;
+	}
+
+	// create sockets
+	
+	rtpsock = socket(PF_INET6,SOCK_DGRAM,0);
+	if (rtpsock == RTPSOCKERR)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_CANTCREATESOCKET;
+	}
+	rtcpsock = socket(PF_INET6,SOCK_DGRAM,0);
+	if (rtcpsock == RTPSOCKERR)
+	{
+		RTPCLOSE(rtpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_CANTCREATESOCKET;
+	}
+	
+	// set socket buffer sizes
+	
+	size = RTPUDPV6TRANS_RTPRECEIVEBUFFER;
+	if (setsockopt(rtpsock,SOL_SOCKET,SO_RCVBUF,(const char *)&size,sizeof(int)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_CANTSETRTPRECEIVEBUF;
+	}
+	size = RTPUDPV6TRANS_RTPTRANSMITBUFFER;
+	if (setsockopt(rtpsock,SOL_SOCKET,SO_SNDBUF,(const char *)&size,sizeof(int)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_CANTSETRTPTRANSMITBUF;
+	}
+	size = RTPUDPV6TRANS_RTCPRECEIVEBUFFER;
+	if (setsockopt(rtcpsock,SOL_SOCKET,SO_RCVBUF,(const char *)&size,sizeof(int)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_CANTSETRTCPRECEIVEBUF;
+	}
+	size = RTPUDPV6TRANS_RTCPTRANSMITBUFFER;
+	if (setsockopt(rtcpsock,SOL_SOCKET,SO_SNDBUF,(const char *)&size,sizeof(int)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_CANTSETRTCPTRANSMITBUF;
+	}
+	
+	// bind sockets
+
+	bindIP = params->GetBindIP();
+	
+	memset(&addr,0,sizeof(struct sockaddr_in6));
+	addr.sin6_family = AF_INET6;
+	addr.sin6_port = htons(params->GetPortbase());
+	addr.sin6_addr = bindIP;
+	if (bind(rtpsock,(struct sockaddr *)&addr,sizeof(struct sockaddr_in6)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_CANTBINDRTPSOCKET;
+	}
+	memset(&addr,0,sizeof(struct sockaddr_in6));
+	addr.sin6_family = AF_INET6;
+	addr.sin6_port = htons(params->GetPortbase()+1);
+	addr.sin6_addr = bindIP;
+	if (bind(rtcpsock,(struct sockaddr *)&addr,sizeof(struct sockaddr_in6)) != 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_CANTBINDRTCPSOCKET;
+	}
+
+	// Try to obtain local IP addresses
+
+	localIPs = params->GetLocalIPList();
+	if (localIPs.empty()) // User did not provide list of local IP addresses, calculate them
+	{
+		int status;
+		
+		if ((status = CreateLocalIPList()) < 0)
+		{
+			RTPCLOSE(rtpsock);
+			RTPCLOSE(rtcpsock);
+			MAINMUTEX_UNLOCK
+			return status;
+		}
+
+#ifdef RTPDEBUG
+		std::cout << "Found these local IP addresses:" << std::endl;
+		
+		std::list<in6_addr>::const_iterator it;
+
+		for (it = localIPs.begin() ; it != localIPs.end() ; it++)
+		{
+			RTPIPv6Address a(*it);
+
+			std::cout << a.GetAddressString() << std::endl;
+		}
+#endif // RTPDEBUG
+	}
+
+#ifdef RTP_SUPPORT_IPV6MULTICAST
+	if (SetMulticastTTL(params->GetMulticastTTL()))
+		supportsmulticasting = true;
+	else
+		supportsmulticasting = false;
+#else // no multicast support enabled
+	supportsmulticasting = false;
+#endif // RTP_SUPPORT_IPV6MULTICAST
+
+	if ((status = CreateAbortDescriptors()) < 0)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		MAINMUTEX_UNLOCK
+		return status;
+	}
+	
+	if (maximumpacketsize > RTPUDPV6TRANS_MAXPACKSIZE)
+	{
+		RTPCLOSE(rtpsock);
+		RTPCLOSE(rtcpsock);
+		DestroyAbortDescriptors();
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_SPECIFIEDSIZETOOBIG;
+	}
+	
+	maxpacksize = maximumpacketsize;
+	portbase = params->GetPortbase();
+	multicastTTL = params->GetMulticastTTL();
+	receivemode = RTPTransmitter::AcceptAll;
+
+	localhostname = 0;
+	localhostnamelength = 0;
+
+	rtppackcount = 0;
+	rtcppackcount = 0;
+	
+	waitingfordata = false;
+	created = true;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+void RTPUDPv6Transmitter::Destroy()
+{
+	if (!init)
+		return;
+
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK;
+		return;
+	}
+
+	if (localhostname)
+	{
+		delete [] localhostname;
+		localhostname = 0;
+		localhostnamelength = 0;
+	}
+	
+	RTPCLOSE(rtpsock);
+	RTPCLOSE(rtcpsock);
+	destinations.Clear();
+#ifdef RTP_SUPPORT_IPV6MULTICAST
+	multicastgroups.Clear();
+#endif // RTP_SUPPORT_IPV6MULTICAST
+	FlushPackets();
+	ClearAcceptIgnoreInfo();
+	localIPs.clear();
+	created = false;
+	
+	if (waitingfordata)
+	{
+		AbortWaitInternal();
+		DestroyAbortDescriptors();
+		MAINMUTEX_UNLOCK
+		WAITMUTEX_LOCK // to make sure that the WaitForIncomingData function ended
+		WAITMUTEX_UNLOCK
+	}
+	else
+		DestroyAbortDescriptors();
+
+	MAINMUTEX_UNLOCK
+}
+
+RTPTransmissionInfo *RTPUDPv6Transmitter::GetTransmissionInfo()
+{
+	if (!init)
+		return 0;
+
+	MAINMUTEX_LOCK
+	RTPTransmissionInfo *tinf = new RTPUDPv6TransmissionInfo(localIPs,rtpsock,rtcpsock);
+	MAINMUTEX_UNLOCK
+	return tinf;
+}
+
+int RTPUDPv6Transmitter::GetLocalHostName(u_int8_t *buffer,size_t *bufferlength)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+
+	if (localhostname == 0)
+	{
+		if (localIPs.empty())
+		{
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_UDPV6TRANS_NOLOCALIPS;
+		}
+		
+		std::list<in6_addr>::const_iterator it;
+		std::list<std::string> hostnames;
+	
+		for (it = localIPs.begin() ; it != localIPs.end() ; it++)
+		{
+			struct hostent *he;
+			in6_addr ip = (*it);	
+			
+			he = gethostbyaddr((char *)&ip,sizeof(in6_addr),AF_INET6);
+			if (he != 0)
+			{
+				std::string hname = std::string(he->h_name);
+				hostnames.push_back(hname);
+			}
+		}
+	
+		bool found  = false;
+		
+		if (!hostnames.empty())	// try to select the most appropriate hostname
+		{
+			std::list<std::string>::const_iterator it;
+			
+			for (it = hostnames.begin() ; !found && it != hostnames.end() ; it++)
+			{
+				if ((*it).find('.') != std::string::npos)
+				{
+					found = true;
+					localhostnamelength = (*it).length();
+					localhostname = new u_int8_t [localhostnamelength+1];
+					if (localhostname == 0)
+					{
+						MAINMUTEX_UNLOCK
+						return ERR_RTP_OUTOFMEM;
+					}
+					memcpy(localhostname,(*it).c_str(),localhostnamelength);
+					localhostname[localhostnamelength] = 0;
+				}
+			}
+		}
+	
+		if (!found) // use an IP address
+		{
+			in6_addr ip;
+			int len;
+			char str[256];
+			u_int16_t ip16[8];
+			int i,j;
+				
+			it = localIPs.begin();
+			ip = (*it);
+			
+			for (i = 0,j = 0 ; j < 8 ; j++,i += 2)
+			{
+				ip16[j] = (((u_int16_t)ip.s6_addr[i])<<8);
+				ip16[j] |= ((u_int16_t)ip.s6_addr[i+1]);
+			}			
+			
+			sprintf(str,"%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X",(int)ip16[0],(int)ip16[1],(int)ip16[2],(int)ip16[3],(int)ip16[4],(int)ip16[5],(int)ip16[6],(int)ip16[7]);
+			len = strlen(str);
+	
+			localhostnamelength = len;
+			localhostname = new u_int8_t [localhostnamelength+1];
+			if (localhostname == 0)
+			{
+				MAINMUTEX_UNLOCK
+				return ERR_RTP_OUTOFMEM;
+			}
+			memcpy(localhostname,str,localhostnamelength);
+			localhostname[localhostnamelength] = 0;
+		}
+	}
+	
+	if ((*bufferlength) < localhostnamelength)
+	{
+		*bufferlength = localhostnamelength; // tell the application the required size of the buffer
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_TRANS_BUFFERLENGTHTOOSMALL;
+	}
+
+	memcpy(buffer,localhostname,localhostnamelength);
+	*bufferlength = localhostnamelength;
+	
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+bool RTPUDPv6Transmitter::ComesFromThisTransmitter(const RTPAddress *addr)
+{
+	if (!init)
+		return false;
+
+	if (addr == 0)
+		return false;
+	
+	MAINMUTEX_LOCK
+	
+	bool v;
+		
+	if (created && addr->GetAddressType() == RTPAddress::IPv6Address)
+	{	
+		const RTPIPv6Address *addr2 = (const RTPIPv6Address *)addr;
+		bool found = false;
+		std::list<in6_addr>::const_iterator it;
+	
+		it = localIPs.begin();
+		while (!found && it != localIPs.end())
+		{
+			in6_addr itip = *it;
+			in6_addr addrip = addr2->GetIP();
+			if (memcmp(&addrip,&itip,sizeof(in6_addr)) == 0)
+				found = true;
+			else
+				++it;
+		}
+	
+		if (!found)
+			v = false;
+		else
+		{
+			if (addr2->GetPort() == portbase) // check for RTP port
+				v = true;
+			else if (addr2->GetPort() == (portbase+1)) // check for RTCP port
+				v = true;
+			else 
+				v = false;
+		}
+	}
+	else
+		v = false;
+
+	MAINMUTEX_UNLOCK
+	return v;
+}
+
+int RTPUDPv6Transmitter::Poll()
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+
+	int status;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	status = PollSocket(true); // poll RTP socket
+	if (status >= 0)
+		status = PollSocket(false); // poll RTCP socket
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPUDPv6Transmitter::WaitForIncomingData(const RTPTime &delay,bool *dataavailable)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	fd_set fdset;
+	struct timeval tv;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (waitingfordata)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_ALREADYWAITING;
+	}
+	
+	FD_ZERO(&fdset);
+	FD_SET(rtpsock,&fdset);
+	FD_SET(rtcpsock,&fdset);
+	FD_SET(abortdesc[0],&fdset);
+	tv.tv_sec = delay.GetSeconds();
+	tv.tv_usec = delay.GetMicroSeconds();
+	
+	waitingfordata = true;
+	
+	WAITMUTEX_LOCK
+	MAINMUTEX_UNLOCK
+
+	if (select(FD_SETSIZE,&fdset,0,0,&tv) < 0)
+	{
+		MAINMUTEX_LOCK
+		waitingfordata = false;
+		MAINMUTEX_UNLOCK
+		WAITMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_ERRORINSELECT;
+	}
+	
+	MAINMUTEX_LOCK
+	waitingfordata = false;
+	if (!created) // destroy called
+	{
+		MAINMUTEX_UNLOCK;
+		WAITMUTEX_UNLOCK
+		return 0;
+	}
+		
+	// if aborted, read from abort buffer
+	if (FD_ISSET(abortdesc[0],&fdset))
+	{
+#if (defined(WIN32) || defined(_WIN32_WCE))
+		char buf[1];
+		
+		recv(abortdesc[0],buf,1,0);
+#else 
+		unsigned char buf[1];
+
+		read(abortdesc[0],buf,1);
+#endif // WIN32
+	}
+	
+	if (dataavailable != 0)
+	{
+		if (FD_ISSET(rtpsock,&fdset) || FD_ISSET(rtcpsock,&fdset))
+			*dataavailable = true;
+		else
+			*dataavailable = false;
+	}	
+
+	MAINMUTEX_UNLOCK
+	WAITMUTEX_UNLOCK
+	return 0;
+}
+
+int RTPUDPv6Transmitter::AbortWait()
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (!waitingfordata)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTWAITING;
+	}
+
+	AbortWaitInternal();
+	
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+int RTPUDPv6Transmitter::SendRTPData(const void *data,size_t len)	
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	struct sockaddr_in6 saddr;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (len > maxpacksize)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_SPECIFIEDSIZETOOBIG;
+	}
+	
+	memset(&saddr,0,sizeof(struct sockaddr_in6));
+	saddr.sin6_family = AF_INET6;
+	destinations.GotoFirstElement();
+	while (destinations.HasCurrentElement())
+	{
+		saddr.sin6_port = destinations.GetCurrentElement().GetRTPPort_NBO();
+		saddr.sin6_addr = destinations.GetCurrentElement().GetIP();
+		sendto(rtpsock,(const char *)data,len,0,(struct sockaddr *)&saddr,sizeof(struct sockaddr_in6));
+		destinations.GotoNextElement();
+	}
+	
+	rtppackcount++;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+int RTPUDPv6Transmitter::SendRTCPData(const void *data,size_t len)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	struct sockaddr_in6 saddr;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (len > maxpacksize)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_SPECIFIEDSIZETOOBIG;
+	}
+	
+	memset(&saddr,0,sizeof(struct sockaddr_in6));
+	saddr.sin6_family = AF_INET6;
+	destinations.GotoFirstElement();
+	while (destinations.HasCurrentElement())
+	{
+		saddr.sin6_port = destinations.GetCurrentElement().GetRTCPPort_NBO();
+		saddr.sin6_addr = destinations.GetCurrentElement().GetIP();
+		sendto(rtcpsock,(const char *)data,len,0,(struct sockaddr *)&saddr,sizeof(struct sockaddr_in6));
+		destinations.GotoNextElement();
+	}
+	
+	rtcppackcount++;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+void RTPUDPv6Transmitter::ResetPacketCount()
+{
+	if (!init)
+		return;
+
+	MAINMUTEX_LOCK
+	if (created)
+	{
+		rtppackcount = 0;
+		rtcppackcount = 0;	
+	}
+	MAINMUTEX_UNLOCK	
+}
+
+u_int32_t RTPUDPv6Transmitter::GetNumRTPPacketsSent()
+{
+	if (!init)
+		return 0;
+
+	MAINMUTEX_LOCK
+	
+	u_int32_t num;
+
+	if (!created)
+		num = 0;
+	else
+		num = rtppackcount;
+
+	MAINMUTEX_UNLOCK
+
+	return num;
+}
+
+u_int32_t RTPUDPv6Transmitter::GetNumRTCPPacketsSent()
+{
+	if (!init)
+		return 0;
+	
+	MAINMUTEX_LOCK
+	
+	u_int32_t num;
+
+	if (!created)
+		num = 0;
+	else
+		num = rtcppackcount;
+
+	MAINMUTEX_UNLOCK
+
+	return num;
+}
+
+int RTPUDPv6Transmitter::AddDestination(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv6Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	RTPIPv6Address &address = (RTPIPv6Address &)addr;
+	RTPIPv6Destination dest(address.GetIP(),address.GetPort());
+	int status = destinations.AddElement(dest);
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPUDPv6Transmitter::DeleteDestination(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv6Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	RTPIPv6Address &address = (RTPIPv6Address &)addr;	
+	RTPIPv6Destination dest(address.GetIP(),address.GetPort());
+	int status = destinations.DeleteElement(dest);
+	
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPUDPv6Transmitter::ClearDestinations()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created)
+		destinations.Clear();
+	MAINMUTEX_UNLOCK
+}
+
+bool RTPUDPv6Transmitter::SupportsMulticasting()
+{
+	if (!init)
+		return false;
+	
+	MAINMUTEX_LOCK
+	
+	bool v;
+		
+	if (!created)
+		v = false;
+	else
+		v = supportsmulticasting;
+
+	MAINMUTEX_UNLOCK
+	return v;
+}
+
+#ifdef RTP_SUPPORT_IPV6MULTICAST
+
+int RTPUDPv6Transmitter::JoinMulticastGroup(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv6Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	const RTPIPv6Address &address = (const RTPIPv6Address &)addr;
+	in6_addr mcastIP = address.GetIP();
+	
+	if (!RTPUDPV6TRANS_IS_MCASTADDR(mcastIP))
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTAMULTICASTADDRESS;
+	}
+	
+	status = multicastgroups.AddElement(mcastIP);
+	if (status >= 0)
+	{
+		RTPUDPV6TRANS_MCASTMEMBERSHIP(rtpsock,IPV6_JOIN_GROUP,mcastIP,status);
+		if (status != 0)
+		{
+			multicastgroups.DeleteElement(mcastIP);
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_UDPV6TRANS_COULDNTJOINMULTICASTGROUP;
+		}
+		RTPUDPV6TRANS_MCASTMEMBERSHIP(rtcpsock,IPV6_JOIN_GROUP,mcastIP,status);
+		if (status != 0)
+		{
+			RTPUDPV6TRANS_MCASTMEMBERSHIP(rtpsock,IPV6_LEAVE_GROUP,mcastIP,status);
+			multicastgroups.DeleteElement(mcastIP);
+			MAINMUTEX_UNLOCK
+			return ERR_RTP_UDPV6TRANS_COULDNTJOINMULTICASTGROUP;
+		}
+	}
+	MAINMUTEX_UNLOCK	
+	return status;
+}
+
+int RTPUDPv6Transmitter::LeaveMulticastGroup(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv6Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_INVALIDADDRESSTYPE;
+	}
+	
+	const RTPIPv6Address &address = (const RTPIPv6Address &)addr;
+	in6_addr mcastIP = address.GetIP();
+	
+	if (!RTPUDPV6TRANS_IS_MCASTADDR(mcastIP))
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTAMULTICASTADDRESS;
+	}
+	
+	status = multicastgroups.DeleteElement(mcastIP);
+	if (status >= 0)
+	{	
+		RTPUDPV6TRANS_MCASTMEMBERSHIP(rtpsock,IPV6_LEAVE_GROUP,mcastIP,status);
+		RTPUDPV6TRANS_MCASTMEMBERSHIP(rtcpsock,IPV6_LEAVE_GROUP,mcastIP,status);
+		status = 0;
+	}
+	
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPUDPv6Transmitter::LeaveAllMulticastGroups()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created)
+	{
+		multicastgroups.GotoFirstElement();
+		while (multicastgroups.HasCurrentElement())
+		{
+			in6_addr mcastIP;
+			int status = 0;
+
+			mcastIP = multicastgroups.GetCurrentElement();
+			RTPUDPV6TRANS_MCASTMEMBERSHIP(rtpsock,IPV6_LEAVE_GROUP,mcastIP,status);
+			RTPUDPV6TRANS_MCASTMEMBERSHIP(rtcpsock,IPV6_LEAVE_GROUP,mcastIP,status);
+			multicastgroups.GotoNextElement();
+		}
+		multicastgroups.Clear();
+	}
+	MAINMUTEX_UNLOCK
+}
+
+#else // no multicast support
+
+int RTPUDPv6Transmitter::JoinMulticastGroup(const RTPAddress &addr)
+{
+	return ERR_RTP_UDPV6TRANS_NOMULTICASTSUPPORT;
+}
+
+int RTPUDPv6Transmitter::LeaveMulticastGroup(const RTPAddress &addr)
+{
+	return ERR_RTP_UDPV6TRANS_NOMULTICASTSUPPORT;
+}
+
+void RTPUDPv6Transmitter::LeaveAllMulticastGroups()
+{
+}
+
+#endif // RTP_SUPPORT_IPV6MULTICAST
+
+int RTPUDPv6Transmitter::SetReceiveMode(RTPTransmitter::ReceiveMode m)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (m != receivemode)
+	{
+		receivemode = m;
+		acceptignoreinfo.Clear();
+	}
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+int RTPUDPv6Transmitter::AddToIgnoreList(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+
+	MAINMUTEX_LOCK
+	
+	int status;
+
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv6Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::IgnoreSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv6Address &address = (const RTPIPv6Address &)addr;
+	status = ProcessAddAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+	
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPUDPv6Transmitter::DeleteFromIgnoreList(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv6Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::IgnoreSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv6Address &address = (const RTPIPv6Address &)addr;	
+	status = ProcessDeleteAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPUDPv6Transmitter::ClearIgnoreList()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created && receivemode == RTPTransmitter::IgnoreSome)
+		ClearAcceptIgnoreInfo();
+	MAINMUTEX_UNLOCK
+}
+
+int RTPUDPv6Transmitter::AddToAcceptList(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv6Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::AcceptSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv6Address &address = (const RTPIPv6Address &)addr;
+	status = ProcessAddAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+int RTPUDPv6Transmitter::DeleteFromAcceptList(const RTPAddress &addr)
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	
+	int status;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (addr.GetAddressType() != RTPAddress::IPv6Address)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_INVALIDADDRESSTYPE;
+	}
+	if (receivemode != RTPTransmitter::AcceptSome)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_DIFFERENTRECEIVEMODE;
+	}
+	
+	const RTPIPv6Address &address = (const RTPIPv6Address &)addr;
+	status = ProcessDeleteAcceptIgnoreEntry(address.GetIP(),address.GetPort());
+
+	MAINMUTEX_UNLOCK
+	return status;
+}
+
+void RTPUDPv6Transmitter::ClearAcceptList()
+{
+	if (!init)
+		return;
+	
+	MAINMUTEX_LOCK
+	if (created && receivemode == RTPTransmitter::AcceptSome)
+		ClearAcceptIgnoreInfo();
+	MAINMUTEX_UNLOCK
+}
+
+int RTPUDPv6Transmitter::SetMaximumPacketSize(size_t s)	
+{
+	if (!init)
+		return ERR_RTP_UDPV6TRANS_NOTINIT;
+	
+	MAINMUTEX_LOCK
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_NOTCREATED;
+	}
+	if (s > RTPUDPV6TRANS_MAXPACKSIZE)
+	{
+		MAINMUTEX_UNLOCK
+		return ERR_RTP_UDPV6TRANS_SPECIFIEDSIZETOOBIG;
+	}
+	maxpacksize = s;
+	MAINMUTEX_UNLOCK
+	return 0;
+}
+
+bool RTPUDPv6Transmitter::NewDataAvailable()
+{
+	if (!init)
+		return false;
+	
+	MAINMUTEX_LOCK
+	
+	bool v;
+		
+	if (!created)
+		v = false;
+	else
+	{
+		if (rawpacketlist.empty())
+			v = false;
+		else
+			v = true;
+	}
+	
+	MAINMUTEX_UNLOCK
+	return v;
+}
+
+RTPRawPacket *RTPUDPv6Transmitter::GetNextPacket()
+{
+	if (!init)
+		return 0;
+	
+	MAINMUTEX_LOCK
+	
+	RTPRawPacket *p;
+	
+	if (!created)
+	{
+		MAINMUTEX_UNLOCK
+		return 0;
+	}
+	if (rawpacketlist.empty())
+	{
+		MAINMUTEX_UNLOCK
+		return 0;
+	}
+
+	p = *(rawpacketlist.begin());
+	rawpacketlist.pop_front();
+
+	MAINMUTEX_UNLOCK
+	return p;
+}
+
+// Here the private functions start...
+
+
+#ifdef RTP_SUPPORT_IPV6MULTICAST
+bool RTPUDPv6Transmitter::SetMulticastTTL(u_int8_t ttl)
+{
+	int ttl2,status;
+
+	ttl2 = (int)ttl;
+	status = setsockopt(rtpsock,IPPROTO_IPV6,IPV6_MULTICAST_HOPS,(const char *)&ttl2,sizeof(int));
+	if (status != 0)
+		return false;
+	status = setsockopt(rtcpsock,IPPROTO_IPV6,IPV6_MULTICAST_HOPS,(const char *)&ttl2,sizeof(int));
+	if (status != 0)
+		return false;
+	return true;
+}
+#endif // RTP_SUPPORT_IPV6MULTICAST
+
+
+void RTPUDPv6Transmitter::FlushPackets()
+{
+	std::list<RTPRawPacket*>::const_iterator it;
+
+	for (it = rawpacketlist.begin() ; it != rawpacketlist.end() ; ++it)
+		delete (*it);
+	rawpacketlist.clear();
+}
+
+int RTPUDPv6Transmitter::PollSocket(bool rtp)
+{
+	RTPSOCKLENTYPE fromlen;
+	int recvlen;
+	char packetbuffer[RTPUDPV6TRANS_MAXPACKSIZE];
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	SOCKET sock;
+	unsigned long len;
+#else 
+	size_t len;
+	int sock;
+#endif // WIN32
+	struct sockaddr_in6 srcaddr;
+	
+	if (rtp)
+		sock = rtpsock;
+	else
+		sock = rtcpsock;
+	
+	len = 0;
+	RTPIOCTL(sock,FIONREAD,&len);
+	if (len <= 0)
+		return 0;
+
+	while (len > 0)
+	{
+		RTPTime curtime = RTPTime::CurrentTime();
+		fromlen = sizeof(struct sockaddr_in6);
+		recvlen = recvfrom(sock,packetbuffer,(int)len,0,(struct sockaddr *)&srcaddr,&fromlen);
+		if (recvlen > 0)
+		{
+			bool acceptdata;
+
+			// got data, process it
+			if (receivemode == RTPTransmitter::AcceptAll)
+				acceptdata = true;
+			else
+				acceptdata = ShouldAcceptData(srcaddr.sin6_addr,htons(srcaddr.sin6_port));
+			
+			if (acceptdata)
+			{
+				RTPRawPacket *pack;
+				RTPIPv6Address *addr;
+				u_int8_t *datacopy;
+
+				addr = new RTPIPv6Address(srcaddr.sin6_addr,ntohs(srcaddr.sin6_port));
+				if (addr == 0)
+					return ERR_RTP_OUTOFMEM;
+				datacopy = new u_int8_t[recvlen];
+				if (datacopy == 0)
+				{
+					delete addr;
+					return ERR_RTP_OUTOFMEM;
+				}
+				memcpy(datacopy,packetbuffer,recvlen);
+				pack = new RTPRawPacket(datacopy,recvlen,addr,curtime,rtp);
+				if (pack == 0)
+				{
+					delete addr;
+					delete [] datacopy;
+					return ERR_RTP_OUTOFMEM;
+				}
+				rawpacketlist.push_back(pack);	
+			}
+		}
+		len = 0;
+		RTPIOCTL(sock,FIONREAD,&len);
+	}
+	return 0;
+}
+
+int RTPUDPv6Transmitter::ProcessAddAcceptIgnoreEntry(in6_addr ip,u_int16_t port)
+{
+	acceptignoreinfo.GotoElement(ip);
+	if (acceptignoreinfo.HasCurrentElement()) // An entry for this IP address already exists
+	{
+		PortInfo *portinf = acceptignoreinfo.GetCurrentElement();
+		
+		if (port == 0) // select all ports
+		{
+			portinf->all = true;
+			portinf->portlist.clear();
+		}
+		else if (!portinf->all)
+		{
+			std::list<u_int16_t>::const_iterator it,begin,end;
+
+			begin = portinf->portlist.begin();
+			end = portinf->portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == port) // already in list
+					return 0;
+			}
+			portinf->portlist.push_front(port);
+		}
+	}
+	else // got to create an entry for this IP address
+	{
+		PortInfo *portinf;
+		int status;
+		
+		portinf = new PortInfo();
+		if (port == 0) // select all ports
+			portinf->all = true;
+		else
+			portinf->portlist.push_front(port);
+		
+		status = acceptignoreinfo.AddElement(ip,portinf);
+		if (status < 0)
+		{
+			delete portinf;
+			return status;
+		}
+	}
+	return 0;
+}
+
+void RTPUDPv6Transmitter::ClearAcceptIgnoreInfo()
+{
+	acceptignoreinfo.GotoFirstElement();
+	while (acceptignoreinfo.HasCurrentElement())
+	{
+		PortInfo *inf;
+
+		inf = acceptignoreinfo.GetCurrentElement();
+		delete inf;
+		acceptignoreinfo.GotoNextElement();
+	}
+	acceptignoreinfo.Clear();
+}
+	
+int RTPUDPv6Transmitter::ProcessDeleteAcceptIgnoreEntry(in6_addr ip,u_int16_t port)
+{
+	acceptignoreinfo.GotoElement(ip);
+	if (!acceptignoreinfo.HasCurrentElement())
+		return ERR_RTP_UDPV6TRANS_NOSUCHENTRY;
+	
+	PortInfo *inf;
+
+	inf = acceptignoreinfo.GetCurrentElement();
+	if (port == 0) // delete all entries
+	{
+		inf->all = false;
+		inf->portlist.clear();
+	}
+	else // a specific port was selected
+	{
+		if (inf->all) // currently, all ports are selected. Add the one to remove to the list
+		{
+			// we have to check if the list doesn't contain the port already
+			std::list<u_int16_t>::const_iterator it,begin,end;
+
+			begin = inf->portlist.begin();
+			end = inf->portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == port) // already in list: this means we already deleted the entry
+					return ERR_RTP_UDPV6TRANS_NOSUCHENTRY;
+			}
+			inf->portlist.push_front(port);
+		}
+		else // check if we can find the port in the list
+		{
+			std::list<u_int16_t>::iterator it,begin,end;
+			
+			begin = inf->portlist.begin();
+			end = inf->portlist.end();
+			for (it = begin ; it != end ; ++it)
+			{
+				if (*it == port) // found it!
+				{
+					inf->portlist.erase(it);
+					return 0;
+				}
+			}
+			// didn't find it
+			return ERR_RTP_UDPV6TRANS_NOSUCHENTRY;			
+		}
+	}
+	return 0;
+}
+
+bool RTPUDPv6Transmitter::ShouldAcceptData(in6_addr srcip,u_int16_t srcport)
+{
+	if (receivemode == RTPTransmitter::AcceptSome)
+	{
+		PortInfo *inf;
+
+		acceptignoreinfo.GotoElement(srcip);
+		if (!acceptignoreinfo.HasCurrentElement())
+			return false;
+		
+		inf = acceptignoreinfo.GetCurrentElement();
+		if (!inf->all) // only accept the ones in the list
+		{
+			std::list<u_int16_t>::const_iterator it,begin,end;
+
+			begin = inf->portlist.begin();
+			end = inf->portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return true;
+			}
+			return false;
+		}
+		else // accept all, except the ones in the list
+		{
+			std::list<u_int16_t>::const_iterator it,begin,end;
+
+			begin = inf->portlist.begin();
+			end = inf->portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return false;
+			}
+			return true;
+		}
+	}
+	else // IgnoreSome
+	{
+		PortInfo *inf;
+
+		acceptignoreinfo.GotoElement(srcip);
+		if (!acceptignoreinfo.HasCurrentElement())
+			return true;
+		
+		inf = acceptignoreinfo.GetCurrentElement();
+		if (!inf->all) // ignore the ports in the list
+		{
+			std::list<u_int16_t>::const_iterator it,begin,end;
+
+			begin = inf->portlist.begin();
+			end = inf->portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return false;
+			}
+			return true;
+		}
+		else // ignore all, except the ones in the list
+		{
+			std::list<u_int16_t>::const_iterator it,begin,end;
+
+			begin = inf->portlist.begin();
+			end = inf->portlist.end();
+			for (it = begin ; it != end ; it++)
+			{
+				if (*it == srcport)
+					return true;
+			}
+			return false;
+		}
+	}
+	return true;
+}
+
+#if (defined(WIN32) || defined(_WIN32_WCE))
+
+int RTPUDPv6Transmitter::CreateAbortDescriptors()
+{
+	SOCKET listensock;
+	int size;
+	struct sockaddr_in6 addr;
+
+	listensock = socket(PF_INET6,SOCK_STREAM,0);
+	if (listensock == RTPSOCKERR)
+		return ERR_RTP_UDPV6TRANS_CANTCREATEABORTDESCRIPTORS;
+	
+	memset(&addr,0,sizeof(struct sockaddr_in6));
+	addr.sin6_family = AF_INET6;
+	if (bind(listensock,(struct sockaddr *)&addr,sizeof(struct sockaddr_in6)) != 0)
+	{
+		RTPCLOSE(listensock);
+		return ERR_RTP_UDPV6TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&addr,0,sizeof(struct sockaddr_in6));
+	size = sizeof(struct sockaddr_in6);
+	if (getsockname(listensock,(struct sockaddr*)&addr,&size) != 0)
+	{
+		RTPCLOSE(listensock);
+		return ERR_RTP_UDPV6TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	unsigned short connectport = ntohs(addr.sin6_port);
+
+	abortdesc[0] = socket(PF_INET6,SOCK_STREAM,0);
+	if (abortdesc[0] == RTPSOCKERR)
+	{
+		RTPCLOSE(listensock);
+		return ERR_RTP_UDPV6TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&addr,0,sizeof(struct sockaddr_in6));
+	addr.sin6_family = AF_INET6;
+	if (bind(abortdesc[0],(struct sockaddr *)&addr,sizeof(struct sockaddr_in6)) != 0)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_UDPV6TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	if (listen(listensock,1) != 0)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_UDPV6TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&addr,0,sizeof(struct sockaddr_in6));
+	addr.sin6_family = AF_INET6;
+	addr.sin6_addr = in6addr_loopback;
+	addr.sin6_port = htons(connectport);
+	
+	if (connect(abortdesc[0],(struct sockaddr *)&addr,sizeof(struct sockaddr_in6)) != 0)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_UDPV6TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	memset(&addr,0,sizeof(struct sockaddr_in6));
+	size = sizeof(struct sockaddr_in6);
+	abortdesc[1] = accept(listensock,(struct sockaddr *)&addr,&size);
+	if (abortdesc[1] == RTPSOCKERR)
+	{
+		RTPCLOSE(listensock);
+		RTPCLOSE(abortdesc[0]);
+		return ERR_RTP_UDPV6TRANS_CANTCREATEABORTDESCRIPTORS;
+	}
+
+	// okay, got the connection, close the listening socket
+
+	RTPCLOSE(listensock);
+	return 0;
+}
+
+void RTPUDPv6Transmitter::DestroyAbortDescriptors()
+{
+	RTPCLOSE(abortdesc[0]);
+	RTPCLOSE(abortdesc[1]);
+}
+
+#else // in a non winsock environment we can use pipes
+
+int RTPUDPv6Transmitter::CreateAbortDescriptors()
+{
+	if (pipe(abortdesc) < 0)
+		return ERR_RTP_UDPV6TRANS_CANTCREATEPIPE;
+	return 0;
+}
+
+void RTPUDPv6Transmitter::DestroyAbortDescriptors()
+{
+	close(abortdesc[0]);
+	close(abortdesc[1]);
+}
+
+#endif // WIN32
+
+int RTPUDPv6Transmitter::CreateLocalIPList()
+{
+	 // first try to obtain the list from the network interface info
+
+	if (!GetLocalIPList_Interfaces())
+	{
+		// If this fails, we'll have to depend on DNS info
+		GetLocalIPList_DNS();
+	}
+	AddLoopbackAddress();
+	return 0;
+}
+
+#if (defined(WIN32) || defined(_WIN32_WCE))
+
+bool RTPUDPv6Transmitter::GetLocalIPList_Interfaces()
+{
+	unsigned char buffer[RTPUDPV6TRANS_IFREQBUFSIZE];
+	DWORD outputsize;
+	DWORD numaddresses,i;
+	SOCKET_ADDRESS_LIST *addrlist;
+
+	if (WSAIoctl(rtpsock,SIO_ADDRESS_LIST_QUERY,NULL,0,&buffer,RTPUDPV6TRANS_IFREQBUFSIZE,&outputsize,NULL,NULL))
+		return false;
+	
+	addrlist = (SOCKET_ADDRESS_LIST *)buffer;
+	numaddresses = addrlist->iAddressCount;
+	for (i = 0 ; i < numaddresses ; i++)
+	{
+		SOCKET_ADDRESS *sockaddr = &(addrlist->Address[i]);
+		if (sockaddr->iSockaddrLength == sizeof(struct sockaddr_in6)) // IPv6 address
+		{
+			struct sockaddr_in6 *addr = (struct sockaddr_in6 *)sockaddr->lpSockaddr;
+
+			localIPs.push_back(addr->sin6_addr);
+		}
+	}
+
+	if (localIPs.empty())
+		return false;
+	return true;
+}
+
+#else
+
+#ifdef RTP_SUPPORT_IFADDRS
+
+bool RTPUDPv6Transmitter::GetLocalIPList_Interfaces()
+{
+	struct ifaddrs *addrs,*tmp;
+	
+	getifaddrs(&addrs);
+	tmp = addrs;
+	
+	while (tmp != 0)
+	{
+		if (tmp->ifa_addr->sa_family == AF_INET6)
+		{
+			struct sockaddr_in6 *inaddr = (struct sockaddr_in6 *)tmp->ifa_addr;
+			localIPs.push_back(inaddr->sin6_addr);
+		}
+		tmp = tmp->ifa_next;
+	}
+	
+	freeifaddrs(addrs);
+	
+	if (localIPs.empty())
+		return false;
+	return true;
+}
+
+#else
+
+bool RTPUDPv6Transmitter::GetLocalIPList_Interfaces()
+{
+	return false;
+}
+
+#endif // RTP_SUPPORT_IFADDRS
+
+#endif // WIN32
+
+void RTPUDPv6Transmitter::GetLocalIPList_DNS()
+{
+	int status;
+	char name[1024];
+
+	gethostname(name,1023);
+	name[1023] = 0;
+
+	struct addrinfo hints;
+	struct addrinfo *res,*tmp;
+	
+	memset(&hints,0,sizeof(struct addrinfo));
+	hints.ai_family = AF_INET6;
+	hints.ai_socktype = 0;
+	hints.ai_protocol = 0;
+
+	if ((status = getaddrinfo(name,0,&hints,&res)) != 0)
+		return;
+
+	tmp = res;
+	while (tmp != 0)
+	{
+		if (tmp->ai_family == AF_INET6)
+		{
+			struct sockaddr_in6 *addr = (struct sockaddr_in6 *)(tmp->ai_addr);
+			localIPs.push_back(addr->sin6_addr);
+		}
+		tmp = tmp->ai_next;
+	}
+	
+	freeaddrinfo(res);	
+}
+
+
+void RTPUDPv6Transmitter::AbortWaitInternal()
+{
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	send(abortdesc[1],"*",1,0);
+#else
+	write(abortdesc[1],"*",1);
+#endif // WIN32
+}
+
+
+void RTPUDPv6Transmitter::AddLoopbackAddress()
+{
+	std::list<in6_addr>::const_iterator it;
+	bool found = false;
+
+	for (it = localIPs.begin() ; !found && it != localIPs.end() ; it++)
+	{
+		if ((*it) == in6addr_loopback)
+			found = true;
+	}
+
+	if (!found)
+		localIPs.push_back(in6addr_loopback);
+}
+
+#ifdef RTPDEBUG
+void RTPUDPv6Transmitter::Dump()
+{
+	if (!init)
+		std::cout << "Not initialized" << std::endl;
+	else
+	{
+		MAINMUTEX_LOCK
+	
+		if (!created)
+			std::cout << "Not created" << std::endl;
+		else
+		{
+			char str[1024];
+			in6_addr ip;
+			u_int16_t ip16[8];
+			std::list<in6_addr>::const_iterator it;
+			int i,j;
+			
+			std::cout << "Portbase:                       " << portbase << std::endl;
+			std::cout << "RTP socket descriptor:          " << rtpsock << std::endl;
+			std::cout << "RTCP socket descriptor:         " << rtcpsock << std::endl;
+			ip = bindIP;
+			for (i = 0,j = 0 ; j < 8 ; j++,i += 2)	{ ip16[j] = (((u_int16_t)ip.s6_addr[i])<<8); ip16[j] |= ((u_int16_t)ip.s6_addr[i+1]); }
+			sprintf(str,"%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X",(int)ip16[0],(int)ip16[1],(int)ip16[2],(int)ip16[3],(int)ip16[4],(int)ip16[5],(int)ip16[6],(int)ip16[7]);
+			std::cout << "Bind IP address:                " << str << std::endl;
+			std::cout << "Local IP addresses:" << std::endl;
+			for (it = localIPs.begin() ; it != localIPs.end() ; it++)
+			{
+				ip = (*it);
+				for (i = 0,j = 0 ; j < 8 ; j++,i += 2)	{ ip16[j] = (((u_int16_t)ip.s6_addr[i])<<8); ip16[j] |= ((u_int16_t)ip.s6_addr[i+1]); }
+				sprintf(str,"%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X",(int)ip16[0],(int)ip16[1],(int)ip16[2],(int)ip16[3],(int)ip16[4],(int)ip16[5],(int)ip16[6],(int)ip16[7]);
+				std::cout << "    " << str << std::endl;
+			}
+			std::cout << "Multicast TTL:                  " << (int)multicastTTL << std::endl;
+			std::cout << "Receive mode:                   ";
+			switch (receivemode)
+			{
+			case RTPTransmitter::AcceptAll:
+				std::cout << "Accept all";
+				break;
+			case RTPTransmitter::AcceptSome:
+				std::cout << "Accept some";
+				break;
+			case RTPTransmitter::IgnoreSome:
+				std::cout << "Ignore some";
+			}
+			std::cout << std::endl;
+			if (receivemode != RTPTransmitter::AcceptAll)
+			{
+				acceptignoreinfo.GotoFirstElement();
+				while(acceptignoreinfo.HasCurrentElement())
+				{
+					ip = acceptignoreinfo.GetCurrentKey();
+					for (i = 0,j = 0 ; j < 8 ; j++,i += 2)	{ ip16[j] = (((u_int16_t)ip.s6_addr[i])<<8); ip16[j] |= ((u_int16_t)ip.s6_addr[i+1]); }
+					sprintf(str,"%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X",(int)ip16[0],(int)ip16[1],(int)ip16[2],(int)ip16[3],(int)ip16[4],(int)ip16[5],(int)ip16[6],(int)ip16[7]);
+					PortInfo *pinfo = acceptignoreinfo.GetCurrentElement();
+					std::cout << "    " << str << ": ";
+					if (pinfo->all)
+					{
+						std::cout << "All ports";
+						if (!pinfo->portlist.empty())
+							std::cout << ", except ";
+					}
+					
+					std::list<u_int16_t>::const_iterator it;
+					
+					for (it = pinfo->portlist.begin() ; it != pinfo->portlist.end() ; )
+					{
+						std::cout << (*it);
+						it++;
+						if (it != pinfo->portlist.end())
+							std::cout << ", ";
+					}
+					std::cout << std::endl;
+				}
+			}
+			
+			std::cout << "Local host name:                ";
+			if (localhostname == 0)
+				std::cout << "Not set";
+			else
+				std::cout << localhostname;
+			std::cout << std::endl;
+
+			std::cout << "List of destinations:           ";
+			destinations.GotoFirstElement();
+			if (destinations.HasCurrentElement())
+			{
+				std::cout << std::endl;
+				do
+				{
+					std::cout << "    " << destinations.GetCurrentElement().GetDestinationString() << std::endl;
+					destinations.GotoNextElement();
+				} while (destinations.HasCurrentElement());
+			}
+			else
+				std::cout << "Empty" << std::endl;
+		
+			std::cout << "Supports multicasting:          " << ((supportsmulticasting)?"Yes":"No") << std::endl;
+#ifdef RTP_SUPPORT_IPV6MULTICAST
+			std::cout << "List of multicast groups:       ";
+			multicastgroups.GotoFirstElement();
+			if (multicastgroups.HasCurrentElement())
+			{
+				std::cout << std::endl;
+				do
+				{
+					ip = multicastgroups.GetCurrentElement();
+					for (i = 0,j = 0 ; j < 8 ; j++,i += 2)	{ ip16[j] = (((u_int16_t)ip.s6_addr[i])<<8); ip16[j] |= ((u_int16_t)ip.s6_addr[i+1]); }
+					sprintf(str,"%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X",(int)ip16[0],(int)ip16[1],(int)ip16[2],(int)ip16[3],(int)ip16[4],(int)ip16[5],(int)ip16[6],(int)ip16[7]);
+					std::cout << "    " << str << std::endl;
+					multicastgroups.GotoNextElement();
+				} while (multicastgroups.HasCurrentElement());
+			}
+			else
+				std::cout << "Empty" << std::endl;
+#endif // RTP_SUPPORT_IPV6MULTICAST
+			
+			std::cout << "Number of raw packets in queue: " << rawpacketlist.size() << std::endl;
+			std::cout << "Maximum allowed packet size:    " << maxpacksize << std::endl;
+			std::cout << "RTP packet count:               " << rtppackcount << std::endl;
+			std::cout << "RTCP packet count:              " << rtcppackcount << std::endl;
+		}
+		
+		MAINMUTEX_UNLOCK
+	}
+
+}
+#endif // RTPDEBUG
+
+#endif // RTP_SUPPORT_IPV6
+

Added: konference/src/rtp/jrtplib/rtpudpv6transmitter.h
===================================================================
--- konference/src/rtp/jrtplib/rtpudpv6transmitter.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/jrtplib/rtpudpv6transmitter.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -0,0 +1,237 @@
+/*
+
+  This file is a part of JRTPLIB
+  Copyright (c) 1999-2005 Jori Liesenborgs
+
+  Contact: jori at lumumba.uhasselt.be
+
+  This library was developed at the "Expertisecentrum Digitale Media"
+  (http://www.edm.uhasselt.be), a research center of the Hasselt University
+  (http://www.uhasselt.be). The library is based upon work done for 
+  my thesis at the School for Knowledge Technology (Belgium/The Netherlands).
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  IN THE SOFTWARE.
+
+*/
+
+#ifndef RTPUDPV6TRANSMITTER_H
+
+#define RTPUDPV6TRANSMITTER_H
+
+#include "rtpconfig.h"
+
+#ifdef RTP_SUPPORT_IPV6
+
+#include "rtptransmitter.h"
+#include "rtpipv6destination.h"
+#include "rtphashtable.h"
+#include "rtpkeyhashtable.h"
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	#include <netinet/in.h>
+#endif // WIN32
+#include <string.h>
+#include <list>
+
+#ifdef RTP_SUPPORT_THREAD
+	#include <jmutex.h>
+#endif // RTP_SUPPORT_THREAD
+
+#define RTPUDPV6TRANS_HASHSIZE									8317
+#define RTPUDPV6TRANS_DEFAULTPORTBASE								5000
+
+class RTPUDPv6TransmissionParams : public RTPTransmissionParams
+{
+public:
+	RTPUDPv6TransmissionParams():RTPTransmissionParams(RTPTransmitter::IPv6UDPProto)	{ portbase = RTPUDPV6TRANS_DEFAULTPORTBASE; for (int i = 0 ; i < 16 ; i++) bindIP.s6_addr[i] = 0; multicastTTL = 1; }
+	void SetBindIP(in6_addr ip)								{ bindIP = ip; }
+	void SetPortbase(u_int16_t pbase)							{ portbase = pbase; }
+	void SetMulticastTTL(u_int8_t mcastTTL)							{ multicastTTL = mcastTTL; }
+	void SetLocalIPList(std::list<in6_addr> &iplist)					{ localIPs = iplist; } 
+	void ClearLocalIPList()									{ localIPs.clear(); }
+	in6_addr GetBindIP() const								{ return bindIP; }
+	u_int16_t GetPortbase() const								{ return portbase; }
+	u_int8_t GetMulticastTTL() const							{ return multicastTTL; }
+	const std::list<in6_addr> &GetLocalIPList() const					{ return localIPs; }
+private:
+	u_int16_t portbase;
+	in6_addr bindIP;
+	std::list<in6_addr> localIPs;
+	u_int8_t multicastTTL;
+};
+
+class RTPUDPv6TransmissionInfo : public RTPTransmissionInfo
+{
+public:
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	RTPUDPv6TransmissionInfo(std::list<in6_addr> iplist,int rtpsock,int rtcpsock) : RTPTransmissionInfo(RTPTransmitter::IPv6UDPProto) 
+#else
+	RTPUDPv6TransmissionInfo(std::list<in6_addr> iplist,SOCKET rtpsock,SOCKET rtcpsock) : RTPTransmissionInfo(RTPTransmitter::IPv6UDPProto) 
+#endif  // WIN32
+												{ localIPlist = iplist; rtpsocket = rtpsock; rtcpsocket = rtcpsock; }
+
+	~RTPUDPv6TransmissionInfo()								{ }
+	std::list<in6_addr> GetLocalIPList() const						{ return localIPlist; }
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	int GetRTPSocket() const								{ return rtpsocket; }
+	int GetRTCPSocket() const								{ return rtcpsocket; }
+#else
+	SOCKET GetRTPSocket() const								{ return rtpsocket; }
+	SOCKET GetRTCPSocket() const								{ return rtcpsocket; }
+#endif // WIN32
+private:
+	std::list<in6_addr> localIPlist;
+#if ! (defined(WIN32) || defined(_WIN32_WCE))
+	int rtpsocket,rtcpsocket;
+#else
+	SOCKET rtpsocket,rtcpsocket;
+#endif // WIN32
+};
+		
+#ifdef RTP_SUPPORT_INLINETEMPLATEPARAM
+	inline int RTPUDPv6Trans_GetHashIndex_IPv6Dest(const RTPIPv6Destination &d)		{ in6_addr ip = d.GetIP(); return ((((u_int32_t)ip.s6_addr[12])<<24)|(((u_int32_t)ip.s6_addr[13])<<16)|(((u_int32_t)ip.s6_addr[14])<<8)|((u_int32_t)ip.s6_addr[15]))%RTPUDPV6TRANS_HASHSIZE; }
+	inline int RTPUDPv6Trans_GetHashIndex_in6_addr(const in6_addr &ip)			{ return ((((u_int32_t)ip.s6_addr[12])<<24)|(((u_int32_t)ip.s6_addr[13])<<16)|(((u_int32_t)ip.s6_addr[14])<<8)|((u_int32_t)ip.s6_addr[15]))%RTPUDPV6TRANS_HASHSIZE; }
+#else // No support for inline function as template parameter
+	int RTPUDPv6Trans_GetHashIndex_IPv6Dest(const RTPIPv6Destination &d);
+	int RTPUDPv6Trans_GetHashIndex_in6_addr(const in6_addr &ip);
+#endif // RTP_SUPPORT_INLINETEMPLATEPARAM
+
+#define RTPUDPV6TRANS_HEADERSIZE								(40+8)
+	
+class RTPUDPv6Transmitter : public RTPTransmitter
+{
+public:
+	RTPUDPv6Transmitter();
+	~RTPUDPv6Transmitter();
+
+	int Init(bool treadsafe);
+	int Create(size_t maxpacksize,const RTPTransmissionParams *transparams);
+	void Destroy();
+	RTPTransmissionInfo *GetTransmissionInfo();
+
+	int GetLocalHostName(u_int8_t *buffer,size_t *bufferlength);
+	bool ComesFromThisTransmitter(const RTPAddress *addr);
+	size_t GetHeaderOverhead()								{ return RTPUDPV6TRANS_HEADERSIZE; }
+	
+	int Poll();
+	int WaitForIncomingData(const RTPTime &delay,bool *dataavailable = 0);
+	int AbortWait();
+	
+	int SendRTPData(const void *data,size_t len);	
+	int SendRTCPData(const void *data,size_t len);
+
+	void ResetPacketCount();
+	u_int32_t GetNumRTPPacketsSent();
+	u_int32_t GetNumRTCPPacketsSent();
+				
+	int AddDestination(const RTPAddress &addr);
+	int DeleteDestination(const RTPAddress &addr);
+	void ClearDestinations();
+
+	bool SupportsMulticasting();
+	int JoinMulticastGroup(const RTPAddress &addr);
+	int LeaveMulticastGroup(const RTPAddress &addr);
+	void LeaveAllMulticastGroups();
+
+	int SetReceiveMode(RTPTransmitter::ReceiveMode m);
+	int AddToIgnoreList(const RTPAddress &addr);
+	int DeleteFromIgnoreList(const RTPAddress &addr);
+	void ClearIgnoreList();
+	int AddToAcceptList(const RTPAddress &addr);
+	int DeleteFromAcceptList(const RTPAddress &addr);
+	void ClearAcceptList();
+	int SetMaximumPacketSize(size_t s);	
+	
+	bool NewDataAvailable();
+	RTPRawPacket *GetNextPacket();
+#ifdef RTPDEBUG
+	void Dump();
+#endif // RTPDEBUG
+private:
+	int CreateLocalIPList();
+	bool GetLocalIPList_Interfaces();
+	void GetLocalIPList_DNS();
+	void AddLoopbackAddress();
+	void FlushPackets();
+	int PollSocket(bool rtp);
+	int ProcessAddAcceptIgnoreEntry(in6_addr ip,u_int16_t port);
+	int ProcessDeleteAcceptIgnoreEntry(in6_addr ip,u_int16_t port);
+#ifdef RTP_SUPPORT_IPV6MULTICAST
+	bool SetMulticastTTL(u_int8_t ttl);
+#endif // RTP_SUPPORT_IPV6MULTICAST
+	bool ShouldAcceptData(in6_addr srcip,u_int16_t srcport);
+	void ClearAcceptIgnoreInfo();
+	
+	bool init;
+	bool created;
+	bool waitingfordata;
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	SOCKET rtpsock,rtcpsock;
+#else // not using winsock
+	int rtpsock,rtcpsock;
+#endif // WIN32
+	in6_addr bindIP;
+	std::list<in6_addr> localIPs;
+	u_int16_t portbase;
+	u_int8_t multicastTTL;
+	RTPTransmitter::ReceiveMode receivemode;
+
+	u_int8_t *localhostname;
+	size_t localhostnamelength;
+	
+	RTPHashTable<const RTPIPv6Destination,RTPUDPv6Trans_GetHashIndex_IPv6Dest,RTPUDPV6TRANS_HASHSIZE> destinations;
+#ifdef RTP_SUPPORT_IPV6MULTICAST
+	RTPHashTable<const in6_addr,RTPUDPv6Trans_GetHashIndex_in6_addr,RTPUDPV6TRANS_HASHSIZE> multicastgroups;
+#endif // RTP_SUPPORT_IPV6MULTICAST
+	std::list<RTPRawPacket*> rawpacketlist;
+
+	bool supportsmulticasting;
+	size_t maxpacksize;
+
+	class PortInfo
+	{
+	public:
+		PortInfo() { all = false; }
+		
+		bool all;
+		std::list<u_int16_t> portlist;
+	};
+
+	RTPKeyHashTable<const in6_addr,PortInfo*,RTPUDPv6Trans_GetHashIndex_in6_addr,RTPUDPV6TRANS_HASHSIZE> acceptignoreinfo;
+
+	// notification descriptors for AbortWait (0 is for reading, 1 for writing)
+#if (defined(WIN32) || defined(_WIN32_WCE))
+	SOCKET abortdesc[2];
+#else
+	int abortdesc[2];
+#endif // WIN32
+	int CreateAbortDescriptors();
+	void DestroyAbortDescriptors();
+	void AbortWaitInternal();
+#ifdef RTP_SUPPORT_THREAD
+	JMutex mainmutex,waitmutex;
+	int threadsafe;
+#endif // RTP_SUPPORT_THREAD
+
+	u_int32_t rtppackcount,rtcppackcount;
+};
+
+#endif // RTP_SUPPORT_IPV6
+
+#endif // RTPUDPV6TRANSMITTER_H
+

Modified: konference/src/rtp/rtpaudio.cpp
===================================================================
--- konference/src/rtp/rtpaudio.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/rtpaudio.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -31,404 +31,120 @@
 #include <linux/sockios.h>
 #include "config.h"
 
+#include <kdebug.h>
+
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include "rtppacket.h"
+#include "rtpudpv4transmitter.h"
+#include "rtpipv4address.h"
+#include "rtpsessionparams.h"
+//#include "rtperrors.h"
+
 #include "rtpaudio.h"
 #include "../codecs/g711.h"
 #include "../codecs/gsmcodec.h"
 
-
-rtpAudio::rtpAudio(int localPort, QString remoteIP, int remotePort,
-                   int mediaPay, int dtmfPay, codecBase *codec, audioBase *audioDevice)
-		: rtpBase(remoteIP, localPort, remotePort)
+rtpAudio::rtpAudio(int localPort, QString remoteIP, int remotePort, codecBase *codec, audioBase *audioDevice)
 {
+	m_codec = codec;
 	m_audioDevice = audioDevice;
 
-	txMode = RTP_TX_AUDIO_FROM_MICROPHONE;
-	rxMode = RTP_RX_AUDIO_TO_SPEAKER;
-	//txMode = RTP_TX_AUDIO_SILENCE;
-	//rxMode = RTP_RX_AUDIO_DISCARD;
+	u_int32_t destip = inet_addr(remoteIP.latin1());
+	if (destip == INADDR_NONE)
+		kdDebug() << "rtpVideo: remoteIP error" << endl;
+	destip = ntohl(destip);
 
-	m_codec = codec;
 
-	audioPayload = mediaPay;
-	dtmfPayload = dtmfPay;
+	// Now, we'll create a RTP session
+	RTPUDPv4TransmissionParams transparams;
+	RTPSessionParams sessparams;
 
-	// Clear variables within the calling tasks thread that are used by the calling
-	// task to prevent race conditions
-	txBuffer = 0;
-	recBuffer = 0;
-	dtmfIn = "";
+	// IMPORTANT: The local timestamp unit MUST be set, otherwise
+	//            RTCP Sender Report info will be calculated wrong
+	// In this case, we'll be sending 10 samples each second, so we'll
+	// put the timestamp unit to (1.0/10.0)
+	//8000 Hz
+	sessparams.SetOwnTimestampUnit(1.0/8000.0);
 
-	killRtpThread = false;
+	sessparams.SetAcceptOwnPackets(true);
+	transparams.SetPortbase(localPort);
+	m_status = m_rtpSession.Create(sessparams,&transparams);
+	//checkerror(status);
+
+	RTPIPv4Address addr(destip,remotePort);
+
+	m_status = m_rtpSession.AddDestination(addr);
+	//checkerror(status);
+	micFirstTime = true;
 	start();
 }
 
 rtpAudio::~rtpAudio()
 {
-	killRtpThread = true;
+	m_killThread = true;
 	wait();
 }
 
 void rtpAudio::run()
 {
-	rtpAudioThreadWorker();
-}
-
-
-void rtpAudio::rtpAudioThreadWorker()
-{
-	RTPPACKET RTPpacket;
-	QTime timeNextTx;
-	bool micFirstTime = true;
-
-	rtpInitialise();
-	openSocket();
-	//set this to have no mic
-	//txMode = RTP_TX_AUDIO_SILENCE;
-	kdDebug() << "rtpAudio::rtpAudioThreadWorker()" << endl;
-
-	PlayoutDelay = SpkJitter;
-	PlayLen = 0;
-	memset(SilenceBuffer, 0, sizeof(SilenceBuffer));
-	SilenceLen = rxPCMSamplesPerPacket * sizeof(short);
-	rxTimestamp = 0;
-	rxSeqNum = 0;
-	rxFirstFrame = true;
-
-	timeNextTx = (QTime::currentTime()).addMSecs(rxMsPacketSize);
-
-	while(!killRtpThread)
+	m_killThread = false;
+	while(!m_killThread)
 	{
-		// Awake every 10ms to see if we need to rx/tx anything
-		// May need to revisit this; as I'd much prefer it to be event driven
-		// usleep(10000) seems to cause a 20ms sleep whereas usleep(0)
-		// seems to sleep for ~10ms
-		usleep(10000);
+		handleOutgoingPackets();
 
-		// Pull in all received packets
-		StreamInAudio();
-		// Write audio to the speaker, but keep in dejitter buffer as long as possible
-		while (m_audioDevice->isSpeakerHungry() &&
-		        pJitter->AnyData() &&
-		        rxMode == RTP_RX_AUDIO_TO_SPEAKER &&
-		        pJitter->isPacketQueued(rxSeqNum))
+		m_rtpSession.BeginDataAccess();
+		// check incoming packets
+		if (m_rtpSession.GotoFirstSourceWithData())
 		{
-			PlayOutAudio();
-		}
-		// For mic. data, the microphone determines the transmit rate
-		// Mic. needs kicked the first time through
-		while ((txMode == RTP_TX_AUDIO_FROM_MICROPHONE) &&
-		        ((m_audioDevice->isMicrophoneData()) || micFirstTime))
-		{
-			micFirstTime = false;
-			if (fillPacketfromMic(RTPpacket))
+			do
 			{
-				txTimeStamp += txPCMSamplesPerPacket;
-				initPacket(RTPpacket);
-				sendPacket(RTPpacket);
-			}
-		}
-
-		// For transmitting silence/buffered data we need to use the clock
-		// as timing
-		if (((txMode == RTP_TX_AUDIO_SILENCE) || (txMode == RTP_TX_AUDIO_FROM_BUFFER)) &&
-		        (timeNextTx <= QTime::currentTime()))
-		{
-			timeNextTx = timeNextTx.addMSecs(rxMsPacketSize);
-			switch (txMode)
-			{
-			default:
-			case RTP_TX_AUDIO_SILENCE:           fillPacketwithSilence(RTPpacket); break;
-			case RTP_TX_AUDIO_FROM_BUFFER:       fillPacketfromBuffer(RTPpacket);  break;
-			}
-			txTimeStamp += txPCMSamplesPerPacket;
-			initPacket(RTPpacket);
-			sendPacket(RTPpacket);
-		}
-
-		//here may be a good place to send dtmf-tones...
-		//SendWaitingDtmf();
-	}
-
-	m_audioDevice->closeDevice();
-	closeSocket();
-	if (pJitter)
-		delete pJitter;
-}
-
-void rtpAudio::rtpInitialise()
-{
-	rxMsPacketSize        = 20;
-	rxPCMSamplesPerPacket = rxMsPacketSize * PCM_SAMPLES_PER_MS;
-	txMsPacketSize        = 20;
-	txPCMSamplesPerPacket = txMsPacketSize*PCM_SAMPLES_PER_MS;
-	SpkJitter             = 5; // Size of the jitter buffer * (rxMsPacketSize/2); so 5=50ms for 20ms packet size
-	txBuffer              = 0;
-	lastDtmfTimestamp     = 0;
-	dtmfIn                = "";
-	recBuffer             = 0;
-	recBufferLen          = 0;
-	recBufferMaxLen       = 0;
-	rxFirstFrame          = true;
-	//spkLowThreshold       = (rxPCMSamplesPerPacket*sizeof(short));
-	oobError              = false;
-	micMuted              = false;
-
-	spkInBuffer = 0;
-
-	m_audioDevice->setSpkLowThreshold(rxPCMSamplesPerPacket*sizeof(short));
-
-	pJitter = new Jitter();
-
-	rtpMPT = m_codec->getPayload();
-	rtpMarker = 0;
-}
-
-void rtpAudio::StreamInAudio()
-{
-	RTPPACKET rtpDump;
-	RTPPACKET *JBuf;
-	bool tryAgain;
-
-	do
-	{
-		tryAgain = false; // We keep going until we empty the socket
-
-		// Get a buffer from the Jitter buffer to put the packet in
-		if ((JBuf = pJitter->GetJBuffer()) != 0)
-		{
-			//JBuf->len = rtpSocket->readBlock((char *)&JBuf->RtpVPXCC, sizeof(RTPPACKET));
-			JBuf->len = readPacket((char *)&JBuf->RtpVPXCC, sizeof(RTPPACKET));
-			if (JBuf->len > 0)
-			{
-				tryAgain = true;
-				if (PAYLOAD(JBuf) == rtpMPT)
+				RTPPacket *pack;
+				while ((pack = m_rtpSession.GetNextPacket()) != NULL)
 				{
-					JBuf->RtpSequenceNumber = ntohs(JBuf->RtpSequenceNumber);
-					JBuf->RtpTimeStamp = ntohl(JBuf->RtpTimeStamp);
-					if (rxFirstFrame)
-					{
-						rxFirstFrame = FALSE;
-						rxSeqNum = JBuf->RtpSequenceNumber;
-					}
-					if (PKLATE(rxSeqNum, JBuf->RtpSequenceNumber))
-					{
-						kdDebug() << "Packet arrived too late to play, try increasing jitter buffer\n";
-						pJitter->FreeJBuffer(JBuf);
-					}
-					else
-						pJitter->InsertJBuffer(JBuf);
+					//pack->Dump();
+					handleIncomingPackets(pack);
+					delete pack;
 				}
-				else if (PAYLOAD(JBuf) == dtmfPayload)
-				{
-					tryAgain = true; // Force us to get another frame since this one is additional
-					HandleRxDTMF(JBuf);
-					if (PKLATE(rxSeqNum, JBuf->RtpSequenceNumber))
-						pJitter->FreeJBuffer(JBuf);
-					else
-						pJitter->InsertDTMF(JBuf); // Do this just so seq-numbers stay intact, it gets discarded later
-				}
-				else
-				{
-					if (PAYLOAD(JBuf) != RTP_PAYLOAD_COMF_NOISE)
-						kdDebug() << "Received Invalid Payload " << (int)JBuf->RtpMPT << "\n";
-					else
-						kdDebug() << "Received Comfort Noise Payload\n";
-					pJitter->FreeJBuffer(JBuf);
-				}
 			}
-			else // No received frames, free the buffer
-				pJitter->FreeJBuffer(JBuf);
+			while (m_rtpSession.GotoNextSourceWithData());
 		}
+		m_rtpSession.EndDataAccess();
 
-		// No free buffers, still get the data from the socket but dump it. Unlikely to recover from this by
-		// ourselves so we really need to discard all queued frames and reset the receiver
-		else
-		{
-			//rtpSocket->readBlock((char *)&rtpDump.RtpVPXCC, sizeof(RTPPACKET));
-			readPacket((char *)&rtpDump.RtpVPXCC, sizeof(RTPPACKET));
-			if (!oobError)
-			{
-				kdDebug() << "Dumping received RTP frame, no free buffers; rx-mode " << rxMode << "; tx-mode " << txMode << endl;
-				pJitter->Debug();
-				oobError = true;
-			}
-		}
+		msleep(20);
+		m_status = m_rtpSession.Poll();
 	}
-	while (tryAgain);
 
-	// Check size of Jitter buffer, make sure it doesn't grow too big
-	//pJitter->Debug();
+	m_audioDevice->closeDevice();
 
 }
 
-
-void rtpAudio::PlayOutAudio()
+void rtpAudio::handleIncomingPackets(RTPPacket *pack)
 {
-	bool tryAgain;
-	int mLen, m, reason;
- 
-	// Implement a playout de-jitter delay
-	if (PlayoutDelay > 0)
-	{
-		PlayoutDelay--;
-		return;
-	}
- 
-	// Now process buffers from the Jitter Buffer
-	do
-	{
-		tryAgain = false;
-		RTPPACKET *JBuf = pJitter->DequeueJBuffer(rxSeqNum, reason);
-		switch (reason)
-		{
-		case JB_REASON_OK:
-			++rxSeqNum;
-			mLen = JBuf->len - RTP_HEADER_SIZE;
-			if ((rxMode == RTP_RX_AUDIO_TO_SPEAKER))
-			{
-				PlayLen = m_codec->Decode(JBuf->RtpData, spkBuffer[spkInBuffer], mLen, spkPower2);
-				//	kdDebug() << "spkPower: " << spkPower2 << endl;
-				//m = write(speakerFd, (uchar *)spkBuffer[spkInBuffer], PlayLen);
-				m_audioDevice->playFrame((uchar *)spkBuffer[spkInBuffer], PlayLen);
-			}
-			//TODO why the heck should we want to put received frames in a buffer
-			//TODO and do nothing with them??
-			//else if (rxMode == RTP_RX_AUDIO_TO_BUFFER)
-			//{
-			//	PlayLen = m_codec->Decode(JBuf->RtpData, SpkBuffer[spkInBuffer], mLen, spkPower2);
-			//	recordInPacket(SpkBuffer[spkInBuffer], PlayLen);
-			//	cout << "rxMode == RTP_RX_AUDIO_TO_BUFFER" << endl;
-			//}
-			//rxTimestamp += mLen;//TODO increasing the timestamp by a length of data??
-			//pJitter->FreeJBuffer(JBuf);
- 
-// rxMode is RTP_RX_AUDIO_DISCARD
-			else
-{}
-			pJitter->FreeJBuffer(JBuf);
-				break
-;
-			case JB_REASON_DUPLICATE: // This should not happen; but it does, especially with DTMF frames!
-				if (JBuf != 0)
-					pJitter->FreeJBuffer(JBuf);
-				tryAgain = true;
-				break;
- 
-			case JB_REASON_DTMF:
-				++rxSeqNum;
-				pJitter->FreeJBuffer(JBuf);
-				tryAgain = true;
-				break;
- 
-				// This may just be because we are putting frames into the driver too early, but no way to tell
-			case JB_REASON_MISSING:
-				rxSeqNum++;
-				memset(SilenceBuffer, 0, sizeof(SilenceBuffer));
-				SilenceLen = rxPCMSamplesPerPacket * sizeof(short);
-				if ((rxMode == RTP_RX_AUDIO_TO_SPEAKER))
-				{
-					m_audioDevice->playFrame((uchar *)SilenceBuffer, SilenceLen);
-					//m = write(speakerFd, (uchar *)SilenceBuffer, SilenceLen);
-				}
-				//TODO see above
-				else if (rxMode == RTP_RX_AUDIO_TO_BUFFER)
-				{
-				rxMode = RTP_RX_AUDIO_DISCARD;
-				kdDebug() << "rxMode == RTP_RX_AUDIO_TO_BUFFER" << endl;
-				//
-				//	recordInPacket(SilenceBuffer, SilenceLen);
-				}
-				pJitter->FreeJBuffer(JBuf);
-				break;
- 
-			case JB_REASON_EMPTY: // nothing to do, just hope the driver playout buffer is full (since we can't tell!)
-				break;
-			case JB_REASON_SEQERR:
-			default:
-				//kdDebug() << "Something funny happened with the seq numbers, should reset them & start again\n";
-				break;
-			}
-		}
-		while (tryAgain);
- 
-	}
+	short int spkPower2;
+	int PlayLen = m_codec->Decode((uchar*)pack->GetPayloadData(), spkBuffer[spkInBuffer], (int)pack->GetPayloadLength(), spkPower2);
+	m_audioDevice->playFrame((uchar *)spkBuffer[spkInBuffer], PlayLen);
 
-
-void rtpAudio::HandleRxDTMF(RTPPACKET *RTPpacket)
-{
-	DTMF_RFC2833 *dtmf = (DTMF_RFC2833 *)RTPpacket->RtpData;
-	RTPpacket->RtpSequenceNumber = ntohs(RTPpacket->RtpSequenceNumber);
-	RTPpacket->RtpTimeStamp = ntohl(RTPpacket->RtpTimeStamp);
-
-	// Check if it is a NEW or REPEATED DTMF character
-	if (RTPpacket->RtpTimeStamp != lastDtmfTimestamp)
-	{
-		lastDtmfTimestamp = RTPpacket->RtpTimeStamp;
-		rtpMutex.lock();
-		dtmfIn.append(DTMF2CHAR(dtmf->dtmfDigit));
-		kdDebug() << "Received DTMF digit " << dtmfIn << endl;
-		rtpMutex.unlock();
-	}
 }
 
-void rtpAudio::initPacket(RTPPACKET &RTPpacket)
+void rtpAudio::handleOutgoingPackets()
 {
-	RTPpacket.RtpVPXCC = 128;
-	RTPpacket.RtpMPT = rtpMPT | rtpMarker;
-	rtpMarker = 0;
-	//seq-numbers are handled by the base-class
-	//RTPpacket.RtpSequenceNumber = htons(txSequenceNumber);
-
-	RTPpacket.RtpTimeStamp = htonl(txTimeStamp);
-}
-
-void rtpAudio::fillPacketwithSilence(RTPPACKET &RTPpacket)
-{
-	RTPpacket.len = m_codec->Silence(RTPpacket.RtpData, txMsPacketSize);
-}
-
-bool rtpAudio::fillPacketfromMic(RTPPACKET &RTPpacket)
-{
-	int gain=0;
-	short buffer[MAX_DECOMP_AUDIO_SAMPLES];
-	//	int len = read(microphoneFd, (char *)buffer, txPCMSamplesPerPacket*sizeof(short));
-	int len = m_audioDevice->recordFrame((char *) buffer, txPCMSamplesPerPacket*sizeof(short));
-
-	if (len != (int)(txPCMSamplesPerPacket*sizeof(short)))
+	while(m_audioDevice->isMicrophoneData() || micFirstTime)
 	{
-		fillPacketwithSilence(RTPpacket);
-		//kdDebug() << "aua :" << len << endl;
-	}
-	else if (micMuted)
-		fillPacketwithSilence(RTPpacket);
-	else
-	{
-		RTPpacket.len = m_codec->Encode(buffer, RTPpacket.RtpData, txPCMSamplesPerPacket, spkPower2, gain);
-		//		kdDebug() << "micPower: " << spkPower2 << endl;
-	}
+		micFirstTime = false;
+		int gain=0;
+		short buffer[MAX_DECOMP_AUDIO_SAMPLES];
+		//	int len = read(microphoneFd, (char *)buffer, txPCMSamplesPerPacket*sizeof(short));
+		int len = m_audioDevice->recordFrame((char *) buffer, 20*8/*txPCMSamplesPerPacket*/*sizeof(short));
+		short int spkPower2;
+		uchar	  RtpData[IP_MAX_MTU-RTP_HEADER_SIZE-UDP_HEADER_SIZE];
 
-	return true;
-}
-
-void rtpAudio::fillPacketfromBuffer(RTPPACKET &RTPpacket)
-{
-	rtpMutex.lock();
-	if (txBuffer == 0)
-	{
-		fillPacketwithSilence(RTPpacket);
-		txMode = RTP_TX_AUDIO_SILENCE;
-		kdDebug() << "No buffer to playout, changing to playing silence\n";
-	}
-	else
-	{
-		RTPpacket.len = m_codec->Encode(txBuffer+txBufferPtr, RTPpacket.RtpData, txPCMSamplesPerPacket, spkPower2, 0);
-		txBufferPtr += txPCMSamplesPerPacket;
-		if (txBufferPtr >= txBufferLen)
+		if (len != (int)(20*8*sizeof(short)))
 		{
-			delete txBuffer;
-			txBuffer = 0;
-			txMode = RTP_TX_AUDIO_SILENCE;
+			//fillPacketwithSilence(RTPpacket);
+			kdDebug() << "aua :" << len << endl;
 		}
+		len = m_codec->Encode((short*)&buffer, (uchar*)&RtpData, 20*8/*txPCMSamplesPerPacket*/, spkPower2, gain);
+		m_status = m_rtpSession.SendPacket((uchar*)&RtpData,len,m_codec->getPayload(),true/*marker*/,160);
 	}
-	rtpMutex.unlock();
 }

Modified: konference/src/rtp/rtpaudio.h
===================================================================
--- konference/src/rtp/rtpaudio.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/rtpaudio.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -17,17 +17,12 @@
  *   Free Software Foundation, Inc.,                                       *
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
- 
+
 #ifndef RTPAUDIO_H_
 #define RTPAUDIO_H_
 
-#include <qsocketdevice.h>
-#include <qtimer.h>
-#include <qptrlist.h>
 #include <qthread.h>
-#include <qdatetime.h>
 
-
 #define IP_MAX_MTU                1500     // Max size of rxed RTP packet
 #define IP_MTU                    1290     // Max size of txed RTP packet. Standard MTU is 1500, leave some room for IPSec etc
 #define TX_USER_STREAM_SIZE       4096
@@ -44,107 +39,34 @@
 #define NUM_SPK_BUFFERS		16
 #define SPK_BUFFER_SIZE		MIC_BUFFER_SIZE // Need to keep these the same (see RTPPACKET)
 
-typedef struct
-{
-	uchar  dtmfDigit;
-	uchar  dtmfERVolume;
-	short dtmfDuration;
-}
-DTMF_RFC2833;
+#define IP_MTU                    1290     // Max size of txed RTP packet. Standard MTU is 1500, leave some room for IPSec etc
+#define IP_MAX_MTU                1500     // Max size of rxed RTP packet
+#define RTP_HEADER_SIZE           12
+#define UDP_HEADER_SIZE           28
 
-
-// Values for RTP Payload Type
-#define RTP_PAYLOAD_MARKER_BIT	0x80
-#define PAYLOAD(r)              (((r)->RtpMPT) & (~RTP_PAYLOAD_MARKER_BIT))
-#define RTP_DTMF_EBIT           0x80
-#define RTP_DTMF_VOLUMEMASK     0x3F
-#define JITTERQ_SIZE	          512
-#define PKLATE(c,r)             (((r)<(c)) && (((c)-(r))<32000))    // check if rxed seq-number is less than current but handle wrap
-
-#define DTMF_STAR 10
-#define DTMF_HASH 11
-#define DTMF2CHAR(d) ((d)>DTMF_HASH ? '?' : ((d)==DTMF_STAR ? '*' : ((d) == DTMF_HASH ? '#' : ((d)+'0'))))
-#define CHAR2DTMF(c) ((c)=='#' ? DTMF_HASH : ((c)=='*' ? DTMF_STAR : ((c)-'0')))
-
-
 #include "../codecs/codecbase.h"
 #include "../audio/audiobase.h"
 
-#include "jitter.h"
+#include "rtpsession.h"
 
-#include "rtpbase.h"
-
-/**
- * @brief Class that handles transmission/receiption of audio
- */
-class rtpAudio : public rtpBase, QThread
+class rtpAudio : public QThread
 {
-
 public:
-	rtpAudio(int localPort, QString remoteIP, int remotePort, int mediaPay, int dtmfPay, codecBase *codec, audioBase *audioDevice);
+	rtpAudio(int localPort, QString remoteIP, int remotePort, codecBase *codec, audioBase *audioDevice);
 	~rtpAudio();
 	virtual void run();
 
 private:
-	void rtpAudioThreadWorker();
-	void rtpInitialise();
-	void StreamInAudio();
-	void PlayOutAudio();
-	void HandleRxDTMF(RTPPACKET *RTPpacket);
-	void SendWaitingDtmf();
-	void initPacket(RTPPACKET &RTPpacket);
-	void fillPacketwithSilence(RTPPACKET &RTPpacket);
-	bool fillPacketfromMic(RTPPACKET &RTPpacket);
-	void fillPacketfromBuffer(RTPPACKET &RTPpacket);
-
-
+	void handleIncomingPackets(RTPPacket *pack);
+	void handleOutgoingPackets();
+	bool micFirstTime;
+	audioBase *m_audioDevice;
+	codecBase   *m_codec;
+	bool m_killThread;
+	int m_status;
+	RTPSession m_rtpSession;
 	short spkBuffer[1][SPK_BUFFER_SIZE];
 	int spkInBuffer;
-
-	codecBase   *m_codec;
-	Jitter *pJitter;
-	int rxMsPacketSize;
-	int txMsPacketSize;
-	int rxPCMSamplesPerPacket;
-	int txPCMSamplesPerPacket;
-	int SpkJitter;
-
-	ulong rxTimestamp;
-	ushort rxSeqNum;
-	bool rxFirstFrame;
-	unsigned long txTimeStamp;
-
-	int PlayoutDelay;
-	short SilenceBuffer[MAX_DECOMP_AUDIO_SAMPLES];
-	int PlayLen;
-	int SilenceLen;
-	uchar rtpMPT;
-	uchar rtpMarker;
-	rtpTxMode txMode;
-	rtpRxMode rxMode;
-
-	bool oobError;
-	bool killRtpThread;
-	short *txBuffer;
-	int txBufferLen, txBufferPtr;
-	ulong lastDtmfTimestamp;
-	QString dtmfIn;
-	short *recBuffer;
-	int recBufferLen, recBufferMaxLen;
-
-	///this may be set to 'true' anytime to transmit silence instead of mic-data (speech)
-	bool micMuted;
-
-	int audioPayload,dtmfPayload;
-	
-	audioBase *m_audioDevice;
-	
-	//this is used by the encode/decode functions of the codecs and stores the power-lvl in this frame
-	//used for statistics/powermeter
-	short spkPower2;
 };
 
-
-
-
 #endif

Modified: konference/src/rtp/rtpbase.h
===================================================================
--- konference/src/rtp/rtpbase.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/rtpbase.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -32,6 +32,7 @@
 #define RTP_PAYLOAD_G711A		0x08
 #define RTP_PAYLOAD_COMF_NOISE	0x0D
 #define RTP_PAYLOAD_GSM			0x03
+#define RTP_PAYLOAD_SPEEX		0x61
 #define PAYLOAD(r)				(((r)->RtpMPT) & (~RTP_PAYLOAD_MARKER_BIT))
 
 #include "jitter.h"

Modified: konference/src/rtp/rtpvideo.cpp
===================================================================
--- konference/src/rtp/rtpvideo.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/rtpvideo.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -18,380 +18,230 @@
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
 
+#include <qapplication.h>//for ::postEvent()
+
+#include <kdebug.h>
+
 #include <netinet/in.h>
+#include <arpa/inet.h>
+#include "rtppacket.h"
+#include "rtpudpv4transmitter.h"
+#include "rtpipv4address.h"
+#include "rtpsessionparams.h"
+//#include "rtperrors.h"
 
 #include "rtpvideo.h"
 
-
-rtpVideo::rtpVideo(QObject *parent, int localPort, QString remoteIP, int remotePort, int mediaPay, rtpTxMode txm, rtpRxMode rxm)
-		: rtpBase(remoteIP, localPort, remotePort)
+rtpVideo::rtpVideo(QObject *parent, int localPort, QString remoteIP, int remotePort, int payloadType, float fps)
 {
+	m_payloadType = payloadType;
 	m_parent = parent;
-	txMode = txm;
-	rxMode = rxm;
 
-	videoPayload = mediaPay;
+	m_videoBuffer.w = m_videoBuffer.h = m_videoBuffer.len = 0;
 
-	//create 10 videobuffers
-	for(int i=0; i<=9; i++)
-		FreeVideoBufferQ.append(new VIDEOBUFFER);
+	u_int32_t destip = inet_addr(remoteIP.latin1());
+	if (destip == INADDR_NONE)
+		kdDebug() << "rtpVideo: remoteIP error" << endl;
+	destip = ntohl(destip);
 
-	videoToTx = 0;
-	pJitter = new Jitter();
-	killRtpThread = false;
-	start();
-}
+	// Now, we'll create a RTP session
+	RTPUDPv4TransmissionParams transparams;
+	RTPSessionParams sessparams;
 
+	// IMPORTANT: The local timestamp unit MUST be set, otherwise
+	//            RTCP Sender Report info will be calculated wrong
+	// In this case, we'll be sending 10 samples each second, so we'll
+	// put the timestamp unit to (1.0/10.0)
+	sessparams.SetOwnTimestampUnit(1.0/fps);
 
-rtpVideo::~rtpVideo()
-{
-	killRtpThread = true;
-	wait();
-	destroyVideoBuffers();
-}
+	sessparams.SetAcceptOwnPackets(true);
+	transparams.SetPortbase(localPort);
+	m_status = m_rtpSession.Create(sessparams,&transparams);
+	//checkerror(status);
 
-void rtpVideo::initialise()
-{
-	rtpMPT = videoPayload;
+	RTPIPv4Address addr(destip,remotePort);
 
-	rxFirstFrame          = true;
+	m_status = m_rtpSession.AddDestination(addr);
+	//checkerror(status);
 
-	rtpMarker = 0;
+	start();
 }
 
-VIDEOBUFFER *rtpVideo::getRxedVideo()
+rtpVideo::~rtpVideo()
 {
-	rtpMutex.lock();
-	VIDEOBUFFER *b=rxedVideoFrames.take(0);
-	rtpMutex.unlock();
-	return b;
+	m_killThread = true;
+	wait();
+	m_rtpSession.Destroy();
 }
 
-VIDEOBUFFER *rtpVideo::getVideoBuffer(int len)
+void rtpVideo::run()
 {
-	if ((len==0) || (len <= MAX_VIDEO_LEN)) // len parameter, is passed, should be checked against buffer sizes
+	m_killThread = false;
+	while(!m_killThread)
 	{
-		VIDEOBUFFER *buf;
-		rtpMutex.lock();
-		buf = FreeVideoBufferQ.take(0);
-		rtpMutex.unlock();
-		return buf;
+		handleOutgoingPackets();
+
+		m_rtpSession.BeginDataAccess();
+		// check incoming packets
+		if (m_rtpSession.GotoFirstSourceWithData())
+		{
+			do
+			{
+				RTPPacket *pack;
+				while ((pack = m_rtpSession.GetNextPacket()) != NULL)
+				{
+					//pack->Dump();
+					handleIncomingPackets(pack);
+					delete pack;
+				}
+			}
+			while (m_rtpSession.GotoNextSourceWithData());
+		}
+		m_rtpSession.EndDataAccess();
+
+		msleep(50);
+		m_status = m_rtpSession.Poll();
 	}
-	kdDebug() << "Received video picture size " << len << " too big for preallocated buffer size " << MAX_VIDEO_LEN << endl;
-	return 0;
+	//m_rtpSession.Destroy();
 }
 
-bool rtpVideo::queueVideo(VIDEOBUFFER *vb)
+void rtpVideo::getReceivedFrame(VIDEOBUFFER *videobuffer)
 {
-	bool res=false;
-	rtpMutex.lock();
-	if (videoToTx==0)
-	{
-		videoToTx=vb;
-//		if (eventCond)
-//			eventCond->wakeAll();
-		res=true;
-	}
-	rtpMutex.unlock();
-	return res;
+	m_rtpMutex.lock();
+	videobuffer->w = m_videoBuffer2.w;
+	videobuffer->h = m_videoBuffer2.h;
+	videobuffer->len = m_videoBuffer2.len;
+	memcpy(videobuffer->video, &m_videoBuffer2.video, m_videoBuffer2.len);
+	m_rtpMutex.unlock();
 }
 
-// Packetisation as per RFC 2190 Mode A
-void rtpVideo::transmitQueuedVideo()
-{
-	// TODO
-	// Currently we only allow one video frame outstanding between the app and the RTP stack. This should be
-	// ok as its only meant to produce 10-30 frames / second, and we should consume much quicker
-	rtpMutex.lock();
-	VIDEOBUFFER *queuedVideo = videoToTx;
-	rtpMutex.unlock();
-
-	if (queuedVideo)
+void rtpVideo::checkFrameSize(RTPPacket *pack)
+{//if we dont know the size of this frame yet, check it.
+	if (m_videoBuffer.w == 0 || m_videoBuffer.h == 0)
 	{
-		RTPPACKET videoPacket;
-		uchar *v = queuedVideo->video;
-		int queuedLen = queuedVideo->len;
-
-		txTimeStamp += 25000; // TODO --- fix this, this is a guessed-at value
-
-		videoPacket.RtpVPXCC = 128;
-		videoPacket.RtpMPT = videoPayload;
-		videoPacket.RtpTimeStamp = htonl(txTimeStamp);
-		videoPacket.RtpSourceID = 0x666;
-		H263_RFC2190_HDR *h263Hdr = (H263_RFC2190_HDR *)videoPacket.RtpData;
-		switch (queuedVideo->w)
+		H263_RFC2190_HDR *h263Hdr = (H263_RFC2190_HDR *)pack->GetPayloadData();
+		switch (H263HDR_GETSZ(h263Hdr->h263hdr))
 		{
-		case 704: h263Hdr->h263hdr = H263HDR(H263_SRC_4CIF); break;
+		case H263_SRC_4CIF:  m_videoBuffer.w = 704; m_videoBuffer.h = 576; break;
 		default:
-		case 352: h263Hdr->h263hdr = H263HDR(H263_SRC_CIF); break;
-		case 176: h263Hdr->h263hdr = H263HDR(H263_SRC_QCIF); break;
-		case 128: h263Hdr->h263hdr = H263HDR(H263_SRC_SQCIF); break;
+		case H263_SRC_CIF:   m_videoBuffer.w = 352; m_videoBuffer.h = 288; break;
+		case H263_SRC_QCIF:  m_videoBuffer.w = 176; m_videoBuffer.h = 144; break;
+		case H263_SRC_SQCIF: m_videoBuffer.w = 128; m_videoBuffer.h = 96;  break;
 		}
-
-		while (queuedLen > 0)
-		{
-			uint pkLen = queuedLen;
-			if (pkLen > H263SPACE)
-				pkLen = H263SPACE;
-
-			videoPacket.len = pkLen+sizeof(H263_RFC2190_HDR);
-			memcpy(videoPacket.RtpData+sizeof(H263_RFC2190_HDR), v, pkLen);
-			v += pkLen;
-			queuedLen -= pkLen;
-
-			//we have reached the last packet for this frame, so mark it
-			if (queuedLen == 0)
-				videoPacket.RtpMPT |= RTP_PAYLOAD_MARKER_BIT;  // Last packet has Marker bit set as per RFC 2190
-
-			sendPacket(videoPacket);
-			
-		}
-		freeVideoBuffer(queuedVideo);
+		//kdDebug() << "received new h263-size of:" << m_videoBuffer.w << "x" << m_videoBuffer.h << endl;
 	}
-	videoToTx = 0;
 }
 
-void rtpVideo::destroyVideoBuffers()
+void rtpVideo::handleOutgoingPackets()
 {
-	VIDEOBUFFER *buf = FreeVideoBufferQ.first();
-	while (buf)
+	if(transmitBuffer.isEmpty())
 	{
-		FreeVideoBufferQ.remove();
-		delete buf;
-		buf = FreeVideoBufferQ.current();
+		//kdDebug() << "buffer empty" << endl;
+		return;
 	}
-}
+	VIDEOBUFFER *queuedVideo;
 
-void rtpVideo::freeVideoBuffer(VIDEOBUFFER *vb)
-{
-	rtpMutex.lock();
-	FreeVideoBufferQ.append(vb);
-	rtpMutex.unlock();
-}
+	queuedVideo = transmitBuffer.first();
+	transmitBuffer.removeFirst();
 
-void rtpVideo::run()
-{
-	initialise();
-	openSocket();
-	
-	while(!killRtpThread)
-	{
-		// wait for the rtpSocket to have some data
-		//eventCond->wait();
-		
-		if (killRtpThread)
-			break;
-		
-		//TODO dirty hack... (prevents blocking)
-		if(bytesAvailable() > 40)
-		{
-			StreamInVideo();
-		}
-		
-		transmitQueuedVideo();
-		msleep(20);
-	}
 
-	if (videoToTx)
+	uchar RtpData[MAX_PAYLOAD_LENGTH];
+	uchar *v = queuedVideo->video;
+	int queuedLen = queuedVideo->len;
+
+	H263_RFC2190_HDR *h263Hdr = (H263_RFC2190_HDR *)&RtpData;
+	switch (queuedVideo->w)
 	{
-		freeVideoBuffer(videoToTx);
-		videoToTx = 0;
+	case 704: h263Hdr->h263hdr = H263HDR(H263_SRC_4CIF); break;
+	default:
+	case 352: h263Hdr->h263hdr = H263HDR(H263_SRC_CIF); break;
+	case 176: h263Hdr->h263hdr = H263HDR(H263_SRC_QCIF); break;
+	case 128: h263Hdr->h263hdr = H263HDR(H263_SRC_SQCIF); break;
 	}
 
-	VIDEOBUFFER *buf;
-	while ((buf = rxedVideoFrames.take(0)) != 0)
+	while (queuedLen > 0)
 	{
-		freeVideoBuffer(buf);
-	}
+		uint pkLen = queuedLen;
+		if (pkLen > H263SPACE)
+			pkLen = H263SPACE;
 
-	closeSocket();
-	if (pJitter)
-		delete pJitter;
-}
+		memcpy((char*)&RtpData+sizeof(H263_RFC2190_HDR), v, pkLen);
+		v += pkLen;
+		queuedLen -= pkLen;
 
-int rtpVideo::appendVideoPacket(VIDEOBUFFER *picture, int curLen, RTPPACKET *JBuf, int mLen)
-{
-	if ((curLen + mLen) <= (int)sizeof(picture->video))
-	{
-		H263_RFC2190_HDR *h263Hdr = (H263_RFC2190_HDR *)JBuf->RtpData;
-		int bitOffset = H263HDR_GETSBIT(h263Hdr->h263hdr);
-		if ((bitOffset == 0) || (curLen == 0))
-		{
-			memcpy(&picture->video[curLen], JBuf->RtpData+sizeof(H263_RFC2190_HDR), mLen);
-			curLen += mLen;
-		}
+		//we have reached the last packet for this frame, so mark it
+		if (queuedLen == 0)
+			m_status = m_rtpSession.SendPacket((char*)&RtpData,pkLen+sizeof(H263_RFC2190_HDR),m_payloadType,true/*marker*/,25000);
 		else
-		{
-			uchar mask = (0xFF >> bitOffset) << bitOffset;
-			picture->video[curLen-1] &= mask; // Keep most sig bits from last frame
-			picture->video[curLen-1] |= (*(JBuf->RtpData+sizeof(H263_RFC2190_HDR)) & (~mask));
-			memcpy(&picture->video[curLen], JBuf->RtpData+sizeof(H263_RFC2190_HDR)+1, mLen-1);
-			curLen += mLen-1;
-		}
+			m_status = m_rtpSession.SendPacket((char*)&RtpData,pkLen+sizeof(H263_RFC2190_HDR),m_payloadType,false/*marker*/,0);
 	}
-	return curLen;
 }
 
-void rtpVideo::StreamInVideo()
+void rtpVideo::queueVideoForTransmission(VIDEOBUFFER *videobuffer)
 {
-	RTPPACKET *JBuf;
-	int mLen, reason;
-	//TODO nice typo :D
-	bool MarketBitSet = false;
+	if(transmitBuffer.count() > 3)
+		return;
 
-	// Get a buffer from the Jitter buffer to put the packet in
-	while ( (JBuf = pJitter->GetJBuffer()) != 0 &&
-	( (JBuf->len = readPacket( (char *)&JBuf->RtpVPXCC, sizeof(RTPPACKET) ) ) > 0))
-	{
-		if (PAYLOAD(JBuf) == rtpMPT)
-		{
-			if (JBuf->RtpMPT & RTP_PAYLOAD_MARKER_BIT)
-				MarketBitSet = true;
+	VIDEOBUFFER *vb = new VIDEOBUFFER;
+	vb->w = videobuffer->w;
+	vb->h = videobuffer->h;
+	vb->len = videobuffer->len;
+	memcpy(vb->video, videobuffer->video, vb->len);
+	m_rtpMutex.lock();
+	transmitBuffer.append(vb);
+	m_rtpMutex.unlock();
+}
 
-			JBuf->RtpSequenceNumber = ntohs(JBuf->RtpSequenceNumber);
-			JBuf->RtpTimeStamp = ntohl(JBuf->RtpTimeStamp);
-			if (rxFirstFrame)
-			{
-				rxFirstFrame = FALSE;
-				videoFrameFirstSeqNum = rxSeqNum = JBuf->RtpSequenceNumber;
-			}
-			if (JBuf->RtpSequenceNumber < videoFrameFirstSeqNum)
-			{
-				kdDebug() << "Packet arrived too late to play, try increasing jitter buffer" << endl;
-				pJitter->FreeJBuffer(JBuf);
-			}
-			else
-				pJitter->InsertJBuffer(JBuf);
-		}
-		else
-		{
-			kdDebug() << "Received Invalid Payload " << (int)JBuf->RtpMPT << endl;
-			pJitter->FreeJBuffer(JBuf);
-		}
+void rtpVideo::handleIncomingPackets(RTPPacket *pack)
+{
+	if(pack->GetPayloadType() != m_payloadType)
+	{
+		kdDebug() << "Received invalid payloadType" << endl;
+		pack->Dump();
+		return;
 	}
 
-	if (JBuf == 0)
-		kdDebug() << "No free buffers, aborting network read" << endl;
+	//get the framesize for this frame... shouldnt chagne though
+	checkFrameSize(pack);
 
-	// Got a buffer but no received frames, free the buffer
-	else if (JBuf->len <= 0)
-		pJitter->FreeJBuffer(JBuf);
+	//this is the length of the actual h263-data without headers
+	h263_data_length = pack->GetPayloadLength() - sizeof(H263_RFC2190_HDR);
 
-	// Currently, whilst we buffer frames until the final one, we use receipt of the final frame
-	// to cause processing of all the received buffers. So any mis-orderering will cause problems!
-	// This should hopefully be flagged by the "VIDEOPKLATE" check above so we will know to fix it!
-	if (MarketBitSet)
+	//handle last packet for this frame
+	if(pack->HasMarker())
 	{
-		// Check if we have all packets in the sequence up until the marker
-		int vidLen = pJitter->GotAllBufsInFrame(rxSeqNum, sizeof(H263_RFC2190_HDR));
-		if (vidLen == 0)
+		//kdDebug() << "Got last packet for this frame" << endl;
+		memcpy(&m_videoBuffer.video[m_videoBuffer.len], (uchar*)pack->GetPayloadData()+sizeof(H263_RFC2190_HDR),h263_data_length);
+		m_videoBuffer.len += h263_data_length;
+
+		m_rtpMutex.lock();
+		m_videoBuffer2 = m_videoBuffer;
+		m_rtpMutex.unlock();
+
+		//since we have all packets for this frame, tell our parent about it.
+		if (m_parent)
+			QApplication::postEvent(m_parent, new rtpVideoEvent(rtpVideoEvent::newFrame));
+
+		//reset variables
+		m_videoBuffer.w = m_videoBuffer.h = m_videoBuffer.len = 0;
+	}
+	else//if no marker was set it can be the first packet of a frame or a packet from the middle
+	{
+		// Concatenate received IP packets into a picture buffer, checking we have all we parts
+		H263_RFC2190_HDR *h263Hdr = (H263_RFC2190_HDR *)pack->GetPayloadData();
+		h263_data_offset = H263HDR_GETSBIT(h263Hdr->h263hdr);
+		if(h263_data_offset == 0 || m_videoBuffer.len == 0)
 		{
-			kdDebug() << "RTP Dropping video frame: Lost Packet" << endl;
-			rxSeqNum = pJitter->DumpAllJBuffers(true) + 1;
+			memcpy(&m_videoBuffer.video[m_videoBuffer.len], (uchar*)pack->GetPayloadData()+sizeof(H263_RFC2190_HDR),h263_data_length);
+			m_videoBuffer.len += h263_data_length;
 		}
 		else
 		{
-			VIDEOBUFFER *picture = getVideoBuffer(vidLen);
-			if (picture)
-			{
-				int pictureIndex = 0;
-				bool markerSetOnLastPacket = false;
-				picture->w = picture->h = 0;
-
-				// Concatenate received IP packets into a picture buffer, checking we have all we parts
-				while ((JBuf = pJitter->DequeueJBuffer(rxSeqNum, reason)) != 0)
-				{
-					++rxSeqNum;
-					mLen = JBuf->len - RTP_HEADER_SIZE - sizeof(H263_RFC2190_HDR);
-					rxTimestamp += mLen;
-					pictureIndex = appendVideoPacket(picture, pictureIndex, JBuf, mLen);
-					if (JBuf->RtpMPT & RTP_PAYLOAD_MARKER_BIT)
-					{
-						markerSetOnLastPacket = true;
-					}
-					if (picture->w == 0)
-					{
-						H263_RFC2190_HDR *h263Hdr = (H263_RFC2190_HDR *)JBuf->RtpData;
-						switch (H263HDR_GETSZ(h263Hdr->h263hdr))
-						{
-						case H263_SRC_4CIF:  picture->w = 704; picture->h = 576; break;
-						default:
-						case H263_SRC_CIF:   picture->w = 352; picture->h = 288; break;
-						case H263_SRC_QCIF:  picture->w = 176; picture->h = 144; break;
-						case H263_SRC_SQCIF: picture->w = 128; picture->h = 96;  break;
-						}
-					}
-					pJitter->FreeJBuffer(JBuf);
-				}
-
-				// Check rxed frame was not too big
-				if (pictureIndex > (int)sizeof(picture->video))
-				{
-					kdDebug() << "Received video frame size " << pictureIndex << "; too big for buffer" << endl;
-					freeVideoBuffer(picture);
-					picture = 0;
-				}
-
-				// Now pass the received picture up to the higher layer. If the last packet has the marker bit set
-				// then we have received a full pictures worth of packets.
-				else if (markerSetOnLastPacket)
-				{
-					picture->len = pictureIndex;
-
-					// Pass received picture to app
-					rtpMutex.lock();
-					if (rxedVideoFrames.count() < 3)    // Limit no of buffes tied up queueing to app
-					{
-						rxedVideoFrames.append(picture);
-						rtpMutex.unlock();
-					}
-					else
-					{
-						rtpMutex.unlock();
-						freeVideoBuffer(picture);
-						kdDebug() << "Discarding frame, app consuming too slowly" << endl;
-					}
-					if (m_parent)
-						QApplication::postEvent(m_parent, new rtpVideoEvent(rtpVideoEvent::newFrame));
-					picture = 0;
-				}
-				else
-				{
-					// We didn't get the whole frame, so dump all buffered packets
-					kdDebug() << "RTP Dropping video frame: ";
-					switch (reason)
-					{
-					case JB_REASON_DUPLICATE:
-						kdDebug() << "Duplicate" << endl;
-						break;
-					case JB_REASON_DTMF:
-						break;
-						kdDebug() << "DTMF" << endl;
-					case JB_REASON_MISSING:
-						kdDebug() << "Missed Packets" << endl;
-						break;
-					case JB_REASON_EMPTY:
-						kdDebug() << "Empty" << endl;
-						break;
-					case JB_REASON_SEQERR:
-						kdDebug() << "Sequence Error" << endl;
-						break;
-					default:
-						kdDebug() << "Unknown" << endl;
-						break;
-					}
-					rxSeqNum = pJitter->DumpAllJBuffers(true) + 1;
-					freeVideoBuffer(picture);
-					picture = 0;
-				}
-			}
-			else
-			{
-				kdDebug() << "No buffers for video frame, dropping" << endl;
-				rxSeqNum = pJitter->DumpAllJBuffers(true) + 1;
-			}
+			uchar mask = (0xFF >> h263_data_offset) << h263_data_offset;
+			m_videoBuffer.video[m_videoBuffer.len-1] &= mask; // Keep most sig bits from last frame
+			m_videoBuffer.video[m_videoBuffer.len-1] |= (*(pack->GetPayloadData()+sizeof(H263_RFC2190_HDR)) & (~mask));
+			memcpy(&m_videoBuffer.video[m_videoBuffer.len], pack->GetPayloadData()+sizeof(H263_RFC2190_HDR)+1, h263_data_length-1);
+			m_videoBuffer.len += h263_data_length-1;
 		}
-		videoFrameFirstSeqNum = rxSeqNum;
 	}
 }
-

Modified: konference/src/rtp/rtpvideo.h
===================================================================
--- konference/src/rtp/rtpvideo.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/rtp/rtpvideo.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -22,19 +22,26 @@
 
 #include <qptrlist.h>
 #include <qevent.h>
+#include <qthread.h>
 
-#include "rtpbase.h"
+#include "rtpsession.h"
 
+#define IP_MTU                    1290     // Max size of txed RTP packet. Standard MTU is 1500, leave some room for IPSec etc
+#define IP_MAX_MTU                1500     // Max size of rxed RTP packet
+#define RTP_HEADER_SIZE           12
+#define UDP_HEADER_SIZE           28
+
 typedef struct
 {
 	ulong h263hdr;
 }
 H263_RFC2190_HDR;
 
+
 #define H263HDR(s)              ((s)<<13)
 #define H263HDR_GETSZ(h)        (((h)>>13) & 0x7)
 #define H263HDR_GETSBIT(h)      (((h)>>3) & 0x7)
-#define H263HDR_GETEBIT(h)      ((h) & 0x7)
+//#define H263HDR_GETEBIT(h)      ((h) & 0x7)
 
 #define H263_SRC_SQCIF          1
 #define H263_SRC_QCIF           2
@@ -43,7 +50,8 @@
 #define H263_SRC_16CIF          5
 
 
-#define H263SPACE               (IP_MTU-RTP_HEADER_SIZE-UDP_HEADER_SIZE-sizeof(H263_RFC2190_HDR))
+#define H263SPACE          (IP_MTU-RTP_HEADER_SIZE-UDP_HEADER_SIZE-sizeof(H263_RFC2190_HDR))
+#define MAX_PAYLOAD_LENGTH (IP_MTU-RTP_HEADER_SIZE-UDP_HEADER_SIZE)
 
 #define MAX_VIDEO_LEN 256000
 
@@ -58,54 +66,53 @@
 class rtpVideoEvent : public QCustomEvent
 {
 public:
-    enum type { newFrame = (QEvent::User + 300)};
-    rtpVideoEvent(type t) : QCustomEvent(t) {}
+	enum type{newFrame};
+	rtpVideoEvent(type t) : QCustomEvent(t) {};
 };
 
 /**
- at author Malte B?hme
-*/
-class rtpVideo : public rtpBase, QThread
+ * class that handles video-rtp hgandling/transmission.
+ * This class also handles (de-)packetization for h263 frames.
+ * currently only h263 is supported.
+ * when a new frame is received,rtpVideoEvent::newFrame is postet
+ * to the parent object. get a received frame through getReceivedFrame()
+ * queueVideoForTransmission() enqueues frames for transmission.
+ *
+ * @author Malte B?hme
+ */
+class rtpVideo : public QThread
 {
 public:
-	rtpVideo(QObject *parent, int localPort, QString remoteIP, int remotePort, int mediaPay, rtpTxMode txm, rtpRxMode rxm);
-	VIDEOBUFFER *getRxedVideo();
-	VIDEOBUFFER *getVideoBuffer(int len=0);
-	bool queueVideo(VIDEOBUFFER *vb);
-	void freeVideoBuffer(VIDEOBUFFER *vb);
-	void destroyVideoBuffers();
-	void transmitQueuedVideo();
-	void initialise();
+	rtpVideo(QObject *parent, int localPort, QString remoteIP, int remotePort, int payloadType, float fps);
 	~rtpVideo();
 	void run();
-	void StreamInVideo();
-	int  appendVideoPacket(VIDEOBUFFER *picture, int curLen, RTPPACKET *JBuf, int mLen);
+	void stop(){m_killThread = true;};
+	/**
+	 * Writes the new frame to videobuffer
+	 * the data is memcpy'ed to the videobuffer.
+	 */
+	void getReceivedFrame(VIDEOBUFFER *videobuffer);
+	/**
+	 * Enqueues a videobuffer for transmission
+	 * the data is memcpy'ed from the videobuffer.
+	 */
+	void queueVideoForTransmission(VIDEOBUFFER *videobuffer);
+private:
+	void handleIncomingPackets(RTPPacket *pack);
+	void handleOutgoingPackets();
 
-protected:
+	void checkFrameSize(RTPPacket *pack);
+	int m_status;//used for jrtplib-error-checks
+	int h263_data_length;//lenght of actual h263-data in the rtp packet (excluding rtp and h263 headers)
+	int h263_data_offset;
+	RTPSession m_rtpSession;
+	bool m_killThread;
+	int m_payloadType;
+	VIDEOBUFFER m_videoBuffer;
+	VIDEOBUFFER m_videoBuffer2;
+	QPtrList<VIDEOBUFFER> transmitBuffer;
 	QObject *m_parent;
-	
-	Jitter *pJitter;
-
-	int videoPayload;
-	QPtrList<VIDEOBUFFER> FreeVideoBufferQ;
-	QPtrList<VIDEOBUFFER> rxedVideoFrames;
-	VIDEOBUFFER *videoToTx;
-	int videoFrameFirstSeqNum;
-
-	rtpTxMode txMode;
-	rtpRxMode rxMode;
-
-	unsigned long txTimeStamp;
-	
-	unsigned long rxTimestamp;
-	unsigned short rxSeqNum;
-
-	bool rxFirstFrame;
-
-	bool killRtpThread;
-
-	uchar rtpMarker;
-	uchar rtpMPT;
+	QMutex m_rtpMutex;
 };
 
 #endif

Modified: konference/src/sip/sipfsm.cpp
===================================================================
--- konference/src/sip/sipfsm.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/sip/sipfsm.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -35,39 +35,495 @@
 #ifndef WIN32
 #include <sys/ioctl.h>
 #include <unistd.h>
+//#include <pthread.h>
 #include <netdb.h>
 #include <netinet/in.h>
 #include <net/if.h>
-
+//#include <linux/sockios.h>
+//#include <linux/videodev.h>
+//#include <mythtv/mythcontext.h>
 #include "config.h"
 #endif
 
+//#ifdef WIN32
+//#include <winsock2.h>
+//#include "gcontext.h"
+//#endif
+
 using namespace std;
 
 #include "sipfsm.h"
 #include "sipsdp.h"
 #include "sipxpidf.h"
-#include "sipthread.h"
-#include "sipfsmbase.h"
-#include "sipcall.h"
 
 // Static variables for the debug file used
+QFile *debugFile;
+QTextStream *debugStream;
+QObject *eventWindow;
+QStringList EventQ;
+QStringList NotifyQ;
+QMutex EventQLock;
+QString localIp;
+QString natIp;
 
+
+
 /**********************************************************************
+SipContainer
+ 
+This is a container class that runs the SIP protocol stack within a 
+separate thread and controls communication with it. This is done
+such that the SIP protocol stack can run in the background regardless
+of which Myth frontend has focus.
+ 
+**********************************************************************/
+
+SipContainer::SipContainer(int listenPort)
+{
+	killSipThread = false;
+	CallState = -1;
+	eventWindow = 0;
+
+	sipThread = new SipThread(this);
+	sipThread->start();
+}
+
+SipContainer::~SipContainer()
+{
+	killSipThread = true;
+	sipThread->wait();
+	delete sipThread;
+}
+
+void SipContainer::PlaceNewCall(QString Mode, QString uri, QString name, bool disableNat)
+{
+	EventQLock.lock();
+	EventQ.append("PLACECALL");
+	EventQ.append(Mode);
+	EventQ.append(uri);
+	EventQ.append(name);
+	EventQ.append(disableNat ? "DisableNAT" : "EnableNAT");
+	EventQLock.unlock();
+}
+
+void SipContainer::AnswerRingingCall(QString Mode, bool disableNat)
+{
+	EventQLock.lock();
+	EventQ.append("ANSWERCALL");
+	EventQ.append(Mode);
+	EventQ.append(disableNat ? "DisableNAT" : "EnableNAT");
+	EventQLock.unlock();
+}
+
+void SipContainer::HangupCall()
+{
+	EventQLock.lock();
+	EventQ.append("HANGUPCALL");
+	EventQLock.unlock();
+}
+
+void SipContainer::UiOpened(QObject *callingApp)
+{
+	EventQLock.lock();
+	eventWindow = callingApp;
+	EventQ.append("UIOPENED");
+	EventQLock.unlock();
+}
+
+void SipContainer::UiClosed()
+{
+	EventQLock.lock();
+	eventWindow = 0;
+	EventQ.append("UICLOSED");
+	EventQLock.unlock();
+}
+
+void SipContainer::UiWatch(QStrList uriList)
+{
+	QStrListIterator it(uriList);
+
+	EventQLock.lock();
+	EventQ.append("UIWATCH");
+	for (; it.current(); ++it)
+		EventQ.append(it.current());
+	EventQ.append("");
+	EventQLock.unlock();
+}
+
+void SipContainer::UiWatch(QString uri)
+{
+	EventQLock.lock();
+	EventQ.append("UIWATCH");
+	EventQ.append(uri);
+	EventQ.append("");
+	EventQLock.unlock();
+}
+
+void SipContainer::UiStopWatchAll()
+{
+	EventQLock.lock();
+	EventQ.append("UISTOPWATCHALL");
+	EventQLock.unlock();
+}
+
+QString SipContainer::UiSendIMMessage(QString DestUrl, QString CallId, QString Msg)
+{
+	SipCallId sipCallId;
+
+	if (CallId.length() == 0)
+	{
+		sipCallId.Generate(localIp);
+		CallId = sipCallId.string();
+	}
+
+	EventQLock.lock();
+	EventQ.append("SENDIM");
+	EventQ.append(DestUrl);
+	EventQ.append(CallId);
+	EventQ.append(Msg);
+	EventQLock.unlock();
+	return CallId;
+}
+
+
+int SipContainer::GetSipState()
+{
+	int tempState;
+	EventQLock.lock();
+	tempState = CallState;
+	EventQLock.unlock();
+	return tempState;
+}
+
+bool SipContainer::GetNotification(QString &type, QString &url, QString &param1, QString &param2)
+{
+	bool notifyFlag = false;
+	EventQLock.lock();
+
+	if (!NotifyQ.empty())
+	{
+		QStringList::Iterator it;
+		notifyFlag = true;
+		it = NotifyQ.begin();
+		type = *it;
+		it = NotifyQ.remove(it);
+		url = *it;
+		it = NotifyQ.remove(it);
+		param1 = *it;
+		it = NotifyQ.remove(it);
+		param2 = *it;
+		NotifyQ.remove(it);
+	}
+
+	EventQLock.unlock();
+	return notifyFlag;
+}
+
+void SipContainer::GetRegistrationStatus(bool &Registered, QString &RegisteredTo, QString &RegisteredAs)
+{
+	EventQLock.lock();
+	Registered = regStatus;
+	RegisteredTo = regTo;
+	RegisteredAs = regAs;
+	EventQLock.unlock();
+}
+
+void SipContainer::GetIncomingCaller(QString &u, QString &d, QString &l, bool &a)
+{
+	EventQLock.lock();
+	u = callerUser;
+	d = callerName;
+	l = callerUrl;
+	a = inAudioOnly;
+	EventQLock.unlock();
+}
+
+void SipContainer::GetSipSDPDetails(QString &ip, int &aport, int &audPay, QString &audCodec, int &dtmfPay, int &vport, int &vidPay, QString &vidCodec, QString &vidRes)
+{
+	EventQLock.lock();
+	ip = remoteIp;
+	aport = remoteAudioPort;
+	vport = remoteVideoPort;
+	audPay = audioPayload;
+	audCodec = audioCodec;
+	dtmfPay = dtmfPayload;
+	vidPay = videoPayload;
+	vidCodec = videoCodec;
+	vidRes = videoRes;
+	EventQLock.unlock();
+}
+
+QString SipContainer::getLocalIpAddress()
+{
+	return localIp;
+}
+
+QString SipContainer::getNatIpAddress()
+{
+	return natIp;
+}
+
+
+/**********************************************************************
+SipThread
+ 
+The main SIP thread that polls for events and handles communication
+with the user via the SipContainer class
+**********************************************************************/
+
+void SipThread::run()
+{
+	SipThreadWorker();
+}
+
+void SipThread::SipThreadWorker()
+{
+	FrontEndActive = false;
+	rnaTimer = -1;
+	// Open a file for writing debug info into
+	char *homeDir = getenv("HOME");
+	QString debugFileName = QString(homeDir) + "/.mythtv/MythPhone/siplog.txt";
+	debugFile = new QFile(debugFileName);
+	if (debugFile->open(IO_WriteOnly))
+		debugStream = new QTextStream (debugFile);
+
+	SipFsm *sipFsm = new SipFsm();
+
+	if (sipFsm->SocketOpenedOk())
+	{
+		while(!sipContainer->killThread())
+		{
+			int OldCallState = CallState;
+
+			// This blocks for timeout or data in Linux
+			CheckNetworkEvents(sipFsm);
+			CheckUIEvents(sipFsm);
+			CheckRegistrationStatus(sipFsm); // Probably don't need to do this every 1/2 sec but this is a fallout of a non event-driven arch.
+			sipFsm->HandleTimerExpiries();
+			ChangePrimaryCallState(sipFsm, sipFsm->getPrimaryCallState());
+
+			// A Ring No Answer timer runs to send calls to voicemail after x seconds
+			if ((CallState == SIP_ICONNECTING) && (rnaTimer != -1))
+			{
+				if (--rnaTimer < 0)
+				{
+					rnaTimer = -1;
+					//vxmlCallActive = true;
+					sipFsm->Answer(true, "", false);
+				}
+			}
+
+			ChangePrimaryCallState(sipFsm, sipFsm->getPrimaryCallState());
+
+			EventQLock.lock();
+			if ((OldCallState != CallState) && (eventWindow))
+				QApplication::postEvent(eventWindow, new SipEvent(SipEvent::SipStateChange));
+			EventQLock.unlock();
+		}
+	}
+
+	delete sipFsm;
+	if (debugStream)
+		delete debugStream;
+	if (debugFile)
+	{
+		debugFile->close();
+		delete debugFile;
+	}
+}
+
+void SipThread::CheckUIEvents(SipFsm *sipFsm)
+{
+	QString event;
+	QStringList::Iterator it;
+
+	// Check why we awoke
+	event = "";
+	EventQLock.lock();
+	if (!EventQ.empty())
+	{
+		it = EventQ.begin();
+		event = *it;
+		EventQ.remove(it);
+	}
+	EventQLock.unlock();
+
+	if (event == "PLACECALL")
+	{
+		EventQLock.lock();
+		it = EventQ.begin();
+		QString Mode = *it;
+		it = EventQ.remove(it);
+		QString Uri = *it;
+		it = EventQ.remove(it);
+		QString Name = *it;
+		it = EventQ.remove(it);
+		QString UseNat = *it;
+		EventQ.remove(it);
+		EventQLock.unlock();
+		sipFsm->NewCall(Mode == "AUDIOONLY" ? true : false, Uri, Name, Mode, UseNat == "DisableNAT" ? true : false);
+	}
+	else if (event == "ANSWERCALL")
+	{
+		EventQLock.lock();
+		it = EventQ.begin();
+		QString Mode = *it;
+		it = EventQ.remove(it);
+		QString UseNat = *it;
+		EventQ.remove(it);
+		EventQLock.unlock();
+		sipFsm->Answer(Mode == "AUDIOONLY" ? true : false, Mode, UseNat == "DisableNAT" ? true : false);
+	}
+	else if (event == "HANGUPCALL")
+		sipFsm->HangUp();
+	else if (event == "UIOPENED")
+	{
+		sipFsm->StatusChanged("OPEN");
+		FrontEndActive = true;
+	}
+	else if (event == "UICLOSED")
+	{
+		sipFsm->StatusChanged("CLOSED");
+		FrontEndActive = false;
+	}
+	else if (event == "UIWATCH")
+	{
+		QString uri;
+		do
+		{
+			EventQLock.lock();
+			it = EventQ.begin();
+			uri = *it;
+			EventQ.remove(it);
+			EventQLock.unlock();
+			if (uri.length() > 0)
+				sipFsm->CreateWatcherFsm(uri);
+		}
+		while (uri.length() > 0);
+	}
+	else if (event == "UISTOPWATCHALL")
+		sipFsm->StopWatchers();
+	else if (event == "SENDIM")
+	{
+		EventQLock.lock();
+		it = EventQ.begin();
+		QString DestUrl = *it;
+		it = EventQ.remove(it);
+		QString CallId = *it;
+		it = EventQ.remove(it);
+		QString imMsg = *it;
+		EventQ.remove(it);
+		EventQLock.unlock();
+		sipFsm->SendIM(DestUrl, CallId, imMsg);
+	}
+
+	ChangePrimaryCallState(sipFsm, sipFsm->getPrimaryCallState());
+}
+
+void SipThread::CheckRegistrationStatus(SipFsm *sipFsm)
+{
+	sipContainer->notifyRegistrationStatus(sipFsm->isRegistered(), sipFsm->registeredTo(),
+	                                       sipFsm->registeredAs());
+}
+
+void SipThread::CheckNetworkEvents(SipFsm *sipFsm)
+{
+	// Check for incoming SIP messages
+	sipFsm->CheckRxEvent();
+
+	// We only handle state changes in the "primary" call; we ignore additional calls which are
+	// currently just rejected with busy
+	ChangePrimaryCallState(sipFsm, sipFsm->getPrimaryCallState());
+}
+
+
+void SipThread::ChangePrimaryCallState(SipFsm *sipFsm, int NewState)
+{
+	int OldState = CallState;
+	CallState = NewState;
+	sipContainer->notifyCallState(CallState);
+
+	if (OldState != CallState)
+	{
+		if (CallState == SIP_IDLE)
+		{
+			callerUser = "";
+			callerName = "";
+			callerUrl = "";
+			inAudioOnly = true;
+			sipContainer->notifyCallerDetails(callerUser, callerName, callerUrl, inAudioOnly);
+			remoteIp = "0.0.0.0";
+			remoteAudioPort = -1;
+			remoteVideoPort = -1;
+			audioPayload = -1;
+			dtmfPayload = -1;
+			videoPayload = -1;
+			audioCodec = "";
+			videoCodec = "";
+			videoRes = "";
+			sipContainer->notifySDPDetails(remoteIp, remoteAudioPort, audioPayload, audioCodec, dtmfPayload, remoteVideoPort, videoPayload, videoCodec, videoRes);
+		}
+
+		if (CallState == SIP_ICONNECTING)
+		{
+			// new incoming call; get the caller info
+			EventQLock.lock();
+			SipCall *call = sipFsm->MatchCall(sipFsm->getPrimaryCall());
+			if (call != 0)
+			{
+				call->GetIncomingCaller(callerUser, callerName, callerUrl, inAudioOnly);
+				sipContainer->notifyCallerDetails(callerUser, callerName, callerUrl, inAudioOnly);
+			}
+			EventQLock.unlock();
+
+			rnaTimer = 10;//TODO atoi((const char *)gContext->GetSetting("TimeToAnswer")) * SIP_POLL_PERIOD;
+		}
+		else
+			rnaTimer = -1;
+
+
+		if (CallState == SIP_CONNECTED)
+		{
+			// connected call; get the SDP info
+			EventQLock.lock();
+			SipCall *call = sipFsm->MatchCall(sipFsm->getPrimaryCall());
+			if (call != 0)
+			{
+				call->GetSdpDetails(remoteIp, remoteAudioPort, audioPayload, audioCodec, dtmfPayload, remoteVideoPort, videoPayload, videoCodec, videoRes);
+				sipContainer->notifySDPDetails(remoteIp, remoteAudioPort, audioPayload, audioCodec, dtmfPayload, remoteVideoPort, videoPayload, videoCodec, videoRes);
+
+			}
+			EventQLock.unlock();
+
+		}
+
+		//TODO sipstack should not have to know anything about the gui!!!
+		if ((CallState == SIP_ICONNECTING) && (FrontEndActive == false))
+		{
+			// No application running to tell of the incoming call
+			// Either alert via on-screen popup or send to voicemail
+			//			SipNotify *notify = new SipNotify();
+			//			notify->Display(callerName, callerUrl);
+			//			delete notify;
+		}
+	}
+}
+
+
+/**********************************************************************
 SipFsm
  
 This class forms the container class for the SIP FSM, and creates call
 instances which handle actual events.
 **********************************************************************/
 
-SipFsm::SipFsm(SipContainer *container, QWidget *parent, const char *name)
+SipFsm::SipFsm(QWidget *parent, const char *name)
 		: QWidget( parent, name )
 {
 	callCount = 0;
 	primaryCall = -1;
 	PresenceStatus = "CLOSED";
-	m_sipContainer = container;
-	
+
 	sipSocket = 0;
 	localPort = 5060;//TODO atoi((const char *)gContext->GetSetting("SipLocalPort"));
 
@@ -75,7 +531,7 @@
 	natIp = DetermineNatAddress();
 	if (natIp.length() == 0)
 		natIp = localIp;
-//	SipFsm::Debug(SipDebugEvent::SipDebugEv, QString("SIP listening on IP Address ") + localIp + ":" + QString::number(localPort) + " NAT address " + natIp + "\n\n");
+	SipFsm::Debug(SipDebugEvent::SipDebugEv, QString("SIP listening on IP Address ") + localIp + ":" + QString::number(localPort) + " NAT address " + natIp + "\n\n");
 	cout << "SIP listening on IP Address " << localIp << ":" << localPort << " NAT address " << natIp << endl;
 
 	// Create the timer list
@@ -85,13 +541,17 @@
 	sipRegistrar = new SipRegistrar(this, "maldn", localIp, localPort);
 
 	// if Proxy Registration is configured ...
-	bool RegisterWithProxy = true;//TODO gContext->GetNumSetting("SipRegisterWithProxy",1);
+	bool RegisterWithProxy = false;//TODO gContext->GetNumSetting("SipRegisterWithProxy",1);
 	sipRegistration = 0;
 	if (RegisterWithProxy)
 	{
 		QString ProxyDNS = "sipgate.de";//TODO gContext->GetSetting("SipProxyName");
 		QString ProxyUsername = "8925303";//TODO gContext->GetSetting("SipProxyAuthName");
-		QString ProxyPassword = "wonttellyou :-)";//TODO gContext->GetSetting("SipProxyAuthPassword");
+		QString ProxyPassword = "DKTYHV";//TODO gContext->GetSetting("SipProxyAuthPassword");
+		//QString ProxyDNS = "fwd.pulver.com";//TODO gContext->GetSetting("SipProxyName");
+		//QString ProxyUsername = "603123";//TODO gContext->GetSetting("SipProxyAuthName");
+		//QString ProxyPassword = "loppy";//TODO gContext->GetSetting("SipProxyAuthPassword");
+		
 		if ((ProxyDNS.length() > 0) && (ProxyUsername.length() > 0) && (ProxyPassword.length() > 0))
 		{
 			sipRegistration = new SipRegistration(this, natIp, localPort, ProxyUsername, ProxyPassword, ProxyDNS, 5060);
@@ -113,6 +573,17 @@
 	CloseSocket();
 }
 
+void SipFsm::Debug(SipDebugEvent::Type t, QString dbg)
+{
+#ifdef WIN32
+	if (eventWindow)
+		QApplication::postEvent(eventWindow, new SipDebugEvent(t, dbg));
+#else
+	if ((debugStream) && ((t == SipDebugEvent::SipTraceRxEv) || (t == SipDebugEvent::SipTraceTxEv)))
+		*debugStream << dbg;
+#endif
+}
+
 QString SipFsm::OpenSocket(int Port)
 {
 	sipSocket = new QSocketDevice (QSocketDevice::Datagram);
@@ -156,8 +627,8 @@
 QString SipFsm::DetermineNatAddress()
 {
 	QString natIP = "";
-	QString NatTraversalMethodStr = "None";//TODO gContext->GetSetting("NatTraversalMethod");
-
+	//QString NatTraversalMethodStr = "Web Server";//TODO gContext->GetSetting("NatTraversalMethod");
+	QString NatTraversalMethodStr = "Manual";
 	if (NatTraversalMethodStr == "Manual")
 	{
 		//TODO natIP = gContext->GetSetting("NatIpAddress");
@@ -241,7 +712,7 @@
 	{
 		QHostAddress dest;
 		dest.setAddress(destIP);
-		//SipFsm::Debug(SipDebugEvent::SipTraceTxEv, QDateTime::currentDateTime().toString() + " Sent to " + destIP + ":" + QString::number(destPort) + "...\n" + Msg + "\n");
+		SipFsm::Debug(SipDebugEvent::SipTraceTxEv, QDateTime::currentDateTime().toString() + " Sent to " + destIP + ":" + QString::number(destPort) + "...\n" + Msg + "\n");
 		sipSocket->writeBlock((const char *)Msg, Msg.length(), dest, destPort);
 	}
 	else
@@ -257,7 +728,7 @@
 		if (len > 0)
 		{
 			rxMsg[len] = 0;
-			//SipFsm::Debug(SipDebugEvent::SipTraceRxEv, QDateTime::currentDateTime().toString() + " Received: Len " + QString::number(len) + "\n" + rxMsg + "\n");
+			SipFsm::Debug(SipDebugEvent::SipTraceRxEv, QDateTime::currentDateTime().toString() + " Received: Len " + QString::number(len) + "\n" + rxMsg + "\n");
 			sipMsg.decode(rxMsg);
 			return true;
 		}
@@ -400,14 +871,17 @@
 
 void SipFsm::SetNotification(QString type, QString uri, QString param1, QString param2)
 {
-	m_sipContainer->getEventQueueMutex()->lock();
-		m_sipContainer->getNotifyQueue()->append(type);
-		m_sipContainer->getNotifyQueue()->append(uri);
-		m_sipContainer->getNotifyQueue()->append(param1);
-		m_sipContainer->getNotifyQueue()->append(param2);
+	EventQLock.lock();
+	if (eventWindow) // Is there someone listening?
+	{
+		NotifyQ.append(type);
+		NotifyQ.append(uri);
+		NotifyQ.append(param1);
+		NotifyQ.append(param2);
 
-		QApplication::postEvent(m_sipContainer->getParent(), new SipEvent(SipEvent::SipNotification));
-	m_sipContainer->getEventQueueMutex()->unlock();
+		QApplication::postEvent(eventWindow, new SipEvent(SipEvent::SipNotification));
+	}
+	EventQLock.unlock();
 }
 
 
@@ -455,7 +929,7 @@
 	SipFsmBase *it;
 	for (it=FsmList.first(); it; it=FsmList.next())
 		if ((it->type() == "CALL") && (it->getCallRef() == cr))
-			return (dynamic_cast<SipCall *>(it));//TODO
+			return (dynamic_cast<SipCall *>(it));
 	return 0;
 }
 
@@ -588,7 +1062,900 @@
 			it->FSM(SIP_PRESENCE_CHANGE, 0, newStatus);
 }
 
+
+
+
 /**********************************************************************
+SipFsmBase
+ 
+A base class for FSM which defines a set of default procedures that are
+used by the derived classes.
+**********************************************************************/
+
+SipFsmBase::SipFsmBase(SipFsm *p)
+{
+	parent = p;
+	remoteUrl = 0;
+	toUrl = 0;
+	contactUrl = 0;
+	recRouteUrl = 0;
+	remoteTag = "";
+	remoteEpid = "";
+	rxedTo = "";
+	rxedFrom = "";
+	MyUrl = 0;
+	MyContactUrl = 0;
+	sentAuthenticated = false;
+}
+
+SipFsmBase::~SipFsmBase()
+{
+	if (remoteUrl != 0)
+		delete remoteUrl;
+	if (toUrl != 0)
+		delete toUrl;
+	if (contactUrl != 0)
+		delete contactUrl;
+	if (recRouteUrl != 0)
+		delete recRouteUrl;
+	if (MyUrl != 0)
+		delete MyUrl;
+	if (MyContactUrl != 0)
+		delete MyContactUrl;
+
+	remoteUrl = 0;
+	toUrl = 0;
+	contactUrl = 0;
+	recRouteUrl = 0;
+	MyUrl = 0;
+	MyContactUrl = 0;
+}
+
+bool SipFsmBase::Retransmit(bool force)
+{
+	if (force || (t1 < 8000))
+	{
+		t1 *= 2;
+		if ((retx.length() > 0) && (retxIp.length() > 0))
+		{
+			parent->Transmit(retx, retxIp, retxPort);
+			return true;
+		}
+	}
+	return false;
+}
+
+void SipFsmBase::ParseSipMsg(int Event, SipMsg *sipMsg)
+{
+	// Pull out Remote TAG
+	remoteTag = (SIP_CMD(Event)) ? sipMsg->getFromTag() : sipMsg->getToTag();
+	remoteEpid = (SIP_CMD(Event)) ? sipMsg->getFromEpid() : QString("");
+
+	// Pull out VIA, To and From information from CMDs to send back in Status
+	if (SIP_CMD(Event))
+	{
+		rxedTo   = sipMsg->getCompleteTo();
+		rxedFrom = sipMsg->getCompleteFrom();
+		RecRoute = sipMsg->getCompleteRR();
+		Via      = sipMsg->getCompleteVia();
+		CallId   = *(sipMsg->getCallId());
+		viaIp    = sipMsg->getViaIp();
+		viaPort  = sipMsg->getViaPort();
+		if (remoteUrl == 0)
+			remoteUrl = new SipUrl(sipMsg->getFromUrl());
+		if (toUrl == 0)
+			toUrl = new SipUrl(sipMsg->getToUrl());
+	}
+
+	// Pull out Contact info
+	SipUrl *s;
+	if ((s = sipMsg->getContactUrl()) != 0)
+	{
+		if (contactUrl)
+			delete contactUrl;
+		contactUrl = new SipUrl(s);
+	}
+
+	// Pull out Record Route info
+	if ((s = sipMsg->getRecRouteUrl()) != 0)
+	{
+		if (recRouteUrl)
+			delete recRouteUrl;
+		recRouteUrl = new SipUrl(s);
+	}
+}
+
+void SipFsmBase::BuildSendStatus(int Code, QString Method, int statusCseq, int Option, int statusExpires, QString sdp)
+{
+	if (remoteUrl == 0)
+	{
+		cerr << "URL variables not setup\n";
+		return;
+	}
+
+	SipMsg Status(Method);
+	Status.addStatusLine(Code);
+	if (RecRoute.length() > 0)
+		Status.addRRCopy(RecRoute);
+	if (Via.length() > 0)
+		Status.addViaCopy(Via);
+	Status.addFromCopy(rxedFrom);
+	Status.addToCopy(rxedTo);
+	Status.addCallId(&CallId);
+	Status.addCSeq(statusCseq);
+	if ((Option & SIP_OPT_EXPIRES) && (statusExpires >= 0))
+		Status.addExpires(statusExpires);
+
+	if (Option & SIP_OPT_ALLOW) // Add my Contact URL to the message
+		Status.addAllow();
+	if (Option & SIP_OPT_CONTACT) // Add my Contact URL to the message
+		Status.addContact(*MyContactUrl);
+	if (Option & SIP_OPT_SDP) // Add an SDP to the message
+		Status.addContent("application/sdp", sdp);
+	else
+		Status.addNullContent();
+
+	// Send STATUS messages to the VIA address
+	parent->Transmit(Status.string(), retxIp = viaIp, retxPort = viaPort);
+
+	if (((Code >= 200) && (Code <= 299)) && (Method == "INVITE"))
+	{
+		retx = Status.string();
+		t1 = 500;
+		(parent->Timer())->Start(this, t1, SIP_RETX);
+	}
+}
+
+
+void SipFsmBase::DebugFsm(int event, int old_state, int new_state)
+{
+	SipFsm::Debug(SipDebugEvent::SipDebugEv, "SIP FSM: Event " + EventtoString(event) + " : "
+	              + StatetoString(old_state) + " -> " + StatetoString(new_state) + "\n");
+}
+
+
+QString SipFsmBase::EventtoString(int Event)
+{
+	switch (Event)
+	{
+	case SIP_OUTCALL:             return "OUTCALL";
+	case SIP_REGISTER:            return "REGISTER";
+	case SIP_INVITE:              return "INVITE";
+	case SIP_INVITESTATUS_3456xx: return "INVST-3456xx";
+	case SIP_INVITESTATUS_2xx:    return "INVSTAT-2xx";
+	case SIP_INVITESTATUS_1xx:    return "INVSTAT-1xx";
+	case SIP_ANSWER:              return "ANSWER";
+	case SIP_ACK:                 return "ACK";
+	case SIP_BYE:                 return "BYE";
+	case SIP_CANCEL:              return "CANCEL";
+	case SIP_HANGUP:              return "HANGUP";
+	case SIP_BYESTATUS:           return "BYESTATUS";
+	case SIP_CANCELSTATUS:        return "CANCSTATUS";
+	case SIP_RETX:                return "RETX";
+	case SIP_REGISTRAR_TEXP:      return "REGITRAR_T";
+	case SIP_REGSTATUS:           return "REG_STATUS";
+	case SIP_REG_TREGEXP:         return "REG_TEXP";
+	case SIP_SUBSCRIBE:           return "SUBSCRIBE";
+	case SIP_SUBSTATUS:           return "SUB_STATUS";
+	case SIP_NOTIFY:              return "NOTIFY";
+	case SIP_NOTSTATUS:           return "NOT_STATUS";
+	case SIP_PRESENCE_CHANGE:     return "PRESENCE_CHNG";
+	case SIP_SUBSCRIBE_EXPIRE:    return "SUB_EXPIRE";
+	case SIP_WATCH:               return "WATCH";
+	case SIP_STOPWATCH:           return "STOPWATCH";
+	case SIP_MESSAGE:             return "MESSAGE";
+	case SIP_MESSAGESTATUS:       return "MESSAGESTATUS";
+	case SIP_INFO:                return "INFO";
+	case SIP_INFOSTATUS:          return "INFOSTATUS";
+	case SIP_IM_TIMEOUT:          return "IM_TIMEOUT";
+	case SIP_USER_MESSAGE:        return "USER_IM";
+	case SIP_KICKWATCH:           return "KICKWATCH";
+	default:
+		break;
+	}
+	return "Unknown-Event";
+}
+
+
+QString SipFsmBase::StatetoString(int S)
+{
+	switch (S)
+	{
+	case SIP_IDLE:              return "IDLE";
+	case SIP_OCONNECTING1:      return "OCONNECT1";
+	case SIP_OCONNECTING2:      return "OCONNECT2";
+	case SIP_ICONNECTING:       return "ICONNECT";
+	case SIP_CONNECTED:         return "CONNECTED";
+	case SIP_DISCONNECTING:     return "DISCONNECT ";
+	case SIP_CONNECTED_VXML:    return "CONNECT-VXML";  // A false state! Only used to indicate to frontend
+	case SIP_SUB_SUBSCRIBED:    return "SUB_SUBSCRIBED";
+	case SIP_WATCH_TRYING:      return "WTCH_TRYING";
+	case SIP_WATCH_ACTIVE:      return "WTCH_ACTIVE";
+	case SIP_WATCH_STOPPING:    return "WTCH_STOPPING";
+	case SIP_WATCH_HOLDOFF:     return "WTCH_HOLDDOFF";
+	case SIP_IM_ACTIVE:         return "IM_ACTIVE";
+
+	default:
+		break;
+	}
+	return "Unknown-State";
+}
+
+
+
+
+
+
+/**********************************************************************
+SipCall
+ 
+This class handles a per call instance of the FSM
+**********************************************************************/
+
+SipCall::SipCall(QString localIp, QString natIp, int localPort, int n, SipFsm *par) : SipFsmBase(par)
+{
+	callRef = n;
+	sipLocalIP = localIp;
+	sipNatIP = natIp;
+	sipLocalPort = localPort;
+	initialise();
+}
+
+SipCall::~SipCall()
+{}
+
+
+void SipCall::initialise()
+{
+	// Initialise Local Parameters.  We get info from the database on every new
+	// call in case it has been changed
+	myDisplayName = "maldn";//TODO gContext->GetSetting("MySipName");
+	sipUsername = "Konference";//gContext->GetSetting("MySipUser");  -- Note; this is really not needed & is too much config
+
+	// Get other params - done on a per call basis so config changes take effect immediately
+	sipAudioRtpPort = 21232;//TODO atoi((const char *)gContext->GetSetting("AudioLocalPort"));
+	sipVideoRtpPort = 21234;//TODO atoi((const char *)gContext->GetSetting("VideoLocalPort"));
+
+	sipRtpPacketisation = 20;
+	State = SIP_IDLE;
+	remoteAudioPort = 0;
+	remoteVideoPort = 0;
+	remoteIp = "";
+	audioPayloadIdx = -1;
+	videoPayload = -1;
+	dtmfPayload = -1;
+	remoteIp = "";
+	allowVideo = true;
+	disableNat = false;
+	rxVideoResolution = "CIF";
+	txVideoResolution = "CIF";
+	viaRegProxy = 0;
+
+	MyUrl = 0;
+	MyContactUrl = 0;
+
+	// Read the codec priority list from the database into an array
+	CodecList[0].Payload = 0;
+	CodecList[0].Encoding = "PCMU";
+	int n=0;
+	QString CodecListString = "G.711u;G.711a;GSM";//TODO gContext->GetSetting("CodecPriorityList");
+	while ((CodecListString.length() > 0) && (n < MAX_AUDIO_CODECS-1))
+	{
+		int sep = CodecListString.find(';');
+		QString CodecStr = CodecListString;
+		if (sep != -1)
+			CodecStr = CodecListString.left(sep);
+		if (CodecStr == "G.711u")
+		{
+			CodecList[n].Payload = 0;
+			CodecList[n++].Encoding = "PCMU";
+		}
+		else if (CodecStr == "G.711a")
+		{
+			CodecList[n].Payload = 8;
+			CodecList[n++].Encoding = "PCMA";
+		}
+		else if (CodecStr == "GSM")
+		{
+			CodecList[n].Payload = 3;
+			CodecList[n++].Encoding = "GSM";
+		}
+		else
+			cout << "Unknown codec " << CodecStr << " in Codec Priority List\n";
+		if (sep != -1)
+		{
+			QString tempStr = CodecListString.mid(sep+1);
+			CodecListString = tempStr;
+		}
+		else
+			break;
+	}
+	CodecList[n].Payload = -1;
+}
+
+
+int SipCall::FSM(int Event, SipMsg *sipMsg, void *Value)
+{
+	(void)Value;
+	int oldState = State;
+
+	// Parse SIP messages for general relevant data
+	if (sipMsg != 0)
+		ParseSipMsg(Event, sipMsg);
+
+	if (State == SIP_IDLE) // Setup local variables on first event
+	{
+		//if (UseNat(remoteUrl->getHostIp()))
+		//	sipLocalIP = sipNatIP;
+		MyContactUrl = new SipUrl(myDisplayName, sipUsername, sipLocalIP, sipLocalPort);
+		if (viaRegProxy == 0)
+			MyUrl = new SipUrl(myDisplayName, sipUsername, sipLocalIP, sipLocalPort);
+		else
+			MyUrl = new SipUrl(myDisplayName, viaRegProxy->registeredAs(), viaRegProxy->registeredTo(), viaRegProxy->registeredPort());
+	}
+
+	switch(Event | State)
+	{
+	case SIP_IDLE_BYE:
+		BuildSendStatus(481, "BYE", sipMsg->getCSeqValue()); //481 Call/Transaction does not exist
+		State = SIP_IDLE;
+		break;
+	case SIP_IDLE_INVITESTATUS_1xx:
+	case SIP_IDLE_INVITESTATUS_2xx:
+	case SIP_IDLE_INVITESTATUS_3456:
+		// Check if we are being a proxy
+		if (sipMsg->getViaIp() == sipLocalIP)
+		{
+			ForwardMessage(sipMsg);
+			State = SIP_IDLE;
+		}
+		break;
+	case SIP_IDLE_OUTCALL:
+		cseq = 1;
+		remoteUrl = new SipUrl(DestinationUri, "");
+		if ((remoteUrl->getHostIp()).length() == 0)
+		{
+			cout << "SIP: Tried to call " << DestinationUri << " but can't get destination IP address\n";
+			State = SIP_IDLE;
+			break;
+		}
+
+#ifdef SIPREGISTRAR
+		// If the domain matches the local registrar, see if user is registered
+		if ((remoteUrl->getHost() == "volkaerts") &&
+		        (!(parent->getRegistrar())->getRegisteredContact(remoteUrl)))
+		{
+			cout << DestinationUri << " is not registered here\n";
+			break;
+		}
+#endif
+		BuildSendInvite(0);
+		State = SIP_OCONNECTING1;
+		break;
+	case SIP_IDLE_INVITE:
+		cseq = sipMsg->getCSeqValue();
+#ifdef SIPREGISTRAR
+		if ((toUrl->getUser() == sipUsername)) && (toUrl->getHost() ==  "Volkaerts"))
+#endif
+		{
+			if (parent->numCalls() > 1)     // Check there are no active calls, and give busy if there is
+			{
+				BuildSendStatus(486, "INVITE", sipMsg->getCSeqValue()); //486 Busy Here
+				State = SIP_DISCONNECTING;
+			}
+			else
+			{
+				GetSDPInfo(sipMsg);
+				if (audioPayloadIdx != -1) // INVITE had a codec we support; proces
+				{
+					AlertUser(sipMsg);
+					BuildSendStatus(100, "INVITE", sipMsg->getCSeqValue(), SIP_OPT_CONTACT); //100 Trying
+					BuildSendStatus(180, "INVITE", sipMsg->getCSeqValue(), SIP_OPT_CONTACT); //180 Ringing
+					State = SIP_ICONNECTING;
+				}
+				else
+				{
+					BuildSendStatus(488, "INVITE", sipMsg->getCSeqValue()); //488 Not Acceptable Here
+					State = SIP_DISCONNECTING;
+				}
+			}
+		}
+
+#ifdef SIPREGISTRAR
+		// Not for me, see if it is for a registered UA
+		else if ((toUrl->getHost() == "volkaerts") && ((parent->getRegistrar())->getRegisteredContact(toUrl)))
+		{
+			ForwardMessage(sipMsg);
+			State = SIP_IDLE;
+		}
+
+		// Not for me and not for anyone registered here
+		else
+		{
+			BuildSendStatus(404, "INVITE", sipMsg->getCSeqValue()); //404 Not Found
+			State = SIP_DISCONNECTING;
+		}
+#endif
+		break;
+	case SIP_OCONNECTING1_INVITESTATUS_1xx:
+			(parent->Timer())->Stop(this, SIP_RETX);
+			parent->SetNotification("CALLSTATUS", "", QString::number(sipMsg->getStatusCode()), sipMsg->getReasonPhrase());
+			State = SIP_OCONNECTING2;
+			break;
+		case SIP_OCONNECTING1_INVITESTATUS_3456:
+				(parent->Timer())->Stop(this, SIP_RETX);
+				parent->SetNotification("CALLSTATUS", "", QString::number(sipMsg->getStatusCode()), sipMsg->getReasonPhrase());
+				// Fall through
+			case SIP_OCONNECTING2_INVITESTATUS_3456:
+					if (((sipMsg->getStatusCode() == 407) || (sipMsg->getStatusCode() == 401)) &&
+						        (viaRegProxy != 0) && (viaRegProxy->isRegistered())) // Authentication Required
+					{
+						if (!sentAuthenticated) // This avoids loops where we are not authenticating properly
+						{
+							BuildSendAck();
+							BuildSendInvite(sipMsg);
+							State = SIP_OCONNECTING1;
+						}
+					}
+					else
+					{
+						BuildSendAck();
+						State = SIP_IDLE;
+					}
+		break;
+	case SIP_OCONNECTING1_INVITESTATUS_2xx:
+			(parent->Timer())->Stop(this, SIP_RETX);
+			// Fall through
+		case SIP_OCONNECTING2_INVITESTATUS_2xx:
+				GetSDPInfo(sipMsg);
+				if (audioPayloadIdx != -1) // INVITE had a codec we support; proces
+			{
+				BuildSendAck();
+					State = SIP_CONNECTED;
+				}
+				else
+				{
+					cerr << "2xx STATUS did not contain a valid Audio codec\n";
+					BuildSendAck();  // What is the right thing to do here?
+					BuildSendBye(0);
+					State = SIP_DISCONNECTING;
+				}
+		break;
+	case SIP_OCONNECTING1_INVITE:
+			// This is usually because we sent the INVITE to ourselves, & when we receive it matches the call-id for this call leg
+			(parent->Timer())->Stop(this, SIP_RETX);
+			BuildSendCancel(0);
+			State = SIP_DISCONNECTING;
+			break;
+		case SIP_OCONNECTING1_HANGUP:
+				(parent->Timer())->Stop(this, SIP_RETX);
+				BuildSendCancel(0);
+				State = SIP_IDLE;
+				break;
+			case SIP_OCONNECTING1_RETX:
+					if (Retransmit(false))
+						(parent->Timer())->Start(this, t1, SIP_RETX);
+						else
+							State = SIP_IDLE;
+							break;
+						case SIP_OCONNECTING2_HANGUP:
+								BuildSendCancel(0);
+								State = SIP_DISCONNECTING;
+								break;
+							case SIP_ICONNECTING_INVITE:
+									BuildSendStatus(180, "INVITE", sipMsg->getCSeqValue(), SIP_OPT_CONTACT); // Retxed INVITE, resend 180 Ringing
+									break;
+								case SIP_ICONNECTING_ANSWER:
+										BuildSendStatus(200, "INVITE", cseq, SIP_OPT_SDP | SIP_OPT_CONTACT, -1, BuildSdpResponse());
+										State = SIP_CONNECTED;
+										break;
+									case SIP_ICONNECTING_CANCEL:
+											BuildSendStatus(200, "CANCEL", sipMsg->getCSeqValue()); //200 Ok
+											State = SIP_IDLE;
+											break;
+										case SIP_CONNECTED_ACK:
+												(parent->Timer())->Stop(this, SIP_RETX); // Stop resending 200 OKs
+												break;
+											case SIP_CONNECTED_INVITESTATUS_2xx:
+													Retransmit(true); // Resend our ACK
+													break;
+												case SIP_CONNECTED_RETX:
+														if (Retransmit(false))
+															(parent->Timer())->Start(this, t1, SIP_RETX);
+															else
+																State = SIP_IDLE;
+																break;
+															case SIP_CONNECTED_BYE:
+																	(parent->Timer())->Stop(this, SIP_RETX);
+																	if (sipMsg->getCSeqValue() > cseq)
+																	{
+																		cseq = sipMsg->getCSeqValue();
+																		BuildSendStatus(200, "BYE", cseq); //200 Ok
+																		State = SIP_IDLE;
+																	}
+																	else
+																		BuildSendStatus(400, "BYE", sipMsg->getCSeqValue()); //400 Bad Request
+																		break;
+																	case SIP_CONNECTED_HANGUP:
+																			BuildSendBye(0);
+																			State = SIP_DISCONNECTING;
+																			break;
+																		case SIP_DISCONNECTING_ACK:
+																				(parent->Timer())->Stop(this, SIP_RETX);
+																				State = SIP_IDLE;
+																				break;
+																			case SIP_DISCONNECTING_RETX:
+																					if (Retransmit(false))
+																						(parent->Timer())->Start(this, t1, SIP_RETX);
+																						else
+																							State = SIP_IDLE;
+																							break;
+																						case SIP_DISCONNECTING_CANCEL:
+																								(parent->Timer())->Stop(this, SIP_RETX);
+																								BuildSendStatus(200, "CANCEL", sipMsg->getCSeqValue()); //200 Ok
+																								State = SIP_IDLE;
+																								break;
+																							case SIP_DISCONNECTING_BYESTATUS:
+																									(parent->Timer())->Stop(this, SIP_RETX);
+																									if (((sipMsg->getStatusCode() == 407) || (sipMsg->getStatusCode() == 401)) &&
+																										        (viaRegProxy != 0) && (viaRegProxy->isRegistered())) // Authentication Required
+																									{
+																										if (!sentAuthenticated)
+																											BuildSendBye(sipMsg);
+																									}
+																									else
+																										State = SIP_IDLE;
+																										break;
+																									case SIP_DISCONNECTING_CANCELSTATUS:
+																											(parent->Timer())->Stop(this, SIP_RETX);
+																											if (((sipMsg->getStatusCode() == 407) || (sipMsg->getStatusCode() == 401)) &&
+																												        (viaRegProxy != 0) && (viaRegProxy->isRegistered())) // Authentication Required
+																											{
+																												if (!sentAuthenticated)
+																													BuildSendCancel(sipMsg);
+																											}
+																											else
+																												State = SIP_IDLE;
+																												break;
+																											case SIP_DISCONNECTING_BYE:
+																													(parent->Timer())->Stop(this, SIP_RETX);
+																													BuildSendStatus(200, "BYE", sipMsg->getCSeqValue()); //200 Ok
+																													State = SIP_IDLE;
+																													break;
+
+																													// Events ignored in states
+																												case SIP_OCONNECTING2_INVITESTATUS_1xx:
+																														parent->SetNotification("CALLSTATUS", "", QString::number(sipMsg->getStatusCode()), sipMsg->getReasonPhrase());
+																														break;
+
+																														// Everything else is an error, just flag it for now
+																													default:
+																															SipFsm::Debug(SipDebugEvent::SipErrorEv, "SIP CALL FSM Error; received " + EventtoString(Event) + " in state " + StatetoString(State) + "\n\n");
+																															break;
+																														}
+
+	DebugFsm(Event, oldState, State);
+	return State;
+}
+
+bool SipCall::UseNat(QString destIPAddress)
+{
+	(void)destIPAddress;
+	// User to check subnets but this was a flawed concept; now checks a configuration item per-remote user
+	return !disableNat;
+}
+
+
+void SipCall::BuildSendInvite(SipMsg *authMsg)
+{
+	if (authMsg == 0)
+		CallId.Generate(sipLocalIP);
+
+	SipMsg Invite("INVITE");
+	Invite.addRequestLine(*remoteUrl);
+	Invite.addVia(sipLocalIP, sipLocalPort);
+	Invite.addFrom(*MyUrl, "ae1d8a43cf3f4d8a8f4f0e1004", "3622b728e3");
+	Invite.addTo(*remoteUrl);
+	Invite.addCallId(&CallId);
+	Invite.addCSeq(++cseq);
+	Invite.addUserAgent();
+
+	if (authMsg)
+	{
+		if (authMsg->getAuthMethod() == "Digest")
+			Invite.addAuthorization(authMsg->getAuthMethod(), viaRegProxy->registeredAs(), viaRegProxy->registeredPasswd(), authMsg->getAuthRealm(), authMsg->getAuthNonce(), remoteUrl->formatReqLineUrl(), authMsg->getStatusCode() == 407);
+		else
+			cout << "SIP: Unknown Auth Type: " << authMsg->getAuthMethod() << endl;
+		sentAuthenticated = true;
+	}
+	else
+		sentAuthenticated = false;
+
+	//Invite.addAllow();
+	Invite.addContact(*MyContactUrl);
+	addSdpToInvite(Invite, allowVideo);
+
+	parent->Transmit(Invite.string(), retxIp = remoteUrl->getHostIp(), retxPort = remoteUrl->getPort());
+	retx = Invite.string();
+	t1 = 500;
+	(parent->Timer())->Start(this, t1, SIP_RETX);
+}
+
+
+
+void SipCall::ForwardMessage(SipMsg *msg)
+{
+	QString toIp;
+	int toPort;
+
+	if (msg->getMethod() != "STATUS")
+	{
+		msg->insertVia(sipLocalIP, sipLocalPort);
+		toIp = toUrl->getHostIp();
+		toPort = toUrl->getPort();
+	}
+	else
+	{
+		msg->removeVia();
+		toIp = msg->getViaIp();
+		toPort = msg->getViaPort();
+	}
+	parent->Transmit(msg->string(), toIp, toPort);
+}
+
+
+
+void SipCall::BuildSendAck()
+{
+	if ((MyUrl == 0) || (remoteUrl == 0))
+	{
+		cerr << "URL variables not setup\n";
+		return;
+	}
+
+	SipMsg Ack("ACK");
+	Ack.addRequestLine(*remoteUrl);
+	Ack.addVia(sipLocalIP, sipLocalPort);
+	Ack.addFrom(*MyUrl, "ae1d8a43cf3f4d8a8f4f0e1004", "3622b728e3");
+	Ack.addTo(*remoteUrl, remoteTag);
+	Ack.addCallId(&CallId);
+	Ack.addCSeq(cseq);
+	Ack.addUserAgent();
+	Ack.addNullContent();
+
+	// Even if we have a contact URL in one of the response messages; we still send the ACK to
+	// the same place we sent the INVITE to
+	parent->Transmit(Ack.string(), retxIp = remoteUrl->getHostIp(), retxPort = remoteUrl->getPort());
+	retx = Ack.string();
+}
+
+
+void SipCall::BuildSendCancel(SipMsg *authMsg)
+{
+	if ((MyUrl == 0) || (remoteUrl == 0))
+	{
+		cerr << "URL variables not setup\n";
+		return;
+	}
+
+	SipMsg Cancel("CANCEL");
+	Cancel.addRequestLine(*remoteUrl);
+	Cancel.addVia(sipLocalIP, sipLocalPort);
+	Cancel.addTo(*remoteUrl, remoteTag);
+	Cancel.addFrom(*MyUrl);
+	Cancel.addCallId(&CallId);
+	Cancel.addCSeq(cseq);
+	Cancel.addUserAgent();
+
+	if (authMsg)
+	{
+		if (authMsg->getAuthMethod() == "Digest")
+			Cancel.addAuthorization(authMsg->getAuthMethod(), viaRegProxy->registeredAs(), viaRegProxy->registeredPasswd(), authMsg->getAuthRealm(), authMsg->getAuthNonce(), remoteUrl->formatReqLineUrl(), authMsg->getStatusCode() == 407);
+		else
+			cout << "SIP: Unknown Auth Type: " << authMsg->getAuthMethod() << endl;
+		sentAuthenticated = true;
+	}
+	else
+		sentAuthenticated = false;
+
+	Cancel.addNullContent();
+
+	// Send new transactions to (a) record route, (b) contact URL or (c) configured URL
+	if (recRouteUrl)
+		parent->Transmit(Cancel.string(), retxIp = recRouteUrl->getHostIp(), retxPort = recRouteUrl->getPort());
+	else if (contactUrl)
+		parent->Transmit(Cancel.string(), retxIp = contactUrl->getHostIp(), retxPort = contactUrl->getPort());
+	else
+		parent->Transmit(Cancel.string(), retxIp = remoteUrl->getHostIp(), retxPort = remoteUrl->getPort());
+	retx = Cancel.string();
+	t1 = 500;
+	(parent->Timer())->Start(this, t1, SIP_RETX);
+}
+
+
+void SipCall::BuildSendBye(SipMsg *authMsg)
+{
+	if (remoteUrl == 0)
+	{
+		cerr << "URL variables not setup\n";
+		return;
+	}
+
+	SipMsg Bye("BYE");
+	Bye.addRequestLine(*remoteUrl);
+	Bye.addVia(sipLocalIP, sipLocalPort);
+	if (rxedFrom.length() > 0)
+	{
+		Bye.addFromCopy(rxedFrom);
+		Bye.addToCopy(rxedTo);
+	}
+	else
+	{
+		Bye.addFrom(*MyUrl);
+		Bye.addTo(*remoteUrl, remoteTag);
+	}
+	Bye.addCallId(&CallId);
+	Bye.addCSeq(++cseq);
+	Bye.addUserAgent();
+
+	if (authMsg)
+	{
+		if (authMsg->getAuthMethod() == "Digest")
+			Bye.addAuthorization(authMsg->getAuthMethod(), viaRegProxy->registeredAs(), viaRegProxy->registeredPasswd(), authMsg->getAuthRealm(), authMsg->getAuthNonce(), remoteUrl->formatReqLineUrl(), authMsg->getStatusCode() == 407);
+		else
+			cout << "SIP: Unknown Auth Type: " << authMsg->getAuthMethod() << endl;
+		sentAuthenticated = true;
+	}
+	else
+		sentAuthenticated = false;
+
+	Bye.addNullContent();
+
+	// Send new transactions to (a) record route, (b) contact URL or (c) configured URL
+	if (recRouteUrl)
+		parent->Transmit(Bye.string(), retxIp = recRouteUrl->getHostIp(), retxPort = recRouteUrl->getPort());
+	else if (contactUrl)
+		parent->Transmit(Bye.string(), retxIp = contactUrl->getHostIp(), retxPort = contactUrl->getPort());
+	else
+		parent->Transmit(Bye.string(), retxIp = remoteUrl->getHostIp(), retxPort = remoteUrl->getPort());
+	retx = Bye.string();
+	t1 = 500;
+	(parent->Timer())->Start(this, t1, SIP_RETX);
+}
+
+void SipCall::AlertUser(SipMsg *rxMsg)
+{
+	// A new incoming call has been received, tell someone!
+	// Actually we just pull out the important bits here & on the
+	// next call to poll the stack the State will have changed to
+	// alert the user
+	if (rxMsg != 0)
+	{
+		SipUrl *from = rxMsg->getFromUrl();
+
+		if (from)
+		{
+			CallersUserid = from->getUser();
+			if ((viaRegProxy) && (viaRegProxy->registeredTo() == from->getHost()))
+				CallerUrl = from->getUser();
+			else
+			{
+				CallerUrl = from->getUser() + "@" + from->getHost();
+				if (from->getPort() != 5060)
+					CallerUrl += ":" + QString::number(from->getPort());
+			}
+			CallersDisplayName = from->getDisplay();
+		}
+		else
+			cerr << "What no from in INVITE?  It is invalid then.\n";
+	}
+	else
+		cerr << "What no INVITE?  How did we get here then?\n";
+}
+
+void SipCall::GetSDPInfo(SipMsg *sipMsg)
+{
+	audioPayloadIdx = -1;
+	videoPayload = -1;
+	dtmfPayload = -1;
+	remoteAudioPort = 0;
+	remoteVideoPort = 0;
+	rxVideoResolution = "AUDIOONLY";
+
+	SipSdp *Sdp = sipMsg->getSdp();
+	if (Sdp != 0)
+	{
+		remoteIp = Sdp->getMediaIP();
+		remoteAudioPort = Sdp->getAudioPort();
+		remoteVideoPort = Sdp->getVideoPort();
+
+		// See if there is an audio codec we support
+		QPtrList<sdpCodec> *audioCodecs = Sdp->getAudioCodecList();
+		sdpCodec *c;
+		if (audioCodecs)
+		{
+			for (int n=0; (n<MAX_AUDIO_CODECS) && (CodecList[n].Payload != -1) &&
+			        (audioPayloadIdx == -1); n++)
+			{
+				for (c=audioCodecs->first(); c; c=audioCodecs->next())
+				{
+					if (CodecList[n].Payload == c->intValue())
+						audioPayloadIdx = n;
+
+					// Note - no checking for dynamic payloads implemented yet --- need to match
+					// by text if .Payload == -1
+				}
+			}
+
+			// Also check for DTMF
+			for (c=audioCodecs->first(); c; c=audioCodecs->next())
+			{
+				if (c->strValue() == "telephone-event/8000")
+					dtmfPayload = c->intValue();
+			}
+		}
+
+		// See if there is a video codec we support
+		QPtrList<sdpCodec> *videoCodecs = Sdp->getVideoCodecList();
+		if (videoCodecs)
+		{
+			for (c=videoCodecs->first(); c; c=videoCodecs->next())
+			{
+				if ((c->intValue() == 34) && (c->strValue() == "H263/90000"))
+				{
+					videoPayload = c->intValue();
+					rxVideoResolution = (c->fmtValue()).section('=', 0, 0);
+					break;
+				}
+			}
+		}
+
+		SipFsm::Debug(SipDebugEvent::SipDebugEv, "SDP contains IP " + remoteIp + " A-Port " + QString::number(remoteAudioPort) + " V-Port " + QString::number(remoteVideoPort) + " Audio Codec:" + QString::number(audioPayloadIdx) + " Video Codec:" + QString::number(videoPayload) + " Format:" + rxVideoResolution + " DTMF: " + QString::number(dtmfPayload) + "\n\n");
+	}
+	else
+		SipFsm::Debug(SipDebugEvent::SipDebugEv, "SIP: No SDP in message\n");
+}
+
+
+
+void SipCall::addSdpToInvite(SipMsg& msg, bool advertiseVideo)
+{
+	SipSdp sdp(sipLocalIP, sipAudioRtpPort, advertiseVideo ? sipVideoRtpPort : 0);
+
+	for (int n=0; (n<MAX_AUDIO_CODECS) && (CodecList[n].Payload != -1); n++)
+		sdp.addAudioCodec(CodecList[n].Payload, CodecList[n].Encoding + "/8000");
+
+	// Signal support for DTMF
+	sdp.addAudioCodec(101, "telephone-event/8000", "0-11");
+
+	if (advertiseVideo)
+		sdp.addVideoCodec(34, "H263/90000", txVideoResolution +"=2");
+	sdp.encode();
+	msg.addContent("application/sdp", sdp.string());
+}
+
+
+QString SipCall::BuildSdpResponse()
+{
+	SipSdp sdp(sipLocalIP, sipAudioRtpPort, (videoPayload != -1) ? sipVideoRtpPort : 0);
+
+	sdp.addAudioCodec(CodecList[audioPayloadIdx].Payload, CodecList[audioPayloadIdx].Encoding + "/8000");
+
+	// Signal support for DTMF
+	if (dtmfPayload != -1)
+		sdp.addAudioCodec(dtmfPayload, "telephone-event/8000", "0-11");
+
+	if (videoPayload != -1)
+		sdp.addVideoCodec(34, "H263/90000", txVideoResolution +"=2");
+
+	sdp.encode();
+	return sdp.string();
+}
+
+
+
+
+/**********************************************************************
 SipRegistrar
  
 A simple registrar class used mainly for testing purposes. Allows
@@ -760,7 +2127,155 @@
 	parent->Transmit(Status.string(), rIp, rPort);
 }
 
+
 /**********************************************************************
+SipRegistration
+ 
+This class is used to register with a SIP Proxy.
+**********************************************************************/
+
+SipRegistration::SipRegistration(SipFsm *par, QString localIp, int localPort, QString Username, QString Password, QString ProxyName, int ProxyPort) : SipFsmBase(par)
+{
+	sipLocalIp = localIp;
+	sipLocalPort = localPort;
+	ProxyUrl = new SipUrl("", "", ProxyName, ProxyPort);
+	MyUrl = new SipUrl("", Username, ProxyName, ProxyPort);
+	MyContactUrl = new SipUrl("", Username, sipLocalIp, sipLocalPort);
+	MyPassword = Password;
+	cseq = 1;
+	CallId.Generate(sipLocalIp);
+
+	SendRegister();
+	State = SIP_REG_TRYING;
+	regRetryCount = REG_RETRY_MAXCOUNT;
+	Expires = 3600;
+	(parent->Timer())->Start(this, REG_RETRY_TIMER, SIP_RETX);
+}
+
+SipRegistration::~SipRegistration()
+{
+	if (ProxyUrl)
+		delete ProxyUrl;
+	if (MyUrl)
+		delete MyUrl;
+	if (MyContactUrl)
+		delete MyContactUrl;
+	ProxyUrl = MyUrl = MyContactUrl = 0;
+	(parent->Timer())->StopAll(this);
+}
+
+int SipRegistration::FSM(int Event, SipMsg *sipMsg, void *Value)
+{
+	(void)Value;
+	switch (Event | State)
+	{
+	case SIP_REG_TRYING_STATUS:
+		(parent->Timer())->Stop(this, SIP_RETX);
+		switch (sipMsg->getStatusCode())
+		{
+		case 200:
+			if (sipMsg->getExpires() > 0)
+				Expires = sipMsg->getExpires();
+			cout << "SIP Registered to " << ProxyUrl->getHost() << " for " << Expires << "s" << endl;
+			State = SIP_REG_REGISTERED;
+			(parent->Timer())->Start(this, (Expires-30)*1000, SIP_REG_TREGEXP); // Assume 30secs max to reregister
+			break;
+		case 401:
+		case 407:
+			SendRegister(sipMsg);
+			regRetryCount = REG_RETRY_MAXCOUNT;
+			State = SIP_REG_CHALLENGED;
+			(parent->Timer())->Start(this, REG_RETRY_TIMER, SIP_RETX);
+			break;
+		default:
+			if (sipMsg->getStatusCode() != 100)
+			{
+				cout << "SIP Registration failed; Reason " << sipMsg->getStatusCode() << " " << sipMsg->getReasonPhrase() << endl;
+				State = SIP_REG_FAILED;
+				(parent->Timer())->Start(this, REG_FAIL_RETRY_TIMER, SIP_RETX); // Try again in 3 minutes
+			}
+			break;
+		}
+		break;
+
+	case SIP_REG_CHALL_STATUS:
+		(parent->Timer())->Stop(this, SIP_RETX);
+		switch (sipMsg->getStatusCode())
+		{
+		case 200:
+			if (sipMsg->getExpires() > 0)
+				Expires = sipMsg->getExpires();
+			cout << "SIP Registered to " << ProxyUrl->getHost() << " for " << Expires << "s" << endl;
+			State = SIP_REG_REGISTERED;
+			(parent->Timer())->Start(this, (Expires-30)*1000, SIP_REG_TREGEXP); // Assume 30secs max to reregister
+			break;
+		default:
+			if (sipMsg->getStatusCode() != 100)
+			{
+				cout << "SIP Registration failed; Reason " << sipMsg->getStatusCode() << " " << sipMsg->getReasonPhrase() << endl;
+				State = SIP_REG_FAILED;
+				(parent->Timer())->Start(this, REG_FAIL_RETRY_TIMER, SIP_RETX); // Try again in 3 minutes
+			}
+			break;
+		}
+		break;
+
+	case SIP_REG_REGISTERED_TREGEXP:
+		regRetryCount = REG_RETRY_MAXCOUNT+1;
+	case SIP_REG_TRYING_RETX:
+	case SIP_REG_CHALL_RETX:
+	case SIP_REG_FAILED_RETX:
+		if (--regRetryCount > 0)
+		{
+			State = SIP_REG_TRYING;
+			SendRegister();
+			(parent->Timer())->Start(this, REG_RETRY_TIMER, SIP_RETX); // Retry every 10 seconds
+		}
+		else
+		{
+			State = SIP_REG_FAILED;
+			cout << "SIP Registration failed; no Response from Server. Are you behind a firewall?\n";
+		}
+		break;
+
+	default:
+		cerr << "SIP Registration: Unknown Event " << EventtoString(Event) << ", State " << State << endl;
+		break;
+	}
+	return 0;
+}
+
+void SipRegistration::SendRegister(SipMsg *authMsg)
+{
+	SipMsg Register("REGISTER");
+	Register.addRequestLine(*ProxyUrl);
+	Register.addVia(sipLocalIp, sipLocalPort);
+	Register.addFrom(*MyUrl);
+	Register.addTo(*MyUrl);
+	Register.addCallId(&CallId);
+	Register.addCSeq(++cseq);
+
+	if (authMsg && (authMsg->getAuthMethod() == "Digest"))
+	{
+		Register.addAuthorization(authMsg->getAuthMethod(), MyUrl->getUser(), MyPassword,
+		                          authMsg->getAuthRealm(), authMsg->getAuthNonce(),
+		                          ProxyUrl->formatReqLineUrl(), authMsg->getStatusCode() == 407);
+		sentAuthenticated = true;
+	}
+	else
+		sentAuthenticated = false;
+
+	Register.addUserAgent();
+	Register.addExpires(Expires=3600);
+	Register.addContact(*MyContactUrl);
+	Register.addNullContent();
+
+	parent->Transmit(Register.string(), ProxyUrl->getHostIp(), ProxyUrl->getPort());
+}
+
+
+
+/**********************************************************************
 SipSubscriber
  
 FSM to handle clients subscribed to our presence status.
@@ -857,11 +2372,11 @@
 		break;
 
 	default:
-//		SipFsm::Debug(SipDebugEvent::SipErrorEv, "SIP Subscriber FSM Error; received " + EventtoString(Event) + " in state " + StatetoString(State) + "\n\n");
+		SipFsm::Debug(SipDebugEvent::SipErrorEv, "SIP Subscriber FSM Error; received " + EventtoString(Event) + " in state " + StatetoString(State) + "\n\n");
 		break;
 	}
 
-//	DebugFsm(Event, OldState, State);
+	DebugFsm(Event, OldState, State);
 	return State;
 }
 
@@ -1094,11 +2609,11 @@
 		break;
 
 	default:
-//		SipFsm::Debug(SipDebugEvent::SipErrorEv, "SIP Watcher FSM Error; received " + EventtoString(Event) + " in state " + StatetoString(State) + "\n\n");
+		SipFsm::Debug(SipDebugEvent::SipErrorEv, "SIP Watcher FSM Error; received " + EventtoString(Event) + " in state " + StatetoString(State) + "\n\n");
 		break;
 	}
 
-//	DebugFsm(Event, OldState, State);
+	DebugFsm(Event, OldState, State);
 	return State;
 }
 
@@ -1251,11 +2766,11 @@
 		break;
 
 	default:
-//		SipFsm::Debug(SipDebugEvent::SipErrorEv, "SIP IM FSM Error; received " + EventtoString(Event) + " in state " + StatetoString(State) + "\n\n");
+		SipFsm::Debug(SipDebugEvent::SipErrorEv, "SIP IM FSM Error; received " + EventtoString(Event) + " in state " + StatetoString(State) + "\n\n");
 		break;
 	}
 
-//	DebugFsm(Event, OldState, State);
+	DebugFsm(Event, OldState, State);
 	return State;
 }
 

Modified: konference/src/sip/sipmsg.cpp
===================================================================
--- konference/src/sip/sipmsg.cpp	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/sip/sipmsg.cpp	2005-10-28 09:33:02 UTC (rev 76)
@@ -422,7 +422,7 @@
 
 		QString thisParamNoWs = thisParam.stripWhiteSpace();
 		QString ParamName  = thisParamNoWs.section('=', 0, 0);
-		QString ParamValue = thisParamNoWs.section('=', 1, 1);
+		QString ParamValue = thisParamNoWs.section('=', 1);
 		QString ParamValueNoQuotes = (ParamValue.startsWith("\"")) ? ParamValue.section('\"', 1, 1) : ParamValue;
 
 		if (ParamName == "realm")

Modified: konference/src/sip/sipurl.h
===================================================================
--- konference/src/sip/sipurl.h	2005-07-03 16:16:08 UTC (rev 75)
+++ konference/src/sip/sipurl.h	2005-10-28 09:33:02 UTC (rev 76)
@@ -22,9 +22,6 @@
 
 #include <qstring.h>
 
-/**
- at author Malte B?hme
-*/
 class SipUrl
 {
 public:



